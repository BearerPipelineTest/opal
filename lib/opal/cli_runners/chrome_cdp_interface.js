(function(global_object) {
  "use strict";

  // @note
  //   A few conventions for the documentation of this file:
  //   1. Always use "//" (in contrast with "/**/")
  //   2. The syntax used is Yardoc (yardoc.org), which is intended for Ruby (se below)
  //   3. `@param` and `@return` types should be preceded by `JS.` when referring to
  //      JavaScript constructors (e.g. `JS.Function`) otherwise Ruby is assumed.
  //   4. `nil` and `null` being unambiguous refer to the respective
  //      objects/values in Ruby and JavaScript
  //   5. This is still WIP :) so please give feedback and suggestions on how
  //      to improve or for alternative solutions
  //
  //   The way the code is digested before going through Yardoc is a secret kept
  //   in the docs repo (https://github.com/opal/docs/tree/master).

  var console;

  // Detect the global object
  if (typeof(globalThis) !== 'undefined') { global_object = globalThis; }
  else if (typeof(global) !== 'undefined') { global_object = global; }
  else if (typeof(window) !== 'undefined') { global_object = window; }

  // Setup a dummy console object if missing
  if (typeof(global_object.console) === 'object') {
    console = global_object.console;
  } else if (global_object.console == null) {
    console = global_object.console = {};
  } else {
    console = {};
  }

  if (!('log' in console)) { console.log = function () {}; }
  if (!('warn' in console)) { console.warn = console.log; }

  if (typeof(global_object.Opal) !== 'undefined') {
    console.warn('Opal already loaded. Loading twice can cause troubles, please fix your setup.');
    return global_object.Opal;
  }

  var nil;

  // The actual class for BasicObject
  var BasicObject;

  // The actual Object class.
  // The leading underscore is to avoid confusion with window.Object()
  var _Object;

  // The actual Module class
  var Module;

  // The actual Class class
  var Class;

  // The Opal object that is exposed globally
  var Opal = global_object.Opal = {};

  // This is a useful reference to global object inside ruby files
  Opal.global = global_object;
  global_object.Opal = Opal;

  // Configure runtime behavior with regards to require and unsupported features
  Opal.config = {
    missing_require_severity: 'error',        // error, warning, ignore
    unsupported_features_severity: 'warning', // error, warning, ignore
    enable_stack_trace: true                  // true, false
  };

  // Minify common function calls
  var $has_own   = Object.hasOwnProperty;
  var $bind      = Function.prototype.bind;
  var $set_proto = Object.setPrototypeOf;
  var $slice     = Array.prototype.slice;
  var $splice    = Array.prototype.splice;

  // Nil object id is always 4
  var nil_id = 4;

  // Generates even sequential numbers greater than 4
  // (nil_id) to serve as unique ids for ruby objects
  var unique_id = nil_id;

  // Return next unique id
  Opal.uid = function() {
    unique_id += 2;
    return unique_id;
  };

  // Retrieve or assign the id of an object
  Opal.id = function(obj) {
    if (obj.$$is_number) return (obj * 2)+1;
    if (obj.$$id != null) {
      return obj.$$id;
    }
    $defineProperty(obj, '$$id', Opal.uid());
    return obj.$$id;
  };

  // Globals table
  Opal.gvars = {};

  // Exit function, this should be replaced by platform specific implementation
  // (See nodejs and chrome for examples)
  Opal.exit = function(status) { if (Opal.gvars.DEBUG) console.log('Exited with status '+status); };

  // keeps track of exceptions for $!
  Opal.exceptions = [];

  // @private
  // Pops an exception from the stack and updates `$!`.
  Opal.pop_exception = function() {
    var exception = Opal.exceptions.pop();
    if (exception) {
      Opal.gvars["!"] = exception;
      Opal.gvars["@"] = exception.$backtrace();
    }
    else {
      Opal.gvars["!"] = Opal.gvars["@"] = nil;
    }
  };

  // Inspect any kind of object, including non Ruby ones
  Opal.inspect = function(obj) {
    if (obj === undefined) {
      return "undefined";
    }
    else if (obj === null) {
      return "null";
    }
    else if (!obj.$$class) {
      return obj.toString();
    }
    else {
      return obj.$inspect();
    }
  };

  function $defineProperty(object, name, initialValue) {
    if (typeof(object) === "string") {
      // Special case for:
      //   s = "string"
      //   def s.m; end
      // String class is the only class that:
      // + compiles to JS primitive
      // + allows method definition directly on instances
      // numbers, true, false and null do not support it.
      object[name] = initialValue;
    } else {
      Object.defineProperty(object, name, {
        value: initialValue,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
  }

  Opal.defineProperty = $defineProperty;

  Opal.slice = $slice;


  // Helpers
  // -----

  Opal.truthy = function(val) {
    return (val !== nil && val != null && (!val.$$is_boolean || val == true));
  };

  Opal.falsy = function(val) {
    return (val === nil || val == null || (val.$$is_boolean && val == false))
  };

  Opal.type_error = function(object, type, method, coerced) {
    object = object.$$class;

    if (coerced && method) {
      coerced = coerced.$$class;
      return Opal.TypeError.$new(
        "can't convert " + object + " into " + type +
        " (" + object + "#" + method + " gives " + coerced + ")"
      )
    } else {
      return Opal.TypeError.$new(
        "no implicit conversion of " + object + " into " + type
      )
    }
  };

  Opal.coerce_to = function(object, type, method, args) {
    if (type['$==='](object)) return object;

    if (!object['$respond_to?'](method)) {
      throw Opal.type_error(object, type);
    }

    if (args == null) args = [];
    return Opal.send(object, method, args);
  }

  Opal.respond_to = function(obj, jsid, include_all) {
    if (obj == null || !obj.$$class) return false;
    include_all = !!include_all;
    var body = obj[jsid];

    if (obj['$respond_to?'].$$pristine) {
      if (obj['$respond_to_missing?'].$$pristine) {
        return typeof(body) === "function" && !body.$$stub;
      } else {
        return Opal.send(obj, obj['$respond_to_missing?'], [jsid.substr(1), include_all]);
      }
    } else {
      return Opal.send(obj, obj['$respond_to?'], [jsid.substr(1), include_all]);
    }
  }

  // TracePoint support
  // ------------------
  //
  // Support for `TracePoint.trace(:class) do ... end`
  Opal.trace_class = false;
  Opal.tracers_for_class = [];

  function invoke_tracers_for_class(klass_or_module) {
    var i, ii, tracer;

    for(i = 0, ii = Opal.tracers_for_class.length; i < ii; i++) {
      tracer = Opal.tracers_for_class[i];
      tracer.trace_object = klass_or_module;
      tracer.block.$call(tracer);
    }
  }

  // Constants
  // ---------
  //
  // For future reference:
  // - The Rails autoloading guide (http://guides.rubyonrails.org/v5.0/autoloading_and_reloading_constants.html)
  // - @ConradIrwin's 2012 post on “Everything you ever wanted to know about constant lookup in Ruby” (http://cirw.in/blog/constant-lookup.html)
  //
  // Legend of MRI concepts/names:
  // - constant reference (cref): the module/class that acts as a namespace
  // - nesting: the namespaces wrapping the current scope, e.g. nesting inside
  //            `module A; module B::C; end; end` is `[B::C, A]`

  // Get the constant in the scope of the current cref
  function const_get_name(cref, name) {
    if (cref) return cref.$$const[name];
  }

  // Walk up the nesting array looking for the constant
  function const_lookup_nesting(nesting, name) {
    var i, ii, constant;

    if (nesting.length === 0) return;

    // If the nesting is not empty the constant is looked up in its elements
    // and in order. The ancestors of those elements are ignored.
    for (i = 0, ii = nesting.length; i < ii; i++) {
      constant = nesting[i].$$const[name];
      if (constant != null) return constant;
    }
  }

  // Walk up the ancestors chain looking for the constant
  function const_lookup_ancestors(cref, name) {
    var i, ii, ancestors;

    if (cref == null) return;

    ancestors = Opal.ancestors(cref);

    for (i = 0, ii = ancestors.length; i < ii; i++) {
      if (ancestors[i].$$const && $has_own.call(ancestors[i].$$const, name)) {
        return ancestors[i].$$const[name];
      }
    }
  }

  // Walk up Object's ancestors chain looking for the constant,
  // but only if cref is missing or a module.
  function const_lookup_Object(cref, name) {
    if (cref == null || cref.$$is_module) {
      return const_lookup_ancestors(_Object, name);
    }
  }

  // Call const_missing if nothing else worked
  function const_missing(cref, name, skip_missing) {
    if (!skip_missing) {
      return (cref || _Object).$const_missing(name);
    }
  }

  // Look for the constant just in the current cref or call `#const_missing`
  Opal.const_get_local = function(cref, name, skip_missing) {
    var result;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    result = const_get_name(cref, name);              if (result != null) return result;
    result = const_missing(cref, name, skip_missing); if (result != null) return result;
  };

  // Look for the constant relative to a cref or call `#const_missing` (when the
  // constant is prefixed by `::`).
  Opal.const_get_qualified = function(cref, name, skip_missing) {
    var result, cache, cached, current_version = Opal.const_cache_version;

    if (cref == null) return;

    if (cref === '::') cref = _Object;

    if (!cref.$$is_module && !cref.$$is_class) {
      throw new Opal.TypeError(cref.toString() + " is not a class/module");
    }

    if ((cache = cref.$$const_cache) == null) {
      $defineProperty(cref, '$$const_cache', Object.create(null));
      cache = cref.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null);
      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Initialize the top level constant cache generation counter
  Opal.const_cache_version = 1;

  // Look for the constant in the open using the current nesting and the nearest
  // cref ancestors or call `#const_missing` (when the constant has no :: prefix).
  Opal.const_get_relative = function(nesting, name, skip_missing) {
    var cref = nesting[0], result, current_version = Opal.const_cache_version, cache, cached;

    if ((cache = nesting.$$const_cache) == null) {
      $defineProperty(nesting, '$$const_cache', Object.create(null));
      cache = nesting.$$const_cache;
    }
    cached = cache[name];

    if (cached == null || cached[0] !== current_version) {
      ((result = const_get_name(cref, name))              != null) ||
      ((result = const_lookup_nesting(nesting, name))     != null) ||
      ((result = const_lookup_ancestors(cref, name))      != null) ||
      ((result = const_lookup_Object(cref, name))         != null);

      cache[name] = [current_version, result];
    } else {
      result = cached[1];
    }

    return result != null ? result : const_missing(cref, name, skip_missing);
  };

  // Register the constant on a cref and opportunistically set the name of
  // unnamed classes/modules.
  Opal.const_set = function(cref, name, value) {
    if (cref == null || cref === '::') cref = _Object;

    if (value.$$is_a_module) {
      if (value.$$name == null || value.$$name === nil) value.$$name = name;
      if (value.$$base_module == null) value.$$base_module = cref;
    }

    cref.$$const = (cref.$$const || Object.create(null));
    cref.$$const[name] = value;

    // Add a short helper to navigate constants manually.
    // @example
    //   Opal.$$.Regexp.$$.IGNORECASE
    cref.$$ = cref.$$const;

    Opal.const_cache_version++;

    // Expose top level constants onto the Opal object
    if (cref === _Object) Opal[name] = value;

    // Name new class directly onto current scope (Opal.Foo.Baz = klass)
    $defineProperty(cref, name, value);

    return value;
  };

  // Get all the constants reachable from a given cref, by default will include
  // inherited constants.
  Opal.constants = function(cref, inherit) {
    if (inherit == null) inherit = true;

    var module, modules = [cref], i, ii, constants = {}, constant;

    if (inherit) modules = modules.concat(Opal.ancestors(cref));
    if (inherit && cref.$$is_module) modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));

    for (i = 0, ii = modules.length; i < ii; i++) {
      module = modules[i];

      // Do not show Objects constants unless we're querying Object itself
      if (cref !== _Object && module == _Object) break;

      for (constant in module.$$const) {
        constants[constant] = true;
      }
    }

    return Object.keys(constants);
  };

  // Remove a constant from a cref.
  Opal.const_remove = function(cref, name) {
    Opal.const_cache_version++;

    if (cref.$$const[name] != null) {
      var old = cref.$$const[name];
      delete cref.$$const[name];
      return old;
    }

    if (cref.$$autoload != null && cref.$$autoload[name] != null) {
      delete cref.$$autoload[name];
      return nil;
    }

    throw Opal.NameError.$new("constant "+cref+"::"+cref.$name()+" not defined");
  };

  // Setup some shortcuts to reduce compiled size
  Opal.$$ = Opal.const_get_relative;
  Opal.$$$ = Opal.const_get_qualified;


  // Modules & Classes
  // -----------------

  // A `class Foo; end` expression in ruby is compiled to call this runtime
  // method which either returns an existing class of the given name, or creates
  // a new class in the given `base` scope.
  //
  // If a constant with the given name exists, then we check to make sure that
  // it is a class and also that the superclasses match. If either of these
  // fail, then we raise a `TypeError`. Note, `superclass` may be null if one
  // was not specified in the ruby code.
  //
  // We pass a constructor to this method of the form `function ClassName() {}`
  // simply so that classes show up with nicely formatted names inside debuggers
  // in the web browser (or node/sprockets).
  //
  // The `scope` is the current `self` value where the class is being created
  // from. We use this to get the scope for where the class should be created.
  // If `scope` is an object (not a class/module), we simple get its class and
  // use that as the scope instead.
  //
  // @param scope        [Object] where the class is being created
  // @param superclass  [Class,null] superclass of the new class (may be null)
  // @param id          [String] the name of the class to be created
  // @param constructor [JS.Function] function to use as constructor
  //
  // @return new [Class]  or existing ruby class
  //
  Opal.allocate_class = function(name, superclass) {
    var klass, constructor;

    if (superclass != null && superclass.$$bridge) {
      // Inheritance from bridged classes requires
      // calling original JS constructors
      constructor = function() {
        var args = $slice.call(arguments),
            self = new ($bind.apply(superclass.$$constructor, [null].concat(args)))();

        // and replacing a __proto__ manually
        $set_proto(self, klass.$$prototype);
        return self;
      }
    } else {
      constructor = function(){};
    }

    if (name) {
      $defineProperty(constructor, 'displayName', '::'+name);
    }

    klass = constructor;

    $defineProperty(klass, '$$name', name);
    $defineProperty(klass, '$$constructor', constructor);
    $defineProperty(klass, '$$prototype', constructor.prototype);
    $defineProperty(klass, '$$const', {});
    $defineProperty(klass, '$$is_class', true);
    $defineProperty(klass, '$$is_a_module', true);
    $defineProperty(klass, '$$super', superclass);
    $defineProperty(klass, '$$cvars', {});
    $defineProperty(klass, '$$own_included_modules', []);
    $defineProperty(klass, '$$own_prepended_modules', []);
    $defineProperty(klass, '$$ancestors', []);
    $defineProperty(klass, '$$ancestors_cache_version', null);

    $defineProperty(klass.$$prototype, '$$class', klass);

    // By default if there are no singleton class methods
    // __proto__ is Class.prototype
    // Later singleton methods generate a singleton_class
    // and inject it into ancestors chain
    if (Opal.Class) {
      $set_proto(klass, Opal.Class.prototype);
    }

    if (superclass != null) {
      $set_proto(klass.$$prototype, superclass.$$prototype);

      if (superclass.$$meta) {
        // If superclass has metaclass then we have explicitely inherit it.
        Opal.build_class_singleton_class(klass);
      }
    }

    return klass;
  };


  function find_existing_class(scope, name) {
    // Try to find the class in the current scope
    var klass = const_get_name(scope, name);

    // If the class exists in the scope, then we must use that
    if (klass) {
      // Make sure the existing constant is a class, or raise error
      if (!klass.$$is_class) {
        throw Opal.TypeError.$new(name + " is not a class");
      }

      return klass;
    }
  }

  function ensureSuperclassMatch(klass, superclass) {
    if (klass.$$super !== superclass) {
      throw Opal.TypeError.$new("superclass mismatch for class " + klass.$$name);
    }
  }

  Opal.klass = function(scope, superclass, name) {
    var bridged;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    // If the superclass is not an Opal-generated class then we're bridging a native JS class
    if (
      superclass != null && (!superclass.hasOwnProperty || (
        superclass.hasOwnProperty && !superclass.hasOwnProperty('$$is_class')
      ))
    ) {
      if (superclass.constructor && superclass.constructor.name == "Function") {
        bridged = superclass;
        superclass = _Object;
      } else {
        throw Opal.TypeError.$new("superclass must be a Class (" + (
          (superclass.constructor && (superclass.constructor.name || superclass.constructor.$$name)) ||
          typeof(superclass)
        ) + " given)");
      }
    }

    var klass = find_existing_class(scope, name);

    if (klass) {
      if (superclass) {
        // Make sure existing class has same superclass
        ensureSuperclassMatch(klass, superclass);
      }

      if (Opal.trace_class) { invoke_tracers_for_class(klass); }

      return klass;
    }

    // Class doesn't exist, create a new one with given superclass...

    // Not specifying a superclass means we can assume it to be Object
    if (superclass == null) {
      superclass = _Object;
    }

    // Create the class object (instance of Class)
    klass = Opal.allocate_class(name, superclass);
    Opal.const_set(scope, name, klass);

    // Call .inherited() hook with new class on the superclass
    if (superclass.$inherited) {
      superclass.$inherited(klass);
    }

    if (bridged) {
      Opal.bridge(bridged, klass);
    }

    if (Opal.trace_class) { invoke_tracers_for_class(klass); }

    return klass;
  };

  // Define new module (or return existing module). The given `scope` is basically
  // the current `self` value the `module` statement was defined in. If this is
  // a ruby module or class, then it is used, otherwise if the scope is a ruby
  // object then that objects real ruby class is used (e.g. if the scope is the
  // main object, then the top level `Object` class is used as the scope).
  //
  // If a module of the given name is already defined in the scope, then that
  // instance is just returned.
  //
  // If there is a class of the given name in the scope, then an error is
  // generated instead (cannot have a class and module of same name in same scope).
  //
  // Otherwise, a new module is created in the scope with the given name, and that
  // new instance is returned back (to be referenced at runtime).
  //
  // @param  scope [Module, Class] class or module this definition is inside
  // @param  id   [String] the name of the new (or existing) module
  //
  // @return [Module]
  Opal.allocate_module = function(name) {
    var constructor = function(){};
    if (name) {
      $defineProperty(constructor, 'displayName', name+'.$$constructor');
    }

    var module = constructor;

    if (name)
      $defineProperty(constructor, 'displayName', name+'.constructor');

    $defineProperty(module, '$$name', name);
    $defineProperty(module, '$$prototype', constructor.prototype);
    $defineProperty(module, '$$const', {});
    $defineProperty(module, '$$is_module', true);
    $defineProperty(module, '$$is_a_module', true);
    $defineProperty(module, '$$cvars', {});
    $defineProperty(module, '$$iclasses', []);
    $defineProperty(module, '$$own_included_modules', []);
    $defineProperty(module, '$$own_prepended_modules', []);
    $defineProperty(module, '$$ancestors', [module]);
    $defineProperty(module, '$$ancestors_cache_version', null);

    $set_proto(module, Opal.Module.prototype);

    return module;
  };

  function find_existing_module(scope, name) {
    var module = const_get_name(scope, name);
    if (module == null && scope === _Object) module = const_lookup_ancestors(_Object, name);

    if (module) {
      if (!module.$$is_module && module !== _Object) {
        throw Opal.TypeError.$new(name + " is not a module");
      }
    }

    return module;
  }

  Opal.module = function(scope, name) {
    var module;

    if (scope == null || scope == '::') {
      // Global scope
      scope = _Object;
    } else if (!scope.$$is_class && !scope.$$is_module) {
      // Scope is an object, use its class
      scope = scope.$$class;
    }

    module = find_existing_module(scope, name);

    if (module) {

      if (Opal.trace_class) { invoke_tracers_for_class(module); }

      return module;
    }

    // Module doesnt exist, create a new one...
    module = Opal.allocate_module(name);
    Opal.const_set(scope, name, module);

    if (Opal.trace_class) { invoke_tracers_for_class(module); }

    return module;
  };

  // Return the singleton class for the passed object.
  //
  // If the given object alredy has a singleton class, then it will be stored on
  // the object as the `$$meta` property. If this exists, then it is simply
  // returned back.
  //
  // Otherwise, a new singleton object for the class or object is created, set on
  // the object at `$$meta` for future use, and then returned.
  //
  // @param object [Object] the ruby object
  // @return [Class] the singleton class for object
  Opal.get_singleton_class = function(object) {
    if (object.$$meta) {
      return object.$$meta;
    }

    if (object.hasOwnProperty('$$is_class')) {
      return Opal.build_class_singleton_class(object);
    } else if (object.hasOwnProperty('$$is_module')) {
      return Opal.build_module_singleton_class(object);
    } else {
      return Opal.build_object_singleton_class(object);
    }
  };

  // Build the singleton class for an existing class. Class object are built
  // with their singleton class already in the prototype chain and inheriting
  // from their superclass object (up to `Class` itself).
  //
  // NOTE: Actually in MRI a class' singleton class inherits from its
  // superclass' singleton class which in turn inherits from Class.
  //
  // @param klass [Class]
  // @return [Class]
  Opal.build_class_singleton_class = function(klass) {
    var superclass, meta;

    if (klass.$$meta) {
      return klass.$$meta;
    }

    // The singleton_class superclass is the singleton_class of its superclass;
    // but BasicObject has no superclass (its `$$super` is null), thus we
    // fallback on `Class`.
    superclass = klass === BasicObject ? Class : Opal.get_singleton_class(klass.$$super);

    meta = Opal.allocate_class(null, superclass, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', klass);
    $defineProperty(klass, '$$meta', meta);
    $set_proto(klass, meta.$$prototype);
    // Restoring ClassName.class
    $defineProperty(klass, '$$class', Opal.Class);

    return meta;
  };

  Opal.build_module_singleton_class = function(mod) {
    if (mod.$$meta) {
      return mod.$$meta;
    }

    var meta = Opal.allocate_class(null, Opal.Module, function(){});

    $defineProperty(meta, '$$is_singleton', true);
    $defineProperty(meta, '$$singleton_of', mod);
    $defineProperty(mod, '$$meta', meta);
    $set_proto(mod, meta.$$prototype);
    // Restoring ModuleName.class
    $defineProperty(mod, '$$class', Opal.Module);

    return meta;
  };

  // Build the singleton class for a Ruby (non class) Object.
  //
  // @param object [Object]
  // @return [Class]
  Opal.build_object_singleton_class = function(object) {
    var superclass = object.$$class,
        klass = Opal.allocate_class(nil, superclass, function(){});

    $defineProperty(klass, '$$is_singleton', true);
    $defineProperty(klass, '$$singleton_of', object);

    delete klass.$$prototype.$$class;

    $defineProperty(object, '$$meta', klass);

    $set_proto(object, object.$$meta.$$prototype);

    return klass;
  };

  Opal.is_method = function(prop) {
    return (prop[0] === '$' && prop[1] !== '$');
  };

  Opal.instance_methods = function(mod) {
    var exclude = [], results = [], ancestors = Opal.ancestors(mod);

    for (var i = 0, l = ancestors.length; i < l; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      var props = Object.getOwnPropertyNames(proto);

      for (var j = 0, ll = props.length; j < ll; j++) {
        var prop = props[j];

        if (Opal.is_method(prop)) {
          var method_name = prop.slice(1),
              method = proto[prop];

          if (method.$$stub && exclude.indexOf(method_name) === -1) {
            exclude.push(method_name);
          }

          if (!method.$$stub && results.indexOf(method_name) === -1 && exclude.indexOf(method_name) === -1) {
            results.push(method_name);
          }
        }
      }
    }

    return results;
  };

  Opal.own_instance_methods = function(mod) {
    var results = [],
        proto = mod.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto);

    for (var i = 0, length = props.length; i < length; i++) {
      var prop = props[i];

      if (Opal.is_method(prop)) {
        var method = proto[prop];

        if (!method.$$stub) {
          var method_name = prop.slice(1);
          results.push(method_name);
        }
      }
    }

    return results;
  };

  Opal.methods = function(obj) {
    return Opal.instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.own_methods = function(obj) {
    return Opal.own_instance_methods(Opal.get_singleton_class(obj));
  };

  Opal.receiver_methods = function(obj) {
    var mod = Opal.get_singleton_class(obj);
    var singleton_methods = Opal.own_instance_methods(mod);
    var instance_methods = Opal.own_instance_methods(mod.$$super);
    return singleton_methods.concat(instance_methods);
  };

  // Returns an object containing all pairs of names/values
  // for all class variables defined in provided +module+
  // and its ancestors.
  //
  // @param module [Module]
  // @return [Object]
  Opal.class_variables = function(module) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length,
        result = {};

    for (i = length - 1; i >= 0; i--) {
      var ancestor = ancestors[i];

      for (var cvar in ancestor.$$cvars) {
        result[cvar] = ancestor.$$cvars[cvar];
      }
    }

    return result;
  };

  // Sets class variable with specified +name+ to +value+
  // in provided +module+
  //
  // @param module [Module]
  // @param name [String]
  // @param value [Object]
  Opal.class_variable_set = function(module, name, value) {
    var ancestors = Opal.ancestors(module),
        i, length = ancestors.length;

    for (i = length - 2; i >= 0; i--) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        ancestor.$$cvars[name] = value;
        return value;
      }
    }

    module.$$cvars[name] = value;

    return value;
  };

  // Gets class variable with specified +name+ from provided +module+
  //
  // @param module [Module]
  // @param name [String]
  Opal.class_variable_get = function(module, name, tolerant) {
    if ($has_own.call(module.$$cvars, name))
      return module.$$cvars[name];

    var ancestors = Opal.ancestors(module),
      i, length = ancestors.length;

    for (i = 0; i < length; i++) {
      var ancestor = ancestors[i];

      if ($has_own.call(ancestor.$$cvars, name)) {
        return ancestor.$$cvars[name];
      }
    }

    if (!tolerant)
      throw Opal.NameError.$new('uninitialized class variable '+name+' in '+module.$name());

    return nil;
  }

  function isRoot(proto) {
    return proto.hasOwnProperty('$$iclass') && proto.hasOwnProperty('$$root');
  }

  function own_included_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    while (proto) {
      if (proto.hasOwnProperty('$$class')) {
        // superclass
        break;
      }
      mod = protoToModule(proto);
      if (mod) {
        result.push(mod);
      }
      proto = Object.getPrototypeOf(proto);
    }

    return result;
  }

  function own_prepended_modules(module) {
    var result = [], mod, proto = Object.getPrototypeOf(module.$$prototype);

    if (module.$$prototype.hasOwnProperty('$$dummy')) {
      while (proto) {
        if (proto === module.$$prototype.$$define_methods_on) {
          break;
        }

        mod = protoToModule(proto);
        if (mod) {
          result.push(mod);
        }

        proto = Object.getPrototypeOf(proto);
      }
    }

    return result;
  }


  // The actual inclusion of a module into a class.
  //
  // ## Class `$$parent` and `iclass`
  //
  // To handle `super` calls, every class has a `$$parent`. This parent is
  // used to resolve the next class for a super call. A normal class would
  // have this point to its superclass. However, if a class includes a module
  // then this would need to take into account the module. The module would
  // also have to then point its `$$parent` to the actual superclass. We
  // cannot modify modules like this, because it might be included in more
  // then one class. To fix this, we actually insert an `iclass` as the class'
  // `$$parent` which can then point to the superclass. The `iclass` acts as
  // a proxy to the actual module, so the `super` chain can then search it for
  // the required method.
  //
  // @param module [Module] the module to include
  // @param includer [Module] the target class to include module into
  // @return [null]
  Opal.append_features = function(module, includer) {
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(includer) !== -1) {
      throw Opal.ArgumentError.$new('cyclic include detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$included', true);
      iclasses.push(iclass);
    }
    var includer_ancestors = Opal.ancestors(includer),
        chain = chain_iclasses(iclasses),
        start_chain_after,
        end_chain_on;

    if (includer_ancestors.indexOf(module) === -1) {
      // first time include

      // includer -> chain.first -> ...chain... -> chain.last -> includer.parent
      start_chain_after = includer.$$prototype;
      end_chain_on = Object.getPrototypeOf(includer.$$prototype);
    } else {
      // The module has been already included,
      // we don't need to put it into the ancestors chain again,
      // but this module may have new included modules.
      // If it's true we need to copy them.
      //
      // The simplest way is to replace ancestors chain from
      //          parent
      //            |
      //   `module` iclass (has a $$root flag)
      //            |
      //   ...previos chain of module.included_modules ...
      //            |
      //  "next ancestor" (has a $$root flag or is a real class)
      //
      // to
      //          parent
      //            |
      //    `module` iclass (has a $$root flag)
      //            |
      //   ...regenerated chain of module.included_modules
      //            |
      //   "next ancestor" (has a $$root flag or is a real class)
      //
      // because there are no intermediate classes between `parent` and `next ancestor`.
      // It doesn't break any prototypes of other objects as we don't change class references.

      var parent = includer.$$prototype, module_iclass = Object.getPrototypeOf(parent);

      while (module_iclass != null) {
        if (module_iclass.$$module === module && isRoot(module_iclass)) {
          break;
        }

        parent = module_iclass;
        module_iclass = Object.getPrototypeOf(module_iclass);
      }

      if (module_iclass) {
        // module has been directly included
        var next_ancestor = Object.getPrototypeOf(module_iclass);

        // skip non-root iclasses (that were recursively included)
        while (next_ancestor.hasOwnProperty('$$iclass') && !isRoot(next_ancestor)) {
          next_ancestor = Object.getPrototypeOf(next_ancestor);
        }

        start_chain_after = parent;
        end_chain_on = next_ancestor;
      } else {
        // module has not been directly included but was in ancestor chain because it was included by another module
        // include it directly
        start_chain_after = includer.$$prototype;
        end_chain_on = Object.getPrototypeOf(includer.$$prototype);
      }
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_included_modules cache
    includer.$$own_included_modules = own_included_modules(includer);

    Opal.const_cache_version++;
  };

  Opal.prepend_features = function(module, prepender) {
    // Here we change the ancestors chain from
    //
    //   prepender
    //      |
    //    parent
    //
    // to:
    //
    // dummy(prepender)
    //      |
    //  iclass(module)
    //      |
    // iclass(prepender)
    //      |
    //    parent
    var module_ancestors = Opal.ancestors(module);
    var iclasses = [];

    if (module_ancestors.indexOf(prepender) !== -1) {
      throw Opal.ArgumentError.$new('cyclic prepend detected');
    }

    for (var i = 0, length = module_ancestors.length; i < length; i++) {
      var ancestor = module_ancestors[i], iclass = create_iclass(ancestor);
      $defineProperty(iclass, '$$prepended', true);
      iclasses.push(iclass);
    }

    var chain = chain_iclasses(iclasses),
        dummy_prepender = prepender.$$prototype,
        previous_parent = Object.getPrototypeOf(dummy_prepender),
        prepender_iclass,
        start_chain_after,
        end_chain_on;

    if (dummy_prepender.hasOwnProperty('$$dummy')) {
      // The module already has some prepended modules
      // which means that we don't need to make it "dummy"
      prepender_iclass = dummy_prepender.$$define_methods_on;
    } else {
      // Making the module "dummy"
      prepender_iclass = create_dummy_iclass(prepender);
      flush_methods_in(prepender);
      $defineProperty(dummy_prepender, '$$dummy', true);
      $defineProperty(dummy_prepender, '$$define_methods_on', prepender_iclass);

      // Converting
      //   dummy(prepender) -> previous_parent
      // to
      //   dummy(prepender) -> iclass(prepender) -> previous_parent
      $set_proto(dummy_prepender, prepender_iclass);
      $set_proto(prepender_iclass, previous_parent);
    }

    var prepender_ancestors = Opal.ancestors(prepender);

    if (prepender_ancestors.indexOf(module) === -1) {
      // first time prepend

      start_chain_after = dummy_prepender;

      // next $$root or prepender_iclass or non-$$iclass
      end_chain_on = Object.getPrototypeOf(dummy_prepender);
      while (end_chain_on != null) {
        if (
          end_chain_on.hasOwnProperty('$$root') ||
          end_chain_on === prepender_iclass ||
          !end_chain_on.hasOwnProperty('$$iclass')
        ) {
          break;
        }

        end_chain_on = Object.getPrototypeOf(end_chain_on);
      }
    } else {
      throw Opal.RuntimeError.$new("Prepending a module multiple times is not supported");
    }

    $set_proto(start_chain_after, chain.first);
    $set_proto(chain.last, end_chain_on);

    // recalculate own_prepended_modules cache
    prepender.$$own_prepended_modules = own_prepended_modules(prepender);

    Opal.const_cache_version++;
  };

  function flush_methods_in(module) {
    var proto = module.$$prototype,
        props = Object.getOwnPropertyNames(proto);

    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      if (Opal.is_method(prop)) {
        delete proto[prop];
      }
    }
  }

  function create_iclass(module) {
    var iclass = create_dummy_iclass(module);

    if (module.$$is_module) {
      module.$$iclasses.push(iclass);
    }

    return iclass;
  }

  // Dummy iclass doesn't receive updates when the module gets a new method.
  function create_dummy_iclass(module) {
    var iclass = {},
        proto = module.$$prototype;

    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }

    var props = Object.getOwnPropertyNames(proto),
        length = props.length, i;

    for (i = 0; i < length; i++) {
      var prop = props[i];
      $defineProperty(iclass, prop, proto[prop]);
    }

    $defineProperty(iclass, '$$iclass', true);
    $defineProperty(iclass, '$$module', module);

    return iclass;
  }

  function chain_iclasses(iclasses) {
    var length = iclasses.length, first = iclasses[0];

    $defineProperty(first, '$$root', true);

    if (length === 1) {
      return { first: first, last: first };
    }

    var previous = first;

    for (var i = 1; i < length; i++) {
      var current = iclasses[i];
      $set_proto(previous, current);
      previous = current;
    }


    return { first: iclasses[0], last: iclasses[length - 1] };
  }

  // For performance, some core Ruby classes are toll-free bridged to their
  // native JavaScript counterparts (e.g. a Ruby Array is a JavaScript Array).
  //
  // This method is used to setup a native constructor (e.g. Array), to have
  // its prototype act like a normal Ruby class. Firstly, a new Ruby class is
  // created using the native constructor so that its prototype is set as the
  // target for the new class. Note: all bridged classes are set to inherit
  // from Object.
  //
  // Example:
  //
  //    Opal.bridge(self, Function);
  //
  // @param klass       [Class] the Ruby class to bridge
  // @param constructor [JS.Function] native JavaScript constructor to use
  // @return [Class] returns the passed Ruby class
  //
  Opal.bridge = function(native_klass, klass) {
    if (native_klass.hasOwnProperty('$$bridge')) {
      throw Opal.ArgumentError.$new("already bridged");
    }

    // constructor is a JS function with a prototype chain like:
    // - constructor
    //   - super
    //
    // What we need to do is to inject our class (with its prototype chain)
    // between constructor and super. For example, after injecting ::Object
    // into JS String we get:
    //
    // - constructor (window.String)
    //   - Opal.Object
    //     - Opal.Kernel
    //       - Opal.BasicObject
    //         - super (window.Object)
    //           - null
    //
    $defineProperty(native_klass, '$$bridge', klass);
    $set_proto(native_klass.prototype, (klass.$$super || Opal.Object).$$prototype);
    $defineProperty(klass, '$$prototype', native_klass.prototype);

    $defineProperty(klass.$$prototype, '$$class', klass);
    $defineProperty(klass, '$$constructor', native_klass);
    $defineProperty(klass, '$$bridge', true);
  };

  function protoToModule(proto) {
    if (proto.hasOwnProperty('$$dummy')) {
      return;
    } else if (proto.hasOwnProperty('$$iclass')) {
      return proto.$$module;
    } else if (proto.hasOwnProperty('$$class')) {
      return proto.$$class;
    }
  }

  function own_ancestors(module) {
    return module.$$own_prepended_modules.concat([module]).concat(module.$$own_included_modules);
  }

  // The Array of ancestors for a given module/class
  Opal.ancestors = function(module) {
    if (!module) { return []; }

    if (module.$$ancestors_cache_version === Opal.const_cache_version) {
      return module.$$ancestors;
    }

    var result = [], i, mods, length;

    for (i = 0, mods = own_ancestors(module), length = mods.length; i < length; i++) {
      result.push(mods[i]);
    }

    if (module.$$super) {
      for (i = 0, mods = Opal.ancestors(module.$$super), length = mods.length; i < length; i++) {
        result.push(mods[i]);
      }
    }

    module.$$ancestors_cache_version = Opal.const_cache_version;
    module.$$ancestors = result;

    return result;
  };

  Opal.included_modules = function(module) {
    var result = [], mod = null, proto = Object.getPrototypeOf(module.$$prototype);

    for (; proto && Object.getPrototypeOf(proto); proto = Object.getPrototypeOf(proto)) {
      mod = protoToModule(proto);
      if (mod && mod.$$is_module && proto.$$iclass && proto.$$included) {
        result.push(mod);
      }
    }

    return result;
  };


  // Method Missing
  // --------------

  // Methods stubs are used to facilitate method_missing in opal. A stub is a
  // placeholder function which just calls `method_missing` on the receiver.
  // If no method with the given name is actually defined on an object, then it
  // is obvious to say that the stub will be called instead, and then in turn
  // method_missing will be called.
  //
  // When a file in ruby gets compiled to javascript, it includes a call to
  // this function which adds stubs for every method name in the compiled file.
  // It should then be safe to assume that method_missing will work for any
  // method call detected.
  //
  // Method stubs are added to the BasicObject prototype, which every other
  // ruby object inherits, so all objects should handle method missing. A stub
  // is only added if the given property name (method name) is not already
  // defined.
  //
  // Note: all ruby methods have a `$` prefix in javascript, so all stubs will
  // have this prefix as well (to make this method more performant).
  //
  //    Opal.add_stubs(["$foo", "$bar", "$baz="]);
  //
  // All stub functions will have a private `$$stub` property set to true so
  // that other internal methods can detect if a method is just a stub or not.
  // `Kernel#respond_to?` uses this property to detect a methods presence.
  //
  // @param stubs [Array] an array of method stubs to add
  // @return [undefined]
  Opal.add_stubs = function(stubs) {
    var proto = Opal.BasicObject.$$prototype;

    for (var i = 0, length = stubs.length; i < length; i++) {
      var stub = stubs[i], existing_method = proto[stub];

      if (existing_method == null || existing_method.$$stub) {
        Opal.add_stub_for(proto, stub);
      }
    }
  };

  // Add a method_missing stub function to the given prototype for the
  // given name.
  //
  // @param prototype [Prototype] the target prototype
  // @param stub [String] stub name to add (e.g. "$foo")
  // @return [undefined]
  Opal.add_stub_for = function(prototype, stub) {
    var method_missing_stub = Opal.stub_for(stub);
    $defineProperty(prototype, stub, method_missing_stub);
  };

  // Generate the method_missing stub for a given method name.
  //
  // @param method_name [String] The js-name of the method to stub (e.g. "$foo")
  // @return [undefined]
  Opal.stub_for = function(method_name) {

    function method_missing_stub() {
      // Copy any given block onto the method_missing dispatcher
      this.$method_missing.$$p = method_missing_stub.$$p;

      // Set block property to null ready for the next call (stop false-positives)
      method_missing_stub.$$p = null;

      // call method missing with correct args (remove '$' prefix on method name)
      var args_ary = new Array(arguments.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = arguments[i]; }

      return this.$method_missing.apply(this, [method_name.slice(1)].concat(args_ary));
    }

    method_missing_stub.$$stub = true;

    return method_missing_stub;
  };


  // Methods
  // -------

  // Arity count error dispatcher for methods
  //
  // @param actual [Fixnum] number of arguments given to method
  // @param expected [Fixnum] expected number of arguments
  // @param object [Object] owner of the method +meth+
  // @param meth [String] method name that got wrong number of arguments
  // @raise [ArgumentError]
  Opal.ac = function(actual, expected, object, meth) {
    var inspect = '';
    if (object.$$is_a_module) {
      inspect += object.$$name + '.';
    }
    else {
      inspect += object.$$class.$$name + '#';
    }
    inspect += meth;

    throw Opal.ArgumentError.$new('[' + inspect + '] wrong number of arguments(' + actual + ' for ' + expected + ')');
  };

  // Arity count error dispatcher for blocks
  //
  // @param actual [Fixnum] number of arguments given to block
  // @param expected [Fixnum] expected number of arguments
  // @param context [Object] context of the block definition
  // @raise [ArgumentError]
  Opal.block_ac = function(actual, expected, context) {
    var inspect = "`block in " + context + "'";

    throw Opal.ArgumentError.$new(inspect + ': wrong number of arguments (' + actual + ' for ' + expected + ')');
  };

  // Super dispatcher
  Opal.find_super_dispatcher = function(obj, mid, current_func, defcheck, allow_stubs) {
    var jsid = '$' + mid, ancestors, super_method;

    if (obj.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(obj.$$meta);
    } else {
      ancestors = Opal.ancestors(obj.$$class);
    }

    var current_index = ancestors.indexOf(current_func.$$owner);

    for (var i = current_index + 1; i < ancestors.length; i++) {
      var ancestor = ancestors[i],
          proto = ancestor.$$prototype;

      if (proto.hasOwnProperty('$$dummy')) {
        proto = proto.$$define_methods_on;
      }

      if (proto.hasOwnProperty(jsid)) {
        super_method = proto[jsid];
        break;
      }
    }

    if (!defcheck && super_method && super_method.$$stub && obj.$method_missing.$$pristine) {
      // method_missing hasn't been explicitly defined
      throw Opal.NoMethodError.$new('super: no superclass method `'+mid+"' for "+obj, mid);
    }

    return (super_method.$$stub && !allow_stubs) ? null : super_method;
  };

  // Iter dispatcher for super in a block
  Opal.find_iter_super_dispatcher = function(obj, jsid, current_func, defcheck, implicit) {
    var call_jsid = jsid;

    if (!current_func) {
      throw Opal.RuntimeError.$new("super called outside of method");
    }

    if (implicit && current_func.$$define_meth) {
      throw Opal.RuntimeError.$new("implicit argument passing of super from method defined by define_method() is not supported. Specify all arguments explicitly");
    }

    if (current_func.$$def) {
      call_jsid = current_func.$$jsid;
    }

    return Opal.find_super_dispatcher(obj, call_jsid, current_func, defcheck);
  };

  // Used to return as an expression. Sometimes, we can't simply return from
  // a javascript function as if we were a method, as the return is used as
  // an expression, or even inside a block which must "return" to the outer
  // method. This helper simply throws an error which is then caught by the
  // method. This approach is expensive, so it is only used when absolutely
  // needed.
  //
  Opal.ret = function(val) {
    Opal.returner.$v = val;
    throw Opal.returner;
  };

  // Used to break out of a block.
  Opal.brk = function(val, breaker) {
    breaker.$v = val;
    throw breaker;
  };

  // Builds a new unique breaker, this is to avoid multiple nested breaks to get
  // in the way of each other.
  Opal.new_brk = function() {
    return new Error('unexpected break');
  };

  // handles yield calls for 1 yielded arg
  Opal.yield1 = function(block, arg) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    var has_mlhs = block.$$has_top_level_mlhs_arg,
        has_trailing_comma = block.$$has_trailing_comma_in_args;

    if (block.length > 1 || ((has_mlhs || has_trailing_comma) && block.length === 1)) {
      arg = Opal.to_ary(arg);
    }

    if ((block.length > 1 || (has_trailing_comma && block.length === 1)) && arg.$$is_array) {
      return block.apply(null, arg);
    }
    else {
      return block(arg);
    }
  };

  // handles yield for > 1 yielded arg
  Opal.yieldX = function(block, args) {
    if (typeof(block) !== "function") {
      throw Opal.LocalJumpError.$new("no block given");
    }

    if (block.length > 1 && args.length === 1) {
      if (args[0].$$is_array) {
        return block.apply(null, args[0]);
      }
    }

    if (!args.$$is_array) {
      var args_ary = new Array(args.length);
      for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

      return block.apply(null, args_ary);
    }

    return block.apply(null, args);
  };

  // Finds the corresponding exception match in candidates.  Each candidate can
  // be a value, or an array of values.  Returns null if not found.
  Opal.rescue = function(exception, candidates) {
    for (var i = 0; i < candidates.length; i++) {
      var candidate = candidates[i];

      if (candidate.$$is_array) {
        var result = Opal.rescue(exception, candidate);

        if (result) {
          return result;
        }
      }
      else if (candidate === Opal.JS.Error) {
        return candidate;
      }
      else if (candidate['$==='](exception)) {
        return candidate;
      }
    }

    return null;
  };

  Opal.is_a = function(object, klass) {
    if (klass != null && object.$$meta === klass || object.$$class === klass) {
      return true;
    }

    if (object.$$is_number && klass.$$is_number_class) {
      return (klass.$$is_integer_class) ? (object % 1) === 0 : true;
    }

    var i, length, ancestors = Opal.ancestors(object.$$is_class ? Opal.get_singleton_class(object) : (object.$$meta || object.$$class));

    for (i = 0, length = ancestors.length; i < length; i++) {
      if (ancestors[i] === klass) {
        return true;
      }
    }

    return false;
  };

  // Helpers for extracting kwsplats
  // Used for: { **h }
  Opal.to_hash = function(value) {
    if (value.$$is_hash) {
      return value;
    }
    else if (value['$respond_to?']('to_hash', true)) {
      var hash = value.$to_hash();
      if (hash.$$is_hash) {
        return hash;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Hash (" + value.$$class + "#to_hash gives " + hash.$$class + ")");
      }
    }
    else {
      throw Opal.TypeError.$new("no implicit conversion of " + value.$$class + " into Hash");
    }
  };

  // Helpers for implementing multiple assignment
  // Our code for extracting the values and assigning them only works if the
  // return value is a JS array.
  // So if we get an Array subclass, extract the wrapped JS array from it

  // Used for: a, b = something (no splat)
  Opal.to_ary = function(value) {
    if (value.$$is_array) {
      return value;
    }
    else if (value['$respond_to?']('to_ary', true)) {
      var ary = value.$to_ary();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_ary gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for: a, b = *something (with splat)
  Opal.to_a = function(value) {
    if (value.$$is_array) {
      // A splatted array must be copied
      return value.slice();
    }
    else if (value['$respond_to?']('to_a', true)) {
      var ary = value.$to_a();
      if (ary === nil) {
        return [value];
      }
      else if (ary.$$is_array) {
        return ary;
      }
      else {
        throw Opal.TypeError.$new("Can't convert " + value.$$class +
          " to Array (" + value.$$class + "#to_a gives " + ary.$$class + ")");
      }
    }
    else {
      return [value];
    }
  };

  // Used for extracting keyword arguments from arguments passed to
  // JS function. If provided +arguments+ list doesn't have a Hash
  // as a last item, returns a blank Hash.
  //
  // @param parameters [Array]
  // @return [Hash]
  //
  Opal.extract_kwargs = function(parameters) {
    var kwargs = parameters[parameters.length - 1];
    if (kwargs != null && Opal.respond_to(kwargs, '$to_hash', true)) {
      $splice.call(parameters, parameters.length - 1, 1);
      return kwargs.$to_hash();
    }
    else {
      return Opal.hash2([], {});
    }
  };

  // Used to get a list of rest keyword arguments. Method takes the given
  // keyword args, i.e. the hash literal passed to the method containing all
  // keyword arguemnts passed to method, as well as the used args which are
  // the names of required and optional arguments defined. This method then
  // just returns all key/value pairs which have not been used, in a new
  // hash literal.
  //
  // @param given_args [Hash] all kwargs given to method
  // @param used_args [Object<String: true>] all keys used as named kwargs
  // @return [Hash]
  //
  Opal.kwrestargs = function(given_args, used_args) {
    var keys      = [],
        map       = {},
        key           ,
        given_map = given_args.$$smap;

    for (key in given_map) {
      if (!used_args[key]) {
        keys.push(key);
        map[key] = given_map[key];
      }
    }

    return Opal.hash2(keys, map);
  };

  // Calls passed method on a ruby object with arguments and block:
  //
  // Can take a method or a method name.
  //
  // 1. When method name gets passed it invokes it by its name
  //    and calls 'method_missing' when object doesn't have this method.
  //    Used internally by Opal to invoke method that takes a block or a splat.
  // 2. When method (i.e. method body) gets passed, it doesn't trigger 'method_missing'
  //    because it doesn't know the name of the actual method.
  //    Used internally by Opal to invoke 'super'.
  //
  // @example
  //   var my_array = [1, 2, 3, 4]
  //   Opal.send(my_array, 'length')                    # => 4
  //   Opal.send(my_array, my_array.$length)            # => 4
  //
  //   Opal.send(my_array, 'reverse!')                  # => [4, 3, 2, 1]
  //   Opal.send(my_array, my_array['$reverse!']')      # => [4, 3, 2, 1]
  //
  // @param recv [Object] ruby object
  // @param method [Function, String] method body or name of the method
  // @param args [Array] arguments that will be passed to the method call
  // @param block [Function] ruby block
  // @return [Object] returning value of the method call
  Opal.send = function(recv, method, args, block) {
    var body;

    if (typeof(method) === 'function') {
      body = method;
      method = null;
    } else if (typeof(method) === 'string') {
      body = recv['$'+method];
    } else {
      throw Opal.NameError.$new("Passed method should be a string or a function");
    }

    return Opal.send2(recv, body, method, args, block);
  };

  Opal.send2 = function(recv, body, method, args, block) {
    if (body == null && method != null && recv.$method_missing) {
      body = recv.$method_missing;
      args = [method].concat(args);
    }

    if (typeof block === 'function') body.$$p = block;
    return body.apply(recv, args);
  };

  Opal.refined_send = function(refinement_groups, recv, method, args, block) {
    var i, j, k, ancestors, ancestor, refinements, refinement, refine_modules, refine_module, body;

    if (recv.hasOwnProperty('$$meta')) {
      ancestors = Opal.ancestors(recv.$$meta);
    } else {
      ancestors = Opal.ancestors(recv.$$class);
    }

    // For all ancestors that there are, starting from the closest to the furthest...
    for (i = 0; i < ancestors.length; i++) {
      ancestor = Opal.id(ancestors[i]);
      // For all refinement groups there are, starting from the closest scope to the furthest...
      for (j = 0; j < refinement_groups.length; j++) {
        refinements = refinement_groups[j];
        // For all refinements there are, starting from the last `using` call to the furthest...
        for (k = refinements.length - 1; k >= 0; k--) {
          refinement = refinements[k];
          if (typeof refinement.$$refine_modules === 'undefined') continue;
          // A single module being given as an argument of the `using` call contains multiple
          // refinement modules
          refine_modules = refinement.$$refine_modules;
          // Does this module refine a given call for a given ancestor module?
          if (typeof refine_modules[ancestor] !== 'undefined') {
            refine_module = refine_modules[ancestor];
            // Does this module define a method we want to call?
            if (typeof refine_module.$$prototype['$'+method] !== 'undefined') {
              body = refine_module.$$prototype['$'+method];
              return Opal.send2(recv, body, method, args, block);
            }
          }
        }
      }
    }

    return Opal.send(recv, method, args, block);
  };

  Opal.lambda = function(block) {
    block.$$is_lambda = true;
    return block;
  };

  // Used to define methods on an object. This is a helper method, used by the
  // compiled source to define methods on special case objects when the compiler
  // can not determine the destination object, or the object is a Module
  // instance. This can get called by `Module#define_method` as well.
  //
  // ## Modules
  //
  // Any method defined on a module will come through this runtime helper.
  // The method is added to the module body, and the owner of the method is
  // set to be the module itself. This is used later when choosing which
  // method should show on a class if more than 1 included modules define
  // the same method. Finally, if the module is in `module_function` mode,
  // then the method is also defined onto the module itself.
  //
  // ## Classes
  //
  // This helper will only be called for classes when a method is being
  // defined indirectly; either through `Module#define_method`, or by a
  // literal `def` method inside an `instance_eval` or `class_eval` body. In
  // either case, the method is simply added to the class' prototype. A special
  // exception exists for `BasicObject` and `Object`. These two classes are
  // special because they are used in toll-free bridged classes. In each of
  // these two cases, extra work is required to define the methods on toll-free
  // bridged class' prototypes as well.
  //
  // ## Objects
  //
  // If a simple ruby object is the object, then the method is simply just
  // defined on the object as a singleton method. This would be the case when
  // a method is defined inside an `instance_eval` block.
  //
  // @param obj  [Object, Class] the actual obj to define method for
  // @param jsid [String] the JavaScript friendly method name (e.g. '$foo')
  // @param body [JS.Function] the literal JavaScript function used as method
  // @return [null]
  //
  Opal.def = function(obj, jsid, body) {
    // Special case for a method definition in the
    // top-level namespace
    if (obj === Opal.top) {
      Opal.defn(Opal.Object, jsid, body)
    }
    // if instance_eval is invoked on a module/class, it sets inst_eval_mod
    else if (!obj.$$eval && obj.$$is_a_module) {
      Opal.defn(obj, jsid, body);
    }
    else {
      Opal.defs(obj, jsid, body);
    }
  };

  // Define method on a module or class (see Opal.def).
  Opal.defn = function(module, jsid, body) {
    body.displayName = jsid;
    body.$$owner = module;

    var proto = module.$$prototype;
    if (proto.hasOwnProperty('$$dummy')) {
      proto = proto.$$define_methods_on;
    }
    $defineProperty(proto, jsid, body);

    if (module.$$is_module) {
      if (module.$$module_function) {
        Opal.defs(module, jsid, body)
      }

      for (var i = 0, iclasses = module.$$iclasses, length = iclasses.length; i < length; i++) {
        var iclass = iclasses[i];
        $defineProperty(iclass, jsid, body);
      }
    }

    var singleton_of = module.$$singleton_of;
    if (module.$method_added && !module.$method_added.$$stub && !singleton_of) {
      module.$method_added(jsid.substr(1));
    }
    else if (singleton_of && singleton_of.$singleton_method_added && !singleton_of.$singleton_method_added.$$stub) {
      singleton_of.$singleton_method_added(jsid.substr(1));
    }
  };

  // Define a singleton method on the given object (see Opal.def).
  Opal.defs = function(obj, jsid, body) {
    if (obj.$$is_string || obj.$$is_number) {
      throw Opal.TypeError.$new("can't define singleton");
    }
    Opal.defn(Opal.get_singleton_class(obj), jsid, body)
  };

  // Called from #remove_method.
  Opal.rdef = function(obj, jsid) {
    if (!$has_own.call(obj.$$prototype, jsid)) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    delete obj.$$prototype[jsid];

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_removed && !obj.$$prototype.$singleton_method_removed.$$stub) {
        obj.$$prototype.$singleton_method_removed(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_removed && !obj.$method_removed.$$stub) {
        obj.$method_removed(jsid.substr(1));
      }
    }
  };

  // Called from #undef_method.
  Opal.udef = function(obj, jsid) {
    if (!obj.$$prototype[jsid] || obj.$$prototype[jsid].$$stub) {
      throw Opal.NameError.$new("method '" + jsid.substr(1) + "' not defined in " + obj.$name());
    }

    Opal.add_stub_for(obj.$$prototype, jsid);

    if (obj.$$is_singleton) {
      if (obj.$$prototype.$singleton_method_undefined && !obj.$$prototype.$singleton_method_undefined.$$stub) {
        obj.$$prototype.$singleton_method_undefined(jsid.substr(1));
      }
    }
    else {
      if (obj.$method_undefined && !obj.$method_undefined.$$stub) {
        obj.$method_undefined(jsid.substr(1));
      }
    }
  };

  function is_method_body(body) {
    return (typeof(body) === "function" && !body.$$stub);
  }

  Opal.alias = function(obj, name, old) {
    var id     = '$' + name,
        old_id = '$' + old,
        body,
        alias;

    // Aliasing on main means aliasing on Object...
    if (typeof obj.$$prototype === 'undefined') {
      obj = Opal.Object;
    }

    body = obj.$$prototype['$' + old];

    // When running inside #instance_eval the alias refers to class methods.
    if (obj.$$eval) {
      return Opal.alias(Opal.get_singleton_class(obj), name, old);
    }

    if (!is_method_body(body)) {
      var ancestor = obj.$$super;

      while (typeof(body) !== "function" && ancestor) {
        body     = ancestor[old_id];
        ancestor = ancestor.$$super;
      }

      if (!is_method_body(body) && obj.$$is_module) {
        // try to look into Object
        body = Opal.Object.$$prototype[old_id]
      }

      if (!is_method_body(body)) {
        throw Opal.NameError.$new("undefined method `" + old + "' for class `" + obj.$name() + "'")
      }
    }

    // If the body is itself an alias use the original body
    // to keep the max depth at 1.
    if (body.$$alias_of) body = body.$$alias_of;

    // We need a wrapper because otherwise properties
    // would be overwritten on the original body.
    alias = function() {
      var block = alias.$$p, args, i, ii;

      args = new Array(arguments.length);
      for(i = 0, ii = arguments.length; i < ii; i++) {
        args[i] = arguments[i];
      }

      if (block != null) { alias.$$p = null }

      return Opal.send(this, body, args, block);
    };

    // Assign the 'length' value with defineProperty because
    // in strict mode the property is not writable.
    // It doesn't work in older browsers (like Chrome 38), where
    // an exception is thrown breaking Opal altogether.
    try {
      Object.defineProperty(alias, 'length', { value: body.length });
    } catch (e) {}

    // Try to make the browser pick the right name
    alias.displayName       = name;

    alias.$$arity           = body.$$arity;
    alias.$$parameters      = body.$$parameters;
    alias.$$source_location = body.$$source_location;
    alias.$$alias_of        = body;
    alias.$$alias_name      = name;

    Opal.defn(obj, id, alias);

    return obj;
  };

  Opal.alias_gvar = function(new_name, old_name) {
    Object.defineProperty(Opal.gvars, new_name, {
      configurable: true,
      enumerable: true,
      get: function() {
        return Opal.gvars[old_name];
      },
      set: function(new_value) {
        Opal.gvars[old_name] = new_value;
      }
    });
    return nil;
  }

  Opal.alias_native = function(obj, name, native_name) {
    var id   = '$' + name,
        body = obj.$$prototype[native_name];

    if (typeof(body) !== "function" || body.$$stub) {
      throw Opal.NameError.$new("undefined native method `" + native_name + "' for class `" + obj.$name() + "'")
    }

    Opal.defn(obj, id, body);

    return obj;
  };


  // Hashes
  // ------

  Opal.hash_init = function(hash) {
    hash.$$smap = Object.create(null);
    hash.$$map  = Object.create(null);
    hash.$$keys = [];
  };

  Opal.hash_clone = function(from_hash, to_hash) {
    to_hash.$$none = from_hash.$$none;
    to_hash.$$proc = from_hash.$$proc;

    for (var i = 0, keys = from_hash.$$keys, smap = from_hash.$$smap, len = keys.length, key, value; i < len; i++) {
      key = keys[i];

      if (key.$$is_string) {
        value = smap[key];
      } else {
        value = key.value;
        key = key.key;
      }

      Opal.hash_put(to_hash, key, value);
    }
  };

  Opal.hash_put = function(hash, key, value) {
    if (key.$$is_string) {
      if (!$has_own.call(hash.$$smap, key)) {
        hash.$$keys.push(key);
      }
      hash.$$smap[key] = value;
      return;
    }

    var key_hash, bucket, last_bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      hash.$$map[key_hash] = bucket;
      return;
    }

    bucket = hash.$$map[key_hash];

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        last_bucket = undefined;
        bucket.value = value;
        break;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }

    if (last_bucket) {
      bucket = {key: key, key_hash: key_hash, value: value};
      hash.$$keys.push(bucket);
      last_bucket.next = bucket;
    }
  };

  Opal.hash_get = function(hash, key) {
    if (key.$$is_string) {
      if ($has_own.call(hash.$$smap, key)) {
        return hash.$$smap[key];
      }
      return;
    }

    var key_hash, bucket;
    key_hash = hash.$$by_identity ? Opal.id(key) : key.$hash();

    if ($has_own.call(hash.$$map, key_hash)) {
      bucket = hash.$$map[key_hash];

      while (bucket) {
        if (key === bucket.key || key['$eql?'](bucket.key)) {
          return bucket.value;
        }
        bucket = bucket.next;
      }
    }
  };

  Opal.hash_delete = function(hash, key) {
    var i, keys = hash.$$keys, length = keys.length, value;

    if (key.$$is_string) {
      if (typeof key !== "string") key = key.valueOf();

      if (!$has_own.call(hash.$$smap, key)) {
        return;
      }

      for (i = 0; i < length; i++) {
        if (keys[i] === key) {
          keys.splice(i, 1);
          break;
        }
      }

      value = hash.$$smap[key];
      delete hash.$$smap[key];
      return value;
    }

    var key_hash = key.$hash();

    if (!$has_own.call(hash.$$map, key_hash)) {
      return;
    }

    var bucket = hash.$$map[key_hash], last_bucket;

    while (bucket) {
      if (key === bucket.key || key['$eql?'](bucket.key)) {
        value = bucket.value;

        for (i = 0; i < length; i++) {
          if (keys[i] === bucket) {
            keys.splice(i, 1);
            break;
          }
        }

        if (last_bucket && bucket.next) {
          last_bucket.next = bucket.next;
        }
        else if (last_bucket) {
          delete last_bucket.next;
        }
        else if (bucket.next) {
          hash.$$map[key_hash] = bucket.next;
        }
        else {
          delete hash.$$map[key_hash];
        }

        return value;
      }
      last_bucket = bucket;
      bucket = bucket.next;
    }
  };

  Opal.hash_rehash = function(hash) {
    for (var i = 0, length = hash.$$keys.length, key_hash, bucket, last_bucket; i < length; i++) {

      if (hash.$$keys[i].$$is_string) {
        continue;
      }

      key_hash = hash.$$keys[i].key.$hash();

      if (key_hash === hash.$$keys[i].key_hash) {
        continue;
      }

      bucket = hash.$$map[hash.$$keys[i].key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          if (last_bucket && bucket.next) {
            last_bucket.next = bucket.next;
          }
          else if (last_bucket) {
            delete last_bucket.next;
          }
          else if (bucket.next) {
            hash.$$map[hash.$$keys[i].key_hash] = bucket.next;
          }
          else {
            delete hash.$$map[hash.$$keys[i].key_hash];
          }
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      hash.$$keys[i].key_hash = key_hash;

      if (!$has_own.call(hash.$$map, key_hash)) {
        hash.$$map[key_hash] = hash.$$keys[i];
        continue;
      }

      bucket = hash.$$map[key_hash];
      last_bucket = undefined;

      while (bucket) {
        if (bucket === hash.$$keys[i]) {
          last_bucket = undefined;
          break;
        }
        last_bucket = bucket;
        bucket = bucket.next;
      }

      if (last_bucket) {
        last_bucket.next = hash.$$keys[i];
      }
    }
  };

  Opal.hash = function() {
    var arguments_length = arguments.length, args, hash, i, length, key, value;

    if (arguments_length === 1 && arguments[0].$$is_hash) {
      return arguments[0];
    }

    hash = new Opal.Hash();
    Opal.hash_init(hash);

    if (arguments_length === 1 && arguments[0].$$is_array) {
      args = arguments[0];
      length = args.length;

      for (i = 0; i < length; i++) {
        if (args[i].length !== 2) {
          throw Opal.ArgumentError.$new("value not of length 2: " + args[i].$inspect());
        }

        key = args[i][0];
        value = args[i][1];

        Opal.hash_put(hash, key, value);
      }

      return hash;
    }

    if (arguments_length === 1) {
      args = arguments[0];
      for (key in args) {
        if ($has_own.call(args, key)) {
          value = args[key];

          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    }

    if (arguments_length % 2 !== 0) {
      throw Opal.ArgumentError.$new("odd number of arguments for Hash");
    }

    for (i = 0; i < arguments_length; i += 2) {
      key = arguments[i];
      value = arguments[i + 1];

      Opal.hash_put(hash, key, value);
    }

    return hash;
  };

  // A faster Hash creator for hashes that just use symbols and
  // strings as keys. The map and keys array can be constructed at
  // compile time, so they are just added here by the constructor
  // function.
  //
  Opal.hash2 = function(keys, smap) {
    var hash = new Opal.Hash();

    hash.$$smap = smap;
    hash.$$map  = Object.create(null);
    hash.$$keys = keys;

    return hash;
  };

  // Create a new range instance with first and last values, and whether the
  // range excludes the last value.
  //
  Opal.range = function(first, last, exc) {
    var range         = new Opal.Range();
        range.begin   = first;
        range.end     = last;
        range.excl    = exc;

    return range;
  };

  // Get the ivar name for a given name.
  // Mostly adds a trailing $ to reserved names.
  //
  Opal.ivar = function(name) {
    if (
        // properties
        name === "constructor" ||
        name === "displayName" ||
        name === "__count__" ||
        name === "__noSuchMethod__" ||
        name === "__parent__" ||
        name === "__proto__" ||

        // methods
        name === "hasOwnProperty" ||
        name === "valueOf"
       )
    {
      return name + "$";
    }

    return name;
  };


  // Regexps
  // -------

  // Escape Regexp special chars letting the resulting string be used to build
  // a new Regexp.
  //
  Opal.escape_regexp = function(str) {
    return str.replace(/([-[\]\/{}()*+?.^$\\| ])/g, '\\$1')
              .replace(/[\n]/g, '\\n')
              .replace(/[\r]/g, '\\r')
              .replace(/[\f]/g, '\\f')
              .replace(/[\t]/g, '\\t');
  };

  // Create a global Regexp from a RegExp object and cache the result
  // on the object itself ($$g attribute).
  //
  Opal.global_regexp = function(pattern) {
    if (pattern.global) {
      return pattern; // RegExp already has the global flag
    }
    if (pattern.$$g == null) {
      pattern.$$g = new RegExp(pattern.source, (pattern.multiline ? 'gm' : 'g') + (pattern.ignoreCase ? 'i' : ''));
    } else {
      pattern.$$g.lastIndex = null; // reset lastIndex property
    }
    return pattern.$$g;
  };

  // Create a global multiline Regexp from a RegExp object and cache the result
  // on the object itself ($$gm or $$g attribute).
  //
  Opal.global_multiline_regexp = function(pattern) {
    var result;
    if (pattern.multiline) {
      if (pattern.global) {
        return pattern; // RegExp already has the global and multiline flag
      }
      // we are using the $$g attribute because the Regexp is already multiline
      if (pattern.$$g != null) {
        result = pattern.$$g;
      } else {
        result = pattern.$$g = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
      }
    } else if (pattern.$$gm != null) {
      result = pattern.$$gm;
    } else {
      result = pattern.$$gm = new RegExp(pattern.source, 'gm' + (pattern.ignoreCase ? 'i' : ''));
    }
    result.lastIndex = null; // reset lastIndex property
    return result;
  };

  // Combine multiple regexp parts together
  Opal.regexp = function(parts, flags) {
    var part;
    var ignoreCase = typeof flags !== 'undefined' && flags && flags.indexOf('i') >= 0;

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part instanceof RegExp) {
        if (part.ignoreCase !== ignoreCase)
          Opal.Kernel.$warn(
            "ignore case doesn't match for " + part.source.$inspect(),
            Opal.hash({uplevel: 1})
          )

        part = part.source;
      }
      if (part === '') part = '(?:' + part + ')';
      parts[i] = part;
    }

    if (flags) {
      return new RegExp(parts.join(''), flags);
    } else {
      return new RegExp(parts.join(''));
    }
  };

  // Require system
  // --------------

  Opal.modules         = {};
  Opal.loaded_features = ['corelib/runtime'];
  Opal.current_dir     = '.';
  Opal.require_table   = {'corelib/runtime': true};

  Opal.normalize = function(path) {
    var parts, part, new_parts = [], SEPARATOR = '/';

    if (Opal.current_dir !== '.') {
      path = Opal.current_dir.replace(/\/*$/, '/') + path;
    }

    path = path.replace(/^\.\//, '');
    path = path.replace(/\.(rb|opal|js)$/, '');
    parts = path.split(SEPARATOR);

    for (var i = 0, ii = parts.length; i < ii; i++) {
      part = parts[i];
      if (part === '') continue;
      (part === '..') ? new_parts.pop() : new_parts.push(part)
    }

    return new_parts.join(SEPARATOR);
  };

  Opal.loaded = function(paths) {
    var i, l, path;

    for (i = 0, l = paths.length; i < l; i++) {
      path = Opal.normalize(paths[i]);

      if (Opal.require_table[path]) {
        continue;
      }

      Opal.loaded_features.push(path);
      Opal.require_table[path] = true;
    }
  };

  Opal.load = function(path) {
    path = Opal.normalize(path);

    Opal.loaded([path]);

    var module = Opal.modules[path];

    if (module) {
      module(Opal);
    }
    else {
      var severity = Opal.config.missing_require_severity;
      var message  = 'cannot load such file -- ' + path;

      if (severity === "error") {
        if (Opal.LoadError) {
          throw Opal.LoadError.$new(message)
        } else {
          throw message
        }
      }
      else if (severity === "warning") {
        console.warn('WARNING: LoadError: ' + message);
      }
    }

    return true;
  };

  Opal.require = function(path) {
    path = Opal.normalize(path);

    if (Opal.require_table[path]) {
      return false;
    }

    return Opal.load(path);
  };


  // Strings
  // -------

  Opal.encodings = Object.create(null);

  // Sets the encoding on a string, will treat string literals as frozen strings
  // raising a FrozenError.
  //
  // @param str [String] the string on which the encoding should be set
  // @param name [String] the canonical name of the encoding
  // @param type [String] possible values are either `"encoding"`, `"internal_encoding"`, or `undefined
  Opal.set_encoding = function(str, name, type) {
    if (typeof type === "undefined") type = "encoding";
    if (typeof str === 'string' || str.$$frozen === true)
      throw Opal.FrozenError.$new("can't modify frozen String");

    var encoding = Opal.find_encoding(name);

    if (encoding === str[type]) { return str; }

    str[type] = encoding;

    return str;
  };

  // Fetches the encoding for the given name or raises ArgumentError.
  Opal.find_encoding = function(name) {
    var register = Opal.encodings;
    var encoding = register[name] || register[name.toUpperCase()];
    if (!encoding) throw Opal.ArgumentError.$new("unknown encoding name - " + name);
    return encoding;
  }

  // @returns a String object with the encoding set from a string literal
  Opal.enc = function(str, name) {
    var dup = new String(str);
    dup = Opal.set_encoding(dup, name);
    dup.internal_encoding = dup.encoding;
    return dup
  }

  // @returns a String object with the internal encoding set to Binary
  Opal.binary = function(str) {
    var dup = new String(str);
    return Opal.set_encoding(dup, "binary", "internal_encoding");
  }


  // Initialization
  // --------------
  function $BasicObject() {}
  function $Object() {}
  function $Module() {}
  function $Class() {}

  Opal.BasicObject = BasicObject = Opal.allocate_class('BasicObject', null, $BasicObject);
  Opal.Object      = _Object     = Opal.allocate_class('Object', Opal.BasicObject, $Object);
  Opal.Module      = Module      = Opal.allocate_class('Module', Opal.Object, $Module);
  Opal.Class       = Class       = Opal.allocate_class('Class', Opal.Module, $Class);

  $set_proto(Opal.BasicObject, Opal.Class.$$prototype);
  $set_proto(Opal.Object, Opal.Class.$$prototype);
  $set_proto(Opal.Module, Opal.Class.$$prototype);
  $set_proto(Opal.Class, Opal.Class.$$prototype);

  // BasicObject can reach itself, avoid const_set to skip the $$base_module logic
  BasicObject.$$const["BasicObject"] = BasicObject;

  // Assign basic constants
  Opal.const_set(_Object, "BasicObject",  BasicObject);
  Opal.const_set(_Object, "Object",       _Object);
  Opal.const_set(_Object, "Module",       Module);
  Opal.const_set(_Object, "Class",        Class);

  // Fix booted classes to have correct .class value
  BasicObject.$$class = Class;
  _Object.$$class     = Class;
  Module.$$class      = Class;
  Class.$$class       = Class;

  // Forward .toString() to #to_s
  $defineProperty(_Object.$$prototype, 'toString', function() {
    var to_s = this.$to_s();
    if (to_s.$$is_string && typeof(to_s) === 'object') {
      // a string created using new String('string')
      return to_s.valueOf();
    } else {
      return to_s;
    }
  });

  // Make Kernel#require immediately available as it's needed to require all the
  // other corelib files.
  $defineProperty(_Object.$$prototype, '$require', Opal.require);

  // Instantiate the main object
  Opal.top = new _Object();
  Opal.top.$to_s = Opal.top.$inspect = function() { return 'main' };
  Opal.top.$define_method = top_define_method;

  // Foward calls to define_method on the top object to Object
  function top_define_method() {
    var args = Opal.slice.call(arguments, 0, arguments.length);
    var block = top_define_method.$$p;
    top_define_method.$$p = null;
    return Opal.send(_Object, 'define_method', args, block)
  };


  // Nil
  function $NilClass() {}
  Opal.NilClass = Opal.allocate_class('NilClass', Opal.Object, $NilClass);
  Opal.const_set(_Object, 'NilClass', Opal.NilClass);
  nil = Opal.nil = new Opal.NilClass();
  nil.$$id = nil_id;
  nil.call = nil.apply = function() { throw Opal.LocalJumpError.$new('no block given'); };

  // Errors
  Opal.breaker  = new Error('unexpected break (old)');
  Opal.returner = new Error('unexpected return');
  TypeError.$$super = Error;
}).call(this);
Opal.loaded(["corelib/runtime.js"]);
/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/helpers"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$===', '$raise', '$respond_to?', '$nil?', '$__send__', '$<=>', '$class', '$coerce_to!', '$new', '$!=', '$[]', '$upcase']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting), $Opal_bridge$1, $Opal_coerce_to$excl$2, $Opal_coerce_to$ques$3, $Opal_try_convert$4, $Opal_compare$5, $Opal_destructure$6, $Opal_respond_to$ques$7, $Opal_instance_variable_name$excl$8, $Opal_class_variable_name$excl$9, $Opal_const_name$excl$10, $Opal_pristine$11;

    
    Opal.defs(self, '$bridge', $Opal_bridge$1 = function $$bridge(constructor, klass) {
      var self = this;

      return Opal.bridge(constructor, klass);
    }, $Opal_bridge$1.$$arity = 2);
    Opal.defs(self, '$coerce_to!', $Opal_coerce_to$excl$2 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$excl$2.$$arity = -4);
    Opal.defs(self, '$coerce_to?', $Opal_coerce_to$ques$3 = function(object, type, method, $a) {
      var $post_args, args, self = this, coerced = nil;

      
      
      $post_args = Opal.slice.call(arguments, 3, arguments.length);
      
      args = $post_args;;
      if ($truthy(object['$respond_to?'](method))) {
      } else {
        return nil
      };
      coerced = $coerce_to(object, type, method, args);
      if ($truthy(coerced['$nil?']())) {
        return nil};
      if ($truthy(type['$==='](coerced))) {
      } else {
        self.$raise($type_error(object, type, method, coerced))
      };
      return coerced;
    }, $Opal_coerce_to$ques$3.$$arity = -4);
    Opal.defs(self, '$try_convert', $Opal_try_convert$4 = function $$try_convert(object, type, method) {
      var self = this;

      
      if ($truthy(type['$==='](object))) {
        return object};
      if ($truthy(object['$respond_to?'](method))) {
        return object.$__send__(method)
      } else {
        return nil
      };
    }, $Opal_try_convert$4.$$arity = 3);
    Opal.defs(self, '$compare', $Opal_compare$5 = function $$compare(a, b) {
      var self = this, compare = nil;

      
      compare = a['$<=>'](b);
      if ($truthy(compare === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (a.$class()) + " with " + (b.$class()) + " failed")};
      return compare;
    }, $Opal_compare$5.$$arity = 2);
    Opal.defs(self, '$destructure', $Opal_destructure$6 = function $$destructure(args) {
      var self = this;

      
      if (args.length == 1) {
        return args[0];
      }
      else if (args.$$is_array) {
        return args;
      }
      else {
        var args_ary = new Array(args.length);
        for(var i = 0, l = args_ary.length; i < l; i++) { args_ary[i] = args[i]; }

        return args_ary;
      }
    
    }, $Opal_destructure$6.$$arity = 1);
    Opal.defs(self, '$respond_to?', $Opal_respond_to$ques$7 = function(obj, method, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      if (obj == null || !obj.$$class) {
        return false;
      }
    ;
      return obj['$respond_to?'](method, include_all);
    }, $Opal_respond_to$ques$7.$$arity = -3);
    Opal.defs(self, '$instance_variable_name!', $Opal_instance_variable_name$excl$8 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(/^@[a-zA-Z_][a-zA-Z0-9_]*?$/.test(name))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "'" + (name) + "' is not allowed as an instance variable name", name))
      };
      return name;
    }, $Opal_instance_variable_name$excl$8.$$arity = 1);
    Opal.defs(self, '$class_variable_name!', $Opal_class_variable_name$excl$9 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      if ($truthy(name.length < 3 || name.slice(0,2) !== '@@')) {
        self.$raise($$($nesting, 'NameError').$new("" + "`" + (name) + "' is not allowed as a class variable name", name))};
      return name;
    }, $Opal_class_variable_name$excl$9.$$arity = 1);
    Opal.defs(self, '$const_name!', $Opal_const_name$excl$10 = function(const_name) {
      var self = this;

      
      const_name = $$($nesting, 'Opal')['$coerce_to!'](const_name, $$($nesting, 'String'), "to_str");
      if ($truthy(const_name['$[]'](0)['$!='](const_name['$[]'](0).$upcase()))) {
        self.$raise($$($nesting, 'NameError'), "" + "wrong constant name " + (const_name))};
      return const_name;
    }, $Opal_const_name$excl$10.$$arity = 1);
    return (Opal.defs(self, '$pristine', $Opal_pristine$11 = function $$pristine(owner_class, $a) {
      var $post_args, method_names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      method_names = $post_args;;
      
      var method_name, method;
      for (var i = method_names.length - 1; i >= 0; i--) {
        method_name = method_names[i];
        method = owner_class.$$prototype['$'+method_name];

        if (method && !method.$$stub) {
          method.$$pristine = true;
        }
      }
    ;
      return nil;
    }, $Opal_pristine$11.$$arity = -2), nil) && 'pristine';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/module"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $lambda = Opal.lambda, $range = Opal.range, $alias = Opal.alias, $send2 = Opal.send2;

  Opal.add_stubs(['$module_eval', '$to_proc', '$===', '$raise', '$equal?', '$<', '$>', '$nil?', '$attr_reader', '$attr_writer', '$warn', '$attr_accessor', '$class_variable_name!', '$const_name!', '$=~', '$new', '$inject', '$split', '$const_get', '$==', '$!~', '$start_with?', '$bind', '$call', '$class', '$append_features', '$included', '$name', '$cover?', '$size', '$merge', '$compile', '$proc', '$any?', '$prepend_features', '$prepended', '$to_s', '$__id__', '$constants', '$include?', '$copy_class_variables', '$copy_constants', '$define_singleton_method', '$inspect', '$class_exec']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_allocate$1, $Module_initialize$2, $Module_$eq_eq_eq$3, $Module_$lt$4, $Module_$lt_eq$5, $Module_$gt$6, $Module_$gt_eq$7, $Module_$lt_eq_gt$8, $Module_alias_method$9, $Module_alias_native$10, $Module_ancestors$11, $Module_append_features$12, $Module_attr_accessor$13, $Module_attr$14, $Module_attr_reader$15, $Module_attr_writer$16, $Module_autoload$17, $Module_class_variables$18, $Module_class_variable_get$19, $Module_class_variable_set$20, $Module_class_variable_defined$ques$21, $Module_remove_class_variable$22, $Module_constants$23, $Module_constants$24, $Module_nesting$25, $Module_const_defined$ques$26, $Module_const_get$27, $Module_const_missing$29, $Module_const_set$30, $Module_public_constant$31, $Module_define_method$32, $Module_remove_method$34, $Module_singleton_class$ques$35, $Module_include$36, $Module_included_modules$37, $Module_include$ques$38, $Module_instance_method$39, $Module_instance_methods$40, $Module_included$41, $Module_extended$42, $Module_extend_object$43, $Module_method_added$44, $Module_method_removed$45, $Module_method_undefined$46, $Module_module_eval$47, $Module_module_exec$49, $Module_method_defined$ques$50, $Module_module_function$51, $Module_name$52, $Module_prepend$53, $Module_prepend_features$54, $Module_prepended$55, $Module_remove_const$56, $Module_to_s$57, $Module_undef_method$58, $Module_instance_variables$59, $Module_dup$60, $Module_copy_class_variables$61, $Module_copy_constants$62, $Module_refine$63, $Module_using$65;

    
    Opal.defs(self, '$allocate', $Module_allocate$1 = function $$allocate() {
      var self = this;

      
      var module = Opal.allocate_module(nil, function(){});
      // Link the prototype of Module subclasses
      if (self !== Opal.Module) Object.setPrototypeOf(module, self.$$prototype);
      return module;
    
    }, $Module_allocate$1.$$arity = 0);
    
    Opal.def(self, '$initialize', $Module_initialize$2 = function $$initialize() {
      var $iter = $Module_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Module_initialize$2.$$p = null;
      
      
      if ($iter) $Module_initialize$2.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'module_eval', [], block.$to_proc())
      } else {
        return nil
      };
    }, $Module_initialize$2.$$arity = 0);
    
    Opal.def(self, '$===', $Module_$eq_eq_eq$3 = function(object) {
      var self = this;

      
      if ($truthy(object == null)) {
        return false};
      return Opal.is_a(object, self);;
    }, $Module_$eq_eq_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Module_$lt$4 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      
      var working = self,
          ancestors,
          i, length;

      if (working === other) {
        return false;
      }

      for (i = 0, ancestors = Opal.ancestors(self), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === other) {
          return true;
        }
      }

      for (i = 0, ancestors = Opal.ancestors(other), length = ancestors.length; i < length; i++) {
        if (ancestors[i] === self) {
          return false;
        }
      }

      return nil;
    ;
    }, $Module_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Module_$lt_eq$5 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self['$equal?'](other)))) {
        return $ret_or_1
      } else {
        return $rb_lt(self, other)
      }
    }, $Module_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$>', $Module_$gt$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "compared with non class/module")
      };
      return $rb_lt(other, self);
    }, $Module_$gt$6.$$arity = 1);
    
    Opal.def(self, '$>=', $Module_$gt_eq$7 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self['$equal?'](other)))) {
        return $ret_or_2
      } else {
        return $rb_gt(self, other)
      }
    }, $Module_$gt_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Module_$lt_eq_gt$8 = function(other) {
      var self = this, lt = nil;

      
      
      if (self === other) {
        return 0;
      }
    ;
      if ($truthy($$($nesting, 'Module')['$==='](other))) {
      } else {
        return nil
      };
      lt = $rb_lt(self, other);
      if ($truthy(lt['$nil?']())) {
        return nil};
      if ($truthy(lt)) {
        return -1
      } else {
        return 1
      };
    }, $Module_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$alias_method', $Module_alias_method$9 = function $$alias_method(newname, oldname) {
      var self = this;

      
      newname = $coerce_to(newname, $$($nesting, 'String'), 'to_str');
      oldname = $coerce_to(oldname, $$($nesting, 'String'), 'to_str');
      Opal.alias(self, newname, oldname);
      return self;
    }, $Module_alias_method$9.$$arity = 2);
    
    Opal.def(self, '$alias_native', $Module_alias_native$10 = function $$alias_native(mid, jsid) {
      var self = this;

      
      
      if (jsid == null) {
        jsid = mid;
      };
      Opal.alias_native(self, mid, jsid);
      return self;
    }, $Module_alias_native$10.$$arity = -2);
    
    Opal.def(self, '$ancestors', $Module_ancestors$11 = function $$ancestors() {
      var self = this;

      return Opal.ancestors(self);
    }, $Module_ancestors$11.$$arity = 0);
    
    Opal.def(self, '$append_features', $Module_append_features$12 = function $$append_features(includer) {
      var self = this;

      
      Opal.append_features(self, includer);
      return self;
    }, $Module_append_features$12.$$arity = 1);
    
    Opal.def(self, '$attr_accessor', $Module_attr_accessor$13 = function $$attr_accessor($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      $send(self, 'attr_reader', Opal.to_a(names));
      return $send(self, 'attr_writer', Opal.to_a(names));
    }, $Module_attr_accessor$13.$$arity = -1);
    
    Opal.def(self, '$attr', $Module_attr$14 = function $$attr($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (args.length == 2 && (args[1] === true || args[1] === false)) {
        self.$warn("optional boolean argument is obsoleted", $hash2(["uplevel"], {"uplevel": 1}))

        args[1] ? self.$attr_accessor(args[0]) : self.$attr_reader(args[0]);
        return nil;
      }
    ;
      return $send(self, 'attr_reader', Opal.to_a(args));
    }, $Module_attr$14.$$arity = -1);
    
    Opal.def(self, '$attr_reader', $Module_attr_reader$15 = function $$attr_reader($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name,
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar) {
          return function() {
            if (this[ivar] == null) {
              return nil;
            }
            else {
              return this[ivar];
            }
          };
        })(ivar);

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        body.$$parameters = [];
        body.$$arity = 0;

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_reader$15.$$arity = -1);
    
    Opal.def(self, '$attr_writer', $Module_attr_writer$16 = function $$attr_writer($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      var proto = self.$$prototype;

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i],
            id   = '$' + name + '=',
            ivar = Opal.ivar(name);

        // the closure here is needed because name will change at the next
        // cycle, I wish we could use let.
        var body = (function(ivar){
          return function(value) {
            return this[ivar] = value;
          }
        })(ivar);

        body.$$parameters = [['req']];
        body.$$arity = 1;

        // initialize the instance variable as nil
        Opal.defineProperty(proto, ivar, nil);

        Opal.defn(self, id, body);
      }
    ;
      return nil;
    }, $Module_attr_writer$16.$$arity = -1);
    
    Opal.def(self, '$autoload', $Module_autoload$17 = function $$autoload(const$, path) {
      var self = this;

      
      if (self.$$autoload == null) self.$$autoload = {};
      Opal.const_cache_version++;
      self.$$autoload[const$] = path;
      return nil;
    
    }, $Module_autoload$17.$$arity = 2);
    
    Opal.def(self, '$class_variables', $Module_class_variables$18 = function $$class_variables() {
      var self = this;

      return Object.keys(Opal.class_variables(self));
    }, $Module_class_variables$18.$$arity = 0);
    
    Opal.def(self, '$class_variable_get', $Module_class_variable_get$19 = function $$class_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_get(self, name, false);;
    }, $Module_class_variable_get$19.$$arity = 1);
    
    Opal.def(self, '$class_variable_set', $Module_class_variable_set$20 = function $$class_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variable_set(self, name, value);;
    }, $Module_class_variable_set$20.$$arity = 2);
    
    Opal.def(self, '$class_variable_defined?', $Module_class_variable_defined$ques$21 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      return Opal.class_variables(self).hasOwnProperty(name);;
    }, $Module_class_variable_defined$ques$21.$$arity = 1);
    
    Opal.def(self, '$remove_class_variable', $Module_remove_class_variable$22 = function $$remove_class_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$class_variable_name!'](name);
      
      if (Opal.hasOwnProperty.call(self.$$cvars, name)) {
        var value = self.$$cvars[name];
        delete self.$$cvars[name];
        return value;
      } else {
        self.$raise($$($nesting, 'NameError'), "" + "cannot remove " + (name) + " for " + (self))
      }
    ;
    }, $Module_remove_class_variable$22.$$arity = 1);
    
    Opal.def(self, '$constants', $Module_constants$23 = function $$constants(inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      return Opal.constants(self, inherit);;
    }, $Module_constants$23.$$arity = -1);
    Opal.defs(self, '$constants', $Module_constants$24 = function $$constants(inherit) {
      var self = this;

      
      ;
      
      if (inherit == null) {
        var nesting = (self.$$nesting || []).concat(Opal.Object),
            constant, constants = {},
            i, ii;

        for(i = 0, ii = nesting.length; i < ii; i++) {
          for (constant in nesting[i].$$const) {
            constants[constant] = true;
          }
        }
        return Object.keys(constants);
      } else {
        return Opal.constants(self, inherit)
      }
    ;
    }, $Module_constants$24.$$arity = -1);
    Opal.defs(self, '$nesting', $Module_nesting$25 = function $$nesting() {
      var self = this;

      return self.$$nesting || [];
    }, $Module_nesting$25.$$arity = 0);
    
    Opal.def(self, '$const_defined?', $Module_const_defined$ques$26 = function(name, inherit) {
      var self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      var module, modules = [self], module_constants, i, ii;

      // Add up ancestors if inherit is true
      if (inherit) {
        modules = modules.concat(Opal.ancestors(self));

        // Add Object's ancestors if it's a module – modules have no ancestors otherwise
        if (self.$$is_module) {
          modules = modules.concat([Opal.Object]).concat(Opal.ancestors(Opal.Object));
        }
      }

      for (i = 0, ii = modules.length; i < ii; i++) {
        module = modules[i];
        if (module.$$const[name] != null) {
          return true;
        }
      }

      return false;
    ;
    }, $Module_const_defined$ques$26.$$arity = -2);
    
    Opal.def(self, '$const_get', $Module_const_get$27 = function $$const_get(name, inherit) {
      var $$28, self = this;

      
      
      if (inherit == null) {
        inherit = true;
      };
      name = $$($nesting, 'Opal')['$const_name!'](name);
      
      if (name.indexOf('::') === 0 && name !== '::'){
        name = name.slice(2);
      }
    ;
      if ($truthy(name.indexOf('::') != -1 && name != '::')) {
        return $send(name.$split("::"), 'inject', [self], ($$28 = function(o, c){var self = $$28.$$s == null ? this : $$28.$$s;

          
          
          if (o == null) {
            o = nil;
          };
          
          if (c == null) {
            c = nil;
          };
          return o.$const_get(c);}, $$28.$$s = self, $$28.$$arity = 2, $$28))};
      if ($truthy(name['$=~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP')))) {
      } else {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))
      };
      
      if (inherit) {
        return $$([self], name);
      } else {
        return Opal.const_get_local(self, name);
      }
    ;
    }, $Module_const_get$27.$$arity = -2);
    
    Opal.def(self, '$const_missing', $Module_const_missing$29 = function $$const_missing(name) {
      var self = this, full_const_name = nil;

      
      
      if (self.$$autoload) {
        var file = self.$$autoload[name];

        if (file) {
          self.$require(file);

          return self.$const_get(name);
        }
      }
    ;
      full_const_name = (function() {if (self['$==']($$($nesting, 'Object'))) {
        return name
      } else {
        return "" + (self) + "::" + (name)
      }; return nil; })();
      return self.$raise($$($nesting, 'NameError').$new("" + "uninitialized constant " + (full_const_name), name));
    }, $Module_const_missing$29.$$arity = 1);
    
    Opal.def(self, '$const_set', $Module_const_set$30 = function $$const_set(name, value) {
      var self = this, $ret_or_3 = nil;

      
      name = $$($nesting, 'Opal')['$const_name!'](name);
      if ($truthy((function() {if ($truthy(($ret_or_3 = name['$!~']($$$($$($nesting, 'Opal'), 'CONST_NAME_REGEXP'))))) {
        return $ret_or_3
      } else {
        return name['$start_with?']("::")
      }; return nil; })())) {
        self.$raise($$($nesting, 'NameError').$new("" + "wrong constant name " + (name), name))};
      Opal.const_set(self, name, value);
      return value;
    }, $Module_const_set$30.$$arity = 2);
    
    Opal.def(self, '$public_constant', $Module_public_constant$31 = function $$public_constant(const_name) {
      var self = this;

      return nil
    }, $Module_public_constant$31.$$arity = 1);
    
    Opal.def(self, '$define_method', $Module_define_method$32 = function $$define_method(name, method) {
      var $iter = $Module_define_method$32.$$p, block = $iter || nil, $$33, self = this, $ret_or_4 = nil, $case = nil;

      if ($iter) $Module_define_method$32.$$p = null;
      
      
      if ($iter) $Module_define_method$32.$$p = null;;
      ;
      if ($truthy(method === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")};
      block = (function() {if ($truthy(($ret_or_4 = block))) {
        return $ret_or_4
      } else {
        return (function() {$case = method;
        if ($$($nesting, 'Proc')['$===']($case)) {return method}
        else if ($$($nesting, 'Method')['$===']($case)) {return method.$to_proc().$$unbound}
        else if ($$($nesting, 'UnboundMethod')['$===']($case)) {return $lambda(($$33 = function($a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args, bound = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          bound = method.$bind(self);
          return $send(bound, 'call', Opal.to_a(args));}, $$33.$$s = self, $$33.$$arity = -1, $$33))}
        else {return self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (block.$class()) + " (expected Proc/Method)")}})()
      }; return nil; })();
      
      var id = '$' + name;

      block.$$jsid        = name;
      block.$$s           = null;
      block.$$def         = block;
      block.$$define_meth = true;

      Opal.defn(self, id, block);

      return name;
    ;
    }, $Module_define_method$32.$$arity = -2);
    
    Opal.def(self, '$remove_method', $Module_remove_method$34 = function $$remove_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.rdef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_remove_method$34.$$arity = -1);
    
    Opal.def(self, '$singleton_class?', $Module_singleton_class$ques$35 = function() {
      var self = this;

      return !!self.$$is_singleton;
    }, $Module_singleton_class$ques$35.$$arity = 0);
    
    Opal.def(self, '$include', $Module_include$36 = function $$include($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(self);
        (mod).$included(self);
      }
    ;
      return self;
    }, $Module_include$36.$$arity = -1);
    
    Opal.def(self, '$included_modules', $Module_included_modules$37 = function $$included_modules() {
      var self = this;

      return Opal.included_modules(self);
    }, $Module_included_modules$37.$$arity = 0);
    
    Opal.def(self, '$include?', $Module_include$ques$38 = function(mod) {
      var self = this;

      
      if (!mod.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
      }

      var i, ii, mod2, ancestors = Opal.ancestors(self);

      for (i = 0, ii = ancestors.length; i < ii; i++) {
        mod2 = ancestors[i];
        if (mod2 === mod && mod2 !== self) {
          return true;
        }
      }

      return false;
    
    }, $Module_include$ques$38.$$arity = 1);
    
    Opal.def(self, '$instance_method', $Module_instance_method$39 = function $$instance_method(name) {
      var self = this;

      
      var meth = self.$$prototype['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$name()) + "'", name));
      }

      return $$($nesting, 'UnboundMethod').$new(self, meth.$$owner || self, meth, name);
    
    }, $Module_instance_method$39.$$arity = 1);
    
    Opal.def(self, '$instance_methods', $Module_instance_methods$40 = function $$instance_methods(include_super) {
      var self = this;

      
      
      if (include_super == null) {
        include_super = true;
      };
      
      if ($truthy(include_super)) {
        return Opal.instance_methods(self);
      } else {
        return Opal.own_instance_methods(self);
      }
    ;
    }, $Module_instance_methods$40.$$arity = -1);
    
    Opal.def(self, '$included', $Module_included$41 = function $$included(mod) {
      var self = this;

      return nil
    }, $Module_included$41.$$arity = 1);
    
    Opal.def(self, '$extended', $Module_extended$42 = function $$extended(mod) {
      var self = this;

      return nil
    }, $Module_extended$42.$$arity = 1);
    
    Opal.def(self, '$extend_object', $Module_extend_object$43 = function $$extend_object(object) {
      var self = this;

      return nil
    }, $Module_extend_object$43.$$arity = 1);
    
    Opal.def(self, '$method_added', $Module_method_added$44 = function $$method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_added$44.$$arity = -1);
    
    Opal.def(self, '$method_removed', $Module_method_removed$45 = function $$method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_removed$45.$$arity = -1);
    
    Opal.def(self, '$method_undefined', $Module_method_undefined$46 = function $$method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_method_undefined$46.$$arity = -1);
    
    Opal.def(self, '$module_eval', $Module_module_eval$47 = function $$module_eval($a) {
      var $iter = $Module_module_eval$47.$$p, block = $iter || nil, $post_args, args, $b, $$48, self = this, $ret_or_5 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_6 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $Module_module_eval$47.$$p = null;
      
      
      if ($iter) $Module_module_eval$47.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_5 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_5
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_6 = file))) {
          return $ret_or_6
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$($nesting, 'Opal').$compile(string, compiling_options);
        block = $send($$($nesting, 'Kernel'), 'proc', [], ($$48 = function(){var self = $$48.$$s == null ? this : $$48.$$s;

          
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$48.$$s = self, $$48.$$arity = 0, $$48));
      } else if ($truthy(args['$any?']())) {
        $$($nesting, 'Kernel').$raise($$($nesting, 'ArgumentError'), "" + ("" + "wrong number of arguments (" + (args.$size()) + " for 0)") + "\n\n  NOTE:If you want to enable passing a String argument please add \"require 'opal-parser'\" to your script\n")};
      
      var old = block.$$s,
          result;

      block.$$s = null;
      result = block.apply(self, [self]);
      block.$$s = old;

      return result;
    ;
    }, $Module_module_eval$47.$$arity = -1);
    $alias(self, "class_eval", "module_eval");
    
    Opal.def(self, '$module_exec', $Module_module_exec$49 = function $$module_exec($a) {
      var $iter = $Module_module_exec$49.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Module_module_exec$49.$$p = null;
      
      
      if ($iter) $Module_module_exec$49.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block === nil) {
        self.$raise($$($nesting, 'LocalJumpError'), "no block given")
      }

      var block_self = block.$$s, result;

      block.$$s = null;
      result = block.apply(self, args);
      block.$$s = block_self;

      return result;
    ;
    }, $Module_module_exec$49.$$arity = -1);
    $alias(self, "class_exec", "module_exec");
    
    Opal.def(self, '$method_defined?', $Module_method_defined$ques$50 = function(method) {
      var self = this;

      
      var body = self.$$prototype['$' + method];
      return (!!body) && !body.$$stub;
    
    }, $Module_method_defined$ques$50.$$arity = 1);
    
    Opal.def(self, '$module_function', $Module_module_function$51 = function $$module_function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = true;
      }
      else {
        for (var i = 0, length = methods.length; i < length; i++) {
          var meth = methods[i],
              id   = '$' + meth,
              func = self.$$prototype[id];

          Opal.defs(self, id, func);
        }
      }

      return self;
    ;
    }, $Module_module_function$51.$$arity = -1);
    
    Opal.def(self, '$name', $Module_name$52 = function $$name() {
      var self = this;

      
      if (self.$$full_name) {
        return self.$$full_name;
      }

      var result = [], base = self;

      while (base) {
        // Give up if any of the ancestors is unnamed
        if (base.$$name === nil || base.$$name == null) return nil;

        result.unshift(base.$$name);

        base = base.$$base_module;

        if (base === Opal.Object) {
          break;
        }
      }

      if (result.length === 0) {
        return nil;
      }

      return self.$$full_name = result.join('::');
    
    }, $Module_name$52.$$arity = 0);
    
    Opal.def(self, '$prepend', $Module_prepend$53 = function $$prepend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      if (mods.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (given 0, expected 1+)")
      }

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$prepend_features(self);
        (mod).$prepended(self);
      }
    ;
      return self;
    }, $Module_prepend$53.$$arity = -1);
    
    Opal.def(self, '$prepend_features', $Module_prepend_features$54 = function $$prepend_features(prepender) {
      var self = this;

      
      
      if (!self.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (self.$class()) + " (expected Module)");
      }

      Opal.prepend_features(self, prepender)
    ;
      return self;
    }, $Module_prepend_features$54.$$arity = 1);
    
    Opal.def(self, '$prepended', $Module_prepended$55 = function $$prepended(mod) {
      var self = this;

      return nil
    }, $Module_prepended$55.$$arity = 1);
    
    Opal.def(self, '$remove_const', $Module_remove_const$56 = function $$remove_const(name) {
      var self = this;

      return Opal.const_remove(self, name);
    }, $Module_remove_const$56.$$arity = 1);
    
    Opal.def(self, '$to_s', $Module_to_s$57 = function $$to_s() {
      var self = this, $ret_or_7 = nil;

      if ($truthy(($ret_or_7 = Opal.Module.$name.call(self)))) {
        return $ret_or_7
      } else {
        return "" + "#<" + (self.$$is_module ? 'Module' : 'Class') + ":0x" + (self.$__id__().$to_s(16)) + ">"
      }
    }, $Module_to_s$57.$$arity = 0);
    $alias(self, "inspect", "to_s");
    
    Opal.def(self, '$undef_method', $Module_undef_method$58 = function $$undef_method($a) {
      var $post_args, names, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      names = $post_args;;
      
      for (var i = 0, length = names.length; i < length; i++) {
        Opal.udef(self, "$" + names[i]);
      }
    ;
      return self;
    }, $Module_undef_method$58.$$arity = -1);
    
    Opal.def(self, '$instance_variables', $Module_instance_variables$59 = function $$instance_variables() {
      var self = this, consts = nil;

      
      consts = (Opal.Module.$$nesting = $nesting, self.$constants());
      
      var result = [];

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$' && name !== 'constructor' && !consts['$include?'](name)) {
          result.push('@' + name);
        }
      }

      return result;
    ;
    }, $Module_instance_variables$59.$$arity = 0);
    
    Opal.def(self, '$dup', $Module_dup$60 = function $$dup() {
      var $iter = $Module_dup$60.$$p, $yield = $iter || nil, self = this, copy = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Module_dup$60.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      copy = $send2(self, Opal.find_super_dispatcher(self, 'dup', $Module_dup$60, false, true), 'dup', $zuper, $iter);
      copy.$copy_class_variables(self);
      copy.$copy_constants(self);
      return copy;
    }, $Module_dup$60.$$arity = 0);
    
    Opal.def(self, '$copy_class_variables', $Module_copy_class_variables$61 = function $$copy_class_variables(other) {
      var self = this;

      
      for (var name in other.$$cvars) {
        self.$$cvars[name] = other.$$cvars[name];
      }
    
    }, $Module_copy_class_variables$61.$$arity = 1);
    
    Opal.def(self, '$copy_constants', $Module_copy_constants$62 = function $$copy_constants(other) {
      var self = this;

      
      var name, other_constants = other.$$const;

      for (name in other_constants) {
        Opal.const_set(self, name, other_constants[name]);
      }
    
    }, $Module_copy_constants$62.$$arity = 1);
    
    Opal.def(self, '$refine', $Module_refine$63 = function $$refine(mod) {
      var $iter = $Module_refine$63.$$p, block = $iter || nil, $a, $$64, self = this, s = nil, m = nil, mod_id = nil;

      if ($iter) $Module_refine$63.$$p = null;
      
      
      if ($iter) $Module_refine$63.$$p = null;;
      $a = [self, nil, nil], (s = $a[0]), (m = $a[1]), (mod_id = $a[2]), $a;
      
      mod_id = Opal.id(mod);
      if (typeof self.$$refine_modules === "undefined") {
        self.$$refine_modules = {};
      }
      if (typeof self.$$refine_modules[mod_id] === "undefined") {
        m = self.$$refine_modules[mod_id] = $$$('::', 'Module').$new();
      }
      else {
        m = self.$$refine_modules[mod_id];
      }
    ;
      $send(m, 'define_singleton_method', ["inspect"], ($$64 = function(){var self = $$64.$$s == null ? this : $$64.$$s;

        return "" + "#<refinement:" + (mod.$inspect()) + "@" + (s.$inspect()) + ">"}, $$64.$$s = self, $$64.$$arity = 0, $$64));
      $send(m, 'class_exec', [], block.$to_proc());
      return m;
    }, $Module_refine$63.$$arity = 1);
    return (Opal.def(self, '$using', $Module_using$65 = function $$using(mod) {
      var self = this;

      return self.$raise("Module#using is not permitted in methods")
    }, $Module_using$65.$$arity = 1), nil) && 'using';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/class"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $send2 = Opal.send2, $alias = Opal.alias;

  Opal.add_stubs(['$require', '$class_eval', '$to_proc', '$initialize_copy', '$allocate', '$name', '$to_s']);
  
  self.$require("corelib/module");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Class');

    var $nesting = [self].concat($parent_nesting), $Class_new$1, $Class_allocate$2, $Class_inherited$3, $Class_initialize_dup$4, $Class_new$5, $Class_superclass$6, $Class_to_s$7;

    
    Opal.defs(self, '$new', $Class_new$1 = function(superclass) {
      var $iter = $Class_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Class_new$1.$$p = null;
      
      
      if ($iter) $Class_new$1.$$p = null;;
      
      if (superclass == null) {
        superclass = $$($nesting, 'Object');
      };
      
      if (!superclass.$$is_class) {
        throw Opal.TypeError.$new("superclass must be a Class");
      }

      var klass = Opal.allocate_class(nil, superclass);
      superclass.$inherited(klass);
      (function() {if ((block !== nil)) {
        return $send((klass), 'class_eval', [], block.$to_proc())
      } else {
        return nil
      }; return nil; })()
      return klass;
    ;
    }, $Class_new$1.$$arity = -1);
    
    Opal.def(self, '$allocate', $Class_allocate$2 = function $$allocate() {
      var self = this;

      
      var obj = new self.$$constructor();
      obj.$$id = Opal.uid();
      return obj;
    
    }, $Class_allocate$2.$$arity = 0);
    
    Opal.def(self, '$inherited', $Class_inherited$3 = function $$inherited(cls) {
      var self = this;

      return nil
    }, $Class_inherited$3.$$arity = 1);
    
    Opal.def(self, '$initialize_dup', $Class_initialize_dup$4 = function $$initialize_dup(original) {
      var self = this;

      
      self.$initialize_copy(original);
      
      self.$$name = null;
      self.$$full_name = null;
    ;
    }, $Class_initialize_dup$4.$$arity = 1);
    
    Opal.def(self, '$new', $Class_new$5 = function($a) {
      var $iter = $Class_new$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Class_new$5.$$p = null;
      
      
      if ($iter) $Class_new$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var object = self.$allocate();
      Opal.send(object, object.$initialize, args, block);
      return object;
    ;
    }, $Class_new$5.$$arity = -1);
    
    Opal.def(self, '$superclass', $Class_superclass$6 = function $$superclass() {
      var self = this;

      return self.$$super || nil;
    }, $Class_superclass$6.$$arity = 0);
    
    Opal.def(self, '$to_s', $Class_to_s$7 = function $$to_s() {
      var $iter = $Class_to_s$7.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Class_to_s$7.$$p = null;
      
      var singleton_of = self.$$singleton_of;

      if (singleton_of && singleton_of.$$is_a_module) {
        return "" + "#<Class:" + ((singleton_of).$name()) + ">";
      }
      else if (singleton_of) {
        // a singleton class created from an object
        return "" + "#<Class:#<" + ((singleton_of.$$class).$name()) + ":0x" + ((Opal.id(singleton_of)).$to_s(16)) + ">>";
      }

      return $send2(self, Opal.find_super_dispatcher(self, 'to_s', $Class_to_s$7, false, true), 'to_s', [], null);
    
    }, $Class_to_s$7.$$arity = 0);
    return $alias(self, "inspect", "to_s");
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/basic_object"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $alias = Opal.alias, $truthy = Opal.truthy, $range = Opal.range, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$==', '$!', '$nil?', '$cover?', '$size', '$raise', '$merge', '$compile', '$proc', '$any?', '$inspect', '$new']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'BasicObject');

    var $nesting = [self].concat($parent_nesting), $BasicObject_initialize$1, $BasicObject_$eq_eq$2, $BasicObject_eql$ques$3, $BasicObject___id__$4, $BasicObject___send__$5, $BasicObject_$excl$6, $BasicObject_$not_eq$7, $BasicObject_instance_eval$8, $BasicObject_instance_exec$10, $BasicObject_singleton_method_added$11, $BasicObject_singleton_method_removed$12, $BasicObject_singleton_method_undefined$13, $BasicObject_method_missing$14, $BasicObject_respond_to_missing$ques$15;

    
    
    Opal.def(self, '$initialize', $BasicObject_initialize$1 = function $$initialize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_initialize$1.$$arity = -1);
    
    Opal.def(self, '$==', $BasicObject_$eq_eq$2 = function(other) {
      var self = this;

      return self === other;
    }, $BasicObject_$eq_eq$2.$$arity = 1);
    
    Opal.def(self, '$eql?', $BasicObject_eql$ques$3 = function(other) {
      var self = this;

      return self['$=='](other)
    }, $BasicObject_eql$ques$3.$$arity = 1);
    $alias(self, "equal?", "==");
    
    Opal.def(self, '$__id__', $BasicObject___id__$4 = function $$__id__() {
      var self = this;

      
      if (self.$$id != null) {
        return self.$$id;
      }
      Opal.defineProperty(self, '$$id', Opal.uid());
      return self.$$id;
    
    }, $BasicObject___id__$4.$$arity = 0);
    
    Opal.def(self, '$__send__', $BasicObject___send__$5 = function $$__send__(symbol, $a) {
      var $iter = $BasicObject___send__$5.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject___send__$5.$$p = null;
      
      
      if ($iter) $BasicObject___send__$5.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      var func = self['$' + symbol]

      if (func) {
        if (block !== nil) {
          func.$$p = block;
        }

        return func.apply(self, args);
      }

      if (block !== nil) {
        self.$method_missing.$$p = block;
      }

      return self.$method_missing.apply(self, [symbol].concat(args));
    ;
    }, $BasicObject___send__$5.$$arity = -2);
    
    Opal.def(self, '$!', $BasicObject_$excl$6 = function() {
      var self = this;

      return false
    }, $BasicObject_$excl$6.$$arity = 0);
    
    Opal.def(self, '$!=', $BasicObject_$not_eq$7 = function(other) {
      var self = this;

      return self['$=='](other)['$!']()
    }, $BasicObject_$not_eq$7.$$arity = 1);
    
    Opal.def(self, '$instance_eval', $BasicObject_instance_eval$8 = function $$instance_eval($a) {
      var $iter = $BasicObject_instance_eval$8.$$p, block = $iter || nil, $post_args, args, $b, $$9, self = this, $ret_or_1 = nil, string = nil, file = nil, _lineno = nil, default_eval_options = nil, $ret_or_2 = nil, compiling_options = nil, compiled = nil;

      if ($iter) $BasicObject_instance_eval$8.$$p = null;
      
      
      if ($iter) $BasicObject_instance_eval$8.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = block['$nil?']()))) {
        return !!Opal.compile;
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        if ($truthy($range(1, 3, false)['$cover?'](args.$size()))) {
        } else {
          $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        };
        $b = [].concat(Opal.to_a(args)), (string = ($b[0] == null ? nil : $b[0])), (file = ($b[1] == null ? nil : $b[1])), (_lineno = ($b[2] == null ? nil : $b[2])), $b;
        default_eval_options = $hash2(["file", "eval"], {"file": (function() {if ($truthy(($ret_or_2 = file))) {
          return $ret_or_2
        } else {
          return "(eval)"
        }; return nil; })(), "eval": true});
        compiling_options = Opal.hash({ arity_check: false }).$merge(default_eval_options);
        compiled = $$$('::', 'Opal').$compile(string, compiling_options);
        block = $send($$$('::', 'Kernel'), 'proc', [], ($$9 = function(){var self = $$9.$$s == null ? this : $$9.$$s;

          
          return (function(self) {
            return eval(compiled);
          })(self)
        }, $$9.$$s = self, $$9.$$arity = 0, $$9));
      } else if ($truthy(args['$any?']())) {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "" + "wrong number of arguments (" + (args.$size()) + " for 0)")};
      
      var old = block.$$s,
          result;

      block.$$s = null;

      // Need to pass $$eval so that method definitions know if this is
      // being done on a class/module. Cannot be compiler driven since
      // send(:instance_eval) needs to work.
      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.call(self, self);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.call(self, self);
      }

      block.$$s = old;

      return result;
    ;
    }, $BasicObject_instance_eval$8.$$arity = -1);
    
    Opal.def(self, '$instance_exec', $BasicObject_instance_exec$10 = function $$instance_exec($a) {
      var $iter = $BasicObject_instance_exec$10.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $BasicObject_instance_exec$10.$$p = null;
      
      
      if ($iter) $BasicObject_instance_exec$10.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(block)) {
      } else {
        $$$('::', 'Kernel').$raise($$$('::', 'ArgumentError'), "no block given")
      };
      
      var block_self = block.$$s,
          result;

      block.$$s = null;

      if (self.$$is_a_module) {
        self.$$eval = true;
        try {
          result = block.apply(self, args);
        }
        finally {
          self.$$eval = false;
        }
      }
      else {
        result = block.apply(self, args);
      }

      block.$$s = block_self;

      return result;
    ;
    }, $BasicObject_instance_exec$10.$$arity = -1);
    
    Opal.def(self, '$singleton_method_added', $BasicObject_singleton_method_added$11 = function $$singleton_method_added($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_added$11.$$arity = -1);
    
    Opal.def(self, '$singleton_method_removed', $BasicObject_singleton_method_removed$12 = function $$singleton_method_removed($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_removed$12.$$arity = -1);
    
    Opal.def(self, '$singleton_method_undefined', $BasicObject_singleton_method_undefined$13 = function $$singleton_method_undefined($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $BasicObject_singleton_method_undefined$13.$$arity = -1);
    
    Opal.def(self, '$method_missing', $BasicObject_method_missing$14 = function $$method_missing(symbol, $a) {
      var $iter = $BasicObject_method_missing$14.$$p, block = $iter || nil, $post_args, args, self = this, message = nil;

      if ($iter) $BasicObject_method_missing$14.$$p = null;
      
      
      if ($iter) $BasicObject_method_missing$14.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      message = (function() {if ($truthy(self.$inspect && !self.$inspect.$$stub)) {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$inspect()) + ":" + (self.$$class)
      } else {
        return "" + "undefined method `" + (symbol) + "' for " + (self.$$class)
      }; return nil; })();
      return $$$('::', 'Kernel').$raise($$$('::', 'NoMethodError').$new(message, symbol));
    }, $BasicObject_method_missing$14.$$arity = -2);
    return (Opal.def(self, '$respond_to_missing?', $BasicObject_respond_to_missing$ques$15 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $BasicObject_respond_to_missing$ques$15.$$arity = -2), nil) && 'respond_to_missing?';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/kernel"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $module = Opal.module, $gvars = Opal.gvars, $hash2 = Opal.hash2, $send = Opal.send, $alias = Opal.alias, $klass = Opal.klass;

  Opal.add_stubs(['$raise', '$new', '$inspect', '$caller', '$!', '$=~', '$==', '$object_id', '$class', '$coerce_to?', '$<<', '$allocate', '$copy_instance_variables', '$copy_singleton_methods', '$initialize_clone', '$initialize_copy', '$define_method', '$singleton_class', '$to_proc', '$initialize_dup', '$for', '$empty?', '$pop', '$call', '$append_features', '$extend_object', '$extended', '$gets', '$__id__', '$each', '$instance_variables', '$+', '$instance_variable_get', '$to_s', '$instance_variable_name!', '$respond_to?', '$to_int', '$coerce_to!', '$Integer', '$nil?', '$===', '$enum_for', '$result', '$any?', '$print', '$format', '$puts', '$<=', '$length', '$[]', '$readline', '$<', '$first', '$split', '$map', '$to_str', '$exception', '$backtrace', '$rand', '$respond_to_missing?', '$pristine', '$try_convert!', '$expand_path', '$join', '$start_with?', '$new_seed', '$srand', '$tag', '$value', '$open', '$include']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_method_missing$1, $Kernel_$eq_tilde$2, $Kernel_$excl_tilde$3, $Kernel_$eq_eq_eq$4, $Kernel_$lt_eq_gt$5, $Kernel_method$6, $Kernel_methods$7, $Kernel_public_methods$8, $Kernel_Array$9, $Kernel_at_exit$10, $Kernel_caller$11, $Kernel_class$12, $Kernel_copy_instance_variables$13, $Kernel_copy_singleton_methods$14, $Kernel_clone$15, $Kernel_initialize_clone$16, $Kernel_define_singleton_method$17, $Kernel_dup$18, $Kernel_initialize_dup$19, $Kernel_enum_for$20, $Kernel_equal$ques$21, $Kernel_exit$22, $Kernel_extend$23, $Kernel_gets$24, $Kernel_hash$25, $Kernel_initialize_copy$26, $Kernel_inspect$27, $Kernel_instance_of$ques$29, $Kernel_instance_variable_defined$ques$30, $Kernel_instance_variable_get$31, $Kernel_instance_variable_set$32, $Kernel_remove_instance_variable$33, $Kernel_instance_variables$34, $Kernel_Integer$35, $Kernel_Float$36, $Kernel_Hash$37, $Kernel_is_a$ques$38, $Kernel_itself$39, $Kernel_lambda$40, $Kernel_load$41, $Kernel_loop$42, $Kernel_nil$ques$44, $Kernel_printf$45, $Kernel_proc$46, $Kernel_puts$47, $Kernel_p$48, $Kernel_print$50, $Kernel_readline$51, $Kernel_warn$52, $Kernel_raise$54, $Kernel_rand$55, $Kernel_respond_to$ques$56, $Kernel_respond_to_missing$ques$57, $Kernel_require$58, $Kernel_require_relative$59, $Kernel_require_tree$60, $Kernel_singleton_class$61, $Kernel_sleep$62, $Kernel_srand$63, $Kernel_String$64, $Kernel_tap$65, $Kernel_to_proc$66, $Kernel_to_s$67, $Kernel_catch$68, $Kernel_throw$69, $Kernel_open$70, $Kernel_yield_self$71;

    
    
    Opal.def(self, '$method_missing', $Kernel_method_missing$1 = function $$method_missing(symbol, $a) {
      var $iter = $Kernel_method_missing$1.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_method_missing$1.$$p = null;
      
      
      if ($iter) $Kernel_method_missing$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      return self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `" + (symbol) + "' for " + (self.$inspect()), symbol, args), nil, self.$caller(1));
    }, $Kernel_method_missing$1.$$arity = -2);
    
    Opal.def(self, '$=~', $Kernel_$eq_tilde$2 = function(obj) {
      var self = this;

      return false
    }, $Kernel_$eq_tilde$2.$$arity = 1);
    
    Opal.def(self, '$!~', $Kernel_$excl_tilde$3 = function(obj) {
      var self = this;

      return self['$=~'](obj)['$!']()
    }, $Kernel_$excl_tilde$3.$$arity = 1);
    
    Opal.def(self, '$===', $Kernel_$eq_eq_eq$4 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.$object_id()['$=='](other.$object_id())))) {
        return $ret_or_1
      } else {
        return self['$=='](other)
      }
    }, $Kernel_$eq_eq_eq$4.$$arity = 1);
    
    Opal.def(self, '$<=>', $Kernel_$lt_eq_gt$5 = function(other) {
      var self = this;

      
      // set guard for infinite recursion
      self.$$comparable = true;

      var x = self['$=='](other);

      if (x && x !== nil) {
        return 0;
      }

      return nil;
    
    }, $Kernel_$lt_eq_gt$5.$$arity = 1);
    
    Opal.def(self, '$method', $Kernel_method$6 = function $$method(name) {
      var self = this;

      
      var meth = self['$' + name];

      if (!meth || meth.$$stub) {
        self.$raise($$($nesting, 'NameError').$new("" + "undefined method `" + (name) + "' for class `" + (self.$class()) + "'", name));
      }

      return $$($nesting, 'Method').$new(self, meth.$$owner || self.$class(), meth, name);
    
    }, $Kernel_method$6.$$arity = 1);
    
    Opal.def(self, '$methods', $Kernel_methods$7 = function $$methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.own_methods(self);
      }
    ;
    }, $Kernel_methods$7.$$arity = -1);
    
    Opal.def(self, '$public_methods', $Kernel_public_methods$8 = function $$public_methods(all) {
      var self = this;

      
      
      if (all == null) {
        all = true;
      };
      
      if ($truthy(all)) {
        return Opal.methods(self);
      } else {
        return Opal.receiver_methods(self);
      }
    ;
    }, $Kernel_public_methods$8.$$arity = -1);
    
    Opal.def(self, '$Array', $Kernel_Array$9 = function $$Array(object) {
      var self = this;

      
      var coerced;

      if (object === nil) {
        return [];
      }

      if (object.$$is_array) {
        return object;
      }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_ary");
      if (coerced !== nil) { return coerced; }

      coerced = $$($nesting, 'Opal')['$coerce_to?'](object, $$($nesting, 'Array'), "to_a");
      if (coerced !== nil) { return coerced; }

      return [object];
    
    }, $Kernel_Array$9.$$arity = 1);
    
    Opal.def(self, '$at_exit', $Kernel_at_exit$10 = function $$at_exit() {
      var $iter = $Kernel_at_exit$10.$$p, block = $iter || nil, self = this, $ret_or_2 = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      if ($iter) $Kernel_at_exit$10.$$p = null;
      
      
      if ($iter) $Kernel_at_exit$10.$$p = null;;
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_2 = $gvars.__at_exit__))) {
        return $ret_or_2
      } else {
        return []
      }; return nil; })();
      $gvars.__at_exit__['$<<'](block);
      return block;
    }, $Kernel_at_exit$10.$$arity = 0);
    
    Opal.def(self, '$caller', $Kernel_caller$11 = function $$caller(start, length) {
      var self = this;

      
      
      if (start == null) {
        start = 1;
      };
      
      if (length == null) {
        length = nil;
      };
      
      var stack, result;

      stack = new Error().$backtrace();
      result = [];

      for (var i = start + 1, ii = stack.length; i < ii; i++) {
        if (!stack[i].match(/runtime\.js/)) {
          result.push(stack[i]);
        }
      }
      if (length != nil) result = result.slice(0, length);
      return result;
    ;
    }, $Kernel_caller$11.$$arity = -1);
    
    Opal.def(self, '$class', $Kernel_class$12 = function() {
      var self = this;

      return self.$$class;
    }, $Kernel_class$12.$$arity = 0);
    
    Opal.def(self, '$copy_instance_variables', $Kernel_copy_instance_variables$13 = function $$copy_instance_variables(other) {
      var self = this;

      
      var keys = Object.keys(other), i, ii, name;
      for (i = 0, ii = keys.length; i < ii; i++) {
        name = keys[i];
        if (name.charAt(0) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_instance_variables$13.$$arity = 1);
    
    Opal.def(self, '$copy_singleton_methods', $Kernel_copy_singleton_methods$14 = function $$copy_singleton_methods(other) {
      var self = this;

      
      var i, name, names, length;

      if (other.hasOwnProperty('$$meta')) {
        var other_singleton_class = Opal.get_singleton_class(other);
        var self_singleton_class = Opal.get_singleton_class(self);
        names = Object.getOwnPropertyNames(other_singleton_class.$$prototype);

        for (i = 0, length = names.length; i < length; i++) {
          name = names[i];
          if (Opal.is_method(name)) {
            self_singleton_class.$$prototype[name] = other_singleton_class.$$prototype[name];
          }
        }

        self_singleton_class.$$const = Object.assign({}, other_singleton_class.$$const);
        Object.setPrototypeOf(
          self_singleton_class.$$prototype,
          Object.getPrototypeOf(other_singleton_class.$$prototype)
        );
      }

      for (i = 0, names = Object.getOwnPropertyNames(other), length = names.length; i < length; i++) {
        name = names[i];
        if (name.charAt(0) === '$' && name.charAt(1) !== '$' && other.hasOwnProperty(name)) {
          self[name] = other[name];
        }
      }
    
    }, $Kernel_copy_singleton_methods$14.$$arity = 1);
    
    Opal.def(self, '$clone', $Kernel_clone$15 = function $$clone($kwargs) {
      var freeze, self = this, copy = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $Kernel_clone$15.$$arity = -1);
    
    Opal.def(self, '$initialize_clone', $Kernel_initialize_clone$16 = function $$initialize_clone(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_clone$16.$$arity = 1);
    
    Opal.def(self, '$define_singleton_method', $Kernel_define_singleton_method$17 = function $$define_singleton_method(name, method) {
      var $iter = $Kernel_define_singleton_method$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_define_singleton_method$17.$$p = null;
      
      
      if ($iter) $Kernel_define_singleton_method$17.$$p = null;;
      ;
      return $send(self.$singleton_class(), 'define_method', [name, method], block.$to_proc());
    }, $Kernel_define_singleton_method$17.$$arity = -2);
    
    Opal.def(self, '$dup', $Kernel_dup$18 = function $$dup() {
      var self = this, copy = nil;

      
      copy = self.$class().$allocate();
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Kernel_dup$18.$$arity = 0);
    
    Opal.def(self, '$initialize_dup', $Kernel_initialize_dup$19 = function $$initialize_dup(other) {
      var self = this;

      return self.$initialize_copy(other)
    }, $Kernel_initialize_dup$19.$$arity = 1);
    
    Opal.def(self, '$enum_for', $Kernel_enum_for$20 = function $$enum_for($a, $b) {
      var $iter = $Kernel_enum_for$20.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Kernel_enum_for$20.$$p = null;
      
      
      if ($iter) $Kernel_enum_for$20.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      return $send($$($nesting, 'Enumerator'), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Kernel_enum_for$20.$$arity = -1);
    $alias(self, "to_enum", "enum_for");
    
    Opal.def(self, '$equal?', $Kernel_equal$ques$21 = function(other) {
      var self = this;

      return self === other;
    }, $Kernel_equal$ques$21.$$arity = 1);
    
    Opal.def(self, '$exit', $Kernel_exit$22 = function $$exit(status) {
      var $a, self = this, $ret_or_3 = nil, block = nil;
      if ($gvars.__at_exit__ == null) $gvars.__at_exit__ = nil;

      
      
      if (status == null) {
        status = true;
      };
      $gvars.__at_exit__ = (function() {if ($truthy(($ret_or_3 = $gvars.__at_exit__))) {
        return $ret_or_3
      } else {
        return []
      }; return nil; })();
      while (!($truthy($gvars.__at_exit__['$empty?']()))) {
        
        block = $gvars.__at_exit__.$pop();
        block.$call();
      };
      
      if (status.$$is_boolean) {
        status = status ? 0 : 1;
      } else {
        status = $coerce_to(status, $$($nesting, 'Integer'), 'to_int')
      }

      Opal.exit(status);
    ;
      return nil;
    }, $Kernel_exit$22.$$arity = -1);
    
    Opal.def(self, '$extend', $Kernel_extend$23 = function $$extend($a) {
      var $post_args, mods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      mods = $post_args;;
      
      var singleton = self.$singleton_class();

      for (var i = mods.length - 1; i >= 0; i--) {
        var mod = mods[i];

        if (!mod.$$is_module) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((mod).$class()) + " (expected Module)");
        }

        (mod).$append_features(singleton);
        (mod).$extend_object(self);
        (mod).$extended(self);
      }
    ;
      return self;
    }, $Kernel_extend$23.$$arity = -1);
    
    Opal.def(self, '$gets', $Kernel_gets$24 = function $$gets($a) {
      var $post_args, args, self = this;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($gvars.stdin, 'gets', Opal.to_a(args));
    }, $Kernel_gets$24.$$arity = -1);
    
    Opal.def(self, '$hash', $Kernel_hash$25 = function $$hash() {
      var self = this;

      return self.$__id__()
    }, $Kernel_hash$25.$$arity = 0);
    
    Opal.def(self, '$initialize_copy', $Kernel_initialize_copy$26 = function $$initialize_copy(other) {
      var self = this;

      return nil
    }, $Kernel_initialize_copy$26.$$arity = 1);
    
    Opal.def(self, '$inspect', $Kernel_inspect$27 = function $$inspect() {
      var $$28, self = this, ivs = nil;

      
      ivs = "";
      $send(self.$instance_variables(), 'each', [], ($$28 = function(i){var self = $$28.$$s == null ? this : $$28.$$s;

        
        
        if (i == null) {
          i = nil;
        };
        return (ivs = $rb_plus(ivs, "" + " " + (i) + "=" + (self.$instance_variable_get(i))));}, $$28.$$s = self, $$28.$$arity = 1, $$28));
      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + (ivs) + ">";
    }, $Kernel_inspect$27.$$arity = 0);
    
    Opal.def(self, '$instance_of?', $Kernel_instance_of$ques$29 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return self.$$class === klass;
    
    }, $Kernel_instance_of$ques$29.$$arity = 1);
    
    Opal.def(self, '$instance_variable_defined?', $Kernel_instance_variable_defined$ques$30 = function(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return Opal.hasOwnProperty.call(self, name.substr(1));;
    }, $Kernel_instance_variable_defined$ques$30.$$arity = 1);
    
    Opal.def(self, '$instance_variable_get', $Kernel_instance_variable_get$31 = function $$instance_variable_get(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var ivar = self[Opal.ivar(name.substr(1))];

      return ivar == null ? nil : ivar;
    ;
    }, $Kernel_instance_variable_get$31.$$arity = 1);
    
    Opal.def(self, '$instance_variable_set', $Kernel_instance_variable_set$32 = function $$instance_variable_set(name, value) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      return self[Opal.ivar(name.substr(1))] = value;;
    }, $Kernel_instance_variable_set$32.$$arity = 2);
    
    Opal.def(self, '$remove_instance_variable', $Kernel_remove_instance_variable$33 = function $$remove_instance_variable(name) {
      var self = this;

      
      name = $$($nesting, 'Opal')['$instance_variable_name!'](name);
      
      var key = Opal.ivar(name.substr(1)),
          val;
      if (self.hasOwnProperty(key)) {
        val = self[key];
        delete self[key];
        return val;
      }
    ;
      return self.$raise($$($nesting, 'NameError'), "" + "instance variable " + (name) + " not defined");
    }, $Kernel_remove_instance_variable$33.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Kernel_instance_variables$34 = function $$instance_variables() {
      var self = this;

      
      var result = [], ivar;

      for (var name in self) {
        if (self.hasOwnProperty(name) && name.charAt(0) !== '$') {
          if (name.substr(-1) === '$') {
            ivar = name.slice(0, name.length - 1);
          } else {
            ivar = name;
          }
          result.push('@' + ivar);
        }
      }

      return result;
    
    }, $Kernel_instance_variables$34.$$arity = 0);
    
    Opal.def(self, '$Integer', $Kernel_Integer$35 = function $$Integer(value, base) {
      var self = this;

      
      ;
      
      var i, str, base_digits;

      if (!value.$$is_string) {
        if (base !== undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "base specified for non string value")
        }
        if (value === nil) {
          self.$raise($$($nesting, 'TypeError'), "can't convert nil into Integer")
        }
        if (value.$$is_number) {
          if (value === Infinity || value === -Infinity || isNaN(value)) {
            self.$raise($$($nesting, 'FloatDomainError'), value)
          }
          return Math.floor(value);
        }
        if (value['$respond_to?']("to_int")) {
          i = value.$to_int();
          if (i !== nil) {
            return i;
          }
        }
        return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Integer'), "to_i");
      }

      if (value === "0") {
        return 0;
      }

      if (base === undefined) {
        base = 0;
      } else {
        base = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');
        if (base === 1 || base < 0 || base > 36) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))
        }
      }

      str = value.toLowerCase();

      str = str.replace(/(\d)_(?=\d)/g, '$1');

      str = str.replace(/^(\s*[+-]?)(0[bodx]?)/, function (_, head, flag) {
        switch (flag) {
        case '0b':
          if (base === 0 || base === 2) {
            base = 2;
            return head;
          }
          // no-break
        case '0':
        case '0o':
          if (base === 0 || base === 8) {
            base = 8;
            return head;
          }
          // no-break
        case '0d':
          if (base === 0 || base === 10) {
            base = 10;
            return head;
          }
          // no-break
        case '0x':
          if (base === 0 || base === 16) {
            base = 16;
            return head;
          }
          // no-break
        }
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      });

      base = (base === 0 ? 10 : base);

      base_digits = '0-' + (base <= 10 ? base - 1 : '9a-' + String.fromCharCode(97 + (base - 11)));

      if (!(new RegExp('^\\s*[+-]?[' + base_digits + ']+\\s*$')).test(str)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      i = parseInt(str, base);

      if (isNaN(i)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Integer(): \"" + (value) + "\"")
      }

      return i;
    ;
    }, $Kernel_Integer$35.$$arity = -2);
    
    Opal.def(self, '$Float', $Kernel_Float$36 = function $$Float(value) {
      var self = this;

      
      var str;

      if (value === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert nil into Float")
      }

      if (value.$$is_string) {
        str = value.toString();

        str = str.replace(/(\d)_(?=\d)/g, '$1');

        //Special case for hex strings only:
        if (/^\s*[-+]?0[xX][0-9a-fA-F]+\s*$/.test(str)) {
          return self.$Integer(str);
        }

        if (!/^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/.test(str)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid value for Float(): \"" + (value) + "\"")
        }

        return parseFloat(str);
      }

      return $$($nesting, 'Opal')['$coerce_to!'](value, $$($nesting, 'Float'), "to_f");
    
    }, $Kernel_Float$36.$$arity = 1);
    
    Opal.def(self, '$Hash', $Kernel_Hash$37 = function $$Hash(arg) {
      var self = this, $ret_or_4 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_4 = arg['$nil?']()))) {
        return $ret_or_4
      } else {
        return arg['$==']([])
      }; return nil; })())) {
        return $hash2([], {})};
      if ($truthy($$($nesting, 'Hash')['$==='](arg))) {
        return arg};
      return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'Hash'), "to_hash");
    }, $Kernel_Hash$37.$$arity = 1);
    
    Opal.def(self, '$is_a?', $Kernel_is_a$ques$38 = function(klass) {
      var self = this;

      
      if (!klass.$$is_class && !klass.$$is_module) {
        self.$raise($$($nesting, 'TypeError'), "class or module required");
      }

      return Opal.is_a(self, klass);
    
    }, $Kernel_is_a$ques$38.$$arity = 1);
    
    Opal.def(self, '$itself', $Kernel_itself$39 = function $$itself() {
      var self = this;

      return self
    }, $Kernel_itself$39.$$arity = 0);
    $alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$lambda', $Kernel_lambda$40 = function $$lambda() {
      var $iter = $Kernel_lambda$40.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_lambda$40.$$p = null;
      
      
      if ($iter) $Kernel_lambda$40.$$p = null;;
      return Opal.lambda(block);;
    }, $Kernel_lambda$40.$$arity = 0);
    
    Opal.def(self, '$load', $Kernel_load$41 = function $$load(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.load(file);
    }, $Kernel_load$41.$$arity = 1);
    
    Opal.def(self, '$loop', $Kernel_loop$42 = function $$loop() {
      var $$43, $a, $iter = $Kernel_loop$42.$$p, $yield = $iter || nil, self = this, e = nil;

      if ($iter) $Kernel_loop$42.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["loop"], ($$43 = function(){var self = $$43.$$s == null ? this : $$43.$$s;

          return $$$($$($nesting, 'Float'), 'INFINITY')}, $$43.$$s = self, $$43.$$arity = 0, $$43))
      };
      while ($truthy(true)) {
        
        try {
          Opal.yieldX($yield, [])
        } catch ($err) {
          if (Opal.rescue($err, [$$($nesting, 'StopIteration')])) {(e = $err)
            try {
              return e.$result()
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        };
      };
      return self;
    }, $Kernel_loop$42.$$arity = 0);
    
    Opal.def(self, '$nil?', $Kernel_nil$ques$44 = function() {
      var self = this;

      return false
    }, $Kernel_nil$ques$44.$$arity = 0);
    $alias(self, "object_id", "__id__");
    
    Opal.def(self, '$printf', $Kernel_printf$45 = function $$printf($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(args['$any?']())) {
        self.$print($send(self, 'format', Opal.to_a(args)))};
      return nil;
    }, $Kernel_printf$45.$$arity = -1);
    
    Opal.def(self, '$proc', $Kernel_proc$46 = function $$proc() {
      var $iter = $Kernel_proc$46.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_proc$46.$$p = null;
      
      
      if ($iter) $Kernel_proc$46.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create Proc object without a block")
      };
      block.$$is_lambda = false;
      return block;
    }, $Kernel_proc$46.$$arity = 0);
    
    Opal.def(self, '$puts', $Kernel_puts$47 = function $$puts($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'puts', Opal.to_a(strs));
    }, $Kernel_puts$47.$$arity = -1);
    
    Opal.def(self, '$p', $Kernel_p$48 = function $$p($a) {
      var $post_args, args, $$49, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      $send(args, 'each', [], ($$49 = function(obj){var self = $$49.$$s == null ? this : $$49.$$s;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        
        if (obj == null) {
          obj = nil;
        };
        return $gvars.stdout.$puts(obj.$inspect());}, $$49.$$s = self, $$49.$$arity = 1, $$49));
      if ($truthy($rb_le(args.$length(), 1))) {
        return args['$[]'](0)
      } else {
        return args
      };
    }, $Kernel_p$48.$$arity = -1);
    
    Opal.def(self, '$print', $Kernel_print$50 = function $$print($a) {
      var $post_args, strs, self = this;
      if ($gvars.stdout == null) $gvars.stdout = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      strs = $post_args;;
      return $send($gvars.stdout, 'print', Opal.to_a(strs));
    }, $Kernel_print$50.$$arity = -1);
    
    Opal.def(self, '$readline', $Kernel_readline$51 = function $$readline($a) {
      var $post_args, args, self = this;
      if ($gvars.stdin == null) $gvars.stdin = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($gvars.stdin, 'readline', Opal.to_a(args));
    }, $Kernel_readline$51.$$arity = -1);
    
    Opal.def(self, '$warn', $Kernel_warn$52 = function $$warn($a, $b) {
      var $post_args, $kwargs, strs, uplevel, $c, $d, $$53, self = this, location = nil, $ret_or_5 = nil;
      if ($gvars.VERBOSE == null) $gvars.VERBOSE = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      strs = $post_args;;
      
      uplevel = $kwargs.$$smap["uplevel"];
      if (uplevel == null) {
        uplevel = nil
      };
      if ($truthy(uplevel)) {
        
        uplevel = $$($nesting, 'Opal')['$coerce_to!'](uplevel, $$($nesting, 'Integer'), "to_str");
        if ($truthy($rb_lt(uplevel, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "negative level (" + (uplevel) + ")")};
        location = ($d = ($c = self.$caller($rb_plus(uplevel, 1), 1).$first(), ($c === nil || $c == null) ? nil : $send($c, 'split', [":in `"])), ($d === nil || $d == null) ? nil : $send($d, 'first', []));
        if ($truthy(location)) {
          location = "" + (location) + ": "};
        strs = $send(strs, 'map', [], ($$53 = function(s){var self = $$53.$$s == null ? this : $$53.$$s;

          
          
          if (s == null) {
            s = nil;
          };
          return "" + (location) + "warning: " + (s);}, $$53.$$s = self, $$53.$$arity = 1, $$53));};
      if ($truthy((function() {if ($truthy(($ret_or_5 = $gvars.VERBOSE['$nil?']()))) {
        return $ret_or_5
      } else {
        return strs['$empty?']()
      }; return nil; })())) {
        return nil
      } else {
        return $send($gvars.stderr, 'puts', Opal.to_a(strs))
      };
    }, $Kernel_warn$52.$$arity = -1);
    
    Opal.def(self, '$raise', $Kernel_raise$54 = function $$raise(exception, string, backtrace) {
      var self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;
      if ($gvars["@"] == null) $gvars["@"] = nil;

      
      ;
      
      if (string == null) {
        string = nil;
      };
      
      if (backtrace == null) {
        backtrace = nil;
      };
      
      if (exception == null && $gvars["!"] !== nil) {
        throw $gvars["!"];
      }
      if (exception == null) {
        exception = $$($nesting, 'RuntimeError').$new("");
      }
      else if ($respond_to(exception, '$to_str')) {
        exception = $$($nesting, 'RuntimeError').$new(exception.$to_str());
      }
      // using respond_to? and not an undefined check to avoid method_missing matching as true
      else if (exception.$$is_class && $respond_to(exception, '$exception')) {
        exception = exception.$exception(string);
      }
      else if (exception.$$is_exception) {
        // exception is fine
      }
      else {
        exception = $$($nesting, 'TypeError').$new("exception class/object expected");
      }

      if (backtrace !== nil) {
        exception.$set_backtrace(backtrace);
      }

      if ($gvars["!"] !== nil) {
        Opal.exceptions.push($gvars["!"]);
      }

      $gvars["!"] = exception;
      $gvars["@"] = (exception).$backtrace();

      throw exception;
    ;
    }, $Kernel_raise$54.$$arity = -1);
    $alias(self, "fail", "raise");
    
    Opal.def(self, '$rand', $Kernel_rand$55 = function $$rand(max) {
      var self = this;

      
      ;
      
      if (max === undefined) {
        return $$$($$($nesting, 'Random'), 'DEFAULT').$rand();
      }

      if (max.$$is_number) {
        if (max < 0) {
          max = Math.abs(max);
        }

        if (max % 1 !== 0) {
          max = max.$to_i();
        }

        if (max === 0) {
          max = undefined;
        }
      }
    ;
      return $$$($$($nesting, 'Random'), 'DEFAULT').$rand(max);
    }, $Kernel_rand$55.$$arity = -1);
    
    Opal.def(self, '$respond_to?', $Kernel_respond_to$ques$56 = function(name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      
      var body = self['$' + name];

      if (typeof(body) === "function" && !body.$$stub) {
        return true;
      }

      if (self['$respond_to_missing?'].$$pristine === true) {
        return false;
      } else {
        return self['$respond_to_missing?'](name, include_all);
      }
    ;
    }, $Kernel_respond_to$ques$56.$$arity = -2);
    
    Opal.def(self, '$respond_to_missing?', $Kernel_respond_to_missing$ques$57 = function(method_name, include_all) {
      var self = this;

      
      
      if (include_all == null) {
        include_all = false;
      };
      return false;
    }, $Kernel_respond_to_missing$ques$57.$$arity = -2);
    $$($nesting, 'Opal').$pristine(self, "respond_to?", "respond_to_missing?");
    
    Opal.def(self, '$require', $Kernel_require$58 = function $$require(file) {
      var self = this;

      
      file = $$($nesting, 'Opal')['$coerce_to!'](file, $$($nesting, 'String'), "to_str");
      return Opal.require(file);
    }, $Kernel_require$58.$$arity = 1);
    
    Opal.def(self, '$require_relative', $Kernel_require_relative$59 = function $$require_relative(file) {
      var self = this;

      
      $$($nesting, 'Opal')['$try_convert!'](file, $$($nesting, 'String'), "to_str");
      file = $$($nesting, 'File').$expand_path($$($nesting, 'File').$join(Opal.current_file, "..", file));
      return Opal.require(file);
    }, $Kernel_require_relative$59.$$arity = 1);
    
    Opal.def(self, '$require_tree', $Kernel_require_tree$60 = function $$require_tree(path) {
      var self = this;

      
      var result = [];

      path = $$($nesting, 'File').$expand_path(path)
      path = Opal.normalize(path);
      if (path === '.') path = '';
      for (var name in Opal.modules) {
        if ((name)['$start_with?'](path)) {
          result.push([name, Opal.require(name)]);
        }
      }

      return result;
    
    }, $Kernel_require_tree$60.$$arity = 1);
    $alias(self, "send", "__send__");
    $alias(self, "public_send", "__send__");
    
    Opal.def(self, '$singleton_class', $Kernel_singleton_class$61 = function $$singleton_class() {
      var self = this;

      return Opal.get_singleton_class(self);
    }, $Kernel_singleton_class$61.$$arity = 0);
    
    Opal.def(self, '$sleep', $Kernel_sleep$62 = function $$sleep(seconds) {
      var self = this;

      
      
      if (seconds == null) {
        seconds = nil;
      };
      
      if (seconds === nil) {
        self.$raise($$($nesting, 'TypeError'), "can't convert NilClass into time interval")
      }
      if (!seconds.$$is_number) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (seconds.$class()) + " into time interval")
      }
      if (seconds < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "time interval must be positive")
      }
      var get_time = Opal.global.performance ?
        function() {return performance.now()} :
        function() {return new Date()}

      var t = get_time();
      while (get_time() - t <= seconds * 1000);
      return Math.round(seconds);
    ;
    }, $Kernel_sleep$62.$$arity = -1);
    
    Opal.def(self, '$srand', $Kernel_srand$63 = function $$srand(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      return $$($nesting, 'Random').$srand(seed);
    }, $Kernel_srand$63.$$arity = -1);
    
    Opal.def(self, '$String', $Kernel_String$64 = function $$String(str) {
      var self = this, $ret_or_6 = nil;

      if ($truthy(($ret_or_6 = $$($nesting, 'Opal')['$coerce_to?'](str, $$($nesting, 'String'), "to_str")))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](str, $$($nesting, 'String'), "to_s")
      }
    }, $Kernel_String$64.$$arity = 1);
    
    Opal.def(self, '$tap', $Kernel_tap$65 = function $$tap() {
      var $iter = $Kernel_tap$65.$$p, block = $iter || nil, self = this;

      if ($iter) $Kernel_tap$65.$$p = null;
      
      
      if ($iter) $Kernel_tap$65.$$p = null;;
      Opal.yield1(block, self);
      return self;
    }, $Kernel_tap$65.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Kernel_to_proc$66 = function $$to_proc() {
      var self = this;

      return self
    }, $Kernel_to_proc$66.$$arity = 0);
    
    Opal.def(self, '$to_s', $Kernel_to_s$67 = function $$to_s() {
      var self = this;

      return "" + "#<" + (self.$class()) + ":0x" + (self.$__id__().$to_s(16)) + ">"
    }, $Kernel_to_s$67.$$arity = 0);
    
    Opal.def(self, '$catch', $Kernel_catch$68 = function(tag) {
      var $iter = $Kernel_catch$68.$$p, $yield = $iter || nil, self = this, $ret_or_7 = nil, e = nil;

      if ($iter) $Kernel_catch$68.$$p = null;
      
      
      if (tag == null) {
        tag = nil;
      };
      try {
        
        tag = (function() {if ($truthy(($ret_or_7 = tag))) {
          return $ret_or_7
        } else {
          return $$($nesting, 'Object').$new()
        }; return nil; })();
        return Opal.yield1($yield, tag);;
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'UncaughtThrowError')])) {(e = $err)
          try {
            
            if (e.$tag()['$=='](tag)) {
              return e.$value()};
            return self.$raise();
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      };
    }, $Kernel_catch$68.$$arity = -1);
    
    Opal.def(self, '$throw', $Kernel_throw$69 = function(tag, obj) {
      var self = this;

      
      
      if (obj == null) {
        obj = nil;
      };
      return self.$raise($$($nesting, 'UncaughtThrowError').$new(tag, obj));
    }, $Kernel_throw$69.$$arity = -2);
    
    Opal.def(self, '$open', $Kernel_open$70 = function $$open($a) {
      var $iter = $Kernel_open$70.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Kernel_open$70.$$p = null;
      
      
      if ($iter) $Kernel_open$70.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send($$($nesting, 'File'), 'open', Opal.to_a(args), block.$to_proc());
    }, $Kernel_open$70.$$arity = -1);
    
    Opal.def(self, '$yield_self', $Kernel_yield_self$71 = function $$yield_self() {
      var $$72, $iter = $Kernel_yield_self$71.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Kernel_yield_self$71.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["yield_self"], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

          return 1}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      return Opal.yield1($yield, self);;
    }, $Kernel_yield_self$71.$$arity = 0);
    $alias(self, "then", "yield_self");
    return $$($nesting, 'Opal').$pristine(self, "method_missing");
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Object');

    var $nesting = [self].concat($parent_nesting);

    return self.$include($$($nesting, 'Kernel'))
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/error"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $gvars = Opal.gvars, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $module = Opal.module, $send2 = Opal.send2;

  Opal.add_stubs(['$new', '$map', '$backtrace', '$clone', '$to_s', '$tty?', '$include?', '$raise', '$dup', '$!', '$empty?', '$caller', '$shift', '$+', '$class', '$join', '$cause', '$full_message', '$==', '$reverse', '$split', '$attr_reader', '$inspect']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Exception');

    var $nesting = [self].concat($parent_nesting), $Exception_new$1, $Exception_exception$2, $Exception_initialize$3, $Exception_backtrace$4, $Exception_backtrace_locations$5, $Exception_cause$7, $Exception_exception$8, $Exception_message$9, $Exception_full_message$10, $Exception_inspect$12, $Exception_set_backtrace$13, $Exception_to_s$15;

    self.$$prototype.message = nil;
    
    Opal.defineProperty(self.$$prototype, '$$is_exception', true);
    var stack_trace_limit;
    Opal.defs(self, '$new', $Exception_new$1 = function($a) {
      var $post_args, args, self = this;
      if ($gvars["!"] == null) $gvars["!"] = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var message   = (args.length > 0) ? args[0] : nil;
      var error     = new self.$$constructor(message);
      error.name    = self.$$name;
      error.message = message;
      error.cause   = $gvars["!"];
      Opal.send(error, error.$initialize, args);

      // Error.captureStackTrace() will use .name and .toString to build the
      // first line of the stack trace so it must be called after the error
      // has been initialized.
      // https://nodejs.org/dist/latest-v6.x/docs/api/errors.html
      if (Opal.config.enable_stack_trace && Error.captureStackTrace) {
        // Passing Kernel.raise will cut the stack trace from that point above
        Error.captureStackTrace(error, stack_trace_limit);
      }

      return error;
    ;
    }, $Exception_new$1.$$arity = -1);
    stack_trace_limit = self.$new;
    Opal.defs(self, '$exception', $Exception_exception$2 = function $$exception($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $Exception_exception$2.$$arity = -1);
    
    Opal.def(self, '$initialize', $Exception_initialize$3 = function $$initialize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.message = (args.length > 0) ? args[0] : nil;;
    }, $Exception_initialize$3.$$arity = -1);
    
    // Convert backtrace from any format to Ruby format
    function correct_backtrace(backtrace) {
      var new_bt = [], m;

      for (var i = 0; i < backtrace.length; i++) {
        var loc = backtrace[i];
        if (!loc || !loc.$$is_string) {
          /* Do nothing */
        }
        /* Chromium format */
        else if ((m = loc.match(/^    at (.*?) \((.*?)\)$/))) {
          new_bt.push(m[2] + ":in `" + m[1] + "'");
        }
        else if ((m = loc.match(/^    at (.*?)$/))) {
          new_bt.push(m[1] + ":in `undefined'");
        }
        /* Node format */
        else if ((m = loc.match(/^  from (.*?)$/))) {
          new_bt.push(m[1]);
        }
        /* Mozilla/Apple format */
        else if ((m = loc.match(/^(.*?)@(.*?)$/))) {
          new_bt.push(m[2] + ':in `' + m[1] + "'");
        }
      }

      return new_bt;
    }
  ;
    
    Opal.def(self, '$backtrace', $Exception_backtrace$4 = function $$backtrace() {
      var self = this;

      
      if (self.backtrace) {
        // nil is a valid backtrace
        return self.backtrace;
      }

      var backtrace = self.stack;

      if (backtrace.$$is_string) {
        return self.backtrace = correct_backtrace(backtrace.split("\n").slice(0, 15));
      }
      else if (backtrace) {
        return self.backtrace = correct_backtrace(backtrace.slice(0, 15));
      }

      return [];
    
    }, $Exception_backtrace$4.$$arity = 0);
    
    Opal.def(self, '$backtrace_locations', $Exception_backtrace_locations$5 = function $$backtrace_locations() {
      var $a, $$6, self = this;

      
      if (self.backtrace_locations) return self.backtrace_locations;
      self.backtrace_locations = ($a = self.$backtrace(), ($a === nil || $a == null) ? nil : $send($a, 'map', [], ($$6 = function(loc){var self = $$6.$$s == null ? this : $$6.$$s;

        
        
        if (loc == null) {
          loc = nil;
        };
        return $$$($$$($$$('::', 'Thread'), 'Backtrace'), 'Location').$new(loc);}, $$6.$$s = self, $$6.$$arity = 1, $$6)))
      return self.backtrace_locations;
    
    }, $Exception_backtrace_locations$5.$$arity = 0);
    
    Opal.def(self, '$cause', $Exception_cause$7 = function $$cause() {
      var self = this;

      return self.cause || nil;
    }, $Exception_cause$7.$$arity = 0);
    
    Opal.def(self, '$exception', $Exception_exception$8 = function $$exception(str) {
      var self = this;

      
      
      if (str == null) {
        str = nil;
      };
      
      if (str === nil || self === str) {
        return self;
      }

      var cloned = self.$clone();
      cloned.message = str;
      if (self.backtrace) cloned.backtrace = self.backtrace.$dup();
      cloned.stack = self.stack;
      cloned.cause = self.cause;
      return cloned;
    ;
    }, $Exception_exception$8.$$arity = -1);
    
    Opal.def(self, '$message', $Exception_message$9 = function $$message() {
      var self = this;

      return self.$to_s()
    }, $Exception_message$9.$$arity = 0);
    
    Opal.def(self, '$full_message', $Exception_full_message$10 = function $$full_message($kwargs) {
      var highlight, order, $$11, self = this, bold_underline = nil, bold = nil, reset = nil, bt = nil, $ret_or_1 = nil, first = nil, msg = nil;
      if ($gvars.stderr == null) $gvars.stderr = nil;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      highlight = $kwargs.$$smap["highlight"];
      if (highlight == null) {
        highlight = $gvars.stderr['$tty?']()
      };
      
      order = $kwargs.$$smap["order"];
      if (order == null) {
        order = "top"
      };
      if ($truthy([true, false]['$include?'](highlight))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "expected true or false as highlight: " + (highlight))
      };
      if ($truthy(["top", "bottom"]['$include?'](order))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "expected :top or :bottom as order: " + (order))
      };
      if ($truthy(highlight)) {
        
        bold_underline = "\u001b[1;4m";
        bold = "\u001b[1m";
        reset = "\u001b[m";
      } else {
        bold_underline = (bold = (reset = ""))
      };
      bt = self.$backtrace().$dup();
      if ($truthy((function() {if ($truthy(($ret_or_1 = bt['$!']()))) {
        return $ret_or_1
      } else {
        return bt['$empty?']()
      }; return nil; })())) {
        bt = self.$caller()};
      first = bt.$shift();
      msg = "" + (first) + ": ";
      msg = $rb_plus(msg, "" + (bold) + (self.$to_s()) + " (" + (bold_underline) + (self.$class()) + (reset) + (bold) + ")" + (reset) + "\n");
      msg = $rb_plus(msg, $send(bt, 'map', [], ($$11 = function(loc){var self = $$11.$$s == null ? this : $$11.$$s;

        
        
        if (loc == null) {
          loc = nil;
        };
        return "" + "\tfrom " + (loc) + "\n";}, $$11.$$s = self, $$11.$$arity = 1, $$11)).$join());
      if ($truthy(self.$cause())) {
        msg = $rb_plus(msg, self.$cause().$full_message($hash2(["highlight"], {"highlight": highlight})))};
      if (order['$==']("bottom")) {
        
        msg = msg.$split("\n").$reverse().$join("\n");
        msg = $rb_plus("" + (bold) + "Traceback" + (reset) + " (most recent call last):\n", msg);};
      return msg;
    }, $Exception_full_message$10.$$arity = -1);
    
    Opal.def(self, '$inspect', $Exception_inspect$12 = function $$inspect() {
      var self = this, as_str = nil;

      
      as_str = self.$to_s();
      if ($truthy(as_str['$empty?']())) {
        return self.$class().$to_s()
      } else {
        return "" + "#<" + (self.$class().$to_s()) + ": " + (self.$to_s()) + ">"
      };
    }, $Exception_inspect$12.$$arity = 0);
    
    Opal.def(self, '$set_backtrace', $Exception_set_backtrace$13 = function $$set_backtrace(backtrace) {
      var $$14, self = this;

      
      var valid = true, i, ii;

      if (backtrace === nil) {
        self.backtrace = nil;
        self.stack = '';
      } else if (backtrace.$$is_string) {
        self.backtrace = [backtrace];
        self.stack = '  from ' + backtrace;
      } else {
        if (backtrace.$$is_array) {
          for (i = 0, ii = backtrace.length; i < ii; i++) {
            if (!backtrace[i].$$is_string) {
              valid = false;
              break;
            }
          }
        } else {
          valid = false;
        }

        if (valid === false) {
          self.$raise($$($nesting, 'TypeError'), "backtrace must be Array of String")
        }

        self.backtrace = backtrace;
        self.stack = $send((backtrace), 'map', [], ($$14 = function(i){var self = $$14.$$s == null ? this : $$14.$$s;

        
        
        if (i == null) {
          i = nil;
        };
        return $rb_plus("  from ", i);}, $$14.$$s = self, $$14.$$arity = 1, $$14)).join("\n");
      }

      return backtrace;
    
    }, $Exception_set_backtrace$13.$$arity = 1);
    return (Opal.def(self, '$to_s', $Exception_to_s$15 = function $$to_s() {
      var self = this, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = self.message))) {
        return self.message.$to_s()
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return $ret_or_2
      } else {
        return self.$class().$to_s()
      }
    }, $Exception_to_s$15.$$arity = 0), nil) && 'to_s';
  })($nesting[0], Error, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ScriptError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SyntaxError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LoadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NotImplementedError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ScriptError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemExit');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMemoryError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SignalException');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Interrupt');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'SignalException'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SecurityError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemStackError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StandardError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Exception'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EncodingError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ZeroDivisionError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'NameError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RuntimeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FrozenError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RuntimeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'LocalJumpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TypeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ArgumentError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IndexError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ClosedQueueError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StopIteration'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IndexError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RangeError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FloatDomainError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'RangeError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IOError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'EOFError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'IOError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'SystemCallError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'ThreadError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FiberError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Errno');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EINVAL');

      var $nesting = [self].concat($parent_nesting), $EINVAL_new$16;

      return (Opal.defs(self, '$new', $EINVAL_new$16 = function(name) {
        var $iter = $EINVAL_new$16.$$p, $yield = $iter || nil, self = this, message = nil;

        if ($iter) $EINVAL_new$16.$$p = null;
        
        
        if (name == null) {
          name = nil;
        };
        message = "Invalid argument";
        if ($truthy(name)) {
          message = $rb_plus(message, "" + " - " + (name))};
        return $send2(self, Opal.find_super_dispatcher(self, 'new', $EINVAL_new$16, false, true), 'new', [message], null);
      }, $EINVAL_new$16.$$arity = -1), nil) && 'new'
    })($nesting[0], $$($nesting, 'SystemCallError'), $nesting)
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UncaughtThrowError');

    var $nesting = [self].concat($parent_nesting), $UncaughtThrowError_initialize$17;

    self.$$prototype.tag = nil;
    
    self.$attr_reader("tag", "value");
    return (Opal.def(self, '$initialize', $UncaughtThrowError_initialize$17 = function $$initialize(tag, value) {
      var $iter = $UncaughtThrowError_initialize$17.$$p, $yield = $iter || nil, self = this;

      if ($iter) $UncaughtThrowError_initialize$17.$$p = null;
      
      
      if (value == null) {
        value = nil;
      };
      self.tag = tag;
      self.value = value;
      return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $UncaughtThrowError_initialize$17, false, true), 'initialize', ["" + "uncaught throw " + (self.tag.$inspect())], null);
    }, $UncaughtThrowError_initialize$17.$$arity = -2), nil) && 'initialize';
  })($nesting[0], $$($nesting, 'ArgumentError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NameError');

    var $nesting = [self].concat($parent_nesting), $NameError_initialize$18;

    
    self.$attr_reader("name");
    return (Opal.def(self, '$initialize', $NameError_initialize$18 = function $$initialize(message, name) {
      var $iter = $NameError_initialize$18.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NameError_initialize$18.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NameError_initialize$18, false, true), 'initialize', [message], null);
      return (self.name = name);
    }, $NameError_initialize$18.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NoMethodError');

    var $nesting = [self].concat($parent_nesting), $NoMethodError_initialize$19;

    
    self.$attr_reader("args");
    return (Opal.def(self, '$initialize', $NoMethodError_initialize$19 = function $$initialize(message, name, args) {
      var $iter = $NoMethodError_initialize$19.$$p, $yield = $iter || nil, self = this;

      if ($iter) $NoMethodError_initialize$19.$$p = null;
      
      
      if (name == null) {
        name = nil;
      };
      
      if (args == null) {
        args = [];
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $NoMethodError_initialize$19, false, true), 'initialize', [message, name], null);
      return (self.args = args);
    }, $NoMethodError_initialize$19.$$arity = -2), nil) && 'initialize';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StopIteration');

    var $nesting = [self].concat($parent_nesting);

    return self.$attr_reader("result")
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'KeyError');

    var $nesting = [self].concat($parent_nesting), $KeyError_initialize$20, $KeyError_receiver$21, $KeyError_key$22;

    self.$$prototype.receiver = self.$$prototype.key = nil;
    
    
    Opal.def(self, '$initialize', $KeyError_initialize$20 = function $$initialize(message, $kwargs) {
      var receiver, key, $iter = $KeyError_initialize$20.$$p, $yield = $iter || nil, self = this;

      if ($iter) $KeyError_initialize$20.$$p = null;
      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      receiver = $kwargs.$$smap["receiver"];
      if (receiver == null) {
        receiver = nil
      };
      
      key = $kwargs.$$smap["key"];
      if (key == null) {
        key = nil
      };
      $send2(self, Opal.find_super_dispatcher(self, 'initialize', $KeyError_initialize$20, false, true), 'initialize', [message], null);
      self.receiver = receiver;
      return (self.key = key);
    }, $KeyError_initialize$20.$$arity = -2);
    
    Opal.def(self, '$receiver', $KeyError_receiver$21 = function $$receiver() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.receiver))) {
        return $ret_or_4
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no receiver is available")
      }
    }, $KeyError_receiver$21.$$arity = 0);
    return (Opal.def(self, '$key', $KeyError_key$22 = function $$key() {
      var self = this, $ret_or_5 = nil;

      if ($truthy(($ret_or_5 = self.key))) {
        return $ret_or_5
      } else {
        return self.$raise($$($nesting, 'ArgumentError'), "no key is available")
      }
    }, $KeyError_key$22.$$arity = 0), nil) && 'key';
  })($nesting[0], null, $nesting);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'JS');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Error');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/constants"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  Opal.const_set($nesting[0], 'RUBY_PLATFORM', "opal");
  Opal.const_set($nesting[0], 'RUBY_ENGINE', "opal");
  Opal.const_set($nesting[0], 'RUBY_VERSION', "3.0.2");
  Opal.const_set($nesting[0], 'RUBY_ENGINE_VERSION', "1.3.0.dev");
  Opal.const_set($nesting[0], 'RUBY_RELEASE_DATE', "2021-08-11");
  Opal.const_set($nesting[0], 'RUBY_PATCHLEVEL', 0);
  Opal.const_set($nesting[0], 'RUBY_REVISION', "0");
  Opal.const_set($nesting[0], 'RUBY_COPYRIGHT', "opal - Copyright (C) 2013-2021 Adam Beynon and the Opal contributors");
  return Opal.const_set($nesting[0], 'RUBY_DESCRIPTION', "" + "opal " + ($$($nesting, 'RUBY_ENGINE_VERSION')) + " (" + ($$($nesting, 'RUBY_RELEASE_DATE')) + " revision " + ($$($nesting, 'RUBY_REVISION')) + ")");
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["opal/base"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("corelib/runtime");
  self.$require("corelib/helpers");
  self.$require("corelib/module");
  self.$require("corelib/class");
  self.$require("corelib/basic_object");
  self.$require("corelib/kernel");
  self.$require("corelib/error");
  return self.$require("corelib/constants");
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/nil"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $alias = Opal.alias, $truthy = Opal.truthy;

  Opal.add_stubs(['$raise', '$name', '$new', '$>', '$length', '$Rational']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'NilClass');

    var $nesting = [self].concat($parent_nesting), $NilClass_$excl$2, $NilClass_$$3, $NilClass_$$4, $NilClass_$$5, $NilClass_$eq_eq$6, $NilClass_dup$7, $NilClass_clone$8, $NilClass_inspect$9, $NilClass_nil$ques$10, $NilClass_singleton_class$11, $NilClass_to_a$12, $NilClass_to_h$13, $NilClass_to_i$14, $NilClass_to_s$15, $NilClass_to_c$16, $NilClass_rationalize$17, $NilClass_to_r$18, $NilClass_instance_variables$19;

    
    self.$$prototype.$$meta = self;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$!', $NilClass_$excl$2 = function() {
      var self = this;

      return true
    }, $NilClass_$excl$2.$$arity = 0);
    
    Opal.def(self, '$&', $NilClass_$$3 = function(other) {
      var self = this;

      return false
    }, $NilClass_$$3.$$arity = 1);
    
    Opal.def(self, '$|', $NilClass_$$4 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$4.$$arity = 1);
    
    Opal.def(self, '$^', $NilClass_$$5 = function(other) {
      var self = this;

      return other !== false && other !== nil;
    }, $NilClass_$$5.$$arity = 1);
    
    Opal.def(self, '$==', $NilClass_$eq_eq$6 = function(other) {
      var self = this;

      return other === nil;
    }, $NilClass_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$dup', $NilClass_dup$7 = function $$dup() {
      var self = this;

      return nil
    }, $NilClass_dup$7.$$arity = 0);
    
    Opal.def(self, '$clone', $NilClass_clone$8 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return nil;
    }, $NilClass_clone$8.$$arity = -1);
    
    Opal.def(self, '$inspect', $NilClass_inspect$9 = function $$inspect() {
      var self = this;

      return "nil"
    }, $NilClass_inspect$9.$$arity = 0);
    
    Opal.def(self, '$nil?', $NilClass_nil$ques$10 = function() {
      var self = this;

      return true
    }, $NilClass_nil$ques$10.$$arity = 0);
    
    Opal.def(self, '$singleton_class', $NilClass_singleton_class$11 = function $$singleton_class() {
      var self = this;

      return $$($nesting, 'NilClass')
    }, $NilClass_singleton_class$11.$$arity = 0);
    
    Opal.def(self, '$to_a', $NilClass_to_a$12 = function $$to_a() {
      var self = this;

      return []
    }, $NilClass_to_a$12.$$arity = 0);
    
    Opal.def(self, '$to_h', $NilClass_to_h$13 = function $$to_h() {
      var self = this;

      return Opal.hash();
    }, $NilClass_to_h$13.$$arity = 0);
    
    Opal.def(self, '$to_i', $NilClass_to_i$14 = function $$to_i() {
      var self = this;

      return 0
    }, $NilClass_to_i$14.$$arity = 0);
    $alias(self, "to_f", "to_i");
    
    Opal.def(self, '$to_s', $NilClass_to_s$15 = function $$to_s() {
      var self = this;

      return ""
    }, $NilClass_to_s$15.$$arity = 0);
    
    Opal.def(self, '$to_c', $NilClass_to_c$16 = function $$to_c() {
      var self = this;

      return $$($nesting, 'Complex').$new(0, 0)
    }, $NilClass_to_c$16.$$arity = 0);
    
    Opal.def(self, '$rationalize', $NilClass_rationalize$17 = function $$rationalize($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy($rb_gt(args.$length(), 1))) {
        self.$raise($$($nesting, 'ArgumentError'))};
      return self.$Rational(0, 1);
    }, $NilClass_rationalize$17.$$arity = -1);
    
    Opal.def(self, '$to_r', $NilClass_to_r$18 = function $$to_r() {
      var self = this;

      return self.$Rational(0, 1)
    }, $NilClass_to_r$18.$$arity = 0);
    return (Opal.def(self, '$instance_variables', $NilClass_instance_variables$19 = function $$instance_variables() {
      var self = this;

      return []
    }, $NilClass_instance_variables$19.$$arity = 0), nil) && 'instance_variables';
  })($nesting[0], null, $nesting);
  return Opal.const_set($nesting[0], 'NIL', nil);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/boolean"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $alias = Opal.alias, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send2 = Opal.send2;

  Opal.add_stubs(['$raise', '$name']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Boolean');

    var $nesting = [self].concat($parent_nesting), $Boolean___id__$2, $Boolean_$excl$3, $Boolean_$$4, $Boolean_$$5, $Boolean_$$6, $Boolean_$eq_eq$7, $Boolean_singleton_class$8, $Boolean_to_s$9, $Boolean_dup$10, $Boolean_clone$11, $Boolean_method_missing$12, $Boolean_respond_to_missing$ques$13;

    
    Opal.defineProperty(self.$$prototype, '$$is_boolean', true);
    
    var properties = ['$$class', '$$meta'];

    for (var i = 0; i < properties.length; i++) {
      Object.defineProperty(self.$$prototype, properties[i], {
        configurable: true,
        enumerable: false,
        get: function() {
          return this == true  ? Opal.TrueClass :
                 this == false ? Opal.FalseClass :
                                 Opal.Boolean;
        }
      });
    }

    Object.defineProperty(self.$$prototype, "$$id", {
      configurable: true,
      enumerable: false,
      get: function() {
        return this == true  ? 2 :
               this == false ? 0 :
                               nil;
      }
    });
  ;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$__id__', $Boolean___id__$2 = function $$__id__() {
      var self = this;

      return self.valueOf() ? 2 : 0;
    }, $Boolean___id__$2.$$arity = 0);
    $alias(self, "object_id", "__id__");
    
    Opal.def(self, '$!', $Boolean_$excl$3 = function() {
      var self = this;

      return self != true;
    }, $Boolean_$excl$3.$$arity = 0);
    
    Opal.def(self, '$&', $Boolean_$$4 = function(other) {
      var self = this;

      return (self == true) ? (other !== false && other !== nil) : false;
    }, $Boolean_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Boolean_$$5 = function(other) {
      var self = this;

      return (self == true) ? true : (other !== false && other !== nil);
    }, $Boolean_$$5.$$arity = 1);
    
    Opal.def(self, '$^', $Boolean_$$6 = function(other) {
      var self = this;

      return (self == true) ? (other === false || other === nil) : (other !== false && other !== nil);
    }, $Boolean_$$6.$$arity = 1);
    
    Opal.def(self, '$==', $Boolean_$eq_eq$7 = function(other) {
      var self = this;

      return (self == true) === other.valueOf();
    }, $Boolean_$eq_eq$7.$$arity = 1);
    $alias(self, "equal?", "==");
    $alias(self, "eql?", "==");
    
    Opal.def(self, '$singleton_class', $Boolean_singleton_class$8 = function $$singleton_class() {
      var self = this;

      return self.$$meta;
    }, $Boolean_singleton_class$8.$$arity = 0);
    
    Opal.def(self, '$to_s', $Boolean_to_s$9 = function $$to_s() {
      var self = this;

      return (self == true) ? 'true' : 'false';
    }, $Boolean_to_s$9.$$arity = 0);
    $alias(self, "inspect", "to_s");
    
    Opal.def(self, '$dup', $Boolean_dup$10 = function $$dup() {
      var self = this;

      return self
    }, $Boolean_dup$10.$$arity = 0);
    
    Opal.def(self, '$clone', $Boolean_clone$11 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Boolean_clone$11.$$arity = -1);
    
    Opal.def(self, '$method_missing', $Boolean_method_missing$12 = function $$method_missing(method, $a) {
      var $iter = $Boolean_method_missing$12.$$p, block = $iter || nil, $post_args, args, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Boolean_method_missing$12.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Boolean_method_missing$12.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      var body = self.$$class.$$prototype['$' + method];
      if ($truthy(typeof body !== 'undefined' && !body.$$stub)) {
      } else {
        $send2(self, Opal.find_super_dispatcher(self, 'method_missing', $Boolean_method_missing$12, false, true), 'method_missing', $zuper, $iter)
      };
      return Opal.send(self, body, args, block);
    }, $Boolean_method_missing$12.$$arity = -2);
    return (Opal.def(self, '$respond_to_missing?', $Boolean_respond_to_missing$ques$13 = function(method, _include_all) {
      var self = this;

      
      
      if (_include_all == null) {
        _include_all = false;
      };
      var body = self.$$class.$$prototype['$' + method];
      return typeof body !== 'undefined' && !body.$$stub;;
    }, $Boolean_respond_to_missing$ques$13.$$arity = -2), nil) && 'respond_to_missing?';
  })($nesting[0], Boolean, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'TrueClass');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Boolean'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'FalseClass');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'Boolean'), $nesting);
  Opal.const_set($nesting[0], 'TRUE', true);
  return Opal.const_set($nesting[0], 'FALSE', false);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/comparable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$>', '$<', '$===', '$raise', '$class', '$<=>', '$equal?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Comparable');

    var $nesting = [self].concat($parent_nesting), $Comparable_$eq_eq$1, $Comparable_$gt$2, $Comparable_$gt_eq$3, $Comparable_$lt$4, $Comparable_$lt_eq$5, $Comparable_between$ques$6, $Comparable_clamp$7, $case = nil;

    
    
    function normalize(what) {
      if (Opal.is_a(what, Opal.Integer)) { return what; }

      if ($rb_gt(what, 0)) { return 1; }
      if ($rb_lt(what, 0)) { return -1; }
      return 0;
    }

    function fail_comparison(lhs, rhs) {
      var class_name;
      (function() {$case = rhs;
    if (nil['$===']($case) || true['$===']($case) || false['$===']($case) || $$($nesting, 'Integer')['$===']($case) || $$($nesting, 'Float')['$===']($case)) {return class_name = rhs.$inspect();}
    else {return class_name = rhs.$$class;}})()
      self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((lhs).$class()) + " with " + (class_name) + " failed")
    }

    function cmp_or_fail(lhs, rhs) {
      var cmp = (lhs)['$<=>'](rhs);
      if ($falsy(cmp)) fail_comparison(lhs, rhs);
      return normalize(cmp);
    }
  ;
    
    Opal.def(self, '$==', $Comparable_$eq_eq$1 = function(other) {
      var self = this, cmp = nil;

      
      if ($truthy(self['$equal?'](other))) {
        return true};
      
      if (self["$<=>"] == Opal.Kernel["$<=>"]) {
        return false;
      }

      // check for infinite recursion
      if (self.$$comparable) {
        delete self.$$comparable;
        return false;
      }
    ;
      if ($truthy((cmp = self['$<=>'](other)))) {
      } else {
        return false
      };
      return normalize(cmp) == 0;;
    }, $Comparable_$eq_eq$1.$$arity = 1);
    
    Opal.def(self, '$>', $Comparable_$gt$2 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) > 0;
    }, $Comparable_$gt$2.$$arity = 1);
    
    Opal.def(self, '$>=', $Comparable_$gt_eq$3 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) >= 0;
    }, $Comparable_$gt_eq$3.$$arity = 1);
    
    Opal.def(self, '$<', $Comparable_$lt$4 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) < 0;
    }, $Comparable_$lt$4.$$arity = 1);
    
    Opal.def(self, '$<=', $Comparable_$lt_eq$5 = function(other) {
      var self = this;

      return cmp_or_fail(self, other) <= 0;
    }, $Comparable_$lt_eq$5.$$arity = 1);
    
    Opal.def(self, '$between?', $Comparable_between$ques$6 = function(min, max) {
      var self = this;

      
      if ($rb_lt(self, min)) {
        return false};
      if ($rb_gt(self, max)) {
        return false};
      return true;
    }, $Comparable_between$ques$6.$$arity = 2);
    return (Opal.def(self, '$clamp', $Comparable_clamp$7 = function $$clamp(min, max) {
      var self = this;

      
      
      if (max == null) {
        max = nil;
      };
      
      var c, excl;

      if (max === nil) {
        // We are dealing with a new Ruby 2.7 behaviour that we are able to
        // provide a single Range argument instead of 2 Comparables.

        if (!Opal.is_a(min, Opal.Range)) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (min.$class()) + " (expected Range)")
        }

        excl = min.excl;
        max = min.end;
        min = min.begin;

        if (max !== nil && excl) {
          self.$raise($$($nesting, 'ArgumentError'), "cannot clamp with an exclusive range")
        }
      }

      if (min !== nil && max !== nil && cmp_or_fail(min, max) > 0) {
        self.$raise($$($nesting, 'ArgumentError'), "min argument must be smaller than max argument")
      }

      if (min !== nil) {
        c = cmp_or_fail(self, min);

        if (c == 0) return self;
        if (c < 0) return min;
      }

      if (max !== nil) {
        c = cmp_or_fail(self, max);

        if (c > 0) return max;
      }

      return self;
    ;
    }, $Comparable_clamp$7.$$arity = -2), nil) && 'clamp';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/regexp"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send2 = Opal.send2, $truthy = Opal.truthy, $gvars = Opal.gvars, $alias = Opal.alias, $send = Opal.send;

  Opal.add_stubs(['$nil?', '$[]', '$raise', '$escape', '$options', '$to_str', '$new', '$join', '$coerce_to!', '$!', '$match', '$coerce_to?', '$begin', '$uniq', '$map', '$scan', '$source', '$to_proc', '$transform_values', '$group_by', '$each_with_index', '$+', '$last', '$=~', '$attr_reader', '$include?', '$names', '$regexp', '$named_captures', '$===', '$captures', '$-', '$inspect', '$empty?', '$each', '$to_a']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'RegexpError');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $$($nesting, 'StandardError'), $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Regexp');

    var $nesting = [self].concat($parent_nesting), $Regexp_$eq_eq$6, $Regexp_$eq_eq_eq$7, $Regexp_$eq_tilde$8, $Regexp_inspect$9, $Regexp_match$10, $Regexp_match$ques$11, $Regexp_names$12, $Regexp_named_captures$13, $Regexp_$$16, $Regexp_source$17, $Regexp_options$18, $Regexp_casefold$ques$19;

    
    Opal.const_set($nesting[0], 'IGNORECASE', 1);
    Opal.const_set($nesting[0], 'EXTENDED', 2);
    Opal.const_set($nesting[0], 'MULTILINE', 4);
    Opal.defineProperty(self.$$prototype, '$$is_regexp', true);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1, $escape$2, $last_match$3, $union$4, $new$5;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var $iter = $allocate$1.$$p, $yield = $iter || nil, self = this, allocated = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

        if ($iter) $allocate$1.$$p = null;
        // Prepare super implicit arguments
        for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
          $zuper[$zuper_i] = arguments[$zuper_i];
        }
        
        allocated = $send2(self, Opal.find_super_dispatcher(self, 'allocate', $allocate$1, false, true), 'allocate', $zuper, $iter);
        allocated.uninitialized = true;
        return allocated;
      }, $allocate$1.$$arity = 0);
      
      Opal.def(self, '$escape', $escape$2 = function $$escape(string) {
        var self = this;

        return Opal.escape_regexp(string);
      }, $escape$2.$$arity = 1);
      
      Opal.def(self, '$last_match', $last_match$3 = function $$last_match(n) {
        var self = this;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        
        if (n == null) {
          n = nil;
        };
        if ($truthy(n['$nil?']())) {
          return $gvars["~"]
        } else {
          return $gvars["~"]['$[]'](n)
        };
      }, $last_match$3.$$arity = -1);
      $alias(self, "quote", "escape");
      
      Opal.def(self, '$union', $union$4 = function $$union($a) {
        var $post_args, parts, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        parts = $post_args;;
        
        var is_first_part_array, quoted_validated, part, options, each_part_options;
        if (parts.length == 0) {
          return /(?!)/;
        }
        // return fast if there's only one element
        if (parts.length == 1 && parts[0].$$is_regexp) {
          return parts[0];
        }
        // cover the 2 arrays passed as arguments case
        is_first_part_array = parts[0].$$is_array;
        if (parts.length > 1 && is_first_part_array) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion of Array into String")
        }
        // deal with splat issues (related to https://github.com/opal/opal/issues/858)
        if (is_first_part_array) {
          parts = parts[0];
        }
        options = undefined;
        quoted_validated = [];
        for (var i=0; i < parts.length; i++) {
          part = parts[i];
          if (part.$$is_string) {
            quoted_validated.push(self.$escape(part));
          }
          else if (part.$$is_regexp) {
            each_part_options = (part).$options();
            if (options != undefined && options != each_part_options) {
              self.$raise($$($nesting, 'TypeError'), "All expressions must use the same options")
            }
            options = each_part_options;
            quoted_validated.push('('+part.source+')');
          }
          else {
            quoted_validated.push(self.$escape((part).$to_str()));
          }
        }
      ;
        return self.$new((quoted_validated).$join("|"), options);
      }, $union$4.$$arity = -1);
      
      Opal.def(self, '$new', $new$5 = function(regexp, options) {
        var self = this;

        
        ;
        
        if (regexp.$$is_regexp) {
          return new RegExp(regexp);
        }

        regexp = $$($nesting, 'Opal')['$coerce_to!'](regexp, $$($nesting, 'String'), "to_str");

        if (regexp.charAt(regexp.length - 1) === '\\' && regexp.charAt(regexp.length - 2) !== '\\') {
          self.$raise($$($nesting, 'RegexpError'), "" + "too short escape sequence: /" + (regexp) + "/")
        }

        if (options === undefined || options['$!']()) {
          return new RegExp(regexp);
        }

        if (options.$$is_number) {
          var temp = '';
          if ($$($nesting, 'IGNORECASE') & options) { temp += 'i'; }
          if ($$($nesting, 'MULTILINE')  & options) { temp += 'm'; }
          options = temp;
        }
        else {
          options = 'i';
        }

        return new RegExp(regexp, options);
      ;
      }, $new$5.$$arity = -2);
      return $alias(self, "compile", "new");
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$==', $Regexp_$eq_eq$6 = function(other) {
      var self = this;

      return other instanceof RegExp && self.toString() === other.toString();
    }, $Regexp_$eq_eq$6.$$arity = 1);
    
    Opal.def(self, '$===', $Regexp_$eq_eq_eq$7 = function(string) {
      var self = this;

      return self.$match($$($nesting, 'Opal')['$coerce_to?'](string, $$($nesting, 'String'), "to_str")) !== nil
    }, $Regexp_$eq_eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$=~', $Regexp_$eq_tilde$8 = function(string) {
      var self = this, $ret_or_1 = nil;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($truthy(($ret_or_1 = self.$match(string)))) {
        return $gvars["~"].$begin(0)
      } else {
        return $ret_or_1
      }
    }, $Regexp_$eq_tilde$8.$$arity = 1);
    $alias(self, "eql?", "==");
    
    Opal.def(self, '$inspect', $Regexp_inspect$9 = function $$inspect() {
      var self = this;

      
      var regexp_format = /^\/(.*)\/([^\/]*)$/;
      var value = self.toString();
      var matches = regexp_format.exec(value);
      if (matches) {
        var regexp_pattern = matches[1];
        var regexp_flags = matches[2];
        var chars = regexp_pattern.split('');
        var chars_length = chars.length;
        var char_escaped = false;
        var regexp_pattern_escaped = '';
        for (var i = 0; i < chars_length; i++) {
          var current_char = chars[i];
          if (!char_escaped && current_char == '/') {
            regexp_pattern_escaped = regexp_pattern_escaped.concat('\\');
          }
          regexp_pattern_escaped = regexp_pattern_escaped.concat(current_char);
          if (current_char == '\\') {
            if (char_escaped) {
              // does not over escape
              char_escaped = false;
            } else {
              char_escaped = true;
            }
          } else {
            char_escaped = false;
          }
        }
        return '/' + regexp_pattern_escaped + '/' + regexp_flags;
      } else {
        return value;
      }
    
    }, $Regexp_inspect$9.$$arity = 0);
    
    Opal.def(self, '$match', $Regexp_match$10 = function $$match(string, pos) {
      var $iter = $Regexp_match$10.$$p, block = $iter || nil, self = this;
      if ($gvars["~"] == null) $gvars["~"] = nil;

      if ($iter) $Regexp_match$10.$$p = null;
      
      
      if ($iter) $Regexp_match$10.$$p = null;;
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        if (string === nil) return ($gvars["~"] = nil);
        var m = self.exec($coerce_to(string, $$($nesting, 'String'), 'to_str'));
        if (m) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(self, m));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        } else {
          return ($gvars["~"] = nil);
        }
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return ($gvars["~"] = nil);
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return ($gvars["~"] = nil);
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      while (true) {
        md = re.exec(string);
        if (md === null) {
          return ($gvars["~"] = nil);
        }
        if (md.index >= pos) {
          ($gvars["~"] = $$($nesting, 'MatchData').$new(re, md));
          return block === nil ? $gvars["~"] : Opal.yield1(block, $gvars["~"]);
        }
        re.lastIndex = md.index + 1;
      }
    ;
    }, $Regexp_match$10.$$arity = -2);
    
    Opal.def(self, '$match?', $Regexp_match$ques$11 = function(string, pos) {
      var self = this;

      
      ;
      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }

      if (pos === undefined) {
        return string === nil ? false : self.test($coerce_to(string, $$($nesting, 'String'), 'to_str'));
      }

      pos = $coerce_to(pos, $$($nesting, 'Integer'), 'to_int');

      if (string === nil) {
        return false;
      }

      string = $coerce_to(string, $$($nesting, 'String'), 'to_str');

      if (pos < 0) {
        pos += string.length;
        if (pos < 0) {
          return false;
        }
      }

      // global RegExp maintains state, so not using self/this
      var md, re = Opal.global_regexp(self);

      md = re.exec(string);
      if (md === null || md.index < pos) {
        return false;
      } else {
        return true;
      }
    ;
    }, $Regexp_match$ques$11.$$arity = -2);
    
    Opal.def(self, '$names', $Regexp_names$12 = function $$names() {
      var self = this;

      return $send(self.$source().$scan(/\(?<(\w+)>/), 'map', [], "first".$to_proc()).$uniq()
    }, $Regexp_names$12.$$arity = 0);
    
    Opal.def(self, '$named_captures', $Regexp_named_captures$13 = function $$named_captures() {
      var $$14, self = this;

      return $send($send($send(self.$source().$scan(/\(?<(\w+)>/), 'map', [], "first".$to_proc()).$each_with_index(), 'group_by', [], "first".$to_proc()), 'transform_values', [], ($$14 = function(i){var self = $$14.$$s == null ? this : $$14.$$s, $$15;

        
        
        if (i == null) {
          i = nil;
        };
        return $send(i, 'map', [], ($$15 = function(j){var self = $$15.$$s == null ? this : $$15.$$s;

          
          
          if (j == null) {
            j = nil;
          };
          return $rb_plus(j.$last(), 1);}, $$15.$$s = self, $$15.$$arity = 1, $$15));}, $$14.$$s = self, $$14.$$arity = 1, $$14))
    }, $Regexp_named_captures$13.$$arity = 0);
    
    Opal.def(self, '$~', $Regexp_$$16 = function() {
      var self = this;
      if ($gvars._ == null) $gvars._ = nil;

      return self['$=~']($gvars._)
    }, $Regexp_$$16.$$arity = 0);
    
    Opal.def(self, '$source', $Regexp_source$17 = function $$source() {
      var self = this;

      return self.source;
    }, $Regexp_source$17.$$arity = 0);
    
    Opal.def(self, '$options', $Regexp_options$18 = function $$options() {
      var self = this;

      
      if (self.uninitialized) {
        self.$raise($$($nesting, 'TypeError'), "uninitialized Regexp")
      }
      var result = 0;
      // should be supported in IE6 according to https://msdn.microsoft.com/en-us/library/7f5z26w4(v=vs.94).aspx
      if (self.multiline) {
        result |= $$($nesting, 'MULTILINE');
      }
      if (self.ignoreCase) {
        result |= $$($nesting, 'IGNORECASE');
      }
      return result;
    
    }, $Regexp_options$18.$$arity = 0);
    
    Opal.def(self, '$casefold?', $Regexp_casefold$ques$19 = function() {
      var self = this;

      return self.ignoreCase;
    }, $Regexp_casefold$ques$19.$$arity = 0);
    return $alias(self, "to_s", "source");
  })($nesting[0], RegExp, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'MatchData');

    var $nesting = [self].concat($parent_nesting), $MatchData_initialize$20, $MatchData_$$$21, $MatchData_offset$22, $MatchData_$eq_eq$23, $MatchData_begin$24, $MatchData_end$25, $MatchData_captures$26, $MatchData_named_captures$27, $MatchData_names$29, $MatchData_inspect$30, $MatchData_length$32, $MatchData_to_a$33, $MatchData_to_s$34, $MatchData_values_at$35;

    self.$$prototype.matches = nil;
    
    self.$attr_reader("post_match", "pre_match", "regexp", "string");
    
    Opal.def(self, '$initialize', $MatchData_initialize$20 = function $$initialize(regexp, match_groups) {
      var self = this;

      
      $gvars["~"] = self;
      self.regexp = regexp;
      self.begin = match_groups.index;
      self.string = match_groups.input;
      self.pre_match = match_groups.input.slice(0, match_groups.index);
      self.post_match = match_groups.input.slice(match_groups.index + match_groups[0].length);
      self.matches = [];
      
      for (var i = 0, length = match_groups.length; i < length; i++) {
        var group = match_groups[i];

        if (group == null) {
          self.matches.push(nil);
        }
        else {
          self.matches.push(group);
        }
      }
    ;
    }, $MatchData_initialize$20.$$arity = 2);
    
    Opal.def(self, '$[]', $MatchData_$$$21 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (args[0].$$is_string) {
        if (self.$regexp().$names()['$include?'](args['$[]'](0))['$!']()) {
          self.$raise($$($nesting, 'IndexError'), "" + "undefined group name reference: " + (args['$[]'](0)))
        }
        return self.$named_captures()['$[]'](args['$[]'](0))
      }
      else {
        return $send(self.matches, '[]', Opal.to_a(args))
      }
    ;
    }, $MatchData_$$$21.$$arity = -1);
    
    Opal.def(self, '$offset', $MatchData_offset$22 = function $$offset(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#offset only supports 0th element")
      }
      return [self.begin, self.begin + self.matches[n].length];
    
    }, $MatchData_offset$22.$$arity = 1);
    
    Opal.def(self, '$==', $MatchData_$eq_eq$23 = function(other) {
      var self = this, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil;

      
      if ($truthy($$($nesting, 'MatchData')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = self.string == other.string))) {
        return self.regexp.toString() == other.regexp.toString();
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return self.pre_match == other.pre_match;
      } else {
        return $ret_or_4
      }; return nil; })()))) {
        return self.post_match == other.post_match;
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return self.begin == other.begin;
      } else {
        return $ret_or_2
      };
    }, $MatchData_$eq_eq$23.$$arity = 1);
    $alias(self, "eql?", "==");
    
    Opal.def(self, '$begin', $MatchData_begin$24 = function $$begin(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#begin only supports 0th element")
      }
      return self.begin;
    
    }, $MatchData_begin$24.$$arity = 1);
    
    Opal.def(self, '$end', $MatchData_end$25 = function $$end(n) {
      var self = this;

      
      if (n !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "MatchData#end only supports 0th element")
      }
      return self.begin + self.matches[n].length;
    
    }, $MatchData_end$25.$$arity = 1);
    
    Opal.def(self, '$captures', $MatchData_captures$26 = function $$captures() {
      var self = this;

      return self.matches.slice(1)
    }, $MatchData_captures$26.$$arity = 0);
    
    Opal.def(self, '$named_captures', $MatchData_named_captures$27 = function $$named_captures() {
      var $$28, self = this, matches = nil;

      
      matches = self.$captures();
      return $send(self.$regexp().$named_captures(), 'transform_values', [], ($$28 = function(i){var self = $$28.$$s == null ? this : $$28.$$s;

        
        
        if (i == null) {
          i = nil;
        };
        return matches['$[]']($rb_minus(i.$last(), 1));}, $$28.$$s = self, $$28.$$arity = 1, $$28));
    }, $MatchData_named_captures$27.$$arity = 0);
    
    Opal.def(self, '$names', $MatchData_names$29 = function $$names() {
      var self = this;

      return self.$regexp().$names()
    }, $MatchData_names$29.$$arity = 0);
    
    Opal.def(self, '$inspect', $MatchData_inspect$30 = function $$inspect() {
      var $$31, self = this;

      
      var str = "#<MatchData " + (self.matches[0]).$inspect();

      if (self.$regexp().$names()['$empty?']()) {
        for (var i = 1, length = self.matches.length; i < length; i++) {
          str += " " + i + ":" + (self.matches[i]).$inspect();
        }
      }
      else {
        $send(self.$named_captures(), 'each', [], ($$31 = function(k, v){var self = $$31.$$s == null ? this : $$31.$$s;

        
        
        if (k == null) {
          k = nil;
        };
        
        if (v == null) {
          v = nil;
        };
        return                str += " " + k + ":" + v.$inspect();}, $$31.$$s = self, $$31.$$arity = 2, $$31))
      }

      return str + ">";
    
    }, $MatchData_inspect$30.$$arity = 0);
    
    Opal.def(self, '$length', $MatchData_length$32 = function $$length() {
      var self = this;

      return self.matches.length
    }, $MatchData_length$32.$$arity = 0);
    $alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $MatchData_to_a$33 = function $$to_a() {
      var self = this;

      return self.matches
    }, $MatchData_to_a$33.$$arity = 0);
    
    Opal.def(self, '$to_s', $MatchData_to_s$34 = function $$to_s() {
      var self = this;

      return self.matches[0]
    }, $MatchData_to_s$34.$$arity = 0);
    return (Opal.def(self, '$values_at', $MatchData_values_at$35 = function $$values_at($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var i, a, index, values = [];

      for (i = 0; i < args.length; i++) {

        if (args[i].$$is_range) {
          a = (args[i]).$to_a();
          a.unshift(i, 1);
          Array.prototype.splice.apply(args, a);
        }

        index = $$($nesting, 'Opal')['$coerce_to!'](args[i], $$($nesting, 'Integer'), "to_int");

        if (index < 0) {
          index += self.matches.length;
          if (index < 0) {
            values.push(nil);
            continue;
          }
        }

        values.push(self.matches[index]);
      }

      return values;
    ;
    }, $MatchData_values_at$35.$$arity = -1), nil) && 'values_at';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/string"] = function(Opal) {
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $alias = Opal.alias, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $gvars = Opal.gvars;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$initialize', '$===', '$format', '$raise', '$respond_to?', '$to_s', '$to_str', '$<=>', '$==', '$=~', '$new', '$force_encoding', '$casecmp', '$empty?', '$ljust', '$ceil', '$/', '$+', '$rjust', '$floor', '$coerce_to!', '$copy_singleton_methods', '$initialize_clone', '$initialize_dup', '$enum_for', '$chomp', '$[]', '$to_i', '$each_line', '$to_proc', '$to_a', '$class', '$match', '$match?', '$captures', '$proc', '$succ', '$escape', '$include?', '$upcase', '$unicode_normalize', '$pristine']);
  
  self.$require("corelib/comparable");
  self.$require("corelib/regexp");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String___id__$1, $String_try_convert$2, $String_new$3, $String_initialize$4, $String_$percent$5, $String_$$6, $String_$plus$7, $String_$lt_eq_gt$8, $String_$eq_eq$9, $String_$eq_tilde$10, $String_$$$11, $String_b$12, $String_capitalize$13, $String_casecmp$14, $String_casecmp$ques$15, $String_center$16, $String_chomp$17, $String_chop$18, $String_chr$19, $String_clone$20, $String_dup$21, $String_count$22, $String_delete$23, $String_delete_prefix$24, $String_delete_suffix$25, $String_downcase$26, $String_each_line$27, $String_empty$ques$28, $String_end_with$ques$29, $String_gsub$30, $String_hash$31, $String_hex$32, $String_include$ques$33, $String_index$34, $String_inspect$35, $String_intern$36, $String_lines$37, $String_ljust$38, $String_lstrip$39, $String_ascii_only$ques$40, $String_match$41, $String_match$ques$42, $String_next$43, $String_oct$44, $String_ord$45, $String_partition$46, $String_reverse$47, $String_rindex$48, $String_rjust$49, $String_rpartition$50, $String_rstrip$51, $String_scan$52, $String_split$53, $String_squeeze$54, $String_start_with$ques$55, $String_strip$56, $String_sub$57, $String_sum$58, $String_swapcase$59, $String_to_f$60, $String_to_i$61, $String_to_proc$62, $String_to_s$64, $String_tr$65, $String_tr_s$66, $String_upcase$67, $String_upto$68, $String_instance_variables$69, $String__load$70, $String_unicode_normalize$71, $String_unicode_normalized$ques$72, $String_unpack$73, $String_unpack1$74, $String_freeze$75, $String_$minus$$76, $String_frozen$ques$77;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.defineProperty(self.$$prototype, '$$is_string', true);

    Opal.defineProperty(self.$$prototype, '$$cast', function(string) {
      var klass = this.$$class;
      if (klass.$$constructor === String) {
        return string;
      } else {
        return new klass.$$constructor(string);
      }
    });
  ;
    
    Opal.def(self, '$__id__', $String___id__$1 = function $$__id__() {
      var self = this;

      return self.toString();
    }, $String___id__$1.$$arity = 0);
    $alias(self, "object_id", "__id__");
    Opal.defs(self, '$try_convert', $String_try_convert$2 = function $$try_convert(what) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](what, $$($nesting, 'String'), "to_str")
    }, $String_try_convert$2.$$arity = 1);
    Opal.defs(self, '$new', $String_new$3 = function($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var str = args[0] || "";
      var opts = args[args.length-1];
      str = $coerce_to(str, $$($nesting, 'String'), 'to_str');
      if (opts && opts.$$is_hash) {
        if (opts.$$smap.encoding) str = str.$force_encoding(opts.$$smap.encoding);
      }
      str = new self.$$constructor(str);
      if (!str.$initialize.$$pristine) $send((str), 'initialize', Opal.to_a(args));
      return str;
    ;
    }, $String_new$3.$$arity = -1);
    
    Opal.def(self, '$initialize', $String_initialize$4 = function $$initialize($a, $b) {
      var $post_args, $kwargs, str, encoding, capacity, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        str = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      encoding = $kwargs.$$smap["encoding"];
      if (encoding == null) {
        encoding = nil
      };
      
      capacity = $kwargs.$$smap["capacity"];
      if (capacity == null) {
        capacity = nil
      };
      return nil;
    }, $String_initialize$4.$$arity = -1);
    
    Opal.def(self, '$%', $String_$percent$5 = function(data) {
      var self = this;

      if ($truthy($$($nesting, 'Array')['$==='](data))) {
        return $send(self, 'format', [self].concat(Opal.to_a(data)))
      } else {
        return self.$format(self, data)
      }
    }, $String_$percent$5.$$arity = 1);
    
    Opal.def(self, '$*', $String_$$6 = function(count) {
      var self = this;

      
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")
      }

      if (count === 0) {
        return self.$$cast('');
      }

      var result = '',
          string = self.toString();

      // All credit for the bit-twiddling magic code below goes to Mozilla
      // polyfill implementation of String.prototype.repeat() posted here:
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat

      if (string.length * count >= 1 << 28) {
        self.$raise($$($nesting, 'RangeError'), "multiply count must not overflow maximum string size")
      }

      for (;;) {
        if ((count & 1) === 1) {
          result += string;
        }
        count >>>= 1;
        if (count === 0) {
          break;
        }
        string += string;
      }

      return self.$$cast(result);
    
    }, $String_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $String_$plus$7 = function(other) {
      var self = this;

      
      other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      
      if (other == "" && self.$$class === Opal.String) return self;
      if (self == "" && other.$$class === Opal.String) return other;
      var out = self + other;
      if (self.encoding === out.encoding && other.encoding === out.encoding) return out;
      if (self.encoding.name === "UTF-8" || other.encoding.name === "UTF-8") return out;
      return Opal.enc(out, self.encoding);
    ;
    }, $String_$plus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $String_$lt_eq_gt$8 = function(other) {
      var self = this;

      if ($truthy(other['$respond_to?']("to_str"))) {
        
        other = other.$to_str().$to_s();
        return self > other ? 1 : (self < other ? -1 : 0);;
      } else {
        
        var cmp = other['$<=>'](self);

        if (cmp === nil) {
          return nil;
        }
        else {
          return cmp > 0 ? -1 : (cmp < 0 ? 1 : 0);
        }
      
      }
    }, $String_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $String_$eq_eq$9 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        return self.toString() === other.toString();
      }
      if ($respond_to(other, '$to_str')) {
        return other['$=='](self);
      }
      return false;
    
    }, $String_$eq_eq$9.$$arity = 1);
    $alias(self, "eql?", "==");
    $alias(self, "===", "==");
    
    Opal.def(self, '$=~', $String_$eq_tilde$10 = function(other) {
      var self = this;

      
      if (other.$$is_string) {
        self.$raise($$($nesting, 'TypeError'), "type mismatch: String given");
      }

      return other['$=~'](self);
    
    }, $String_$eq_tilde$10.$$arity = 1);
    
    Opal.def(self, '$[]', $String_$$$11 = function(index, length) {
      var self = this;

      
      ;
      
      var size = self.length, exclude;

      if (index.$$is_range) {
        exclude = index.excl;
        length  = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');
        index   = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int');

        if (Math.abs(index) > size) {
          return nil;
        }

        if (index < 0) {
          index += size;
        }

        if (length < 0) {
          length += size;
        }

        if (!exclude) {
          length += 1;
        }

        length = length - index;

        if (length < 0) {
          length = 0;
        }

        return self.$$cast(self.substr(index, length));
      }


      if (index.$$is_string) {
        if (length != null) {
          self.$raise($$($nesting, 'TypeError'))
        }
        return self.indexOf(index) !== -1 ? self.$$cast(index) : nil;
      }


      if (index.$$is_regexp) {
        var match = self.match(index);

        if (match === null) {
          ($gvars["~"] = nil)
          return nil;
        }

        ($gvars["~"] = $$($nesting, 'MatchData').$new(index, match))

        if (length == null) {
          return self.$$cast(match[0]);
        }

        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (length < 0 && -length < match.length) {
          return self.$$cast(match[length += match.length]);
        }

        if (length >= 0 && length < match.length) {
          return self.$$cast(match[length]);
        }

        return nil;
      }


      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += size;
      }

      if (length == null) {
        if (index >= size || index < 0) {
          return nil;
        }
        return self.$$cast(self.substr(index, 1));
      }

      length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

      if (length < 0) {
        return nil;
      }

      if (index > size || index < 0) {
        return nil;
      }

      return self.$$cast(self.substr(index, length));
    ;
    }, $String_$$$11.$$arity = -2);
    $alias(self, "byteslice", "[]");
    
    Opal.def(self, '$b', $String_b$12 = function $$b() {
      var self = this;

      return (new String(self)).$force_encoding("binary")
    }, $String_b$12.$$arity = 0);
    
    Opal.def(self, '$capitalize', $String_capitalize$13 = function $$capitalize() {
      var self = this;

      return self.$$cast(self.charAt(0).toUpperCase() + self.substr(1).toLowerCase());
    }, $String_capitalize$13.$$arity = 0);
    
    Opal.def(self, '$casecmp', $String_casecmp$14 = function $$casecmp(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
      } else {
        return nil
      };
      other = ($coerce_to(other, $$($nesting, 'String'), 'to_str')).$to_s();
      
      var ascii_only = /^[\x00-\x7F]*$/;
      if (ascii_only.test(self) && ascii_only.test(other)) {
        self = self.toLowerCase();
        other = other.toLowerCase();
      }
    ;
      return self['$<=>'](other);
    }, $String_casecmp$14.$$arity = 1);
    
    Opal.def(self, '$casecmp?', $String_casecmp$ques$15 = function(other) {
      var self = this;

      
      var cmp = self.$casecmp(other);
      if (cmp === nil) {
        return nil;
      } else {
        return cmp === 0;
      }
    
    }, $String_casecmp$ques$15.$$arity = 1);
    
    Opal.def(self, '$center', $String_center$16 = function $$center(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var ljustified = self.$ljust($rb_divide($rb_plus(width, self.length), 2).$ceil(), padstr),
          rjustified = self.$rjust($rb_divide($rb_plus(width, self.length), 2).$floor(), padstr);

      return self.$$cast(rjustified + ljustified.slice(self.length));
    ;
    }, $String_center$16.$$arity = -2);
    
    Opal.def(self, '$chomp', $String_chomp$17 = function $$chomp(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ($truthy(separator === nil || self.length === 0)) {
        return self};
      separator = $$($nesting, 'Opal')['$coerce_to!'](separator, $$($nesting, 'String'), "to_str").$to_s();
      
      var result;

      if (separator === "\n") {
        result = self.replace(/\r?\n?$/, '');
      }
      else if (separator === "") {
        result = self.replace(/(\r?\n)+$/, '');
      }
      else if (self.length >= separator.length) {
        var tail = self.substr(self.length - separator.length, separator.length);

        if (tail === separator) {
          result = self.substr(0, self.length - separator.length);
        }
      }

      if (result != null) {
        return self.$$cast(result);
      }
    ;
      return self;
    }, $String_chomp$17.$$arity = -1);
    
    Opal.def(self, '$chop', $String_chop$18 = function $$chop() {
      var self = this;

      
      var length = self.length, result;

      if (length <= 1) {
        result = "";
      } else if (self.charAt(length - 1) === "\n" && self.charAt(length - 2) === "\r") {
        result = self.substr(0, length - 2);
      } else {
        result = self.substr(0, length - 1);
      }

      return self.$$cast(result);
    
    }, $String_chop$18.$$arity = 0);
    
    Opal.def(self, '$chr', $String_chr$19 = function $$chr() {
      var self = this;

      return self.charAt(0);
    }, $String_chr$19.$$arity = 0);
    
    Opal.def(self, '$clone', $String_clone$20 = function $$clone() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$copy_singleton_methods(self);
      copy.$initialize_clone(self);
      return copy;
    }, $String_clone$20.$$arity = 0);
    
    Opal.def(self, '$dup', $String_dup$21 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new String(self);
      copy.$initialize_dup(self);
      return copy;
    }, $String_dup$21.$$arity = 0);
    
    Opal.def(self, '$count', $String_count$22 = function $$count($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return 0;
      }
      return self.length - self.replace(new RegExp(char_class, 'g'), '').length;
    ;
    }, $String_count$22.$$arity = -1);
    
    Opal.def(self, '$delete', $String_delete$23 = function($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        self.$raise($$($nesting, 'ArgumentError'), "ArgumentError: wrong number of arguments (0 for 1+)")
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp(char_class, 'g'), ''));
    ;
    }, $String_delete$23.$$arity = -1);
    
    Opal.def(self, '$delete_prefix', $String_delete_prefix$24 = function $$delete_prefix(prefix) {
      var self = this;

      
      if (!prefix.$$is_string) {
        prefix = $coerce_to(prefix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(0, prefix.length) === prefix) {
        return self.$$cast(self.slice(prefix.length));
      } else {
        return self;
      }
    
    }, $String_delete_prefix$24.$$arity = 1);
    
    Opal.def(self, '$delete_suffix', $String_delete_suffix$25 = function $$delete_suffix(suffix) {
      var self = this;

      
      if (!suffix.$$is_string) {
        suffix = $coerce_to(suffix, $$($nesting, 'String'), 'to_str');
      }

      if (self.slice(self.length - suffix.length) === suffix) {
        return self.$$cast(self.slice(0, self.length - suffix.length));
      } else {
        return self;
      }
    
    }, $String_delete_suffix$25.$$arity = 1);
    
    Opal.def(self, '$downcase', $String_downcase$26 = function $$downcase() {
      var self = this;

      return self.$$cast(self.toLowerCase());
    }, $String_downcase$26.$$arity = 0);
    
    Opal.def(self, '$each_line', $String_each_line$27 = function $$each_line(separator) {
      var $iter = $String_each_line$27.$$p, block = $iter || nil, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_each_line$27.$$p = null;
      
      
      if ($iter) $String_each_line$27.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_line", separator)
      };
      
      if (separator === nil) {
        Opal.yield1(block, self);

        return self;
      }

      separator = $coerce_to(separator, $$($nesting, 'String'), 'to_str')

      var a, i, n, length, chomped, trailing, splitted;

      if (separator.length === 0) {
        for (a = self.split(/(\n{2,})/), i = 0, n = a.length; i < n; i += 2) {
          if (a[i] || a[i + 1]) {
            var value = (a[i] || "") + (a[i + 1] || "");
            Opal.yield1(block, self.$$cast(value));
          }
        }

        return self;
      }

      chomped  = self.$chomp(separator);
      trailing = self.length != chomped.length;
      splitted = chomped.split(separator);

      for (i = 0, length = splitted.length; i < length; i++) {
        if (i < length - 1 || trailing) {
          Opal.yield1(block, self.$$cast(splitted[i] + separator));
        }
        else {
          Opal.yield1(block, self.$$cast(splitted[i]));
        }
      }
    ;
      return self;
    }, $String_each_line$27.$$arity = -1);
    
    Opal.def(self, '$empty?', $String_empty$ques$28 = function() {
      var self = this;

      return self.length === 0;
    }, $String_empty$ques$28.$$arity = 0);
    
    Opal.def(self, '$end_with?', $String_end_with$ques$29 = function($a) {
      var $post_args, suffixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      suffixes = $post_args;;
      
      for (var i = 0, length = suffixes.length; i < length; i++) {
        var suffix = $coerce_to(suffixes[i], $$($nesting, 'String'), 'to_str').$to_s();

        if (self.length >= suffix.length &&
            self.substr(self.length - suffix.length, suffix.length) == suffix) {
          return true;
        }
      }
    ;
      return false;
    }, $String_end_with$ques$29.$$arity = -1);
    $alias(self, "equal?", "===");
    
    Opal.def(self, '$gsub', $String_gsub$30 = function $$gsub(pattern, replacement) {
      var $iter = $String_gsub$30.$$p, block = $iter || nil, self = this;

      if ($iter) $String_gsub$30.$$p = null;
      
      
      if ($iter) $String_gsub$30.$$p = null;;
      ;
      
      if (replacement === undefined && block === nil) {
        return self.$enum_for("gsub", pattern);
      }

      var result = '', match_data = nil, index = 0, match, _replacement;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      var lastIndex;
      while (true) {
        match = pattern.exec(self);

        if (match === null) {
          ($gvars["~"] = nil)
          result += self.slice(index);
          break;
        }

        match_data = $$($nesting, 'MatchData').$new(pattern, match);

        if (replacement === undefined) {
          lastIndex = pattern.lastIndex;
          _replacement = block(match[0]);
          pattern.lastIndex = lastIndex; // save and restore lastIndex
        }
        else if (replacement.$$is_hash) {
          _replacement = (replacement)['$[]'](match[0]).$to_s();
        }
        else {
          if (!replacement.$$is_string) {
            replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');
          }
          _replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');
        }

        if (pattern.lastIndex === match.index) {
          result += (self.slice(index, match.index) + _replacement + (self[match.index] || ""));
          pattern.lastIndex += 1;
        }
        else {
          result += (self.slice(index, match.index) + _replacement)
        }
        index = pattern.lastIndex;
      }

      ($gvars["~"] = match_data)
      return self.$$cast(result);
    ;
    }, $String_gsub$30.$$arity = -2);
    
    Opal.def(self, '$hash', $String_hash$31 = function $$hash() {
      var self = this;

      return self.toString();
    }, $String_hash$31.$$arity = 0);
    
    Opal.def(self, '$hex', $String_hex$32 = function $$hex() {
      var self = this;

      return self.$to_i(16)
    }, $String_hex$32.$$arity = 0);
    
    Opal.def(self, '$include?', $String_include$ques$33 = function(other) {
      var self = this;

      
      if (!other.$$is_string) {
        other = $coerce_to(other, $$($nesting, 'String'), 'to_str');
      }
      return self.indexOf(other) !== -1;
    
    }, $String_include$ques$33.$$arity = 1);
    
    Opal.def(self, '$index', $String_index$34 = function $$index(search, offset) {
      var self = this;

      
      ;
      
      var index,
          match,
          regex;

      if (offset === undefined) {
        offset = 0;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        regex = Opal.global_multiline_regexp(search);
        while (true) {
          match = regex.exec(self);
          if (match === null) {
            ($gvars["~"] = nil);
            index = -1;
            break;
          }
          if (match.index >= offset) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regex, match))
            index = match.index;
            break;
          }
          regex.lastIndex = match.index + 1;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        if (search.length === 0 && offset > self.length) {
          index = -1;
        } else {
          index = self.indexOf(search, offset);
        }
      }

      return index === -1 ? nil : index;
    ;
    }, $String_index$34.$$arity = -2);
    
    Opal.def(self, '$inspect', $String_inspect$35 = function $$inspect() {
      var self = this;

      
      /* eslint-disable no-misleading-character-class */
      var escapable = /[\\\"\x00-\x1f\u007F-\u009F\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
          meta = {
            '\u0007': '\\a',
            '\u001b': '\\e',
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '\v': '\\v',
            '"' : '\\"',
            '\\': '\\\\'
          },
          escaped = self.replace(escapable, function (chr) {
            if (meta[chr]) return meta[chr];
            chr = chr.charCodeAt(0);
            if (chr <= 0xff && (self.encoding["$binary?"]() || self.internal_encoding["$binary?"]())) {
              return '\\x' + ('00' + chr.toString(16).toUpperCase()).slice(-2);
            } else {
              return '\\u' + ('0000' + chr.toString(16).toUpperCase()).slice(-4);
            }
          });
      return '"' + escaped.replace(/\#[\$\@\{]/g, '\\$&') + '"';
      /* eslint-enable no-misleading-character-class */
    
    }, $String_inspect$35.$$arity = 0);
    
    Opal.def(self, '$intern', $String_intern$36 = function $$intern() {
      var self = this;

      return self.toString();
    }, $String_intern$36.$$arity = 0);
    
    Opal.def(self, '$lines', $String_lines$37 = function $$lines(separator) {
      var $iter = $String_lines$37.$$p, block = $iter || nil, self = this, e = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $String_lines$37.$$p = null;
      
      
      if ($iter) $String_lines$37.$$p = null;;
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      e = $send(self, 'each_line', [separator], block.$to_proc());
      if ($truthy(block)) {
        return self
      } else {
        return e.$to_a()
      };
    }, $String_lines$37.$$arity = -1);
    
    Opal.def(self, '$ljust', $String_ljust$38 = function $$ljust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var index  = -1,
          result = "";

      width -= self.length;

      while (++index < width) {
        result += padstr;
      }

      return self.$$cast(self + result.slice(0, width));
    ;
    }, $String_ljust$38.$$arity = -2);
    
    Opal.def(self, '$lstrip', $String_lstrip$39 = function $$lstrip() {
      var self = this;

      return self.replace(/^\s*/, '');
    }, $String_lstrip$39.$$arity = 0);
    
    Opal.def(self, '$ascii_only?', $String_ascii_only$ques$40 = function() {
      var self = this;

      
      if (!self.encoding.ascii) return false;
      return /^[\x00-\x7F]*$/.test(self);
    
    }, $String_ascii_only$ques$40.$$arity = 0);
    
    Opal.def(self, '$match', $String_match$41 = function $$match(pattern, pos) {
      var $iter = $String_match$41.$$p, block = $iter || nil, self = this, $ret_or_1 = nil;

      if ($iter) $String_match$41.$$p = null;
      
      
      if ($iter) $String_match$41.$$p = null;;
      ;
      if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_1
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return $send(pattern, 'match', [self, pos], block.$to_proc());
    }, $String_match$41.$$arity = -2);
    
    Opal.def(self, '$match?', $String_match$ques$42 = function(pattern, pos) {
      var self = this, $ret_or_2 = nil;

      
      ;
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'String')['$==='](pattern)))) {
        return $ret_or_2
      } else {
        return pattern['$respond_to?']("to_str")
      }; return nil; })())) {
        pattern = $$($nesting, 'Regexp').$new(pattern.$to_str())};
      if ($truthy($$($nesting, 'Regexp')['$==='](pattern))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + (pattern.$class()) + " (expected Regexp)")
      };
      return pattern['$match?'](self, pos);
    }, $String_match$ques$42.$$arity = -2);
    
    Opal.def(self, '$next', $String_next$43 = function $$next() {
      var self = this;

      
      var i = self.length;
      if (i === 0) {
        return self.$$cast('');
      }
      var result = self;
      var first_alphanum_char_index = self.search(/[a-zA-Z0-9]/);
      var carry = false;
      var code;
      while (i--) {
        code = self.charCodeAt(i);
        if ((code >= 48 && code <= 57) ||
          (code >= 65 && code <= 90) ||
          (code >= 97 && code <= 122)) {
          switch (code) {
          case 57:
            carry = true;
            code = 48;
            break;
          case 90:
            carry = true;
            code = 65;
            break;
          case 122:
            carry = true;
            code = 97;
            break;
          default:
            carry = false;
            code += 1;
          }
        } else {
          if (first_alphanum_char_index === -1) {
            if (code === 255) {
              carry = true;
              code = 0;
            } else {
              carry = false;
              code += 1;
            }
          } else {
            carry = true;
          }
        }
        result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i + 1);
        if (carry && (i === 0 || i === first_alphanum_char_index)) {
          switch (code) {
          case 65:
            break;
          case 97:
            break;
          default:
            code += 1;
          }
          if (i === 0) {
            result = String.fromCharCode(code) + result;
          } else {
            result = result.slice(0, i) + String.fromCharCode(code) + result.slice(i);
          }
          carry = false;
        }
        if (!carry) {
          break;
        }
      }
      return self.$$cast(result);
    
    }, $String_next$43.$$arity = 0);
    
    Opal.def(self, '$oct', $String_oct$44 = function $$oct() {
      var self = this;

      
      var result,
          string = self,
          radix = 8;

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/i, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x') {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          radix = 2;
          break;
        case '0':
        case '0o':
          radix = 8;
          break;
        case '0d':
          radix = 10;
          break;
        case '0x':
          radix = 16;
          break;
        }
        return head + tail;
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    
    }, $String_oct$44.$$arity = 0);
    
    Opal.def(self, '$ord', $String_ord$45 = function $$ord() {
      var self = this;

      
      if (typeof self.codePointAt === "function") {
        return self.codePointAt(0);
      }
      else {
        return self.charCodeAt(0);
      }
    
    }, $String_ord$45.$$arity = 0);
    
    Opal.def(self, '$partition', $String_partition$46 = function $$partition(sep) {
      var self = this;

      
      var i, m;

      if (sep.$$is_regexp) {
        m = sep.exec(self);
        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(sep, m);
          sep = m[0];
          i = m.index;
        }
      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.indexOf(sep);
      }

      if (i === -1) {
        return [self, '', ''];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_partition$46.$$arity = 1);
    
    Opal.def(self, '$reverse', $String_reverse$47 = function $$reverse() {
      var self = this;

      return self.split('').reverse().join('');
    }, $String_reverse$47.$$arity = 0);
    
    Opal.def(self, '$rindex', $String_rindex$48 = function $$rindex(search, offset) {
      var self = this;

      
      ;
      
      var i, m, r, _m;

      if (offset === undefined) {
        offset = self.length;
      } else {
        offset = $coerce_to(offset, $$($nesting, 'Integer'), 'to_int');
        if (offset < 0) {
          offset += self.length;
          if (offset < 0) {
            return nil;
          }
        }
      }

      if (search.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(search);
        while (true) {
          _m = r.exec(self);
          if (_m === null || _m.index > offset) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }
        if (m === null) {
          ($gvars["~"] = nil)
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          i = m.index;
        }
      } else {
        search = $coerce_to(search, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(search, offset);
      }

      return i === -1 ? nil : i;
    ;
    }, $String_rindex$48.$$arity = -2);
    
    Opal.def(self, '$rjust', $String_rjust$49 = function $$rjust(width, padstr) {
      var self = this;

      
      
      if (padstr == null) {
        padstr = " ";
      };
      width = $coerce_to(width, $$($nesting, 'Integer'), 'to_int');
      padstr = ($coerce_to(padstr, $$($nesting, 'String'), 'to_str')).$to_s();
      if ($truthy(padstr['$empty?']())) {
        self.$raise($$($nesting, 'ArgumentError'), "zero width padding")};
      if ($truthy(width <= self.length)) {
        return self};
      
      var chars     = Math.floor(width - self.length),
          patterns  = Math.floor(chars / padstr.length),
          result    = Array(patterns + 1).join(padstr),
          remaining = chars - result.length;

      return self.$$cast(result + padstr.slice(0, remaining) + self);
    ;
    }, $String_rjust$49.$$arity = -2);
    
    Opal.def(self, '$rpartition', $String_rpartition$50 = function $$rpartition(sep) {
      var self = this;

      
      var i, m, r, _m;

      if (sep.$$is_regexp) {
        m = null;
        r = Opal.global_multiline_regexp(sep);

        while (true) {
          _m = r.exec(self);
          if (_m === null) {
            break;
          }
          m = _m;
          r.lastIndex = m.index + 1;
        }

        if (m === null) {
          i = -1;
        } else {
          $$($nesting, 'MatchData').$new(r, m);
          sep = m[0];
          i = m.index;
        }

      } else {
        sep = $coerce_to(sep, $$($nesting, 'String'), 'to_str');
        i = self.lastIndexOf(sep);
      }

      if (i === -1) {
        return ['', '', self];
      }

      return [
        self.slice(0, i),
        self.slice(i, i + sep.length),
        self.slice(i + sep.length)
      ];
    
    }, $String_rpartition$50.$$arity = 1);
    
    Opal.def(self, '$rstrip', $String_rstrip$51 = function $$rstrip() {
      var self = this;

      return self.replace(/[\s\u0000]*$/, '');
    }, $String_rstrip$51.$$arity = 0);
    
    Opal.def(self, '$scan', $String_scan$52 = function $$scan(pattern) {
      var $iter = $String_scan$52.$$p, block = $iter || nil, self = this;

      if ($iter) $String_scan$52.$$p = null;
      
      
      if ($iter) $String_scan$52.$$p = null;;
      
      var result = [],
          match_data = nil,
          match;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
      }

      while ((match = pattern.exec(self)) != null) {
        match_data = $$($nesting, 'MatchData').$new(pattern, match);
        if (block === nil) {
          match.length == 1 ? result.push(match[0]) : result.push((match_data).$captures());
        } else {
          match.length == 1 ? block(match[0]) : block.call(self, (match_data).$captures());
        }
        if (pattern.lastIndex === match.index) {
          pattern.lastIndex += 1;
        }
      }

      ($gvars["~"] = match_data)

      return (block !== nil ? self : result);
    ;
    }, $String_scan$52.$$arity = 1);
    $alias(self, "slice", "[]");
    
    Opal.def(self, '$split', $String_split$53 = function $$split(pattern, limit) {
      var self = this, $ret_or_3 = nil;
      if ($gvars[";"] == null) $gvars[";"] = nil;

      
      ;
      ;
      
      if (self.length === 0) {
        return [];
      }

      if (limit === undefined) {
        limit = 0;
      } else {
        limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");
        if (limit === 1) {
          return [self];
        }
      }

      if (pattern === undefined || pattern === nil) {
        pattern = (function() {if ($truthy(($ret_or_3 = $gvars[";"]))) {
        return $ret_or_3
      } else {
        return " "
      }; return nil; })();
      }

      var result = [],
          string = self.toString(),
          index = 0,
          match,
          i, ii;

      if (pattern.$$is_regexp) {
        pattern = Opal.global_multiline_regexp(pattern);
      } else {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str').$to_s();
        if (pattern === ' ') {
          pattern = /\s+/gm;
          string = string.replace(/^\s+/, '');
        } else {
          pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gm');
        }
      }

      result = string.split(pattern);

      if (result.length === 1 && result[0] === string) {
        return [self.$$cast(result[0])];
      }

      while ((i = result.indexOf(undefined)) !== -1) {
        result.splice(i, 1);
      }

      function castResult() {
        for (i = 0; i < result.length; i++) {
          result[i] = self.$$cast(result[i]);
        }
      }

      if (limit === 0) {
        while (result[result.length - 1] === '') {
          result.length -= 1;
        }
        castResult();
        return result;
      }

      match = pattern.exec(string);

      if (limit < 0) {
        if (match !== null && match[0] === '' && pattern.source.indexOf('(?=') === -1) {
          for (i = 0, ii = match.length; i < ii; i++) {
            result.push('');
          }
        }
        castResult();
        return result;
      }

      if (match !== null && match[0] === '') {
        result.splice(limit - 1, result.length - 1, result.slice(limit - 1).join(''));
        castResult();
        return result;
      }

      if (limit >= result.length) {
        castResult();
        return result;
      }

      i = 0;
      while (match !== null) {
        i++;
        index = pattern.lastIndex;
        if (i + 1 === limit) {
          break;
        }
        match = pattern.exec(string);
      }
      result.splice(limit - 1, result.length - 1, string.slice(index));
      castResult();
      return result;
    ;
    }, $String_split$53.$$arity = -1);
    
    Opal.def(self, '$squeeze', $String_squeeze$54 = function $$squeeze($a) {
      var $post_args, sets, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      sets = $post_args;;
      
      if (sets.length === 0) {
        return self.$$cast(self.replace(/(.)\1+/g, '$1'));
      }
      var char_class = char_class_from_char_sets(sets);
      if (char_class === null) {
        return self;
      }
      return self.$$cast(self.replace(new RegExp('(' + char_class + ')\\1+', 'g'), '$1'));
    ;
    }, $String_squeeze$54.$$arity = -1);
    
    Opal.def(self, '$start_with?', $String_start_with$ques$55 = function($a) {
      var $post_args, prefixes, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      prefixes = $post_args;;
      
      for (var i = 0, length = prefixes.length; i < length; i++) {
        if (prefixes[i].$$is_regexp) {
          var regexp = prefixes[i];
          var match = regexp.exec(self);

          if (match != null && match.index === 0) {
            ($gvars["~"] = $$($nesting, 'MatchData').$new(regexp, match));
            return true;
          } else {
            ($gvars["~"] = nil)
          }
        } else {
          var prefix = $coerce_to(prefixes[i], $$($nesting, 'String'), 'to_str').$to_s();

          if (self.indexOf(prefix) === 0) {
            return true;
          }
        }
      }

      return false;
    ;
    }, $String_start_with$ques$55.$$arity = -1);
    
    Opal.def(self, '$strip', $String_strip$56 = function $$strip() {
      var self = this;

      return self.replace(/^\s*/, '').replace(/[\s\u0000]*$/, '');
    }, $String_strip$56.$$arity = 0);
    
    Opal.def(self, '$sub', $String_sub$57 = function $$sub(pattern, replacement) {
      var $iter = $String_sub$57.$$p, block = $iter || nil, self = this;

      if ($iter) $String_sub$57.$$p = null;
      
      
      if ($iter) $String_sub$57.$$p = null;;
      ;
      
      if (!pattern.$$is_regexp) {
        pattern = $coerce_to(pattern, $$($nesting, 'String'), 'to_str');
        pattern = new RegExp(pattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
      }

      var result, match = pattern.exec(self);

      if (match === null) {
        ($gvars["~"] = nil)
        result = self.toString();
      } else {
        $$($nesting, 'MatchData').$new(pattern, match)

        if (replacement === undefined) {

          if (block === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 2)")
          }
          result = self.slice(0, match.index) + block(match[0]) + self.slice(match.index + match[0].length);

        } else if (replacement.$$is_hash) {

          result = self.slice(0, match.index) + (replacement)['$[]'](match[0]).$to_s() + self.slice(match.index + match[0].length);

        } else {

          replacement = $coerce_to(replacement, $$($nesting, 'String'), 'to_str');

          replacement = replacement.replace(/([\\]+)([0-9+&`'])/g, function (original, slashes, command) {
            if (slashes.length % 2 === 0) {
              return original;
            }
            switch (command) {
            case "+":
              for (var i = match.length - 1; i > 0; i--) {
                if (match[i] !== undefined) {
                  return slashes.slice(1) + match[i];
                }
              }
              return '';
            case "&": return slashes.slice(1) + match[0];
            case "`": return slashes.slice(1) + self.slice(0, match.index);
            case "'": return slashes.slice(1) + self.slice(match.index + match[0].length);
            default:  return slashes.slice(1) + (match[command] || '');
            }
          }).replace(/\\\\/g, '\\');

          result = self.slice(0, match.index) + replacement + self.slice(match.index + match[0].length);
        }
      }

      return self.$$cast(result);
    ;
    }, $String_sub$57.$$arity = -2);
    $alias(self, "succ", "next");
    
    Opal.def(self, '$sum', $String_sum$58 = function $$sum(n) {
      var self = this;

      
      
      if (n == null) {
        n = 16;
      };
      
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');

      var result = 0,
          length = self.length,
          i = 0;

      for (; i < length; i++) {
        result += self.charCodeAt(i);
      }

      if (n <= 0) {
        return result;
      }

      return result & (Math.pow(2, n) - 1);
    ;
    }, $String_sum$58.$$arity = -1);
    
    Opal.def(self, '$swapcase', $String_swapcase$59 = function $$swapcase() {
      var self = this;

      
      var str = self.replace(/([a-z]+)|([A-Z]+)/g, function($0,$1,$2) {
        return $1 ? $0.toUpperCase() : $0.toLowerCase();
      });

      if (self.constructor === String) {
        return str;
      }

      return self.$class().$new(str);
    
    }, $String_swapcase$59.$$arity = 0);
    
    Opal.def(self, '$to_f', $String_to_f$60 = function $$to_f() {
      var self = this;

      
      if (self.charAt(0) === '_') {
        return 0;
      }

      var result = parseFloat(self.replace(/_/g, ''));

      if (isNaN(result) || result == Infinity || result == -Infinity) {
        return 0;
      }
      else {
        return result;
      }
    
    }, $String_to_f$60.$$arity = 0);
    
    Opal.def(self, '$to_i', $String_to_i$61 = function $$to_i(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      
      var result,
          string = self.toLowerCase(),
          radix = $coerce_to(base, $$($nesting, 'Integer'), 'to_int');

      if (radix === 1 || radix < 0 || radix > 36) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (radix))
      }

      if (/^\s*_/.test(string)) {
        return 0;
      }

      string = string.replace(/^(\s*[+-]?)(0[bodx]?)(.+)$/, function (original, head, flag, tail) {
        switch (tail.charAt(0)) {
        case '+':
        case '-':
          return original;
        case '0':
          if (tail.charAt(1) === 'x' && flag === '0x' && (radix === 0 || radix === 16)) {
            return original;
          }
        }
        switch (flag) {
        case '0b':
          if (radix === 0 || radix === 2) {
            radix = 2;
            return head + tail;
          }
          break;
        case '0':
        case '0o':
          if (radix === 0 || radix === 8) {
            radix = 8;
            return head + tail;
          }
          break;
        case '0d':
          if (radix === 0 || radix === 10) {
            radix = 10;
            return head + tail;
          }
          break;
        case '0x':
          if (radix === 0 || radix === 16) {
            radix = 16;
            return head + tail;
          }
          break;
        }
        return original
      });

      result = parseInt(string.replace(/_(?!_)/g, ''), radix);
      return isNaN(result) ? 0 : result;
    ;
    }, $String_to_i$61.$$arity = -1);
    
    Opal.def(self, '$to_proc', $String_to_proc$62 = function $$to_proc() {
      var $$63, $iter = $String_to_proc$62.$$p, $yield = $iter || nil, self = this, method_name = nil;

      if ($iter) $String_to_proc$62.$$p = null;
      
      method_name = $rb_plus("$", self.valueOf());
      return $send(self, 'proc', [], ($$63 = function($a){var self = $$63.$$s == null ? this : $$63.$$s, $iter = $$63.$$p, block = $iter || nil, $post_args, args;

        
        
        if ($iter) $$63.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        
        if (args.length === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "no receiver given")
        }

        var recv = args[0];

        if (recv == null) recv = nil;

        var body = recv[method_name];

        if (!body) {
          return recv.$method_missing.apply(recv, args);
        }

        if (typeof block === 'function') {
          body.$$p = block;
        }

        if (args.length === 1) {
          return body.call(recv);
        } else {
          return body.apply(recv, args.slice(1));
        }
      ;}, $$63.$$s = self, $$63.$$arity = -1, $$63));
    }, $String_to_proc$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $String_to_s$64 = function $$to_s() {
      var self = this;

      return self.toString();
    }, $String_to_s$64.$$arity = 0);
    $alias(self, "to_str", "to_s");
    $alias(self, "to_sym", "intern");
    
    Opal.def(self, '$tr', $String_tr$65 = function $$tr(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0 || from === to) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_to == null) {
              last_to = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_to.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_to = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }

      var new_str = ''
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch];
        if (inverse) {
          new_str += (sub == null ? global_sub : ch);
        }
        else {
          new_str += (sub != null ? sub : ch);
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr$65.$$arity = 2);
    
    Opal.def(self, '$tr_s', $String_tr_s$66 = function $$tr_s(from, to) {
      var self = this;

      
      from = $coerce_to(from, $$($nesting, 'String'), 'to_str').$to_s();
      to = $coerce_to(to, $$($nesting, 'String'), 'to_str').$to_s();

      if (from.length == 0) {
        return self;
      }

      var i, in_range, c, ch, start, end, length;
      var subs = {};
      var from_chars = from.split('');
      var from_length = from_chars.length;
      var to_chars = to.split('');
      var to_length = to_chars.length;

      var inverse = false;
      var global_sub = null;
      if (from_chars[0] === '^' && from_chars.length > 1) {
        inverse = true;
        from_chars.shift();
        global_sub = to_chars[to_length - 1]
        from_length -= 1;
      }

      var from_chars_expanded = [];
      var last_from = null;
      in_range = false;
      for (i = 0; i < from_length; i++) {
        ch = from_chars[i];
        if (last_from == null) {
          last_from = ch;
          from_chars_expanded.push(ch);
        }
        else if (ch === '-') {
          if (last_from === '-') {
            from_chars_expanded.push('-');
            from_chars_expanded.push('-');
          }
          else if (i == from_length - 1) {
            from_chars_expanded.push('-');
          }
          else {
            in_range = true;
          }
        }
        else if (in_range) {
          start = last_from.charCodeAt(0);
          end = ch.charCodeAt(0);
          if (start > end) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
          }
          for (c = start + 1; c < end; c++) {
            from_chars_expanded.push(String.fromCharCode(c));
          }
          from_chars_expanded.push(ch);
          in_range = null;
          last_from = null;
        }
        else {
          from_chars_expanded.push(ch);
        }
      }

      from_chars = from_chars_expanded;
      from_length = from_chars.length;

      if (inverse) {
        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = true;
        }
      }
      else {
        if (to_length > 0) {
          var to_chars_expanded = [];
          var last_to = null;
          in_range = false;
          for (i = 0; i < to_length; i++) {
            ch = to_chars[i];
            if (last_from == null) {
              last_from = ch;
              to_chars_expanded.push(ch);
            }
            else if (ch === '-') {
              if (last_to === '-') {
                to_chars_expanded.push('-');
                to_chars_expanded.push('-');
              }
              else if (i == to_length - 1) {
                to_chars_expanded.push('-');
              }
              else {
                in_range = true;
              }
            }
            else if (in_range) {
              start = last_from.charCodeAt(0);
              end = ch.charCodeAt(0);
              if (start > end) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (String.fromCharCode(start)) + "-" + (String.fromCharCode(end)) + "\" in string transliteration")
              }
              for (c = start + 1; c < end; c++) {
                to_chars_expanded.push(String.fromCharCode(c));
              }
              to_chars_expanded.push(ch);
              in_range = null;
              last_from = null;
            }
            else {
              to_chars_expanded.push(ch);
            }
          }

          to_chars = to_chars_expanded;
          to_length = to_chars.length;
        }

        var length_diff = from_length - to_length;
        if (length_diff > 0) {
          var pad_char = (to_length > 0 ? to_chars[to_length - 1] : '');
          for (i = 0; i < length_diff; i++) {
            to_chars.push(pad_char);
          }
        }

        for (i = 0; i < from_length; i++) {
          subs[from_chars[i]] = to_chars[i];
        }
      }
      var new_str = ''
      var last_substitute = null
      for (i = 0, length = self.length; i < length; i++) {
        ch = self.charAt(i);
        var sub = subs[ch]
        if (inverse) {
          if (sub == null) {
            if (last_substitute == null) {
              new_str += global_sub;
              last_substitute = true;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
        else {
          if (sub != null) {
            if (last_substitute == null || last_substitute !== sub) {
              new_str += sub;
              last_substitute = sub;
            }
          }
          else {
            new_str += ch;
            last_substitute = null;
          }
        }
      }
      return self.$$cast(new_str);
    
    }, $String_tr_s$66.$$arity = 2);
    
    Opal.def(self, '$upcase', $String_upcase$67 = function $$upcase() {
      var self = this;

      return self.$$cast(self.toUpperCase());
    }, $String_upcase$67.$$arity = 0);
    
    Opal.def(self, '$upto', $String_upto$68 = function $$upto(stop, excl) {
      var $iter = $String_upto$68.$$p, block = $iter || nil, self = this;

      if ($iter) $String_upto$68.$$p = null;
      
      
      if ($iter) $String_upto$68.$$p = null;;
      
      if (excl == null) {
        excl = false;
      };
      if ((block !== nil)) {
      } else {
        return self.$enum_for("upto", stop, excl)
      };
      
      var a, b, s = self.toString();

      stop = $coerce_to(stop, $$($nesting, 'String'), 'to_str');

      if (s.length === 1 && stop.length === 1) {

        a = s.charCodeAt(0);
        b = stop.charCodeAt(0);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(String.fromCharCode(a));

          a += 1;
        }

      } else if (parseInt(s, 10).toString() === s && parseInt(stop, 10).toString() === stop) {

        a = parseInt(s, 10);
        b = parseInt(stop, 10);

        while (a <= b) {
          if (excl && a === b) {
            break;
          }

          block(a.toString());

          a += 1;
        }

      } else {

        while (s.length <= stop.length && s <= stop) {
          if (excl && s === stop) {
            break;
          }

          block(s);

          s = (s).$succ();
        }

      }
      return self;
    ;
    }, $String_upto$68.$$arity = -2);
    
    function char_class_from_char_sets(sets) {
      function explode_sequences_in_character_set(set) {
        var result = '',
            i, len = set.length,
            curr_char,
            skip_next_dash,
            char_code_from,
            char_code_upto,
            char_code;
        for (i = 0; i < len; i++) {
          curr_char = set.charAt(i);
          if (curr_char === '-' && i > 0 && i < (len - 1) && !skip_next_dash) {
            char_code_from = set.charCodeAt(i - 1);
            char_code_upto = set.charCodeAt(i + 1);
            if (char_code_from > char_code_upto) {
              self.$raise($$($nesting, 'ArgumentError'), "" + "invalid range \"" + (char_code_from) + "-" + (char_code_upto) + "\" in string transliteration")
            }
            for (char_code = char_code_from + 1; char_code < char_code_upto + 1; char_code++) {
              result += String.fromCharCode(char_code);
            }
            skip_next_dash = true;
            i++;
          } else {
            skip_next_dash = (curr_char === '\\');
            result += curr_char;
          }
        }
        return result;
      }

      function intersection(setA, setB) {
        if (setA.length === 0) {
          return setB;
        }
        var result = '',
            i, len = setA.length,
            chr;
        for (i = 0; i < len; i++) {
          chr = setA.charAt(i);
          if (setB.indexOf(chr) !== -1) {
            result += chr;
          }
        }
        return result;
      }

      var i, len, set, neg, chr, tmp,
          pos_intersection = '',
          neg_intersection = '';

      for (i = 0, len = sets.length; i < len; i++) {
        set = $coerce_to(sets[i], $$($nesting, 'String'), 'to_str');
        neg = (set.charAt(0) === '^' && set.length > 1);
        set = explode_sequences_in_character_set(neg ? set.slice(1) : set);
        if (neg) {
          neg_intersection = intersection(neg_intersection, set);
        } else {
          pos_intersection = intersection(pos_intersection, set);
        }
      }

      if (pos_intersection.length > 0 && neg_intersection.length > 0) {
        tmp = '';
        for (i = 0, len = pos_intersection.length; i < len; i++) {
          chr = pos_intersection.charAt(i);
          if (neg_intersection.indexOf(chr) === -1) {
            tmp += chr;
          }
        }
        pos_intersection = tmp;
        neg_intersection = '';
      }

      if (pos_intersection.length > 0) {
        return '[' + $$($nesting, 'Regexp').$escape(pos_intersection) + ']';
      }

      if (neg_intersection.length > 0) {
        return '[^' + $$($nesting, 'Regexp').$escape(neg_intersection) + ']';
      }

      return null;
    }
  ;
    
    Opal.def(self, '$instance_variables', $String_instance_variables$69 = function $$instance_variables() {
      var self = this;

      return []
    }, $String_instance_variables$69.$$arity = 0);
    Opal.defs(self, '$_load', $String__load$70 = function $$_load($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return $send(self, 'new', Opal.to_a(args));
    }, $String__load$70.$$arity = -1);
    
    Opal.def(self, '$unicode_normalize', $String_unicode_normalize$71 = function $$unicode_normalize(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      if ($truthy(["nfc", "nfd", "nfkc", "nfkd"]['$include?'](form))) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "" + "Invalid normalization form " + (form))
      };
      return self.normalize(form.$upcase());
    }, $String_unicode_normalize$71.$$arity = -1);
    
    Opal.def(self, '$unicode_normalized?', $String_unicode_normalized$ques$72 = function(form) {
      var self = this;

      
      
      if (form == null) {
        form = "nfc";
      };
      return self.$unicode_normalize(form)['$=='](self);
    }, $String_unicode_normalized$ques$72.$$arity = -1);
    
    Opal.def(self, '$unpack', $String_unpack$73 = function $$unpack(format) {
      var self = this;

      return self.$raise("To use String#unpack, you must first require 'corelib/string/unpack'.")
    }, $String_unpack$73.$$arity = 1);
    
    Opal.def(self, '$unpack1', $String_unpack1$74 = function $$unpack1(format) {
      var self = this;

      return self.$raise("To use String#unpack1, you must first require 'corelib/string/unpack'.")
    }, $String_unpack1$74.$$arity = 1);
    
    Opal.def(self, '$freeze', $String_freeze$75 = function $$freeze() {
      var self = this;

      
      if (typeof self === 'string') return self;
      self.$$frozen = true;
      return self;
    
    }, $String_freeze$75.$$arity = 0);
    $alias(self, "+@", "dup");
    
    Opal.def(self, '$-@', $String_$minus$$76 = function() {
      var self = this;

      
      if (typeof self === 'string') return self;
      if (self.$$frozen === true) return self;
      if (self.encoding.name == 'UTF-8' && self.internal_encoding.name == 'UTF-8') return self.toString();
      return self.$dup().$freeze();
    
    }, $String_$minus$$76.$$arity = 0);
    
    Opal.def(self, '$frozen?', $String_frozen$ques$77 = function() {
      var self = this;

      return typeof self === 'string' || self.$$frozen === true;
    }, $String_frozen$ques$77.$$arity = 0);
    return $$($nesting, 'Opal').$pristine(self, "initialize");
  })($nesting[0], String, $nesting);
  return Opal.const_set($nesting[0], 'Symbol', $$($nesting, 'String'));
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/enumerable"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $module = Opal.module, $send = Opal.send, $alias = Opal.alias, $hash2 = Opal.hash2, $lambda = Opal.lambda;

  Opal.add_stubs(['$each', '$public_send', '$destructure', '$to_enum', '$enumerator_size', '$new', '$yield', '$raise', '$slice_when', '$!', '$enum_for', '$flatten', '$map', '$warn', '$proc', '$==', '$nil?', '$respond_to?', '$coerce_to!', '$>', '$*', '$try_convert', '$<', '$+', '$-', '$ceil', '$/', '$size', '$select', '$to_proc', '$__send__', '$length', '$<=', '$[]', '$push', '$<<', '$[]=', '$===', '$inspect', '$<=>', '$first', '$reverse', '$sort', '$take', '$sort_by', '$compare', '$call', '$dup', '$to_a', '$sort!', '$map!', '$key?', '$values', '$transform_values', '$group_by', '$to_h', '$coerce_to?', '$class', '$zip']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Enumerable');

    var $nesting = [self].concat($parent_nesting), $Enumerable_all$ques$1, $Enumerable_any$ques$5, $Enumerable_chunk$9, $Enumerable_chunk_while$12, $Enumerable_collect$14, $Enumerable_collect_concat$16, $Enumerable_count$19, $Enumerable_cycle$23, $Enumerable_detect$25, $Enumerable_drop$27, $Enumerable_drop_while$28, $Enumerable_each_cons$29, $Enumerable_each_entry$31, $Enumerable_each_slice$33, $Enumerable_each_with_index$35, $Enumerable_each_with_object$37, $Enumerable_entries$39, $Enumerable_filter_map$40, $Enumerable_find_all$42, $Enumerable_find_index$44, $Enumerable_first$47, $Enumerable_grep$50, $Enumerable_grep_v$52, $Enumerable_group_by$54, $Enumerable_include$ques$56, $Enumerable_inject$58, $Enumerable_lazy$59, $Enumerable_enumerator_size$61, $Enumerable_max$62, $Enumerable_max_by$63, $Enumerable_min$65, $Enumerable_min_by$67, $Enumerable_minmax$69, $Enumerable_minmax_by$71, $Enumerable_none$ques$73, $Enumerable_one$ques$77, $Enumerable_partition$81, $Enumerable_reject$83, $Enumerable_reverse_each$85, $Enumerable_slice_before$87, $Enumerable_slice_after$89, $Enumerable_slice_when$92, $Enumerable_sort$94, $Enumerable_sort_by$96, $Enumerable_sum$101, $Enumerable_take$103, $Enumerable_take_while$104, $Enumerable_uniq$106, $Enumerable_tally$108, $Enumerable_to_h$109, $Enumerable_zip$110;

    
    
    function comparableForPattern(value) {
      if (value.length === 0) {
        value = [nil];
      }

      if (value.length > 1) {
        value = [value];
      }

      return value;
    }
  ;
    
    Opal.def(self, '$all?', $Enumerable_all$ques$1 = function(pattern) {try {

      var $iter = $Enumerable_all$ques$1.$$p, block = $iter || nil, $$2, $$3, $$4, self = this;

      if ($iter) $Enumerable_all$ques$1.$$p = null;
      
      
      if ($iter) $Enumerable_all$ques$1.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$2 = function($a){var self = $$2.$$s == null ? this : $$2.$$s, $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$2.$$s = self, $$2.$$arity = -1, $$2))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$3 = function($a){var self = $$3.$$s == null ? this : $$3.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$3.$$s = self, $$3.$$arity = -1, $$3))
      } else {
        $send(self, 'each', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            return nil
          } else {
            Opal.ret(false)
          };}, $$4.$$s = self, $$4.$$arity = -1, $$4))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_all$ques$1.$$arity = -1);
    
    Opal.def(self, '$any?', $Enumerable_any$ques$5 = function(pattern) {try {

      var $iter = $Enumerable_any$ques$5.$$p, block = $iter || nil, $$6, $$7, $$8, self = this;

      if ($iter) $Enumerable_any$ques$5.$$p = null;
      
      
      if ($iter) $Enumerable_any$ques$5.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$6.$$s = self, $$6.$$arity = -1, $$6))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$7 = function($a){var self = $$7.$$s == null ? this : $$7.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$7.$$s = self, $$7.$$arity = -1, $$7))
      } else {
        $send(self, 'each', [], ($$8 = function($a){var self = $$8.$$s == null ? this : $$8.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
            Opal.ret(true)
          } else {
            return nil
          };}, $$8.$$s = self, $$8.$$arity = -1, $$8))
      };
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_any$ques$5.$$arity = -1);
    
    Opal.def(self, '$chunk', $Enumerable_chunk$9 = function $$chunk() {
      var $iter = $Enumerable_chunk$9.$$p, block = $iter || nil, $$10, $$11, self = this;

      if ($iter) $Enumerable_chunk$9.$$p = null;
      
      
      if ($iter) $Enumerable_chunk$9.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["chunk"], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

          return self.$enumerator_size()}, $$10.$$s = self, $$10.$$arity = 0, $$10))
      };
      return $send($$$('::', 'Enumerator'), 'new', [], ($$11 = function(yielder){var self = $$11.$$s == null ? this : $$11.$$s;

        
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var previous = nil, accumulate = [];

        function releaseAccumulate() {
          if (accumulate.length > 0) {
            yielder.$yield(previous, accumulate)
          }
        }

        self.$each.$$p = function(value) {
          var key = Opal.yield1(block, value);

          if (key === nil) {
            releaseAccumulate();
            accumulate = [];
            previous = nil;
          } else {
            if (previous === nil || previous === key) {
              accumulate.push(value);
            } else {
              releaseAccumulate();
              accumulate = [value];
            }

            previous = key;
          }
        }

        self.$each();

        releaseAccumulate();
      ;}, $$11.$$s = self, $$11.$$arity = 1, $$11));
    }, $Enumerable_chunk$9.$$arity = 0);
    
    Opal.def(self, '$chunk_while', $Enumerable_chunk_while$12 = function $$chunk_while() {
      var $iter = $Enumerable_chunk_while$12.$$p, block = $iter || nil, $$13, self = this;

      if ($iter) $Enumerable_chunk_while$12.$$p = null;
      
      
      if ($iter) $Enumerable_chunk_while$12.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "no block given")
      };
      return $send(self, 'slice_when', [], ($$13 = function(before, after){var self = $$13.$$s == null ? this : $$13.$$s;

        
        
        if (before == null) {
          before = nil;
        };
        
        if (after == null) {
          after = nil;
        };
        return Opal.yieldX(block, [before, after])['$!']();}, $$13.$$s = self, $$13.$$arity = 2, $$13));
    }, $Enumerable_chunk_while$12.$$arity = 0);
    
    Opal.def(self, '$collect', $Enumerable_collect$14 = function $$collect() {
      var $iter = $Enumerable_collect$14.$$p, block = $iter || nil, $$15, self = this;

      if ($iter) $Enumerable_collect$14.$$p = null;
      
      
      if ($iter) $Enumerable_collect$14.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$15 = function(){var self = $$15.$$s == null ? this : $$15.$$s;

          return self.$enumerator_size()}, $$15.$$s = self, $$15.$$arity = 0, $$15))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var value = Opal.yieldX(block, arguments);

        result.push(value);
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_collect$14.$$arity = 0);
    
    Opal.def(self, '$collect_concat', $Enumerable_collect_concat$16 = function $$collect_concat() {
      var $iter = $Enumerable_collect_concat$16.$$p, block = $iter || nil, $$17, $$18, self = this;

      if ($iter) $Enumerable_collect_concat$16.$$p = null;
      
      
      if ($iter) $Enumerable_collect_concat$16.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect_concat"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s;

          return self.$enumerator_size()}, $$17.$$s = self, $$17.$$arity = 0, $$17))
      };
      return $send(self, 'map', [], ($$18 = function(item){var self = $$18.$$s == null ? this : $$18.$$s;

        
        
        if (item == null) {
          item = nil;
        };
        return Opal.yield1(block, item);;}, $$18.$$s = self, $$18.$$arity = 1, $$18)).$flatten(1);
    }, $Enumerable_collect_concat$16.$$arity = 0);
    
    Opal.def(self, '$count', $Enumerable_count$19 = function $$count(object) {
      var $iter = $Enumerable_count$19.$$p, block = $iter || nil, $$20, $$21, $$22, self = this, result = nil;

      if ($iter) $Enumerable_count$19.$$p = null;
      
      
      if ($iter) $Enumerable_count$19.$$p = null;;
      ;
      result = 0;
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      if ($truthy(object != null)) {
        block = $send(self, 'proc', [], ($$20 = function($a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          return $$($nesting, 'Opal').$destructure(args)['$=='](object);}, $$20.$$s = self, $$20.$$arity = -1, $$20))
      } else if ($truthy(block['$nil?']())) {
        block = $send(self, 'proc', [], ($$21 = function(){var self = $$21.$$s == null ? this : $$21.$$s;

          return true}, $$21.$$s = self, $$21.$$arity = 0, $$21))};
      $send(self, 'each', [], ($$22 = function($a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($truthy(Opal.yieldX(block, args))) {
          return result++;
        } else {
          return nil
        };}, $$22.$$s = self, $$22.$$arity = -1, $$22));
      return result;
    }, $Enumerable_count$19.$$arity = -1);
    
    Opal.def(self, '$cycle', $Enumerable_cycle$23 = function $$cycle(n) {
      var $iter = $Enumerable_cycle$23.$$p, block = $iter || nil, $$24, self = this;

      if ($iter) $Enumerable_cycle$23.$$p = null;
      
      
      if ($iter) $Enumerable_cycle$23.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$24 = function(){var self = $$24.$$s == null ? this : $$24.$$s;

          if ($truthy(n['$nil?']())) {
            if ($truthy(self['$respond_to?']("size"))) {
              return $$$($$($nesting, 'Float'), 'INFINITY')
            } else {
              return nil
            }
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$24.$$s = self, $$24.$$arity = 0, $$24))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if ($truthy(n <= 0)) {
          return nil};
      };
      
      var all = [], i, length, value;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        all.push(param);
      }

      self.$each();

      if (all.length === 0) {
        return nil;
      }

      if (n === nil) {
        while (true) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }
        }
      }
      else {
        while (n > 1) {
          for (i = 0, length = all.length; i < length; i++) {
            value = Opal.yield1(block, all[i]);
          }

          n--;
        }
      }
    ;
    }, $Enumerable_cycle$23.$$arity = -1);
    
    Opal.def(self, '$detect', $Enumerable_detect$25 = function $$detect(ifnone) {try {

      var $iter = $Enumerable_detect$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Enumerable_detect$25.$$p = null;
      
      
      if ($iter) $Enumerable_detect$25.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("detect", ifnone)
      };
      $send(self, 'each', [], ($$26 = function($a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args, value = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
          Opal.ret(value)
        } else {
          return nil
        };}, $$26.$$s = self, $$26.$$arity = -1, $$26));
      
      if (ifnone !== undefined) {
        if (typeof(ifnone) === 'function') {
          return ifnone();
        } else {
          return ifnone;
        }
      }
    ;
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_detect$25.$$arity = -1);
    
    Opal.def(self, '$drop', $Enumerable_drop$27 = function $$drop(number) {
      var self = this;

      
      number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(number < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
      
      var result  = [],
          current = 0;

      self.$each.$$p = function() {
        if (number <= current) {
          result.push($$($nesting, 'Opal').$destructure(arguments));
        }

        current++;
      };

      self.$each()

      return result;
    ;
    }, $Enumerable_drop$27.$$arity = 1);
    
    Opal.def(self, '$drop_while', $Enumerable_drop_while$28 = function $$drop_while() {
      var $iter = $Enumerable_drop_while$28.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_drop_while$28.$$p = null;
      
      
      if ($iter) $Enumerable_drop_while$28.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("drop_while")
      };
      
      var result   = [],
          dropping = true;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        if (dropping) {
          var value = Opal.yield1(block, param);

          if ($falsy(value)) {
            dropping = false;
            result.push(param);
          }
        }
        else {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_drop_while$28.$$arity = 0);
    
    Opal.def(self, '$each_cons', $Enumerable_each_cons$29 = function $$each_cons(n) {
      var $iter = $Enumerable_each_cons$29.$$p, block = $iter || nil, $$30, self = this;

      if ($iter) $Enumerable_each_cons$29.$$p = null;
      
      
      if ($iter) $Enumerable_each_cons$29.$$p = null;;
      if ($truthy(arguments.length != 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 1)")};
      n = $$($nesting, 'Opal').$try_convert(n, $$($nesting, 'Integer'), "to_int");
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_cons", n], ($$30 = function(){var self = $$30.$$s == null ? this : $$30.$$s, enum_size = nil, $ret_or_1 = nil;

          
          enum_size = self.$enumerator_size();
          if ($truthy(enum_size['$nil?']())) {
            return nil
          } else if ($truthy((function() {if ($truthy(($ret_or_1 = enum_size['$=='](0)))) {
            return $ret_or_1
          } else {
            return $rb_lt(enum_size, n)
          }; return nil; })())) {
            return 0
          } else {
            return $rb_plus($rb_minus(enum_size, n), 1)
          };}, $$30.$$s = self, $$30.$$arity = 0, $$30))
      };
      
      var buffer = [];

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        buffer.push(element);
        if (buffer.length > n) {
          buffer.shift();
        }
        if (buffer.length == n) {
          Opal.yield1(block, buffer.slice(0, n));
        }
      }

      self.$each();

      return nil;
    ;
    }, $Enumerable_each_cons$29.$$arity = 1);
    
    Opal.def(self, '$each_entry', $Enumerable_each_entry$31 = function $$each_entry($a) {
      var $iter = $Enumerable_each_entry$31.$$p, block = $iter || nil, $post_args, data, $$32, self = this;

      if ($iter) $Enumerable_each_entry$31.$$p = null;
      
      
      if ($iter) $Enumerable_each_entry$31.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      data = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'to_enum', ["each_entry"].concat(Opal.to_a(data)), ($$32 = function(){var self = $$32.$$s == null ? this : $$32.$$s;

          return self.$enumerator_size()}, $$32.$$s = self, $$32.$$arity = 0, $$32))
      };
      
      self.$each.$$p = function() {
        var item = $$($nesting, 'Opal').$destructure(arguments);

        Opal.yield1(block, item);
      }

      self.$each.apply(self, data);

      return self;
    ;
    }, $Enumerable_each_entry$31.$$arity = -1);
    
    Opal.def(self, '$each_slice', $Enumerable_each_slice$33 = function $$each_slice(n) {
      var $iter = $Enumerable_each_slice$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Enumerable_each_slice$33.$$p = null;
      
      
      if ($iter) $Enumerable_each_slice$33.$$p = null;;
      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(n <= 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "invalid slice size")};
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_slice", n], ($$34 = function(){var self = $$34.$$s == null ? this : $$34.$$s;

          if ($truthy(self['$respond_to?']("size"))) {
            return $rb_divide(self.$size(), n).$ceil()
          } else {
            return nil
          }}, $$34.$$s = self, $$34.$$arity = 0, $$34))
      };
      
      var slice = []

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        slice.push(param);

        if (slice.length === n) {
          Opal.yield1(block, slice);
          slice = [];
        }
      };

      self.$each();

      // our "last" group, if smaller than n then won't have been yielded
      if (slice.length > 0) {
        Opal.yield1(block, slice);
      }
    ;
      return nil;
    }, $Enumerable_each_slice$33.$$arity = 1);
    
    Opal.def(self, '$each_with_index', $Enumerable_each_with_index$35 = function $$each_with_index($a) {
      var $iter = $Enumerable_each_with_index$35.$$p, block = $iter || nil, $post_args, args, $$36, self = this;

      if ($iter) $Enumerable_each_with_index$35.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_index$35.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"].concat(Opal.to_a(args)), ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$enumerator_size()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      var index = 0;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, index);

        index++;
      };

      self.$each.apply(self, args);
    ;
      return self;
    }, $Enumerable_each_with_index$35.$$arity = -1);
    
    Opal.def(self, '$each_with_object', $Enumerable_each_with_object$37 = function $$each_with_object(object) {
      var $iter = $Enumerable_each_with_object$37.$$p, block = $iter || nil, $$38, self = this;

      if ($iter) $Enumerable_each_with_object$37.$$p = null;
      
      
      if ($iter) $Enumerable_each_with_object$37.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_object", object], ($$38 = function(){var self = $$38.$$s == null ? this : $$38.$$s;

          return self.$enumerator_size()}, $$38.$$s = self, $$38.$$arity = 0, $$38))
      };
      
      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);

        block(param, object);
      };

      self.$each();
    ;
      return object;
    }, $Enumerable_each_with_object$37.$$arity = 1);
    
    Opal.def(self, '$entries', $Enumerable_entries$39 = function $$entries($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      self.$each.$$p = function() {
        result.push($$($nesting, 'Opal').$destructure(arguments));
      };

      self.$each.apply(self, args);

      return result;
    ;
    }, $Enumerable_entries$39.$$arity = -1);
    
    Opal.def(self, '$filter_map', $Enumerable_filter_map$40 = function $$filter_map() {
      var $iter = $Enumerable_filter_map$40.$$p, block = $iter || nil, $$41, self = this;

      if ($iter) $Enumerable_filter_map$40.$$p = null;
      
      
      if ($iter) $Enumerable_filter_map$40.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["filter_map"], ($$41 = function(){var self = $$41.$$s == null ? this : $$41.$$s;

          return self.$enumerator_size()}, $$41.$$s = self, $$41.$$arity = 0, $$41))
      };
      return $send($send(self, 'map', [], block.$to_proc()), 'select', [], "itself".$to_proc());
    }, $Enumerable_filter_map$40.$$arity = 0);
    $alias(self, "find", "detect");
    
    Opal.def(self, '$find_all', $Enumerable_find_all$42 = function $$find_all() {
      var $iter = $Enumerable_find_all$42.$$p, block = $iter || nil, $$43, self = this;

      if ($iter) $Enumerable_find_all$42.$$p = null;
      
      
      if ($iter) $Enumerable_find_all$42.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["find_all"], ($$43 = function(){var self = $$43.$$s == null ? this : $$43.$$s;

          return self.$enumerator_size()}, $$43.$$s = self, $$43.$$arity = 0, $$43))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_find_all$42.$$arity = 0);
    $alias(self, "filter", "find_all");
    
    Opal.def(self, '$find_index', $Enumerable_find_index$44 = function $$find_index(object) {try {

      var $iter = $Enumerable_find_index$44.$$p, block = $iter || nil, $$45, $$46, self = this, index = nil;

      if ($iter) $Enumerable_find_index$44.$$p = null;
      
      
      if ($iter) $Enumerable_find_index$44.$$p = null;;
      ;
      if ($truthy(object === undefined && block === nil)) {
        return self.$enum_for("find_index")};
      
      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }
    ;
      index = 0;
      if ($truthy(object != null)) {
        $send(self, 'each', [], ($$45 = function($a){var self = $$45.$$s == null ? this : $$45.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($$($nesting, 'Opal').$destructure(value)['$=='](object)) {
            Opal.ret(index)};
          return index += 1;;}, $$45.$$s = self, $$45.$$arity = -1, $$45))
      } else {
        $send(self, 'each', [], ($$46 = function($a){var self = $$46.$$s == null ? this : $$46.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(index)};
          return index += 1;;}, $$46.$$s = self, $$46.$$arity = -1, $$46))
      };
      return nil;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_find_index$44.$$arity = -1);
    
    Opal.def(self, '$first', $Enumerable_first$47 = function $$first(number) {try {

      var $$48, $$49, self = this, result = nil, current = nil;

      
      ;
      if ($truthy(number === undefined)) {
        return $send(self, 'each', [], ($$48 = function(value){var self = $$48.$$s == null ? this : $$48.$$s;

          
          
          if (value == null) {
            value = nil;
          };
          Opal.ret(value);}, $$48.$$s = self, $$48.$$arity = 1, $$48))
      } else {
        
        result = [];
        number = $coerce_to(number, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(number < 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        if ($truthy(number == 0)) {
          return []};
        current = 0;
        $send(self, 'each', [], ($$49 = function($a){var self = $$49.$$s == null ? this : $$49.$$s, $post_args, args;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          args = $post_args;;
          result.push($$($nesting, 'Opal').$destructure(args));
          if ($truthy(number <= ++current)) {
            Opal.ret(result)
          } else {
            return nil
          };}, $$49.$$s = self, $$49.$$arity = -1, $$49));
        return result;
      };
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_first$47.$$arity = -1);
    $alias(self, "flat_map", "collect_concat");
    
    Opal.def(self, '$grep', $Enumerable_grep$50 = function $$grep(pattern) {
      var $iter = $Enumerable_grep$50.$$p, block = $iter || nil, $$51, self = this, result = nil;

      if ($iter) $Enumerable_grep$50.$$p = null;
      
      
      if ($iter) $Enumerable_grep$50.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$51 = function($a){var self = $$51.$$s == null ? this : $$51.$$s, $post_args, value, cmp = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
        } else {
          return nil;
        };
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$51.$$s = self, $$51.$$arity = -1, $$51));
      return result;
    }, $Enumerable_grep$50.$$arity = 1);
    
    Opal.def(self, '$grep_v', $Enumerable_grep_v$52 = function $$grep_v(pattern) {
      var $iter = $Enumerable_grep_v$52.$$p, block = $iter || nil, $$53, self = this, result = nil;

      if ($iter) $Enumerable_grep_v$52.$$p = null;
      
      
      if ($iter) $Enumerable_grep_v$52.$$p = null;;
      result = [];
      $send(self, 'each', [], ($$53 = function($a){var self = $$53.$$s == null ? this : $$53.$$s, $post_args, value, cmp = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        value = $post_args;;
        cmp = comparableForPattern(value);
        if ($truthy($send(pattern, '__send__', ["==="].concat(Opal.to_a(cmp))))) {
          return nil;};
        if ((block !== nil)) {
          
          if ($truthy($rb_gt(value.$length(), 1))) {
            value = [value]};
          value = Opal.yieldX(block, Opal.to_a(value));
        } else if ($truthy($rb_le(value.$length(), 1))) {
          value = value['$[]'](0)};
        return result.$push(value);}, $$53.$$s = self, $$53.$$arity = -1, $$53));
      return result;
    }, $Enumerable_grep_v$52.$$arity = 1);
    
    Opal.def(self, '$group_by', $Enumerable_group_by$54 = function $$group_by() {
      var $iter = $Enumerable_group_by$54.$$p, block = $iter || nil, $$55, self = this, hash = nil, $ret_or_2 = nil, $writer = nil;

      if ($iter) $Enumerable_group_by$54.$$p = null;
      
      
      if ($iter) $Enumerable_group_by$54.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["group_by"], ($$55 = function(){var self = $$55.$$s == null ? this : $$55.$$s;

          return self.$enumerator_size()}, $$55.$$s = self, $$55.$$arity = 0, $$55))
      };
      hash = $hash2([], {});
      
      var result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        (function() {if ($truthy(($ret_or_2 = hash['$[]'](value)))) {
        return $ret_or_2
      } else {
        
        $writer = [value, []];
        $send(hash, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];
      }; return nil; })()['$<<'](param);
      }

      self.$each();

      if (result !== undefined) {
        return result;
      }
    ;
      return hash;
    }, $Enumerable_group_by$54.$$arity = 0);
    
    Opal.def(self, '$include?', $Enumerable_include$ques$56 = function(obj) {try {

      var $$57, self = this;

      
      $send(self, 'each', [], ($$57 = function($a){var self = $$57.$$s == null ? this : $$57.$$s, $post_args, args;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        if ($$($nesting, 'Opal').$destructure(args)['$=='](obj)) {
          Opal.ret(true)
        } else {
          return nil
        };}, $$57.$$s = self, $$57.$$arity = -1, $$57));
      return false;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_include$ques$56.$$arity = 1);
    
    Opal.def(self, '$inject', $Enumerable_inject$58 = function $$inject(object, sym) {
      var $iter = $Enumerable_inject$58.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_inject$58.$$p = null;
      
      
      if ($iter) $Enumerable_inject$58.$$p = null;;
      ;
      ;
      
      var result = object;

      if (block !== nil && sym === undefined) {
        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          value = Opal.yieldX(block, [result, value]);

          result = value;
        };
      }
      else {
        if (sym === undefined) {
          if (!$$($nesting, 'Symbol')['$==='](object)) {
            self.$raise($$($nesting, 'TypeError'), "" + (object.$inspect()) + " is not a Symbol");
          }

          sym    = object;
          result = undefined;
        }

        self.$each.$$p = function() {
          var value = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = value;
            return;
          }

          result = (result).$__send__(sym, value);
        };
      }

      self.$each();

      return result == undefined ? nil : result;
    ;
    }, $Enumerable_inject$58.$$arity = -1);
    
    Opal.def(self, '$lazy', $Enumerable_lazy$59 = function $$lazy() {
      var $$60, self = this;

      return $send($$$($$($nesting, 'Enumerator'), 'Lazy'), 'new', [self, self.$enumerator_size()], ($$60 = function(enum$, $a){var self = $$60.$$s == null ? this : $$60.$$s, $post_args, args;

        
        
        if (enum$ == null) {
          enum$ = nil;
        };
        
        $post_args = Opal.slice.call(arguments, 1, arguments.length);
        
        args = $post_args;;
        return $send(enum$, 'yield', Opal.to_a(args));}, $$60.$$s = self, $$60.$$arity = -2, $$60))
    }, $Enumerable_lazy$59.$$arity = 0);
    
    Opal.def(self, '$enumerator_size', $Enumerable_enumerator_size$61 = function $$enumerator_size() {
      var self = this;

      if ($truthy(self['$respond_to?']("size"))) {
        return self.$size()
      } else {
        return nil
      }
    }, $Enumerable_enumerator_size$61.$$arity = 0);
    $alias(self, "map", "collect");
    
    Opal.def(self, '$max', $Enumerable_max$62 = function $$max(n) {
      var $iter = $Enumerable_max$62.$$p, block = $iter || nil, self = this;

      if ($iter) $Enumerable_max$62.$$p = null;
      
      
      if ($iter) $Enumerable_max$62.$$p = null;;
      ;
      
      if (n === undefined || n === nil) {
        var result, value;

        self.$each.$$p = function() {
          var item = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = item;
            return;
          }

          if (block !== nil) {
            value = Opal.yieldX(block, [item, result]);
          } else {
            value = (item)['$<=>'](result);
          }

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value > 0) {
            result = item;
          }
        }

        self.$each();

        if (result === undefined) {
          return nil;
        } else {
          return result;
        }
      }

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
    ;
      return $send(self, 'sort', [], block.$to_proc()).$reverse().$first(n);
    }, $Enumerable_max$62.$$arity = -1);
    
    Opal.def(self, '$max_by', $Enumerable_max_by$63 = function $$max_by(n) {
      var $iter = $Enumerable_max_by$63.$$p, block = $iter || nil, $$64, self = this;

      if ($iter) $Enumerable_max_by$63.$$p = null;
      
      
      if ($iter) $Enumerable_max_by$63.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["max_by", n], ($$64 = function(){var self = $$64.$$s == null ? this : $$64.$$s;

          return self.$enumerator_size()}, $$64.$$s = self, $$64.$$arity = 0, $$64))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$reverse().$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) > 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_max_by$63.$$arity = -1);
    $alias(self, "member?", "include?");
    
    Opal.def(self, '$min', $Enumerable_min$65 = function $$min(n) {
      var $iter = $Enumerable_min$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Enumerable_min$65.$$p = null;
      
      
      if ($iter) $Enumerable_min$65.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(n['$nil?']())) {
      } else if ((block !== nil)) {
        return $send(self, 'sort', [], ($$66 = function(a, b){var self = $$66.$$s == null ? this : $$66.$$s;

          
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return Opal.yieldX(block, [a, b]);;}, $$66.$$s = self, $$66.$$arity = 2, $$66)).$take(n)
      } else {
        return self.$sort().$take(n)
      };
      
      var result;

      if (block !== nil) {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          var value = block(param, result);

          if (value === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed");
          }

          if (value < 0) {
            result = param;
          }
        };
      }
      else {
        self.$each.$$p = function() {
          var param = $$($nesting, 'Opal').$destructure(arguments);

          if (result === undefined) {
            result = param;
            return;
          }

          if ($$($nesting, 'Opal').$compare(param, result) < 0) {
            result = param;
          }
        };
      }

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min$65.$$arity = -1);
    
    Opal.def(self, '$min_by', $Enumerable_min_by$67 = function $$min_by(n) {
      var $iter = $Enumerable_min_by$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Enumerable_min_by$67.$$p = null;
      
      
      if ($iter) $Enumerable_min_by$67.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["min_by", n], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

          return self.$enumerator_size()}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      if ($truthy(n['$nil?']())) {
      } else {
        return $send(self, 'sort_by', [], block.$to_proc()).$take(n)
      };
      
      var result,
          by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if (result === undefined) {
          result = param;
          by     = value;
          return;
        }

        if ((value)['$<=>'](by) < 0) {
          result = param
          by     = value;
        }
      };

      self.$each();

      return result === undefined ? nil : result;
    ;
    }, $Enumerable_min_by$67.$$arity = -1);
    
    Opal.def(self, '$minmax', $Enumerable_minmax$69 = function $$minmax() {
      var $iter = $Enumerable_minmax$69.$$p, block = $iter || nil, $$70, self = this, $ret_or_3 = nil;

      if ($iter) $Enumerable_minmax$69.$$p = null;
      
      
      if ($iter) $Enumerable_minmax$69.$$p = null;;
      block = (function() {if ($truthy(($ret_or_3 = block))) {
        return $ret_or_3
      } else {
        return $send(self, 'proc', [], ($$70 = function(a, b){var self = $$70.$$s == null ? this : $$70.$$s;

          
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$70.$$s = self, $$70.$$arity = 2, $$70))
      }; return nil; })();
      
      var min = nil, max = nil, first_time = true;

      self.$each.$$p = function() {
        var element = $$($nesting, 'Opal').$destructure(arguments);
        if (first_time) {
          min = max = element;
          first_time = false;
        } else {
          var min_cmp = block.$call(min, element);

          if (min_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (min_cmp > 0) {
            min = element;
          }

          var max_cmp = block.$call(max, element);

          if (max_cmp === nil) {
            self.$raise($$($nesting, 'ArgumentError'), "comparison failed")
          } else if (max_cmp < 0) {
            max = element;
          }
        }
      }

      self.$each();

      return [min, max];
    ;
    }, $Enumerable_minmax$69.$$arity = 0);
    
    Opal.def(self, '$minmax_by', $Enumerable_minmax_by$71 = function $$minmax_by() {
      var $iter = $Enumerable_minmax_by$71.$$p, block = $iter || nil, $$72, self = this;

      if ($iter) $Enumerable_minmax_by$71.$$p = null;
      
      
      if ($iter) $Enumerable_minmax_by$71.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["minmax_by"], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

          return self.$enumerator_size()}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var min_result = nil,
          max_result = nil,
          min_by,
          max_by;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ((min_by === undefined) || (value)['$<=>'](min_by) < 0) {
          min_result = param;
          min_by     = value;
        }

        if ((max_by === undefined) || (value)['$<=>'](max_by) > 0) {
          max_result = param;
          max_by     = value;
        }
      };

      self.$each();

      return [min_result, max_result];
    ;
    }, $Enumerable_minmax_by$71.$$arity = 0);
    
    Opal.def(self, '$none?', $Enumerable_none$ques$73 = function(pattern) {try {

      var $iter = $Enumerable_none$ques$73.$$p, block = $iter || nil, $$74, $$75, $$76, self = this;

      if ($iter) $Enumerable_none$ques$73.$$p = null;
      
      
      if ($iter) $Enumerable_none$ques$73.$$p = null;;
      ;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$74 = function($a){var self = $$74.$$s == null ? this : $$74.$$s, $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$74.$$s = self, $$74.$$arity = -1, $$74))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$75 = function($a){var self = $$75.$$s == null ? this : $$75.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$75.$$s = self, $$75.$$arity = -1, $$75))
      } else {
        $send(self, 'each', [], ($$76 = function($a){var self = $$76.$$s == null ? this : $$76.$$s, $post_args, value, item = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          item = $$($nesting, 'Opal').$destructure(value);
          if ($truthy(item)) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$76.$$s = self, $$76.$$arity = -1, $$76))
      };
      return true;
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_none$ques$73.$$arity = -1);
    
    Opal.def(self, '$one?', $Enumerable_one$ques$77 = function(pattern) {try {

      var $iter = $Enumerable_one$ques$77.$$p, block = $iter || nil, $$78, $$79, $$80, self = this, count = nil;

      if ($iter) $Enumerable_one$ques$77.$$p = null;
      
      
      if ($iter) $Enumerable_one$ques$77.$$p = null;;
      ;
      count = 0;
      if ($truthy(pattern !== undefined)) {
        $send(self, 'each', [], ($$78 = function($a){var self = $$78.$$s == null ? this : $$78.$$s, $post_args, value, comparable = nil;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          comparable = comparableForPattern(value);
          if ($truthy($send(pattern, 'public_send', ["==="].concat(Opal.to_a(comparable))))) {
            
            count = $rb_plus(count, 1);
            if ($truthy($rb_gt(count, 1))) {
              Opal.ret(false)
            } else {
              return nil
            };
          } else {
            return nil
          };}, $$78.$$s = self, $$78.$$arity = -1, $$78))
      } else if ((block !== nil)) {
        $send(self, 'each', [], ($$79 = function($a){var self = $$79.$$s == null ? this : $$79.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy(Opal.yieldX(block, Opal.to_a(value)))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$79.$$s = self, $$79.$$arity = -1, $$79))
      } else {
        $send(self, 'each', [], ($$80 = function($a){var self = $$80.$$s == null ? this : $$80.$$s, $post_args, value;

          
          
          $post_args = Opal.slice.call(arguments, 0, arguments.length);
          
          value = $post_args;;
          if ($truthy($$($nesting, 'Opal').$destructure(value))) {
          } else {
            return nil;
          };
          count = $rb_plus(count, 1);
          if ($truthy($rb_gt(count, 1))) {
            Opal.ret(false)
          } else {
            return nil
          };}, $$80.$$s = self, $$80.$$arity = -1, $$80))
      };
      return count['$=='](1);
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_one$ques$77.$$arity = -1);
    
    Opal.def(self, '$partition', $Enumerable_partition$81 = function $$partition() {
      var $iter = $Enumerable_partition$81.$$p, block = $iter || nil, $$82, self = this;

      if ($iter) $Enumerable_partition$81.$$p = null;
      
      
      if ($iter) $Enumerable_partition$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["partition"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

          return self.$enumerator_size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      
      var truthy = [], falsy = [], result;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($truthy(value)) {
          truthy.push(param);
        }
        else {
          falsy.push(param);
        }
      };

      self.$each();

      return [truthy, falsy];
    ;
    }, $Enumerable_partition$81.$$arity = 0);
    $alias(self, "reduce", "inject");
    
    Opal.def(self, '$reject', $Enumerable_reject$83 = function $$reject() {
      var $iter = $Enumerable_reject$83.$$p, block = $iter || nil, $$84, self = this;

      if ($iter) $Enumerable_reject$83.$$p = null;
      
      
      if ($iter) $Enumerable_reject$83.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$84 = function(){var self = $$84.$$s == null ? this : $$84.$$s;

          return self.$enumerator_size()}, $$84.$$s = self, $$84.$$arity = 0, $$84))
      };
      
      var result = [];

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = Opal.yield1(block, param);

        if ($falsy(value)) {
          result.push(param);
        }
      };

      self.$each();

      return result;
    ;
    }, $Enumerable_reject$83.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Enumerable_reverse_each$85 = function $$reverse_each() {
      var $iter = $Enumerable_reverse_each$85.$$p, block = $iter || nil, $$86, self = this;

      if ($iter) $Enumerable_reverse_each$85.$$p = null;
      
      
      if ($iter) $Enumerable_reverse_each$85.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$86 = function(){var self = $$86.$$s == null ? this : $$86.$$s;

          return self.$enumerator_size()}, $$86.$$s = self, $$86.$$arity = 0, $$86))
      };
      
      var result = [];

      self.$each.$$p = function() {
        result.push(arguments);
      };

      self.$each();

      for (var i = result.length - 1; i >= 0; i--) {
        Opal.yieldX(block, result[i]);
      }

      return result;
    ;
    }, $Enumerable_reverse_each$85.$$arity = 0);
    $alias(self, "select", "find_all");
    
    Opal.def(self, '$slice_before', $Enumerable_slice_before$87 = function $$slice_before(pattern) {
      var $iter = $Enumerable_slice_before$87.$$p, block = $iter || nil, $$88, self = this;

      if ($iter) $Enumerable_slice_before$87.$$p = null;
      
      
      if ($iter) $Enumerable_slice_before$87.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$88 = function(e){var self = $$88.$$s == null ? this : $$88.$$s;

        
        
        if (e == null) {
          e = nil;
        };
        
        var slice = [];

        if (block !== nil) {
          if (pattern === undefined) {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = Opal.yield1(block, param);

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
          else {
            self.$each.$$p = function() {
              var param = $$($nesting, 'Opal').$destructure(arguments),
                  value = block(param, pattern.$dup());

              if ($truthy(value) && slice.length > 0) {
                e['$<<'](slice);
                slice = [];
              }

              slice.push(param);
            };
          }
        }
        else {
          self.$each.$$p = function() {
            var param = $$($nesting, 'Opal').$destructure(arguments),
                value = pattern['$==='](param);

            if ($truthy(value) && slice.length > 0) {
              e['$<<'](slice);
              slice = [];
            }

            slice.push(param);
          };
        }

        self.$each();

        if (slice.length > 0) {
          e['$<<'](slice);
        }
      ;}, $$88.$$s = self, $$88.$$arity = 1, $$88));
    }, $Enumerable_slice_before$87.$$arity = -1);
    
    Opal.def(self, '$slice_after', $Enumerable_slice_after$89 = function $$slice_after(pattern) {
      var $iter = $Enumerable_slice_after$89.$$p, block = $iter || nil, $$90, $$91, self = this;

      if ($iter) $Enumerable_slice_after$89.$$p = null;
      
      
      if ($iter) $Enumerable_slice_after$89.$$p = null;;
      ;
      if ($truthy(pattern === undefined && block === nil)) {
        self.$raise($$($nesting, 'ArgumentError'), "both pattern and block are given")};
      if ($truthy(pattern !== undefined && block !== nil || arguments.length > 1)) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " expected 1)")};
      if ($truthy(pattern !== undefined)) {
        block = $send(self, 'proc', [], ($$90 = function(e){var self = $$90.$$s == null ? this : $$90.$$s;

          
          
          if (e == null) {
            e = nil;
          };
          return pattern['$==='](e);}, $$90.$$s = self, $$90.$$arity = 1, $$90))};
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$91 = function(yielder){var self = $$91.$$s == null ? this : $$91.$$s;

        
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var accumulate;

        self.$each.$$p = function() {
          var element = $$($nesting, 'Opal').$destructure(arguments),
              end_chunk = Opal.yield1(block, element);

          if (accumulate == null) {
            accumulate = [];
          }

          if ($truthy(end_chunk)) {
            accumulate.push(element);
            yielder.$yield(accumulate);
            accumulate = null;
          } else {
            accumulate.push(element)
          }
        }

        self.$each();

        if (accumulate != null) {
          yielder.$yield(accumulate);
        }
      ;}, $$91.$$s = self, $$91.$$arity = 1, $$91));
    }, $Enumerable_slice_after$89.$$arity = -1);
    
    Opal.def(self, '$slice_when', $Enumerable_slice_when$92 = function $$slice_when() {
      var $iter = $Enumerable_slice_when$92.$$p, block = $iter || nil, $$93, self = this;

      if ($iter) $Enumerable_slice_when$92.$$p = null;
      
      
      if ($iter) $Enumerable_slice_when$92.$$p = null;;
      if ((block !== nil)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1)")
      };
      return $send($$($nesting, 'Enumerator'), 'new', [], ($$93 = function(yielder){var self = $$93.$$s == null ? this : $$93.$$s;

        
        
        if (yielder == null) {
          yielder = nil;
        };
        
        var slice = nil, last_after = nil;

        self.$each_cons.$$p = function() {
          var params = $$($nesting, 'Opal').$destructure(arguments),
              before = params[0],
              after = params[1],
              match = Opal.yieldX(block, [before, after]);

          last_after = after;

          if (slice === nil) {
            slice = [];
          }

          if ($truthy(match)) {
            slice.push(before);
            yielder.$yield(slice);
            slice = [];
          } else {
            slice.push(before);
          }
        }

        self.$each_cons(2);

        if (slice !== nil) {
          slice.push(last_after);
          yielder.$yield(slice);
        }
      ;}, $$93.$$s = self, $$93.$$arity = 1, $$93));
    }, $Enumerable_slice_when$92.$$arity = 0);
    
    Opal.def(self, '$sort', $Enumerable_sort$94 = function $$sort() {
      var $iter = $Enumerable_sort$94.$$p, block = $iter || nil, $$95, self = this, ary = nil;

      if ($iter) $Enumerable_sort$94.$$p = null;
      
      
      if ($iter) $Enumerable_sort$94.$$p = null;;
      ary = self.$to_a();
      if ((block !== nil)) {
      } else {
        block = $lambda(($$95 = function(a, b){var self = $$95.$$s == null ? this : $$95.$$s;

          
          
          if (a == null) {
            a = nil;
          };
          
          if (b == null) {
            b = nil;
          };
          return a['$<=>'](b);}, $$95.$$s = self, $$95.$$arity = 2, $$95))
      };
      return $send(ary, 'sort', [], block.$to_proc());
    }, $Enumerable_sort$94.$$arity = 0);
    
    Opal.def(self, '$sort_by', $Enumerable_sort_by$96 = function $$sort_by() {
      var $iter = $Enumerable_sort_by$96.$$p, block = $iter || nil, $$97, $$98, $$99, $$100, self = this, dup = nil;

      if ($iter) $Enumerable_sort_by$96.$$p = null;
      
      
      if ($iter) $Enumerable_sort_by$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

          return self.$enumerator_size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      dup = $send(self, 'map', [], ($$98 = function(){var self = $$98.$$s == null ? this : $$98.$$s, arg = nil;

        
        arg = $$($nesting, 'Opal').$destructure(arguments);
        return [Opal.yield1(block, arg), arg];}, $$98.$$s = self, $$98.$$arity = 0, $$98));
      $send(dup, 'sort!', [], ($$99 = function(a, b){var self = $$99.$$s == null ? this : $$99.$$s;

        
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return (a[0])['$<=>'](b[0]);}, $$99.$$s = self, $$99.$$arity = 2, $$99));
      return $send(dup, 'map!', [], ($$100 = function(i){var self = $$100.$$s == null ? this : $$100.$$s;

        
        
        if (i == null) {
          i = nil;
        };
        return i[1];;}, $$100.$$s = self, $$100.$$arity = 1, $$100));
    }, $Enumerable_sort_by$96.$$arity = 0);
    
    Opal.def(self, '$sum', $Enumerable_sum$101 = function $$sum(initial) {
      var $$102, $iter = $Enumerable_sum$101.$$p, $yield = $iter || nil, self = this, result = nil;

      if ($iter) $Enumerable_sum$101.$$p = null;
      
      
      if (initial == null) {
        initial = 0;
      };
      result = initial;
      $send(self, 'each', [], ($$102 = function($a){var self = $$102.$$s == null ? this : $$102.$$s, $post_args, args, item = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        item = (function() {if (($yield !== nil)) {
          return Opal.yieldX($yield, Opal.to_a(args));
        } else {
          return $$($nesting, 'Opal').$destructure(args)
        }; return nil; })();
        return (result = $rb_plus(result, item));}, $$102.$$s = self, $$102.$$arity = -1, $$102));
      return result;
    }, $Enumerable_sum$101.$$arity = -1);
    
    Opal.def(self, '$take', $Enumerable_take$103 = function $$take(num) {
      var self = this;

      return self.$first(num)
    }, $Enumerable_take$103.$$arity = 1);
    
    Opal.def(self, '$take_while', $Enumerable_take_while$104 = function $$take_while() {try {

      var $iter = $Enumerable_take_while$104.$$p, block = $iter || nil, $$105, self = this, result = nil;

      if ($iter) $Enumerable_take_while$104.$$p = null;
      
      
      if ($iter) $Enumerable_take_while$104.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$enum_for("take_while")
      };
      result = [];
      return $send(self, 'each', [], ($$105 = function($a){var self = $$105.$$s == null ? this : $$105.$$s, $post_args, args, value = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        if ($truthy(Opal.yield1(block, value))) {
        } else {
          Opal.ret(result)
        };
        return result.push(value);;}, $$105.$$s = self, $$105.$$arity = -1, $$105));
      } catch ($returner) { if ($returner === Opal.returner) { return $returner.$v } throw $returner; }
    }, $Enumerable_take_while$104.$$arity = 0);
    
    Opal.def(self, '$uniq', $Enumerable_uniq$106 = function $$uniq() {
      var $iter = $Enumerable_uniq$106.$$p, block = $iter || nil, $$107, self = this, hash = nil;

      if ($iter) $Enumerable_uniq$106.$$p = null;
      
      
      if ($iter) $Enumerable_uniq$106.$$p = null;;
      hash = $hash2([], {});
      $send(self, 'each', [], ($$107 = function($a){var self = $$107.$$s == null ? this : $$107.$$s, $post_args, args, value = nil, produced = nil, $writer = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        value = $$($nesting, 'Opal').$destructure(args);
        produced = (function() {if ((block !== nil)) {
          return Opal.yield1(block, value);
        } else {
          return value
        }; return nil; })();
        if ($truthy(hash['$key?'](produced))) {
          return nil
        } else {
          
          $writer = [produced, value];
          $send(hash, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];
        };}, $$107.$$s = self, $$107.$$arity = -1, $$107));
      return hash.$values();
    }, $Enumerable_uniq$106.$$arity = 0);
    
    Opal.def(self, '$tally', $Enumerable_tally$108 = function $$tally() {
      var self = this;

      return $send($send(self, 'group_by', [], "itself".$to_proc()), 'transform_values', [], "count".$to_proc())
    }, $Enumerable_tally$108.$$arity = 0);
    $alias(self, "to_a", "entries");
    
    Opal.def(self, '$to_h', $Enumerable_to_h$109 = function $$to_h($a) {
      var $iter = $Enumerable_to_h$109.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Enumerable_to_h$109.$$p = null;
      
      
      if ($iter) $Enumerable_to_h$109.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(args))};
      
      var hash = $hash2([], {});

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments);
        var ary = $$($nesting, 'Opal')['$coerce_to?'](param, $$($nesting, 'Array'), "to_ary"), key, val;
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];

        Opal.hash_put(hash, key, val);
      };

      self.$each.apply(self, args);

      return hash;
    ;
    }, $Enumerable_to_h$109.$$arity = -1);
    return (Opal.def(self, '$zip', $Enumerable_zip$110 = function $$zip($a) {
      var $iter = $Enumerable_zip$110.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Enumerable_zip$110.$$p = null;
      
      
      if ($iter) $Enumerable_zip$110.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$to_a(), 'zip', Opal.to_a(others));
    }, $Enumerable_zip$110.$$arity = -1), nil) && 'zip';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/enumerator"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $breaker = Opal.breaker, $slice = Opal.slice, $falsy = Opal.falsy, $truthy = Opal.truthy, $coerce_to = Opal.coerce_to, $klass = Opal.klass, $send = Opal.send, $alias = Opal.alias, $send2 = Opal.send2;

  Opal.add_stubs(['$require', '$include', '$allocate', '$new', '$to_proc', '$!', '$respond_to?', '$nil?', '$empty?', '$+', '$class', '$__send__', '$call', '$enum_for', '$size', '$destructure', '$inspect', '$any?', '$[]', '$raise', '$yield', '$each', '$enumerator_size', '$try_convert', '$<', '$===', '$for']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Enumerator');

    var $nesting = [self].concat($parent_nesting), $Enumerator_for$1, $Enumerator_initialize$2, $Enumerator_each$3, $Enumerator_size$4, $Enumerator_with_index$5, $Enumerator_each_with_index$7, $Enumerator_inspect$9;

    self.$$prototype.size = self.$$prototype.args = self.$$prototype.object = self.$$prototype.method = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_enumerator = true;
    Opal.defs(self, '$for', $Enumerator_for$1 = function(object, $a, $b) {
      var $iter = $Enumerator_for$1.$$p, block = $iter || nil, $post_args, method, args, self = this;

      if ($iter) $Enumerator_for$1.$$p = null;
      
      
      if ($iter) $Enumerator_for$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      if ($post_args.length > 0) {
        method = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (method == null) {
        method = "each";
      };
      
      args = $post_args;;
      
      var obj = self.$allocate();

      obj.object = object;
      obj.size   = block;
      obj.method = method;
      obj.args   = args;

      return obj;
    ;
    }, $Enumerator_for$1.$$arity = -2);
    
    Opal.def(self, '$initialize', $Enumerator_initialize$2 = function $$initialize($a) {
      var $iter = $Enumerator_initialize$2.$$p, block = $iter || nil, $post_args, self = this, $ret_or_1 = nil;

      if ($iter) $Enumerator_initialize$2.$$p = null;
      
      
      if ($iter) $Enumerator_initialize$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      if ($truthy(block)) {
        
        self.object = $send($$($nesting, 'Generator'), 'new', [], block.$to_proc());
        self.method = "each";
        self.args = [];
        self.size = arguments[0] || nil;
        if ($truthy((function() {if ($truthy(($ret_or_1 = self.size))) {
          return self.size['$respond_to?']("call")['$!']()
        } else {
          return $ret_or_1
        }; return nil; })())) {
          return (self.size = $coerce_to(self.size, $$($nesting, 'Integer'), 'to_int'))
        } else {
          return nil
        };
      } else {
        
        self.object = arguments[0];
        self.method = arguments[1] || "each";
        self.args = $slice.call(arguments, 2);
        return (self.size = nil);
      };
    }, $Enumerator_initialize$2.$$arity = -1);
    
    Opal.def(self, '$each', $Enumerator_each$3 = function $$each($a) {
      var $iter = $Enumerator_each$3.$$p, block = $iter || nil, $post_args, args, self = this, $ret_or_2 = nil;

      if ($iter) $Enumerator_each$3.$$p = null;
      
      
      if ($iter) $Enumerator_each$3.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_2 = block['$nil?']()))) {
        return args['$empty?']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self};
      args = $rb_plus(self.args, args);
      if ($truthy(block['$nil?']())) {
        return $send(self.$class(), 'new', [self.object, self.method].concat(Opal.to_a(args)))};
      return $send(self.object, '__send__', [self.method].concat(Opal.to_a(args)), block.$to_proc());
    }, $Enumerator_each$3.$$arity = -1);
    
    Opal.def(self, '$size', $Enumerator_size$4 = function $$size() {
      var self = this;

      if ($truthy(self.size['$respond_to?']("call"))) {
        return $send(self.size, 'call', Opal.to_a(self.args))
      } else {
        return self.size
      }
    }, $Enumerator_size$4.$$arity = 0);
    
    Opal.def(self, '$with_index', $Enumerator_with_index$5 = function $$with_index(offset) {
      var $iter = $Enumerator_with_index$5.$$p, block = $iter || nil, $$6, self = this;

      if ($iter) $Enumerator_with_index$5.$$p = null;
      
      
      if ($iter) $Enumerator_with_index$5.$$p = null;;
      
      if (offset == null) {
        offset = 0;
      };
      offset = (function() {if ($truthy(offset)) {
        return $coerce_to(offset, $$($nesting, 'Integer'), 'to_int')
      } else {
        return 0
      }; return nil; })();
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["with_index", offset], ($$6 = function(){var self = $$6.$$s == null ? this : $$6.$$s;

          return self.$size()}, $$6.$$s = self, $$6.$$arity = 0, $$6))
      };
      
      var result, index = offset;

      self.$each.$$p = function() {
        var param = $$($nesting, 'Opal').$destructure(arguments),
            value = block(param, index);

        index++;

        return value;
      }

      return self.$each();
    ;
    }, $Enumerator_with_index$5.$$arity = -1);
    $alias(self, "with_object", "each_with_object");
    
    Opal.def(self, '$each_with_index', $Enumerator_each_with_index$7 = function $$each_with_index() {
      var $iter = $Enumerator_each_with_index$7.$$p, block = $iter || nil, $$8, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Enumerator_each_with_index$7.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Enumerator_each_with_index$7.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_with_index"], ($$8 = function(){var self = $$8.$$s == null ? this : $$8.$$s;

          return self.$size()}, $$8.$$s = self, $$8.$$arity = 0, $$8))
      };
      $send2(self, Opal.find_super_dispatcher(self, 'each_with_index', $Enumerator_each_with_index$7, false, true), 'each_with_index', $zuper, $iter);
      return self.object;
    }, $Enumerator_each_with_index$7.$$arity = 0);
    
    Opal.def(self, '$inspect', $Enumerator_inspect$9 = function $$inspect() {
      var self = this, result = nil;

      
      result = "" + "#<" + (self.$class()) + ": " + (self.object.$inspect()) + ":" + (self.method);
      if ($truthy(self.args['$any?']())) {
        result = $rb_plus(result, "" + "(" + (self.args.$inspect()['$[]']($$($nesting, 'Range').$new(1, -2))) + ")")};
      return $rb_plus(result, ">");
    }, $Enumerator_inspect$9.$$arity = 0);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Generator');

      var $nesting = [self].concat($parent_nesting), $Generator_initialize$10, $Generator_each$11;

      self.$$prototype.block = nil;
      
      self.$include($$($nesting, 'Enumerable'));
      
      Opal.def(self, '$initialize', $Generator_initialize$10 = function $$initialize() {
        var $iter = $Generator_initialize$10.$$p, block = $iter || nil, self = this;

        if ($iter) $Generator_initialize$10.$$p = null;
        
        
        if ($iter) $Generator_initialize$10.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'LocalJumpError'), "no block given")
        };
        return (self.block = block);
      }, $Generator_initialize$10.$$arity = 0);
      return (Opal.def(self, '$each', $Generator_each$11 = function $$each($a) {
        var $iter = $Generator_each$11.$$p, block = $iter || nil, $post_args, args, self = this, yielder = nil;

        if ($iter) $Generator_each$11.$$p = null;
        
        
        if ($iter) $Generator_each$11.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        yielder = $send($$($nesting, 'Yielder'), 'new', [], block.$to_proc());
        
        try {
          args.unshift(yielder);

          Opal.yieldX(self.block, args);
        }
        catch (e) {
          if (e === $breaker) {
            return $breaker.$v;
          }
          else {
            throw e;
          }
        }
      ;
        return self;
      }, $Generator_each$11.$$arity = -1), nil) && 'each';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Yielder');

      var $nesting = [self].concat($parent_nesting), $Yielder_initialize$12, $Yielder_yield$13, $Yielder_$lt$lt$14;

      self.$$prototype.block = nil;
      
      
      Opal.def(self, '$initialize', $Yielder_initialize$12 = function $$initialize() {
        var $iter = $Yielder_initialize$12.$$p, block = $iter || nil, self = this;

        if ($iter) $Yielder_initialize$12.$$p = null;
        
        
        if ($iter) $Yielder_initialize$12.$$p = null;;
        return (self.block = block);
      }, $Yielder_initialize$12.$$arity = 0);
      
      Opal.def(self, '$yield', $Yielder_yield$13 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        
        var value = Opal.yieldX(self.block, values);

        if (value === $breaker) {
          throw $breaker;
        }

        return value;
      ;
      }, $Yielder_yield$13.$$arity = -1);
      return (Opal.def(self, '$<<', $Yielder_$lt$lt$14 = function($a) {
        var $post_args, values, self = this;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        values = $post_args;;
        $send(self, 'yield', Opal.to_a(values));
        return self;
      }, $Yielder_$lt$lt$14.$$arity = -1), nil) && '<<';
    })($nesting[0], null, $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Lazy');

      var $nesting = [self].concat($parent_nesting), $Lazy_initialize$15, $Lazy_lazy$18, $Lazy_collect$19, $Lazy_collect_concat$21, $Lazy_drop$25, $Lazy_drop_while$27, $Lazy_enum_for$29, $Lazy_find_all$30, $Lazy_grep$32, $Lazy_reject$35, $Lazy_take$37, $Lazy_take_while$39, $Lazy_inspect$41;

      self.$$prototype.enumerator = nil;
      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'StopLazyError');

        var $nesting = [self].concat($parent_nesting);

        return nil
      })($nesting[0], $$($nesting, 'Exception'), $nesting);
      
      Opal.def(self, '$initialize', $Lazy_initialize$15 = function $$initialize(object, size) {
        var $iter = $Lazy_initialize$15.$$p, block = $iter || nil, $$16, self = this;

        if ($iter) $Lazy_initialize$15.$$p = null;
        
        
        if ($iter) $Lazy_initialize$15.$$p = null;;
        
        if (size == null) {
          size = nil;
        };
        if ((block !== nil)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy new without a block")
        };
        self.enumerator = object;
        return $send2(self, Opal.find_super_dispatcher(self, 'initialize', $Lazy_initialize$15, false, true), 'initialize', [size], ($$16 = function(yielder, $a){var self = $$16.$$s == null ? this : $$16.$$s, $post_args, each_args, $$17;

          
          
          if (yielder == null) {
            yielder = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          each_args = $post_args;;
          try {
            return $send(object, 'each', Opal.to_a(each_args), ($$17 = function($b){var self = $$17.$$s == null ? this : $$17.$$s, $post_args, args;

              
              
              $post_args = Opal.slice.call(arguments, 0, arguments.length);
              
              args = $post_args;;
              
            args.unshift(yielder);

            Opal.yieldX(block, args);
          ;}, $$17.$$s = self, $$17.$$arity = -1, $$17))
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'Exception')])) {
              try {
                return nil
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };}, $$16.$$s = self, $$16.$$arity = -2, $$16));
      }, $Lazy_initialize$15.$$arity = -2);
      $alias(self, "force", "to_a");
      
      Opal.def(self, '$lazy', $Lazy_lazy$18 = function $$lazy() {
        var self = this;

        return self
      }, $Lazy_lazy$18.$$arity = 0);
      
      Opal.def(self, '$collect', $Lazy_collect$19 = function $$collect() {
        var $iter = $Lazy_collect$19.$$p, block = $iter || nil, $$20, self = this;

        if ($iter) $Lazy_collect$19.$$p = null;
        
        
        if ($iter) $Lazy_collect$19.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, self.$enumerator_size()], ($$20 = function(enum$, $a){var self = $$20.$$s == null ? this : $$20.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          enum$.$yield(value);
        ;}, $$20.$$s = self, $$20.$$arity = -2, $$20));
      }, $Lazy_collect$19.$$arity = 0);
      
      Opal.def(self, '$collect_concat', $Lazy_collect_concat$21 = function $$collect_concat() {
        var $iter = $Lazy_collect_concat$21.$$p, block = $iter || nil, $$22, self = this;

        if ($iter) $Lazy_collect_concat$21.$$p = null;
        
        
        if ($iter) $Lazy_collect_concat$21.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy map without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$22 = function(enum$, $a){var self = $$22.$$s == null ? this : $$22.$$s, $post_args, args, $$23, $$24;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ((value)['$respond_to?']("force") && (value)['$respond_to?']("each")) {
            $send((value), 'each', [], ($$23 = function(v){var self = $$23.$$s == null ? this : $$23.$$s;

            
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$23.$$s = self, $$23.$$arity = 1, $$23))
          }
          else {
            var array = $$($nesting, 'Opal').$try_convert(value, $$($nesting, 'Array'), "to_ary");

            if (array === nil) {
              enum$.$yield(value);
            }
            else {
              $send((value), 'each', [], ($$24 = function(v){var self = $$24.$$s == null ? this : $$24.$$s;

            
            
            if (v == null) {
              v = nil;
            };
            return enum$.$yield(v);}, $$24.$$s = self, $$24.$$arity = 1, $$24));
            }
          }
        ;}, $$22.$$s = self, $$22.$$arity = -2, $$22));
      }, $Lazy_collect_concat$21.$$arity = 0);
      
      Opal.def(self, '$drop', $Lazy_drop$25 = function $$drop(n) {
        var $$26, self = this, current_size = nil, set_size = nil, dropped = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to drop negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        dropped = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$26 = function(enum$, $a){var self = $$26.$$s == null ? this : $$26.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(dropped, n))) {
            return (dropped = $rb_plus(dropped, 1))
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$26.$$s = self, $$26.$$arity = -2, $$26));
      }, $Lazy_drop$25.$$arity = 1);
      
      Opal.def(self, '$drop_while', $Lazy_drop_while$27 = function $$drop_while() {
        var $iter = $Lazy_drop_while$27.$$p, block = $iter || nil, $$28, self = this, succeeding = nil;

        if ($iter) $Lazy_drop_while$27.$$p = null;
        
        
        if ($iter) $Lazy_drop_while$27.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy drop_while without a block")
        };
        succeeding = true;
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$28 = function(enum$, $a){var self = $$28.$$s == null ? this : $$28.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy(succeeding)) {
            
            var value = Opal.yieldX(block, args);

            if ($falsy(value)) {
              succeeding = false;

              $send(enum$, 'yield', Opal.to_a(args));
            }
          
          } else {
            return $send(enum$, 'yield', Opal.to_a(args))
          };}, $$28.$$s = self, $$28.$$arity = -2, $$28));
      }, $Lazy_drop_while$27.$$arity = 0);
      
      Opal.def(self, '$enum_for', $Lazy_enum_for$29 = function $$enum_for($a, $b) {
        var $iter = $Lazy_enum_for$29.$$p, block = $iter || nil, $post_args, method, args, self = this;

        if ($iter) $Lazy_enum_for$29.$$p = null;
        
        
        if ($iter) $Lazy_enum_for$29.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        if ($post_args.length > 0) {
          method = $post_args[0];
          $post_args.splice(0, 1);
        }
        if (method == null) {
          method = "each";
        };
        
        args = $post_args;;
        return $send(self.$class(), 'for', [self, method].concat(Opal.to_a(args)), block.$to_proc());
      }, $Lazy_enum_for$29.$$arity = -1);
      $alias(self, "filter", "find_all");
      
      Opal.def(self, '$find_all', $Lazy_find_all$30 = function $$find_all() {
        var $iter = $Lazy_find_all$30.$$p, block = $iter || nil, $$31, self = this;

        if ($iter) $Lazy_find_all$30.$$p = null;
        
        
        if ($iter) $Lazy_find_all$30.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy select without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$31 = function(enum$, $a){var self = $$31.$$s == null ? this : $$31.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$31.$$s = self, $$31.$$arity = -2, $$31));
      }, $Lazy_find_all$30.$$arity = 0);
      $alias(self, "flat_map", "collect_concat");
      
      Opal.def(self, '$grep', $Lazy_grep$32 = function $$grep(pattern) {
        var $iter = $Lazy_grep$32.$$p, block = $iter || nil, $$33, $$34, self = this;

        if ($iter) $Lazy_grep$32.$$p = null;
        
        
        if ($iter) $Lazy_grep$32.$$p = null;;
        if ($truthy(block)) {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$33 = function(enum$, $a){var self = $$33.$$s == null ? this : $$33.$$s, $post_args, args;

            
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              value = Opal.yield1(block, param);

              enum$.$yield(Opal.yield1(block, param));
            }
          ;}, $$33.$$s = self, $$33.$$arity = -2, $$33))
        } else {
          return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$34 = function(enum$, $a){var self = $$34.$$s == null ? this : $$34.$$s, $post_args, args;

            
            
            if (enum$ == null) {
              enum$ = nil;
            };
            
            $post_args = Opal.slice.call(arguments, 1, arguments.length);
            
            args = $post_args;;
            
            var param = $$($nesting, 'Opal').$destructure(args),
                value = pattern['$==='](param);

            if ($truthy(value)) {
              enum$.$yield(param);
            }
          ;}, $$34.$$s = self, $$34.$$arity = -2, $$34))
        };
      }, $Lazy_grep$32.$$arity = 1);
      $alias(self, "map", "collect");
      $alias(self, "select", "find_all");
      
      Opal.def(self, '$reject', $Lazy_reject$35 = function $$reject() {
        var $iter = $Lazy_reject$35.$$p, block = $iter || nil, $$36, self = this;

        if ($iter) $Lazy_reject$35.$$p = null;
        
        
        if ($iter) $Lazy_reject$35.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy reject without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$36 = function(enum$, $a){var self = $$36.$$s == null ? this : $$36.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($falsy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
        ;}, $$36.$$s = self, $$36.$$arity = -2, $$36));
      }, $Lazy_reject$35.$$arity = 0);
      
      Opal.def(self, '$take', $Lazy_take$37 = function $$take(n) {
        var $$38, self = this, current_size = nil, set_size = nil, taken = nil;

        
        n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int');
        if ($truthy($rb_lt(n, 0))) {
          self.$raise($$($nesting, 'ArgumentError'), "attempt to take negative size")};
        current_size = self.$enumerator_size();
        set_size = (function() {if ($truthy($$($nesting, 'Integer')['$==='](current_size))) {
          if ($truthy($rb_lt(n, current_size))) {
            return n
          } else {
            return current_size
          }
        } else {
          return current_size
        }; return nil; })();
        taken = 0;
        return $send($$($nesting, 'Lazy'), 'new', [self, set_size], ($$38 = function(enum$, $a){var self = $$38.$$s == null ? this : $$38.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          if ($truthy($rb_lt(taken, n))) {
            
            $send(enum$, 'yield', Opal.to_a(args));
            return (taken = $rb_plus(taken, 1));
          } else {
            return self.$raise($$($nesting, 'StopLazyError'))
          };}, $$38.$$s = self, $$38.$$arity = -2, $$38));
      }, $Lazy_take$37.$$arity = 1);
      
      Opal.def(self, '$take_while', $Lazy_take_while$39 = function $$take_while() {
        var $iter = $Lazy_take_while$39.$$p, block = $iter || nil, $$40, self = this;

        if ($iter) $Lazy_take_while$39.$$p = null;
        
        
        if ($iter) $Lazy_take_while$39.$$p = null;;
        if ($truthy(block)) {
        } else {
          self.$raise($$($nesting, 'ArgumentError'), "tried to call lazy take_while without a block")
        };
        return $send($$($nesting, 'Lazy'), 'new', [self, nil], ($$40 = function(enum$, $a){var self = $$40.$$s == null ? this : $$40.$$s, $post_args, args;

          
          
          if (enum$ == null) {
            enum$ = nil;
          };
          
          $post_args = Opal.slice.call(arguments, 1, arguments.length);
          
          args = $post_args;;
          
          var value = Opal.yieldX(block, args);

          if ($truthy(value)) {
            $send(enum$, 'yield', Opal.to_a(args));
          }
          else {
            self.$raise($$($nesting, 'StopLazyError'));
          }
        ;}, $$40.$$s = self, $$40.$$arity = -2, $$40));
      }, $Lazy_take_while$39.$$arity = 0);
      $alias(self, "to_enum", "enum_for");
      return (Opal.def(self, '$inspect', $Lazy_inspect$41 = function $$inspect() {
        var self = this;

        return "" + "#<" + (self.$class()) + ": " + (self.enumerator.$inspect()) + ">"
      }, $Lazy_inspect$41.$$arity = 0), nil) && 'inspect';
    })($nesting[0], self, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ArithmeticSequence');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], self, $nesting);
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/numeric"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $hash2 = Opal.hash2, $send = Opal.send;

  Opal.add_stubs(['$require', '$include', '$instance_of?', '$class', '$Float', '$respond_to?', '$coerce', '$__send__', '$===', '$raise', '$equal?', '$-', '$*', '$div', '$<', '$-@', '$ceil', '$to_f', '$denominator', '$to_r', '$==', '$floor', '$/', '$%', '$Complex', '$zero?', '$numerator', '$abs', '$arg', '$coerce_to!', '$round', '$<=>', '$compare', '$enum_for', '$to_proc', '$negative?', '$>=', '$<=', '$+', '$to_i', '$truncate', '$>']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Numeric');

    var $nesting = [self].concat($parent_nesting), $Numeric_coerce$1, $Numeric___coerced__$2, $Numeric_$lt_eq_gt$3, $Numeric_$plus$$4, $Numeric_$minus$$5, $Numeric_$percent$6, $Numeric_abs$7, $Numeric_abs2$8, $Numeric_angle$9, $Numeric_ceil$10, $Numeric_conj$11, $Numeric_denominator$12, $Numeric_div$13, $Numeric_divmod$14, $Numeric_fdiv$15, $Numeric_floor$16, $Numeric_i$17, $Numeric_imag$18, $Numeric_integer$ques$19, $Numeric_nonzero$ques$20, $Numeric_numerator$21, $Numeric_polar$22, $Numeric_quo$23, $Numeric_real$24, $Numeric_real$ques$25, $Numeric_rect$26, $Numeric_round$27, $Numeric_step$28, $Numeric_to_c$29, $Numeric_to_int$30, $Numeric_truncate$31, $Numeric_zero$ques$32, $Numeric_positive$ques$33, $Numeric_negative$ques$34, $Numeric_dup$35, $Numeric_clone$36, $Numeric_finite$ques$37, $Numeric_infinite$ques$38;

    
    self.$include($$($nesting, 'Comparable'));
    
    Opal.def(self, '$coerce', $Numeric_coerce$1 = function $$coerce(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
        return [other, self]};
      return [self.$Float(other), self.$Float(self)];
    }, $Numeric_coerce$1.$$arity = 1);
    
    Opal.def(self, '$__coerced__', $Numeric___coerced__$2 = function $$__coerced__(method, other) {
      var $a, $b, self = this, a = nil, b = nil, $case = nil;

      if ($truthy(other['$respond_to?']("coerce"))) {
        
        $b = other.$coerce(self), $a = Opal.to_ary($b), (a = ($a[0] == null ? nil : $a[0])), (b = ($a[1] == null ? nil : $a[1])), $b;
        return a.$__send__(method, b);
      } else {
        return (function() {$case = method;
        if ("+"['$===']($case) || "-"['$===']($case) || "*"['$===']($case) || "/"['$===']($case) || "%"['$===']($case) || "&"['$===']($case) || "|"['$===']($case) || "^"['$===']($case) || "**"['$===']($case)) {return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Numeric")}
        else if (">"['$===']($case) || ">="['$===']($case) || "<"['$===']($case) || "<="['$===']($case) || "<=>"['$===']($case)) {return self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (other.$class()) + " failed")}
        else { return nil }})()
      }
    }, $Numeric___coerced__$2.$$arity = 2);
    
    Opal.def(self, '$<=>', $Numeric_$lt_eq_gt$3 = function(other) {
      var self = this;

      
      if ($truthy(self['$equal?'](other))) {
        return 0};
      return nil;
    }, $Numeric_$lt_eq_gt$3.$$arity = 1);
    
    Opal.def(self, '$+@', $Numeric_$plus$$4 = function() {
      var self = this;

      return self
    }, $Numeric_$plus$$4.$$arity = 0);
    
    Opal.def(self, '$-@', $Numeric_$minus$$5 = function() {
      var self = this;

      return $rb_minus(0, self)
    }, $Numeric_$minus$$5.$$arity = 0);
    
    Opal.def(self, '$%', $Numeric_$percent$6 = function(other) {
      var self = this;

      return $rb_minus(self, $rb_times(other, self.$div(other)))
    }, $Numeric_$percent$6.$$arity = 1);
    
    Opal.def(self, '$abs', $Numeric_abs$7 = function $$abs() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return self['$-@']()
      } else {
        return self
      }
    }, $Numeric_abs$7.$$arity = 0);
    
    Opal.def(self, '$abs2', $Numeric_abs2$8 = function $$abs2() {
      var self = this;

      return $rb_times(self, self)
    }, $Numeric_abs2$8.$$arity = 0);
    
    Opal.def(self, '$angle', $Numeric_angle$9 = function $$angle() {
      var self = this;

      if ($rb_lt(self, 0)) {
        return $$$($$($nesting, 'Math'), 'PI')
      } else {
        return 0
      }
    }, $Numeric_angle$9.$$arity = 0);
    $alias(self, "arg", "angle");
    
    Opal.def(self, '$ceil', $Numeric_ceil$10 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$ceil(ndigits);
    }, $Numeric_ceil$10.$$arity = -1);
    
    Opal.def(self, '$conj', $Numeric_conj$11 = function $$conj() {
      var self = this;

      return self
    }, $Numeric_conj$11.$$arity = 0);
    $alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Numeric_denominator$12 = function $$denominator() {
      var self = this;

      return self.$to_r().$denominator()
    }, $Numeric_denominator$12.$$arity = 0);
    
    Opal.def(self, '$div', $Numeric_div$13 = function $$div(other) {
      var self = this;

      
      if (other['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by o")};
      return $rb_divide(self, other).$floor();
    }, $Numeric_div$13.$$arity = 1);
    
    Opal.def(self, '$divmod', $Numeric_divmod$14 = function $$divmod(other) {
      var self = this;

      return [self.$div(other), self['$%'](other)]
    }, $Numeric_divmod$14.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Numeric_fdiv$15 = function $$fdiv(other) {
      var self = this;

      return $rb_divide(self.$to_f(), other)
    }, $Numeric_fdiv$15.$$arity = 1);
    
    Opal.def(self, '$floor', $Numeric_floor$16 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$floor(ndigits);
    }, $Numeric_floor$16.$$arity = -1);
    
    Opal.def(self, '$i', $Numeric_i$17 = function $$i() {
      var self = this;

      return self.$Complex(0, self)
    }, $Numeric_i$17.$$arity = 0);
    
    Opal.def(self, '$imag', $Numeric_imag$18 = function $$imag() {
      var self = this;

      return 0
    }, $Numeric_imag$18.$$arity = 0);
    $alias(self, "imaginary", "imag");
    
    Opal.def(self, '$integer?', $Numeric_integer$ques$19 = function() {
      var self = this;

      return false
    }, $Numeric_integer$ques$19.$$arity = 0);
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    
    Opal.def(self, '$nonzero?', $Numeric_nonzero$ques$20 = function() {
      var self = this;

      if ($truthy(self['$zero?']())) {
        return nil
      } else {
        return self
      }
    }, $Numeric_nonzero$ques$20.$$arity = 0);
    
    Opal.def(self, '$numerator', $Numeric_numerator$21 = function $$numerator() {
      var self = this;

      return self.$to_r().$numerator()
    }, $Numeric_numerator$21.$$arity = 0);
    $alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Numeric_polar$22 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Numeric_polar$22.$$arity = 0);
    
    Opal.def(self, '$quo', $Numeric_quo$23 = function $$quo(other) {
      var self = this;

      return $rb_divide($$($nesting, 'Opal')['$coerce_to!'](self, $$($nesting, 'Rational'), "to_r"), other)
    }, $Numeric_quo$23.$$arity = 1);
    
    Opal.def(self, '$real', $Numeric_real$24 = function $$real() {
      var self = this;

      return self
    }, $Numeric_real$24.$$arity = 0);
    
    Opal.def(self, '$real?', $Numeric_real$ques$25 = function() {
      var self = this;

      return true
    }, $Numeric_real$ques$25.$$arity = 0);
    
    Opal.def(self, '$rect', $Numeric_rect$26 = function $$rect() {
      var self = this;

      return [self, 0]
    }, $Numeric_rect$26.$$arity = 0);
    $alias(self, "rectangular", "rect");
    
    Opal.def(self, '$round', $Numeric_round$27 = function $$round(digits) {
      var self = this;

      
      ;
      return self.$to_f().$round(digits);
    }, $Numeric_round$27.$$arity = -1);
    
    Opal.def(self, '$step', $Numeric_step$28 = function $$step($a, $b, $c) {
      var $iter = $Numeric_step$28.$$p, block = $iter || nil, $post_args, $kwargs, limit, step, to, by, $d, self = this, counter = nil;

      if ($iter) $Numeric_step$28.$$p = null;
      
      
      if ($iter) $Numeric_step$28.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      if ($post_args.length > 0) {
        limit = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      if ($post_args.length > 0) {
        step = $post_args[0];
        $post_args.splice(0, 1);
      };
      
      to = $kwargs.$$smap["to"];;
      
      by = $kwargs.$$smap["by"];;
      
      if (limit !== undefined && to !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "to is given twice")
      }

      if (step !== undefined && by !== undefined) {
        self.$raise($$($nesting, 'ArgumentError'), "step is given twice")
      }

      if (to !== undefined) {
        limit = to;
      }

      if (by !== undefined) {
        step = by;
      }

      if (limit === undefined) {
        limit = nil;
      }

      function validateParameters() {
        if (step === nil) {
          self.$raise($$($nesting, 'TypeError'), "step must be numeric")
        }

        if (step != null && step['$=='](0)) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }

        if (step === nil || step == null) {
          step = 1;
        }

        var sign = step['$<=>'](0);

        if (sign === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "0 can't be coerced into " + (step.$class()))
        }

        if (limit === nil || limit == null) {
          limit = sign > 0 ? $$$($$($nesting, 'Float'), 'INFINITY') : $$$($$($nesting, 'Float'), 'INFINITY')['$-@']();
        }

        $$($nesting, 'Opal').$compare(self, limit)
      }

      function stepFloatSize() {
        if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else if (step === Infinity || step === -Infinity) {
          return 1;
        } else {
          var abs = Math.abs, floor = Math.floor,
              err = (abs(self) + abs(limit) + abs(limit - self)) / abs(step) * $$$($$($nesting, 'Float'), 'EPSILON');

          if (err === Infinity || err === -Infinity) {
            return 0;
          } else {
            if (err > 0.5) {
              err = 0.5;
            }

            return floor((limit - self) / step + err) + 1
          }
        }
      }

      function stepSize() {
        validateParameters();

        if (step === 0) {
          return Infinity;
        }

        if (step % 1 !== 0) {
          return stepFloatSize();
        } else if ((step > 0 && self > limit) || (step < 0 && self < limit)) {
          return 0;
        } else {
          var ceil = Math.ceil, abs = Math.abs,
              lhs = abs(self - limit) + 1,
              rhs = abs(step);

          return ceil(lhs / rhs);
        }
      }

    ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", limit, step], (stepSize).$to_proc())
      };
      
      validateParameters();

      var isDesc = step['$negative?'](),
          isInf = step['$=='](0) ||
                  (limit === Infinity && !isDesc) ||
                  (limit === -Infinity && isDesc);

      if (self.$$is_number && step.$$is_number && limit.$$is_number) {
        if (self % 1 === 0 && (isInf || limit % 1 === 0) && step % 1 === 0) {
          var value = self;

          if (isInf) {
            for (;; value += step) {
              block(value);
            }
          } else if (isDesc) {
            for (; value >= limit; value += step) {
              block(value);
            }
          } else {
            for (; value <= limit; value += step) {
              block(value);
            }
          }

          return self;
        } else {
          var begin = self.$to_f().valueOf();
          step = step.$to_f().valueOf();
          limit = limit.$to_f().valueOf();

          var n = stepFloatSize();

          if (!isFinite(step)) {
            if (n !== 0) block(begin);
          } else if (step === 0) {
            while (true) {
              block(begin);
            }
          } else {
            for (var i = 0; i < n; i++) {
              var d = i * step + self;
              if (step >= 0 ? limit < d : limit > d) {
                d = limit;
              }
              block(d);
            }
          }

          return self;
        }
      }
    ;
      counter = self;
      while ($truthy(isDesc ? $rb_ge(counter, limit) : $rb_le(counter, limit))) {
        
        Opal.yield1(block, counter);
        counter = $rb_plus(counter, step);
      };
    }, $Numeric_step$28.$$arity = -1);
    
    Opal.def(self, '$to_c', $Numeric_to_c$29 = function $$to_c() {
      var self = this;

      return self.$Complex(self, 0)
    }, $Numeric_to_c$29.$$arity = 0);
    
    Opal.def(self, '$to_int', $Numeric_to_int$30 = function $$to_int() {
      var self = this;

      return self.$to_i()
    }, $Numeric_to_int$30.$$arity = 0);
    
    Opal.def(self, '$truncate', $Numeric_truncate$31 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      return self.$to_f().$truncate(ndigits);
    }, $Numeric_truncate$31.$$arity = -1);
    
    Opal.def(self, '$zero?', $Numeric_zero$ques$32 = function() {
      var self = this;

      return self['$=='](0)
    }, $Numeric_zero$ques$32.$$arity = 0);
    
    Opal.def(self, '$positive?', $Numeric_positive$ques$33 = function() {
      var self = this;

      return $rb_gt(self, 0)
    }, $Numeric_positive$ques$33.$$arity = 0);
    
    Opal.def(self, '$negative?', $Numeric_negative$ques$34 = function() {
      var self = this;

      return $rb_lt(self, 0)
    }, $Numeric_negative$ques$34.$$arity = 0);
    
    Opal.def(self, '$dup', $Numeric_dup$35 = function $$dup() {
      var self = this;

      return self
    }, $Numeric_dup$35.$$arity = 0);
    
    Opal.def(self, '$clone', $Numeric_clone$36 = function $$clone($kwargs) {
      var freeze, self = this;

      
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      freeze = $kwargs.$$smap["freeze"];
      if (freeze == null) {
        freeze = true
      };
      return self;
    }, $Numeric_clone$36.$$arity = -1);
    
    Opal.def(self, '$finite?', $Numeric_finite$ques$37 = function() {
      var self = this;

      return true
    }, $Numeric_finite$ques$37.$$arity = 0);
    return (Opal.def(self, '$infinite?', $Numeric_infinite$ques$38 = function() {
      var self = this;

      return nil
    }, $Numeric_infinite$ques$38.$$arity = 0), nil) && 'infinite?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/array"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $falsy = Opal.falsy, $hash_ids = Opal.hash_ids, $yield1 = Opal.yield1, $hash_get = Opal.hash_get, $hash_put = Opal.hash_put, $hash_delete = Opal.hash_delete, $coerce_to = Opal.coerce_to, $respond_to = Opal.respond_to, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $send = Opal.send, $gvars = Opal.gvars, $alias = Opal.alias;

  Opal.add_stubs(['$require', '$include', '$to_a', '$warn', '$raise', '$replace', '$respond_to?', '$to_ary', '$coerce_to?', '$===', '$join', '$to_str', '$hash', '$<=>', '$==', '$object_id', '$inspect', '$enum_for', '$class', '$bsearch_index', '$to_proc', '$nil?', '$coerce_to!', '$>', '$*', '$enumerator_size', '$empty?', '$size', '$map', '$equal?', '$dup', '$each', '$reduce', '$-', '$[]', '$dig', '$eql?', '$length', '$exclude_end?', '$flatten', '$__id__', '$&', '$to_s', '$new', '$max', '$min', '$!', '$>=', '$**', '$delete_if', '$reverse', '$rotate', '$rand', '$at', '$keep_if', '$shuffle!', '$<', '$sort', '$sort_by', '$!=', '$times', '$[]=', '$<<', '$uniq', '$|', '$values', '$is_a?', '$last', '$first', '$upto', '$reject', '$pristine', '$singleton_class']);
  
  self.$require("corelib/enumerable");
  self.$require("corelib/numeric");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Array');

    var $nesting = [self].concat($parent_nesting), $Array_$$$1, $Array_initialize$2, $Array_try_convert$3, $Array_$$4, $Array_$$5, $Array_$$6, $Array_$plus$7, $Array_$minus$8, $Array_$lt$lt$9, $Array_$lt_eq_gt$10, $Array_$eq_eq$11, $Array_$$$12, $Array_$$$eq$13, $Array_any$ques$14, $Array_assoc$15, $Array_at$16, $Array_bsearch_index$17, $Array_bsearch$18, $Array_cycle$19, $Array_clear$21, $Array_count$22, $Array_initialize_copy$23, $Array_collect$24, $Array_collect$excl$26, $Array_combination$28, $Array_repeated_combination$30, $Array_compact$32, $Array_compact$excl$33, $Array_concat$34, $Array_delete$37, $Array_delete_at$38, $Array_delete_if$39, $Array_difference$41, $Array_dig$43, $Array_drop$44, $Array_dup$45, $Array_each$46, $Array_each_index$48, $Array_empty$ques$50, $Array_eql$ques$51, $Array_fetch$52, $Array_fill$53, $Array_first$54, $Array_flatten$55, $Array_flatten$excl$56, $Array_hash$57, $Array_include$ques$58, $Array_index$59, $Array_insert$60, $Array_inspect$61, $Array_intersection$62, $Array_join$64, $Array_keep_if$65, $Array_last$67, $Array_length$68, $Array_max$69, $Array_min$70, $Array_permutation$71, $Array_repeated_permutation$73, $Array_pop$75, $Array_product$76, $Array_push$77, $Array_rassoc$78, $Array_reject$79, $Array_reject$excl$81, $Array_replace$83, $Array_reverse$84, $Array_reverse$excl$85, $Array_reverse_each$86, $Array_rindex$88, $Array_rotate$89, $Array_rotate$excl$90, $Array_sample$93, $Array_select$94, $Array_select$excl$96, $Array_shift$98, $Array_shuffle$99, $Array_shuffle$excl$100, $Array_slice$excl$101, $Array_sort$102, $Array_sort$excl$103, $Array_sort_by$excl$104, $Array_take$106, $Array_take_while$107, $Array_to_a$108, $Array_to_ary$109, $Array_to_h$110, $Array_transpose$111, $Array_union$114, $Array_uniq$116, $Array_uniq$excl$117, $Array_unshift$118, $Array_values_at$119, $Array_zip$122, $Array_inherited$123, $Array_instance_variables$124, $Array_pack$126;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defineProperty(self.$$prototype, '$$is_array', true);
    
    // Recent versions of V8 (> 7.1) only use an optimized implementation when Array.prototype is unmodified.
    // For instance, "array-splice.tq" has a "fast path" (ExtractFastJSArray, defined in "src/codegen/code-stub-assembler.cc")
    // but it's only enabled when "IsPrototypeInitialArrayPrototype()" is true.
    //
    // Older versions of V8 were using relatively fast JS-with-extensions code even when Array.prototype is modified:
    // https://github.com/v8/v8/blob/7.0.1/src/js/array.js#L599-L642
    //
    // In short, Array operations are slow in recent versions of V8 when the Array.prototype has been tampered.
    // So, when possible, we are using faster open-coded version to boost the performance.

    // As of V8 8.4, depending on the size of the array, this is up to ~25x times faster than Array#shift()
    // Implementation is heavily inspired by: https://github.com/nodejs/node/blob/ba684805b6c0eded76e5cd89ee00328ac7a59365/lib/internal/util.js#L341-L347
    function shiftNoArg(list) {
      var r = list[0];
      var index = 1;
      var length = list.length;
      for (; index < length; index++) {
        list[index - 1] = list[index];
      }
      list.pop();
      return r;
    }

    function toArraySubclass(obj, klass) {
      if (klass.$$name === Opal.Array) {
        return obj;
      } else {
        return klass.$allocate().$replace((obj).$to_a());
      }
    }

    // A helper for keep_if and delete_if, filter is either Opal.truthy
    // or Opal.falsy.
    function filterIf(self, filter, block) {
      var value, raised = null, updated = new Array(self.length);

      for (var i = 0, i2 = 0, length = self.length; i < length; i++) {
        if (!raised) {
          try {
            value = $yield1(block, self[i])
          } catch(error) {
            raised = error;
          }
        }

        if (raised || filter(value)) {
          updated[i2] = self[i]
          i2 += 1;
        }
      }

      if (i2 !== i) {
        self.splice.apply(self, [0, updated.length].concat(updated));
        self.splice(i2, updated.length);
      }

      if (raised) throw raised;
    }
  ;
    Opal.defs(self, '$[]', $Array_$$$1 = function($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      return toArraySubclass(objects, self);;
    }, $Array_$$$1.$$arity = -1);
    
    Opal.def(self, '$initialize', $Array_initialize$2 = function $$initialize(size, obj) {
      var $iter = $Array_initialize$2.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_initialize$2.$$p = null;
      
      
      if ($iter) $Array_initialize$2.$$p = null;;
      
      if (size == null) {
        size = nil;
      };
      
      if (obj == null) {
        obj = nil;
      };
      
      if (obj !== nil && block !== nil) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (size > $$$($$($nesting, 'Integer'), 'MAX')) {
        self.$raise($$($nesting, 'ArgumentError'), "array size too big")
      }

      if (arguments.length > 2) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..2)")
      }

      if (arguments.length === 0) {
        self.splice(0, self.length);
        return self;
      }

      if (arguments.length === 1) {
        if (size.$$is_array) {
          self.$replace(size.$to_a())
          return self;
        } else if (size['$respond_to?']("to_ary")) {
          self.$replace(size.$to_ary())
          return self;
        }
      }

      size = $coerce_to(size, $$($nesting, 'Integer'), 'to_int');

      if (size < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")
      }

      self.splice(0, self.length);
      var i, value;

      if (block === nil) {
        for (i = 0; i < size; i++) {
          self.push(obj);
        }
      }
      else {
        for (i = 0, value; i < size; i++) {
          value = block(i);
          self[i] = value;
        }
      }

      return self;
    ;
    }, $Array_initialize$2.$$arity = -1);
    Opal.defs(self, '$try_convert', $Array_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Array'), "to_ary")
    }, $Array_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$&', $Array_$$4 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_delete(hash, item) !== undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$$4.$$arity = 1);
    
    Opal.def(self, '$|', $Array_$$5 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      var hash = $hash2([], {}), i, length, item;

      for (i = 0, length = self.length; i < length; i++) {
        $hash_put(hash, self[i], true);
      }

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      return hash.$keys();
    ;
    }, $Array_$$5.$$arity = 1);
    
    Opal.def(self, '$*', $Array_$$6 = function(other) {
      var self = this;

      
      if ($truthy(other['$respond_to?']("to_str"))) {
        return self.$join(other.$to_str())};
      other = $coerce_to(other, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(other < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative argument")};
      
      var result = [],
          converted = self.$to_a();

      for (var i = 0; i < other; i++) {
        result = result.concat(converted);
      }

      return result;
    ;
    }, $Array_$$6.$$arity = 1);
    
    Opal.def(self, '$+', $Array_$plus$7 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      return self.concat(other);;
    }, $Array_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Array_$minus$8 = function(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(other.length === 0)) {
        return self.slice()};
      
      var result = [], hash = $hash2([], {}), i, length, item;

      for (i = 0, length = other.length; i < length; i++) {
        $hash_put(hash, other[i], true);
      }

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];
        if ($hash_get(hash, item) === undefined) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_$minus$8.$$arity = 1);
    
    Opal.def(self, '$<<', $Array_$lt$lt$9 = function(object) {
      var self = this;

      
      self.push(object);
      return self;
    }, $Array_$lt$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=>', $Array_$lt_eq_gt$10 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Array')['$==='](other))) {
        other = other.$to_a()
      } else if ($truthy(other['$respond_to?']("to_ary"))) {
        other = other.$to_ary().$to_a()
      } else {
        return nil
      };
      
      if (self.$hash() === other.$hash()) {
        return 0;
      }

      var count = Math.min(self.length, other.length);

      for (var i = 0; i < count; i++) {
        var tmp = (self[i])['$<=>'](other[i]);

        if (tmp !== 0) {
          return tmp;
        }
      }

      return (self.length)['$<=>'](other.length);
    ;
    }, $Array_$lt_eq_gt$10.$$arity = 1);
    
    Opal.def(self, '$==', $Array_$eq_eq$11 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eqeq(array, other) {
        var i, length, a, b;

        if (array === other)
          return true;

        if (!other.$$is_array) {
          if ($respond_to(other, '$to_ary')) {
            return (other)['$=='](array);
          } else {
            return false;
          }
        }

        if (array.$$constructor !== Array)
          array = (array).$to_a();
        if (other.$$constructor !== Array)
          other = (other).$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    
    }, $Array_$eq_eq$11.$$arity = 1);
    
    function $array_slice_range(self, index) {
      var size = self.length,
          exclude, from, to, result;

      exclude = index.excl;
      from    = $coerce_to(index.begin, Opal.Integer, 'to_int');
      to      = $coerce_to(index.end, Opal.Integer, 'to_int');

      if (from < 0) {
        from += size;

        if (from < 0) {
          return nil;
        }
      }

      if (from > size) {
        return nil;
      }

      if (to < 0) {
        to += size;

        if (to < 0) {
          return [];
        }
      }

      if (!exclude) {
        to += 1;
      }

      result = self.slice(from, to);
      return result;
    }

    function $array_slice_index_length(self, index, length) {
      var size = self.length,
          exclude, from, to, result;

      index = $coerce_to(index, Opal.Integer, 'to_int');

      if (index < 0) {
        index += size;

        if (index < 0) {
          return nil;
        }
      }

      if (length === undefined) {
        if (index >= size || index < 0) {
          return nil;
        }

        return self[index];
      }
      else {
        length = $coerce_to(length, Opal.Integer, 'to_int');

        if (length < 0 || index > size || index < 0) {
          return nil;
        }

        result = self.slice(index, index + length);
      }
      return result;
    }
  ;
    
    Opal.def(self, '$[]', $Array_$$$12 = function(index, length) {
      var self = this;

      
      ;
      
      if (index.$$is_range) {
        return $array_slice_range(self, index);
      }
      else {
        return $array_slice_index_length(self, index, length);
      }
    ;
    }, $Array_$$$12.$$arity = -2);
    
    Opal.def(self, '$[]=', $Array_$$$eq$13 = function(index, value, extra) {
      var self = this, data = nil, length = nil;

      
      ;
            var i, size = self.length;;
      if ($truthy($$($nesting, 'Range')['$==='](index))) {
        
        data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
          return value.$to_a()
        } else if ($truthy(value['$respond_to?']("to_ary"))) {
          return value.$to_ary().$to_a()
        } else {
          return [value]
        }; return nil; })();
        
        var exclude = index.excl,
            from    = $coerce_to(index.begin, $$($nesting, 'Integer'), 'to_int'),
            to      = $coerce_to(index.end, $$($nesting, 'Integer'), 'to_int');

        if (from < 0) {
          from += size;

          if (from < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + (index.$inspect()) + " out of range");
          }
        }

        if (to < 0) {
          to += size;
        }

        if (!exclude) {
          to += 1;
        }

        if (from > size) {
          for (i = size; i < from; i++) {
            self[i] = nil;
          }
        }

        if (to < 0) {
          self.splice.apply(self, [from, 0].concat(data));
        }
        else {
          self.splice.apply(self, [from, to - from].concat(data));
        }

        return value;
      ;
      } else {
        
        if ($truthy(extra === undefined)) {
          length = 1
        } else {
          
          length = value;
          value = extra;
          data = (function() {if ($truthy($$($nesting, 'Array')['$==='](value))) {
            return value.$to_a()
          } else if ($truthy(value['$respond_to?']("to_ary"))) {
            return value.$to_ary().$to_a()
          } else {
            return [value]
          }; return nil; })();
        };
        
        var old;

        index  = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');

        if (index < 0) {
          old    = index;
          index += size;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + "index " + (old) + " too small for array; minimum " + (-self.length));
          }
        }

        if (length < 0) {
          self.$raise($$($nesting, 'IndexError'), "" + "negative length (" + (length) + ")")
        }

        if (index > size) {
          for (i = size; i < index; i++) {
            self[i] = nil;
          }
        }

        if (extra === undefined) {
          self[index] = value;
        }
        else {
          self.splice.apply(self, [index, length].concat(data));
        }

        return value;
      ;
      };
    }, $Array_$$$eq$13.$$arity = -3);
    
    Opal.def(self, '$any?', $Array_any$ques$14 = function(pattern) {
      var $iter = $Array_any$ques$14.$$p, block = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_any$ques$14.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_any$ques$14.$$p = null;;
      ;
      if (self.length === 0) return false;
      return $send2(self, Opal.find_super_dispatcher(self, 'any?', $Array_any$ques$14, false, true), 'any?', $zuper, $iter);
    }, $Array_any$ques$14.$$arity = -1);
    
    Opal.def(self, '$assoc', $Array_assoc$15 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        if (item = self[i], item.length && (item[0])['$=='](object)) {
          return item;
        }
      }

      return nil;
    
    }, $Array_assoc$15.$$arity = 1);
    
    Opal.def(self, '$at', $Array_at$16 = function $$at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int')

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      return self[index];
    
    }, $Array_at$16.$$arity = 1);
    
    Opal.def(self, '$bsearch_index', $Array_bsearch_index$17 = function $$bsearch_index() {
      var $iter = $Array_bsearch_index$17.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_bsearch_index$17.$$p = null;
      
      
      if ($iter) $Array_bsearch_index$17.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch_index")
      };
      
      var min = 0,
          max = self.length,
          mid,
          val,
          ret,
          smaller = false,
          satisfied = nil;

      while (min < max) {
        mid = min + Math.floor((max - min) / 2);
        val = self[mid];
        ret = $yield1(block, val);

        if (ret === true) {
          satisfied = mid;
          smaller = true;
        }
        else if (ret === false || ret === nil) {
          smaller = false;
        }
        else if (ret.$$is_number) {
          if (ret === 0) { return mid; }
          smaller = (ret < 0);
        }
        else {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong argument type " + ((ret).$class()) + " (must be numeric, true, false or nil)")
        }

        if (smaller) { max = mid; } else { min = mid + 1; }
      }

      return satisfied;
    ;
    }, $Array_bsearch_index$17.$$arity = 0);
    
    Opal.def(self, '$bsearch', $Array_bsearch$18 = function $$bsearch() {
      var $iter = $Array_bsearch$18.$$p, block = $iter || nil, self = this, index = nil;

      if ($iter) $Array_bsearch$18.$$p = null;
      
      
      if ($iter) $Array_bsearch$18.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      index = $send(self, 'bsearch_index', [], block.$to_proc());
      
      if (index != null && index.$$is_number) {
        return self[index];
      } else {
        return index;
      }
    ;
    }, $Array_bsearch$18.$$arity = 0);
    
    Opal.def(self, '$cycle', $Array_cycle$19 = function $$cycle(n) {
      var $iter = $Array_cycle$19.$$p, block = $iter || nil, $$20, self = this, $ret_or_1 = nil;

      if ($iter) $Array_cycle$19.$$p = null;
      
      
      if ($iter) $Array_cycle$19.$$p = null;;
      
      if (n == null) {
        n = nil;
      };
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["cycle", n], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s;

          if ($truthy(n['$nil?']())) {
            return $$$($$($nesting, 'Float'), 'INFINITY')
          } else {
            
            n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
            if ($truthy($rb_gt(n, 0))) {
              return $rb_times(self.$enumerator_size(), n)
            } else {
              return 0
            };
          }}, $$20.$$s = self, $$20.$$arity = 0, $$20))
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = self['$empty?']()))) {
        return $ret_or_1
      } else {
        return n['$=='](0)
      }; return nil; })())) {
        return nil};
      
      var i, length, value;

      if (n === nil) {
        while (true) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }
        }
      }
      else {
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        if (n <= 0) {
          return self;
        }

        while (n > 0) {
          for (i = 0, length = self.length; i < length; i++) {
            value = $yield1(block, self[i]);
          }

          n--;
        }
      }
    ;
      return self;
    }, $Array_cycle$19.$$arity = -1);
    
    Opal.def(self, '$clear', $Array_clear$21 = function $$clear() {
      var self = this;

      
      self.splice(0, self.length);
      return self;
    }, $Array_clear$21.$$arity = 0);
    
    Opal.def(self, '$count', $Array_count$22 = function $$count(object) {
      var $iter = $Array_count$22.$$p, block = $iter || nil, self = this, $ret_or_2 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_count$22.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Array_count$22.$$p = null;;
      
      if (object == null) {
        object = nil;
      };
      if ($truthy((function() {if ($truthy(($ret_or_2 = object))) {
        return $ret_or_2
      } else {
        return block
      }; return nil; })())) {
        return $send2(self, Opal.find_super_dispatcher(self, 'count', $Array_count$22, false, true), 'count', $zuper, $iter)
      } else {
        return self.$size()
      };
    }, $Array_count$22.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Array_initialize_copy$23 = function $$initialize_copy(other) {
      var self = this;

      return self.$replace(other)
    }, $Array_initialize_copy$23.$$arity = 1);
    
    Opal.def(self, '$collect', $Array_collect$24 = function $$collect() {
      var $iter = $Array_collect$24.$$p, block = $iter || nil, $$25, self = this;

      if ($iter) $Array_collect$24.$$p = null;
      
      
      if ($iter) $Array_collect$24.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect"], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s;

          return self.$size()}, $$25.$$s = self, $$25.$$arity = 0, $$25))
      };
      
      var result = [];

      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        result.push(value);
      }

      return result;
    ;
    }, $Array_collect$24.$$arity = 0);
    
    Opal.def(self, '$collect!', $Array_collect$excl$26 = function() {
      var $iter = $Array_collect$excl$26.$$p, block = $iter || nil, $$27, self = this;

      if ($iter) $Array_collect$excl$26.$$p = null;
      
      
      if ($iter) $Array_collect$excl$26.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["collect!"], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s;

          return self.$size()}, $$27.$$s = self, $$27.$$arity = 0, $$27))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
        self[i] = value;
      }
    ;
      return self;
    }, $Array_collect$excl$26.$$arity = 0);
    
    function binomial_coefficient(n, k) {
      if (n === k || k === 0) {
        return 1;
      }

      if (k > 0 && n > k) {
        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k);
      }

      return 0;
    }
  ;
    
    Opal.def(self, '$combination', $Array_combination$28 = function $$combination(n) {
      var $$29, $iter = $Array_combination$28.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_combination$28.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["combination", num], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

          return binomial_coefficient(self.length, num)}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      var i, length, stack, chosen, lev, done, next;

      if (num === 0) {
        Opal.yield1($yield, [])
      } else if (num === 1) {
        for (i = 0, length = self.length; i < length; i++) {
          Opal.yield1($yield, [self[i]])
        }
      }
      else if (num === self.length) {
        Opal.yield1($yield, self.slice())
      }
      else if (num >= 0 && num < self.length) {
        stack = [];
        for (i = 0; i <= num + 1; i++) {
          stack.push(0);
        }

        chosen = [];
        lev = 0;
        done = false;
        stack[0] = -1;

        while (!done) {
          chosen[lev] = self[stack[lev+1]];
          while (lev < num - 1) {
            lev++;
            next = stack[lev+1] = stack[lev] + 1;
            chosen[lev] = self[next];
          }
          Opal.yield1($yield, chosen.slice())
          lev++;
          do {
            done = (lev === 0);
            stack[lev]++;
            lev--;
          } while ( stack[lev+1] + num === self.length + lev + 1 );
        }
      }
    ;
      return self;
    }, $Array_combination$28.$$arity = 1);
    
    Opal.def(self, '$repeated_combination', $Array_repeated_combination$30 = function $$repeated_combination(n) {
      var $$31, $iter = $Array_repeated_combination$30.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_combination$30.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_combination", num], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

          return binomial_coefficient(self.length + num - 1, num);}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      function iterate(max, from, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = from; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, i, buffer, self);
          buffer.pop();
        }
      }

      if (num >= 0) {
        iterate(num, 0, [], self);
      }
    ;
      return self;
    }, $Array_repeated_combination$30.$$arity = 1);
    
    Opal.def(self, '$compact', $Array_compact$32 = function $$compact() {
      var self = this;

      
      var result = [];

      for (var i = 0, length = self.length, item; i < length; i++) {
        if ((item = self[i]) !== nil) {
          result.push(item);
        }
      }

      return result;
    
    }, $Array_compact$32.$$arity = 0);
    
    Opal.def(self, '$compact!', $Array_compact$excl$33 = function() {
      var self = this;

      
      var original = self.length;

      for (var i = 0, length = self.length; i < length; i++) {
        if (self[i] === nil) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      return self.length === original ? nil : self;
    
    }, $Array_compact$excl$33.$$arity = 0);
    
    Opal.def(self, '$concat', $Array_concat$34 = function $$concat($a) {
      var $post_args, others, $$35, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      others = $send(others, 'map', [], ($$35 = function(other){var self = $$35.$$s == null ? this : $$35.$$s;

        
        
        if (other == null) {
          other = nil;
        };
        other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
          return other.$to_a()
        } else {
          return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        if ($truthy(other['$equal?'](self))) {
          other = other.$dup()};
        return other;}, $$35.$$s = self, $$35.$$arity = 1, $$35));
      $send(others, 'each', [], ($$36 = function(other){var self = $$36.$$s == null ? this : $$36.$$s;

        
        
        if (other == null) {
          other = nil;
        };
        
        for (var i = 0, length = other.length; i < length; i++) {
          self.push(other[i]);
        }
      ;}, $$36.$$s = self, $$36.$$arity = 1, $$36));
      return self;
    }, $Array_concat$34.$$arity = -1);
    
    Opal.def(self, '$delete', $Array_delete$37 = function(object) {
      var $iter = $Array_delete$37.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Array_delete$37.$$p = null;
      
      var original = self.length;

      for (var i = 0, length = original; i < length; i++) {
        if ((self[i])['$=='](object)) {
          self.splice(i, 1);

          length--;
          i--;
        }
      }

      if (self.length === original) {
        if (($yield !== nil)) {
          return Opal.yieldX($yield, []);
        }
        return nil;
      }
      return object;
    
    }, $Array_delete$37.$$arity = 1);
    
    Opal.def(self, '$delete_at', $Array_delete_at$38 = function $$delete_at(index) {
      var self = this;

      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index < 0 || index >= self.length) {
        return nil;
      }

      var result = self[index];

      self.splice(index, 1);

      return result;
    
    }, $Array_delete_at$38.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Array_delete_if$39 = function $$delete_if() {
      var $iter = $Array_delete_if$39.$$p, block = $iter || nil, $$40, self = this;

      if ($iter) $Array_delete_if$39.$$p = null;
      
      
      if ($iter) $Array_delete_if$39.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$40 = function(){var self = $$40.$$s == null ? this : $$40.$$s;

          return self.$size()}, $$40.$$s = self, $$40.$$arity = 0, $$40))
      };
      filterIf(self, $falsy, block);
      return self;
    }, $Array_delete_if$39.$$arity = 0);
    
    Opal.def(self, '$difference', $Array_difference$41 = function $$difference($a) {
      var $post_args, arrays, $$42, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], ($$42 = function(a, b){var self = $$42.$$s == null ? this : $$42.$$s;

        
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return $rb_minus(a, b);}, $$42.$$s = self, $$42.$$arity = 2, $$42));
    }, $Array_difference$41.$$arity = -1);
    
    Opal.def(self, '$dig', $Array_dig$43 = function $$dig(idx, $a) {
      var $post_args, idxs, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      idxs = $post_args;;
      item = self['$[]'](idx);
      
      if (item === nil || idxs.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(idxs));
    }, $Array_dig$43.$$arity = -2);
    
    Opal.def(self, '$drop', $Array_drop$44 = function $$drop(number) {
      var self = this;

      
      if (number < 0) {
        self.$raise($$($nesting, 'ArgumentError'))
      }

      return self.slice(number);
    
    }, $Array_drop$44.$$arity = 1);
    
    Opal.def(self, '$dup', $Array_dup$45 = function $$dup() {
      var $iter = $Array_dup$45.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_dup$45.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if (self.$$class === Opal.Array &&
          self.$$class.$allocate.$$pristine &&
          self.$copy_instance_variables.$$pristine &&
          self.$initialize_dup.$$pristine) {
        return self.slice(0);
      }
    ;
      return $send2(self, Opal.find_super_dispatcher(self, 'dup', $Array_dup$45, false, true), 'dup', $zuper, $iter);
    }, $Array_dup$45.$$arity = 0);
    
    Opal.def(self, '$each', $Array_each$46 = function $$each() {
      var $iter = $Array_each$46.$$p, block = $iter || nil, $$47, self = this;

      if ($iter) $Array_each$46.$$p = null;
      
      
      if ($iter) $Array_each$46.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$47 = function(){var self = $$47.$$s == null ? this : $$47.$$s;

          return self.$size()}, $$47.$$s = self, $$47.$$arity = 0, $$47))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, self[i]);
      }
    ;
      return self;
    }, $Array_each$46.$$arity = 0);
    
    Opal.def(self, '$each_index', $Array_each_index$48 = function $$each_index() {
      var $iter = $Array_each_index$48.$$p, block = $iter || nil, $$49, self = this;

      if ($iter) $Array_each_index$48.$$p = null;
      
      
      if ($iter) $Array_each_index$48.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_index"], ($$49 = function(){var self = $$49.$$s == null ? this : $$49.$$s;

          return self.$size()}, $$49.$$s = self, $$49.$$arity = 0, $$49))
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        var value = $yield1(block, i);
      }
    ;
      return self;
    }, $Array_each_index$48.$$arity = 0);
    
    Opal.def(self, '$empty?', $Array_empty$ques$50 = function() {
      var self = this;

      return self.length === 0;
    }, $Array_empty$ques$50.$$arity = 0);
    
    Opal.def(self, '$eql?', $Array_eql$ques$51 = function(other) {
      var self = this;

      
      var recursed = {};

      function _eql(array, other) {
        var i, length, a, b;

        if (!other.$$is_array) {
          return false;
        }

        other = other.$to_a();

        if (array.length !== other.length) {
          return false;
        }

        recursed[(array).$object_id()] = true;

        for (i = 0, length = array.length; i < length; i++) {
          a = array[i];
          b = other[i];
          if (a.$$is_array) {
            if (b.$$is_array && b.length !== a.length) {
              return false;
            }
            if (!recursed.hasOwnProperty((a).$object_id())) {
              if (!_eql(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eql(self, other);
    
    }, $Array_eql$ques$51.$$arity = 1);
    
    Opal.def(self, '$fetch', $Array_fetch$52 = function $$fetch(index, defaults) {
      var $iter = $Array_fetch$52.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_fetch$52.$$p = null;
      
      
      if ($iter) $Array_fetch$52.$$p = null;;
      ;
      
      var original = index;

      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (index < 0) {
        index += self.length;
      }

      if (index >= 0 && index < self.length) {
        return self[index];
      }

      if (block !== nil && defaults != null) {
        self.$warn("warning: block supersedes default value argument")
      }

      if (block !== nil) {
        return block(original);
      }

      if (defaults != null) {
        return defaults;
      }

      if (self.length === 0) {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: 0...0")
      }
      else {
        self.$raise($$($nesting, 'IndexError'), "" + "index " + (original) + " outside of array bounds: -" + (self.length) + "..." + (self.length));
      }
    ;
    }, $Array_fetch$52.$$arity = -2);
    
    Opal.def(self, '$fill', $Array_fill$53 = function $$fill($a) {
      var $iter = $Array_fill$53.$$p, block = $iter || nil, $post_args, args, $b, $c, self = this, one = nil, two = nil, obj = nil, left = nil, right = nil;

      if ($iter) $Array_fill$53.$$p = null;
      
      
      if ($iter) $Array_fill$53.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
            var i, length, value;;
      if ($truthy(block)) {
        
        if ($truthy(args.length > 2)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 0..2)")};
        $c = args, $b = Opal.to_ary($c), (one = ($b[0] == null ? nil : $b[0])), (two = ($b[1] == null ? nil : $b[1])), $c;
      } else {
        
        if ($truthy(args.length == 0)) {
          self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (0 for 1..3)")
        } else if ($truthy(args.length > 3)) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (args.$length()) + " for 1..3)")};
        $c = args, $b = Opal.to_ary($c), (obj = ($b[0] == null ? nil : $b[0])), (one = ($b[1] == null ? nil : $b[1])), (two = ($b[2] == null ? nil : $b[2])), $c;
      };
      if ($truthy($$($nesting, 'Range')['$==='](one))) {
        
        if ($truthy(two)) {
          self.$raise($$($nesting, 'TypeError'), "length invalid with range")};
        left = $coerce_to(one.begin, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          self.$raise($$($nesting, 'RangeError'), "" + (one.$inspect()) + " out of range")};
        right = $coerce_to(one.end, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(right < 0)) {
          right += this.length};
        if ($truthy(one['$exclude_end?']())) {
        } else {
          right += 1
        };
        if ($truthy(right <= left)) {
          return self};
      } else if ($truthy(one)) {
        
        left = $coerce_to(one, $$($nesting, 'Integer'), 'to_int');
        if ($truthy(left < 0)) {
          left += this.length};
        if ($truthy(left < 0)) {
          left = 0};
        if ($truthy(two)) {
          
          right = $coerce_to(two, $$($nesting, 'Integer'), 'to_int');
          if ($truthy(right == 0)) {
            return self};
          right += left;
        } else {
          right = this.length
        };
      } else {
        
        left = 0;
        right = this.length;
      };
      if ($truthy(left > this.length)) {
        
        for (i = this.length; i < right; i++) {
          self[i] = nil;
        }
      };
      if ($truthy(right > this.length)) {
        this.length = right};
      if ($truthy(block)) {
        
        for (length = this.length; left < right; left++) {
          value = block(left);
          self[left] = value;
        }
      
      } else {
        
        for (length = this.length; left < right; left++) {
          self[left] = obj;
        }
      
      };
      return self;
    }, $Array_fill$53.$$arity = -1);
    
    Opal.def(self, '$first', $Array_first$54 = function $$first(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[0];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      return self.slice(0, count);
    ;
    }, $Array_first$54.$$arity = -1);
    
    Opal.def(self, '$flatten', $Array_flatten$55 = function $$flatten(level) {
      var self = this;

      
      ;
      
      function _flatten(array, level) {
        var result = [],
            i, length,
            item, ary;

        array = (array).$to_a();

        for (i = 0, length = array.length; i < length; i++) {
          item = array[i];

          if (!$respond_to(item, '$to_ary', true)) {
            result.push(item);
            continue;
          }

          ary = (item).$to_ary();

          if (ary === nil) {
            result.push(item);
            continue;
          }

          if (!ary.$$is_array) {
            self.$raise($$($nesting, 'TypeError'));
          }

          if (ary === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          switch (level) {
          case undefined:
            result = result.concat(_flatten(ary));
            break;
          case 0:
            result.push(ary);
            break;
          default:
            result.push.apply(result, _flatten(ary, level - 1));
          }
        }
        return result;
      }

      if (level !== undefined) {
        level = $coerce_to(level, $$($nesting, 'Integer'), 'to_int');
      }

      return _flatten(self, level);
    ;
    }, $Array_flatten$55.$$arity = -1);
    
    Opal.def(self, '$flatten!', $Array_flatten$excl$56 = function(level) {
      var self = this;

      
      ;
      
      var flattened = self.$flatten(level);

      if (self.length == flattened.length) {
        for (var i = 0, length = self.length; i < length; i++) {
          if (self[i] !== flattened[i]) {
            break;
          }
        }

        if (i == length) {
          return nil;
        }
      }

      self.$replace(flattened);
    ;
      return self;
    }, $Array_flatten$excl$56.$$arity = -1);
    
    Opal.def(self, '$hash', $Array_hash$57 = function $$hash() {
      var self = this;

      
      var top = ($hash_ids === undefined),
          result = ['A'],
          hash_id = self.$object_id(),
          item, i, key;

      try {
        if (top) {
          $hash_ids = Object.create(null);
        }

        // return early for recursive structures
        if ($hash_ids[hash_id]) {
          return 'self';
        }

        for (key in $hash_ids) {
          item = $hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        $hash_ids[hash_id] = self;

        for (i = 0; i < self.length; i++) {
          item = self[i];
          result.push(item.$hash());
        }

        return result.join(',');
      } finally {
        if (top) {
          $hash_ids = undefined;
        }
      }
    
    }, $Array_hash$57.$$arity = 0);
    
    Opal.def(self, '$include?', $Array_include$ques$58 = function(member) {
      var self = this;

      
      for (var i = 0, length = self.length; i < length; i++) {
        if ((self[i])['$=='](member)) {
          return true;
        }
      }

      return false;
    
    }, $Array_include$ques$58.$$arity = 1);
    
    Opal.def(self, '$index', $Array_index$59 = function $$index(object) {
      var $iter = $Array_index$59.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_index$59.$$p = null;
      
      
      if ($iter) $Array_index$59.$$p = null;;
      ;
      
      var i, length, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = 0, length = self.length; i < length; i++) {
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = 0, length = self.length; i < length; i++) {
          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else {
        return self.$enum_for("index");
      }

      return nil;
    ;
    }, $Array_index$59.$$arity = -1);
    
    Opal.def(self, '$insert', $Array_insert$60 = function $$insert(index, $a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      objects = $post_args;;
      
      index = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');

      if (objects.length > 0) {
        if (index < 0) {
          index += self.length + 1;

          if (index < 0) {
            self.$raise($$($nesting, 'IndexError'), "" + (index) + " is out of bounds");
          }
        }
        if (index > self.length) {
          for (var i = self.length; i < index; i++) {
            self.push(nil);
          }
        }

        self.splice.apply(self, [index, 0].concat(objects));
      }
    ;
      return self;
    }, $Array_insert$60.$$arity = -2);
    
    Opal.def(self, '$inspect', $Array_inspect$61 = function $$inspect() {
      var self = this;

      
      var result = [],
          id     = self.$__id__();

      for (var i = 0, length = self.length; i < length; i++) {
        var item = self['$[]'](i);

        if ((item).$__id__() === id) {
          result.push('[...]');
        }
        else {
          result.push((item).$inspect());
        }
      }

      return '[' + result.join(', ') + ']';
    
    }, $Array_inspect$61.$$arity = 0);
    
    Opal.def(self, '$intersection', $Array_intersection$62 = function $$intersection($a) {
      var $post_args, arrays, $$63, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$to_a().$dup()], ($$63 = function(a, b){var self = $$63.$$s == null ? this : $$63.$$s;

        
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$&'](b);}, $$63.$$s = self, $$63.$$arity = 2, $$63));
    }, $Array_intersection$62.$$arity = -1);
    
    Opal.def(self, '$join', $Array_join$64 = function $$join(sep) {
      var self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      if (sep == null) {
        sep = nil;
      };
      if ($truthy(self.length === 0)) {
        return ""};
      if ($truthy(sep === nil)) {
        sep = $gvars[","]};
      
      var result = [];
      var i, length, item, tmp;

      for (i = 0, length = self.length; i < length; i++) {
        item = self[i];

        if ($respond_to(item, '$to_str')) {
          tmp = (item).$to_str();

          if (tmp !== nil) {
            result.push((tmp).$to_s());

            continue;
          }
        }

        if ($respond_to(item, '$to_ary')) {
          tmp = (item).$to_ary();

          if (tmp === self) {
            self.$raise($$($nesting, 'ArgumentError'));
          }

          if (tmp !== nil) {
            result.push((tmp).$join(sep));

            continue;
          }
        }

        if ($respond_to(item, '$to_s')) {
          tmp = (item).$to_s();

          if (tmp !== nil) {
            result.push(tmp);

            continue;
          }
        }

        self.$raise($$($nesting, 'NoMethodError').$new("" + (Opal.inspect(item)) + " doesn't respond to #to_str, #to_ary or #to_s", "to_str"));
      }

      if (sep === nil) {
        return result.join('');
      }
      else {
        return result.join($$($nesting, 'Opal')['$coerce_to!'](sep, $$($nesting, 'String'), "to_str").$to_s());
      }
    ;
    }, $Array_join$64.$$arity = -1);
    
    Opal.def(self, '$keep_if', $Array_keep_if$65 = function $$keep_if() {
      var $iter = $Array_keep_if$65.$$p, block = $iter || nil, $$66, self = this;

      if ($iter) $Array_keep_if$65.$$p = null;
      
      
      if ($iter) $Array_keep_if$65.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$66 = function(){var self = $$66.$$s == null ? this : $$66.$$s;

          return self.$size()}, $$66.$$s = self, $$66.$$arity = 0, $$66))
      };
      filterIf(self, $truthy, block);
      return self;
    }, $Array_keep_if$65.$$arity = 0);
    
    Opal.def(self, '$last', $Array_last$67 = function $$last(count) {
      var self = this;

      
      ;
      
      if (count == null) {
        return self.length === 0 ? nil : self[self.length - 1];
      }

      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');

      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size");
      }

      if (count > self.length) {
        count = self.length;
      }

      return self.slice(self.length - count, self.length);
    ;
    }, $Array_last$67.$$arity = -1);
    
    Opal.def(self, '$length', $Array_length$68 = function $$length() {
      var self = this;

      return self.length;
    }, $Array_length$68.$$arity = 0);
    $alias(self, "map", "collect");
    $alias(self, "map!", "collect!");
    
    Opal.def(self, '$max', $Array_max$69 = function $$max(n) {
      var $iter = $Array_max$69.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_max$69.$$p = null;
      
      
      if ($iter) $Array_max$69.$$p = null;;
      ;
      return $send(self.$each(), 'max', [n], block.$to_proc());
    }, $Array_max$69.$$arity = -1);
    
    Opal.def(self, '$min', $Array_min$70 = function $$min() {
      var $iter = $Array_min$70.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_min$70.$$p = null;
      
      
      if ($iter) $Array_min$70.$$p = null;;
      return $send(self.$each(), 'min', [], block.$to_proc());
    }, $Array_min$70.$$arity = 0);
    
    // Returns the product of from, from-1, ..., from - how_many + 1.
    function descending_factorial(from, how_many) {
      var count = how_many >= 0 ? 1 : 0;
      while (how_many) {
        count *= from;
        from--;
        how_many--;
      }
      return count;
    }
  ;
    
    Opal.def(self, '$permutation', $Array_permutation$71 = function $$permutation(num) {
      var $iter = $Array_permutation$71.$$p, block = $iter || nil, $$72, self = this, perm = nil, used = nil;

      if ($iter) $Array_permutation$71.$$p = null;
      
      
      if ($iter) $Array_permutation$71.$$p = null;;
      ;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["permutation", num], ($$72 = function(){var self = $$72.$$s == null ? this : $$72.$$s;

          return descending_factorial(self.length, num === undefined ? self.length : num);}, $$72.$$s = self, $$72.$$arity = 0, $$72))
      };
      
      var permute, offensive, output;

      if (num === undefined) {
        num = self.length;
      }
      else {
        num = $coerce_to(num, $$($nesting, 'Integer'), 'to_int');
      }

      if (num < 0 || self.length < num) {
        // no permutations, yield nothing
      }
      else if (num === 0) {
        // exactly one permutation: the zero-length array
        Opal.yield1(block, [])
      }
      else if (num === 1) {
        // this is a special, easy case
        for (var i = 0; i < self.length; i++) {
          Opal.yield1(block, [self[i]])
        }
      }
      else {
        // this is the general case
        (perm = $$($nesting, 'Array').$new(num));
        (used = $$($nesting, 'Array').$new(self.length, false));

        permute = function(num, perm, index, used, blk) {
          self = this;
          for(var i = 0; i < self.length; i++){
            if(used['$[]'](i)['$!']()) {
              perm[index] = i;
              if(index < num - 1) {
                used[i] = true;
                permute.call(self, num, perm, index + 1, used, blk);
                used[i] = false;
              }
              else {
                output = [];
                for (var j = 0; j < perm.length; j++) {
                  output.push(self[perm[j]]);
                }
                $yield1(blk, output);
              }
            }
          }
        }

        if ((block !== nil)) {
          // offensive (both definitions) copy.
          offensive = self.slice();
          permute.call(offensive, num, perm, 0, used, block);
        }
        else {
          permute.call(self, num, perm, 0, used, block);
        }
      }
    ;
      return self;
    }, $Array_permutation$71.$$arity = -1);
    
    Opal.def(self, '$repeated_permutation', $Array_repeated_permutation$73 = function $$repeated_permutation(n) {
      var $$74, $iter = $Array_repeated_permutation$73.$$p, $yield = $iter || nil, self = this, num = nil;

      if ($iter) $Array_repeated_permutation$73.$$p = null;
      
      num = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["repeated_permutation", num], ($$74 = function(){var self = $$74.$$s == null ? this : $$74.$$s;

          if ($truthy($rb_ge(num, 0))) {
            return self.$size()['$**'](num)
          } else {
            return 0
          }}, $$74.$$s = self, $$74.$$arity = 0, $$74))
      };
      
      function iterate(max, buffer, self) {
        if (buffer.length == max) {
          var copy = buffer.slice();
          Opal.yield1($yield, copy)
          return;
        }
        for (var i = 0; i < self.length; i++) {
          buffer.push(self[i]);
          iterate(max, buffer, self);
          buffer.pop();
        }
      }

      iterate(num, [], self.slice());
    ;
      return self;
    }, $Array_repeated_permutation$73.$$arity = 1);
    
    Opal.def(self, '$pop', $Array_pop$75 = function $$pop(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return self.pop();};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      if ($truthy(count === 1)) {
        return [self.pop()];
      } else if ($truthy(count > self.length)) {
        return self.splice(0, self.length);
      } else {
        return self.splice(self.length - count, self.length);
      };
    }, $Array_pop$75.$$arity = -1);
    
    Opal.def(self, '$product', $Array_product$76 = function $$product($a) {
      var $iter = $Array_product$76.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Array_product$76.$$p = null;
      
      
      if ($iter) $Array_product$76.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = (block !== nil) ? null : [],
          n = args.length + 1,
          counters = new Array(n),
          lengths  = new Array(n),
          arrays   = new Array(n),
          i, m, subarray, len, resultlen = 1;

      arrays[0] = self;
      for (i = 1; i < n; i++) {
        arrays[i] = $coerce_to(args[i - 1], $$($nesting, 'Array'), 'to_ary');
      }

      for (i = 0; i < n; i++) {
        len = arrays[i].length;
        if (len === 0) {
          return result || self;
        }
        resultlen *= len;
        if (resultlen > 2147483647) {
          self.$raise($$($nesting, 'RangeError'), "too big to product")
        }
        lengths[i] = len;
        counters[i] = 0;
      }

      outer_loop: for (;;) {
        subarray = [];
        for (i = 0; i < n; i++) {
          subarray.push(arrays[i][counters[i]]);
        }
        if (result) {
          result.push(subarray);
        } else {
          Opal.yield1(block, subarray)
        }
        m = n - 1;
        counters[m]++;
        while (counters[m] === lengths[m]) {
          counters[m] = 0;
          if (--m < 0) break outer_loop;
          counters[m]++;
        }
      }

      return result || self;
    ;
    }, $Array_product$76.$$arity = -1);
    
    Opal.def(self, '$push', $Array_push$77 = function $$push($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      for (var i = 0, length = objects.length; i < length; i++) {
        self.push(objects[i]);
      }
    ;
      return self;
    }, $Array_push$77.$$arity = -1);
    $alias(self, "append", "push");
    
    Opal.def(self, '$rassoc', $Array_rassoc$78 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, length = self.length, item; i < length; i++) {
        item = self[i];

        if (item.length && item[1] !== undefined) {
          if ((item[1])['$=='](object)) {
            return item;
          }
        }
      }

      return nil;
    
    }, $Array_rassoc$78.$$arity = 1);
    
    Opal.def(self, '$reject', $Array_reject$79 = function $$reject() {
      var $iter = $Array_reject$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Array_reject$79.$$p = null;
      
      
      if ($iter) $Array_reject$79.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$80 = function(){var self = $$80.$$s == null ? this : $$80.$$s;

          return self.$size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      var result = [];

      for (var i = 0, length = self.length, value; i < length; i++) {
        value = block(self[i]);

        if (value === false || value === nil) {
          result.push(self[i]);
        }
      }
      return result;
    ;
    }, $Array_reject$79.$$arity = 0);
    
    Opal.def(self, '$reject!', $Array_reject$excl$81 = function() {
      var $iter = $Array_reject$excl$81.$$p, block = $iter || nil, $$82, self = this, original = nil;

      if ($iter) $Array_reject$excl$81.$$p = null;
      
      
      if ($iter) $Array_reject$excl$81.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$82 = function(){var self = $$82.$$s == null ? this : $$82.$$s;

          return self.$size()}, $$82.$$s = self, $$82.$$arity = 0, $$82))
      };
      original = self.$length();
      $send(self, 'delete_if', [], block.$to_proc());
      if (self.$length()['$=='](original)) {
        return nil
      } else {
        return self
      };
    }, $Array_reject$excl$81.$$arity = 0);
    
    Opal.def(self, '$replace', $Array_replace$83 = function $$replace(other) {
      var self = this;

      
      other = (function() {if ($truthy($$($nesting, 'Array')['$==='](other))) {
        return other.$to_a()
      } else {
        return ($coerce_to(other, $$($nesting, 'Array'), 'to_ary')).$to_a()
      }; return nil; })();
      
      self.splice(0, self.length);
      self.push.apply(self, other);
    ;
      return self;
    }, $Array_replace$83.$$arity = 1);
    
    Opal.def(self, '$reverse', $Array_reverse$84 = function $$reverse() {
      var self = this;

      return self.slice(0).reverse();
    }, $Array_reverse$84.$$arity = 0);
    
    Opal.def(self, '$reverse!', $Array_reverse$excl$85 = function() {
      var self = this;

      return self.reverse();
    }, $Array_reverse$excl$85.$$arity = 0);
    
    Opal.def(self, '$reverse_each', $Array_reverse_each$86 = function $$reverse_each() {
      var $iter = $Array_reverse_each$86.$$p, block = $iter || nil, $$87, self = this;

      if ($iter) $Array_reverse_each$86.$$p = null;
      
      
      if ($iter) $Array_reverse_each$86.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["reverse_each"], ($$87 = function(){var self = $$87.$$s == null ? this : $$87.$$s;

          return self.$size()}, $$87.$$s = self, $$87.$$arity = 0, $$87))
      };
      $send(self.$reverse(), 'each', [], block.$to_proc());
      return self;
    }, $Array_reverse_each$86.$$arity = 0);
    
    Opal.def(self, '$rindex', $Array_rindex$88 = function $$rindex(object) {
      var $iter = $Array_rindex$88.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_rindex$88.$$p = null;
      
      
      if ($iter) $Array_rindex$88.$$p = null;;
      ;
      
      var i, value;

      if (object != null && block !== nil) {
        self.$warn("warning: given block not used")
      }

      if (object != null) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }
          if ((self[i])['$=='](object)) {
            return i;
          }
        }
      }
      else if (block !== nil) {
        for (i = self.length - 1; i >= 0; i--) {
          if (i >= self.length) {
            break;
          }

          value = block(self[i]);

          if (value !== false && value !== nil) {
            return i;
          }
        }
      }
      else if (object == null) {
        return self.$enum_for("rindex");
      }

      return nil;
    ;
    }, $Array_rindex$88.$$arity = -1);
    
    Opal.def(self, '$rotate', $Array_rotate$89 = function $$rotate(n) {
      var self = this;

      
      
      if (n == null) {
        n = 1;
      };
      
      var ary, idx, firstPart, lastPart;

      n = $coerce_to(n, $$($nesting, 'Integer'), 'to_int')

      if (self.length === 1) {
        return self.slice();
      }
      if (self.length === 0) {
        return [];
      }

      ary = self.slice();
      idx = n % ary.length;

      firstPart = ary.slice(idx);
      lastPart = ary.slice(0, idx);
      return firstPart.concat(lastPart);
    ;
    }, $Array_rotate$89.$$arity = -1);
    
    Opal.def(self, '$rotate!', $Array_rotate$excl$90 = function(cnt) {
      var self = this, ary = nil;

      
      
      if (cnt == null) {
        cnt = 1;
      };
      
      if (self.length === 0 || self.length === 1) {
        return self;
      }
      cnt = $coerce_to(cnt, $$($nesting, 'Integer'), 'to_int');
    ;
      ary = self.$rotate(cnt);
      return self.$replace(ary);
    }, $Array_rotate$excl$90.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'SampleRandom');

      var $nesting = [self].concat($parent_nesting), $SampleRandom_initialize$91, $SampleRandom_rand$92;

      self.$$prototype.rng = nil;
      
      
      Opal.def(self, '$initialize', $SampleRandom_initialize$91 = function $$initialize(rng) {
        var self = this;

        return (self.rng = rng)
      }, $SampleRandom_initialize$91.$$arity = 1);
      return (Opal.def(self, '$rand', $SampleRandom_rand$92 = function $$rand(size) {
        var self = this, random = nil;

        
        random = $coerce_to(self.rng.$rand(size), $$($nesting, 'Integer'), 'to_int');
        if ($truthy(random < 0)) {
          self.$raise($$($nesting, 'RangeError'), "random value must be >= 0")};
        if ($truthy(random < size)) {
        } else {
          self.$raise($$($nesting, 'RangeError'), "random value must be less than Array size")
        };
        return random;
      }, $SampleRandom_rand$92.$$arity = 1), nil) && 'rand';
    })($nesting[0], null, $nesting);
    
    Opal.def(self, '$sample', $Array_sample$93 = function $$sample(count, options) {
      var self = this, o = nil, $ret_or_3 = nil, rng = nil, $ret_or_4 = nil;

      
      ;
      ;
      if ($truthy(count === undefined)) {
        return self.$at($$($nesting, 'Kernel').$rand(self.length))};
      if ($truthy(options === undefined)) {
        if ($truthy((o = $$($nesting, 'Opal')['$coerce_to?'](count, $$($nesting, 'Hash'), "to_hash")))) {
          
          options = o;
          count = nil;
        } else {
          
          options = nil;
          count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        }
      } else {
        
        count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
        options = $coerce_to(options, $$($nesting, 'Hash'), 'to_hash');
      };
      if ($truthy((function() {if ($truthy(($ret_or_3 = count))) {
        return count < 0;
      } else {
        return $ret_or_3
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "count must be greater than 0")};
      if ($truthy(options)) {
        rng = options['$[]']("random")};
      rng = (function() {if ($truthy((function() {if ($truthy(($ret_or_4 = rng))) {
        return rng['$respond_to?']("rand")
      } else {
        return $ret_or_4
      }; return nil; })())) {
        return $$($nesting, 'SampleRandom').$new(rng)
      } else {
        return $$($nesting, 'Kernel')
      }; return nil; })();
      if ($truthy(count)) {
      } else {
        return self[rng.$rand(self.length)]
      };
      

      var abandon, spin, result, i, j, k, targetIndex, oldValue;

      if (count > self.length) {
        count = self.length;
      }

      switch (count) {
        case 0:
          return [];
          break;
        case 1:
          return [self[rng.$rand(self.length)]];
          break;
        case 2:
          i = rng.$rand(self.length);
          j = rng.$rand(self.length);
          if (i === j) {
            j = i === 0 ? i + 1 : i - 1;
          }
          return [self[i], self[j]];
          break;
        default:
          if (self.length / count > 3) {
            abandon = false;
            spin = 0;

            result = $$($nesting, 'Array').$new(count);
            i = 1;

            result[0] = rng.$rand(self.length);
            while (i < count) {
              k = rng.$rand(self.length);
              j = 0;

              while (j < i) {
                while (k === result[j]) {
                  spin++;
                  if (spin > 100) {
                    abandon = true;
                    break;
                  }
                  k = rng.$rand(self.length);
                }
                if (abandon) { break; }

                j++;
              }

              if (abandon) { break; }

              result[i] = k;

              i++;
            }

            if (!abandon) {
              i = 0;
              while (i < count) {
                result[i] = self[result[i]];
                i++;
              }

              return result;
            }
          }

          result = self.slice();

          for (var c = 0; c < count; c++) {
            targetIndex = rng.$rand(self.length);
            oldValue = result[c];
            result[c] = result[targetIndex];
            result[targetIndex] = oldValue;
          }

          return count === self.length ? result : (result)['$[]'](0, count);
      }
    ;
    }, $Array_sample$93.$$arity = -1);
    
    Opal.def(self, '$select', $Array_select$94 = function $$select() {
      var $iter = $Array_select$94.$$p, block = $iter || nil, $$95, self = this;

      if ($iter) $Array_select$94.$$p = null;
      
      
      if ($iter) $Array_select$94.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$95 = function(){var self = $$95.$$s == null ? this : $$95.$$s;

          return self.$size()}, $$95.$$s = self, $$95.$$arity = 0, $$95))
      };
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = $yield1(block, item);

        if ($truthy(value)) {
          result.push(item);
        }
      }

      return result;
    ;
    }, $Array_select$94.$$arity = 0);
    
    Opal.def(self, '$select!', $Array_select$excl$96 = function() {
      var $iter = $Array_select$excl$96.$$p, block = $iter || nil, $$97, self = this;

      if ($iter) $Array_select$excl$96.$$p = null;
      
      
      if ($iter) $Array_select$excl$96.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$97 = function(){var self = $$97.$$s == null ? this : $$97.$$s;

          return self.$size()}, $$97.$$s = self, $$97.$$arity = 0, $$97))
      };
      
      var original = self.length;
      $send(self, 'keep_if', [], block.$to_proc());
      return self.length === original ? nil : self;
    ;
    }, $Array_select$excl$96.$$arity = 0);
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Array_shift$98 = function $$shift(count) {
      var self = this;

      
      ;
      if ($truthy(count === undefined)) {
        
        if ($truthy(self.length === 0)) {
          return nil};
        return shiftNoArg(self);};
      count = $coerce_to(count, $$($nesting, 'Integer'), 'to_int');
      if ($truthy(count < 0)) {
        self.$raise($$($nesting, 'ArgumentError'), "negative array size")};
      if ($truthy(self.length === 0)) {
        return []};
      return self.splice(0, count);;
    }, $Array_shift$98.$$arity = -1);
    $alias(self, "size", "length");
    
    Opal.def(self, '$shuffle', $Array_shuffle$99 = function $$shuffle(rng) {
      var self = this;

      
      ;
      return self.$dup().$to_a()['$shuffle!'](rng);
    }, $Array_shuffle$99.$$arity = -1);
    
    Opal.def(self, '$shuffle!', $Array_shuffle$excl$100 = function(rng) {
      var self = this;

      
      ;
      
      var randgen, i = self.length, j, tmp;

      if (rng !== undefined) {
        rng = $$($nesting, 'Opal')['$coerce_to?'](rng, $$($nesting, 'Hash'), "to_hash");

        if (rng !== nil) {
          rng = rng['$[]']("random");

          if (rng !== nil && rng['$respond_to?']("rand")) {
            randgen = rng;
          }
        }
      }

      while (i) {
        if (randgen) {
          j = randgen.$rand(i).$to_int();

          if (j < 0) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too small " + (j))
          }

          if (j >= i) {
            self.$raise($$($nesting, 'RangeError'), "" + "random number too big " + (j))
          }
        }
        else {
          j = self.$rand(i);
        }

        tmp = self[--i];
        self[i] = self[j];
        self[j] = tmp;
      }

      return self;
    ;
    }, $Array_shuffle$excl$100.$$arity = -1);
    $alias(self, "slice", "[]");
    
    Opal.def(self, '$slice!', $Array_slice$excl$101 = function(index, length) {
      var self = this, result = nil, range = nil, range_start = nil, range_end = nil, start = nil;

      
      ;
      result = nil;
      if ($truthy(length === undefined)) {
        if ($truthy($$($nesting, 'Range')['$==='](index))) {
          
          range = index;
          result = self['$[]'](range);
          range_start = $coerce_to(range.begin, $$($nesting, 'Integer'), 'to_int');
          range_end = $coerce_to(range.end, $$($nesting, 'Integer'), 'to_int');
          
          if (range_start < 0) {
            range_start += self.length;
          }

          if (range_end < 0) {
            range_end += self.length;
          } else if (range_end >= self.length) {
            range_end = self.length - 1;
            if (range.excl) {
              range_end += 1;
            }
          }

          var range_length = range_end - range_start;
          if (range.excl) {
            range_end -= 1;
          } else {
            range_length += 1;
          }

          if (range_start < self.length && range_start >= 0 && range_end < self.length && range_end >= 0 && range_length > 0) {
            self.splice(range_start, range_length);
          }
        ;
        } else {
          
          start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start += self.length;
          }

          if (start < 0 || start >= self.length) {
            return nil;
          }

          result = self[start];

          if (start === 0) {
            self.shift();
          } else {
            self.splice(start, 1);
          }
        ;
        }
      } else {
        
        start = $coerce_to(index, $$($nesting, 'Integer'), 'to_int');
        length = $coerce_to(length, $$($nesting, 'Integer'), 'to_int');
        
        if (length < 0) {
          return nil;
        }

        var end = start + length;

        result = self['$[]'](start, length);

        if (start < 0) {
          start += self.length;
        }

        if (start + length > self.length) {
          length = self.length - start;
        }

        if (start < self.length && start >= 0) {
          self.splice(start, length);
        }
      ;
      };
      return result;
    }, $Array_slice$excl$101.$$arity = -2);
    
    Opal.def(self, '$sort', $Array_sort$102 = function $$sort() {
      var $iter = $Array_sort$102.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$102.$$p = null;
      
      
      if ($iter) $Array_sort$102.$$p = null;;
      if ($truthy(self.length > 1)) {
      } else {
        return self
      };
      
      if (block === nil) {
        block = function(a, b) {
          return (a)['$<=>'](b);
        };
      }

      return self.slice().sort(function(x, y) {
        var ret = block(x, y);

        if (ret === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + ((x).$inspect()) + " with " + ((y).$inspect()) + " failed");
        }

        return $rb_gt(ret, 0) ? 1 : ($rb_lt(ret, 0) ? -1 : 0);
      });
    ;
    }, $Array_sort$102.$$arity = 0);
    
    Opal.def(self, '$sort!', $Array_sort$excl$103 = function() {
      var $iter = $Array_sort$excl$103.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_sort$excl$103.$$p = null;
      
      
      if ($iter) $Array_sort$excl$103.$$p = null;;
      
      var result;

      if ((block !== nil)) {
        result = $send((self.slice()), 'sort', [], block.$to_proc());
      }
      else {
        result = (self.slice()).$sort();
      }

      self.length = 0;
      for(var i = 0, length = result.length; i < length; i++) {
        self.push(result[i]);
      }

      return self;
    ;
    }, $Array_sort$excl$103.$$arity = 0);
    
    Opal.def(self, '$sort_by!', $Array_sort_by$excl$104 = function() {
      var $iter = $Array_sort_by$excl$104.$$p, block = $iter || nil, $$105, self = this;

      if ($iter) $Array_sort_by$excl$104.$$p = null;
      
      
      if ($iter) $Array_sort_by$excl$104.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["sort_by!"], ($$105 = function(){var self = $$105.$$s == null ? this : $$105.$$s;

          return self.$size()}, $$105.$$s = self, $$105.$$arity = 0, $$105))
      };
      return self.$replace($send(self, 'sort_by', [], block.$to_proc()));
    }, $Array_sort_by$excl$104.$$arity = 0);
    
    Opal.def(self, '$take', $Array_take$106 = function $$take(count) {
      var self = this;

      
      if (count < 0) {
        self.$raise($$($nesting, 'ArgumentError'));
      }

      return self.slice(0, count);
    
    }, $Array_take$106.$$arity = 1);
    
    Opal.def(self, '$take_while', $Array_take_while$107 = function $$take_while() {
      var $iter = $Array_take_while$107.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_take_while$107.$$p = null;
      
      
      if ($iter) $Array_take_while$107.$$p = null;;
      
      var result = [];

      for (var i = 0, length = self.length, item, value; i < length; i++) {
        item = self[i];

        value = block(item);

        if (value === false || value === nil) {
          return result;
        }

        result.push(item);
      }

      return result;
    ;
    }, $Array_take_while$107.$$arity = 0);
    
    Opal.def(self, '$to_a', $Array_to_a$108 = function $$to_a() {
      var self = this;

      
      if (self.$$class === Opal.Array) {
        return self;
      }
      else {
        return Opal.Array.$new(self);
      }
    
    }, $Array_to_a$108.$$arity = 0);
    
    Opal.def(self, '$to_ary', $Array_to_ary$109 = function $$to_ary() {
      var self = this;

      return self
    }, $Array_to_ary$109.$$arity = 0);
    
    Opal.def(self, '$to_h', $Array_to_h$110 = function $$to_h() {
      var $iter = $Array_to_h$110.$$p, block = $iter || nil, self = this, array = nil;

      if ($iter) $Array_to_h$110.$$p = null;
      
      
      if ($iter) $Array_to_h$110.$$p = null;;
      array = self;
      if ((block !== nil)) {
        array = $send(array, 'map', [], block.$to_proc())};
      
      var i, len = array.length, ary, key, val, hash = $hash2([], {});

      for (i = 0; i < len; i++) {
        ary = $$($nesting, 'Opal')['$coerce_to?'](array[i], $$($nesting, 'Array'), "to_ary");
        if (!ary.$$is_array) {
          self.$raise($$($nesting, 'TypeError'), "" + "wrong element type " + ((ary).$class()) + " at " + (i) + " (expected array)")
        }
        if (ary.length !== 2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong array length at " + (i) + " (expected 2, was " + ((ary).$length()) + ")")
        }
        key = ary[0];
        val = ary[1];
        $hash_put(hash, key, val);
      }

      return hash;
    ;
    }, $Array_to_h$110.$$arity = 0);
    $alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transpose', $Array_transpose$111 = function $$transpose() {
      var $$112, self = this, result = nil, max = nil;

      
      if ($truthy(self['$empty?']())) {
        return []};
      result = [];
      max = nil;
      $send(self, 'each', [], ($$112 = function(row){var self = $$112.$$s == null ? this : $$112.$$s, $$113, $ret_or_5 = nil;

        
        
        if (row == null) {
          row = nil;
        };
        row = (function() {if ($truthy($$($nesting, 'Array')['$==='](row))) {
          return row.$to_a()
        } else {
          return ($coerce_to(row, $$($nesting, 'Array'), 'to_ary')).$to_a()
        }; return nil; })();
        max = (function() {if ($truthy(($ret_or_5 = max))) {
          return $ret_or_5
        } else {
          return row.length;
        }; return nil; })();
        if ($truthy((row.length)['$!='](max))) {
          self.$raise($$($nesting, 'IndexError'), "" + "element size differs (" + (row.length) + " should be " + (max) + ")")};
        return $send((row.length), 'times', [], ($$113 = function(i){var self = $$113.$$s == null ? this : $$113.$$s, entry = nil, $ret_or_6 = nil, $writer = nil;

          
          
          if (i == null) {
            i = nil;
          };
          entry = (function() {if ($truthy(($ret_or_6 = result['$[]'](i)))) {
            return $ret_or_6
          } else {
            
            $writer = [i, []];
            $send(result, '[]=', Opal.to_a($writer));
            return $writer[$rb_minus($writer["length"], 1)];
          }; return nil; })();
          return entry['$<<'](row.$at(i));}, $$113.$$s = self, $$113.$$arity = 1, $$113));}, $$112.$$s = self, $$112.$$arity = 1, $$112));
      return result;
    }, $Array_transpose$111.$$arity = 0);
    
    Opal.def(self, '$union', $Array_union$114 = function $$union($a) {
      var $post_args, arrays, $$115, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      arrays = $post_args;;
      return $send(arrays, 'reduce', [self.$uniq()], ($$115 = function(a, b){var self = $$115.$$s == null ? this : $$115.$$s;

        
        
        if (a == null) {
          a = nil;
        };
        
        if (b == null) {
          b = nil;
        };
        return a['$|'](b);}, $$115.$$s = self, $$115.$$arity = 2, $$115));
    }, $Array_union$114.$$arity = -1);
    
    Opal.def(self, '$uniq', $Array_uniq$116 = function $$uniq() {
      var $iter = $Array_uniq$116.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$116.$$p = null;
      
      
      if ($iter) $Array_uniq$116.$$p = null;;
      
      var hash = $hash2([], {}), i, length, item, key;

      if (block === nil) {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          if ($hash_get(hash, item) === undefined) {
            $hash_put(hash, item, item);
          }
        }
      }
      else {
        for (i = 0, length = self.length; i < length; i++) {
          item = self[i];
          key = $yield1(block, item);
          if ($hash_get(hash, key) === undefined) {
            $hash_put(hash, key, item);
          }
        }
      }

      return (hash).$values();
    ;
    }, $Array_uniq$116.$$arity = 0);
    
    Opal.def(self, '$uniq!', $Array_uniq$excl$117 = function() {
      var $iter = $Array_uniq$excl$117.$$p, block = $iter || nil, self = this;

      if ($iter) $Array_uniq$excl$117.$$p = null;
      
      
      if ($iter) $Array_uniq$excl$117.$$p = null;;
      
      var original_length = self.length, hash = $hash2([], {}), i, length, item, key;

      for (i = 0, length = original_length; i < length; i++) {
        item = self[i];
        key = (block === nil ? item : $yield1(block, item));

        if ($hash_get(hash, key) === undefined) {
          $hash_put(hash, key, item);
          continue;
        }

        self.splice(i, 1);
        length--;
        i--;
      }

      return self.length === original_length ? nil : self;
    ;
    }, $Array_uniq$excl$117.$$arity = 0);
    
    Opal.def(self, '$unshift', $Array_unshift$118 = function $$unshift($a) {
      var $post_args, objects, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      objects = $post_args;;
      
      var selfLength = self.length
      var objectsLength = objects.length
      if (objectsLength == 0) return self;
      var index = selfLength - objectsLength
      for (var i = 0; i < objectsLength; i++) {
        self.push(self[index + i])
      }
      var len = selfLength - 1
      while (len - objectsLength >= 0) {
        self[len] = self[len - objectsLength]
        len--
      }
      for (var j = 0; j < objectsLength; j++) {
        self[j] = objects[j]
      }
      return self;
    ;
    }, $Array_unshift$118.$$arity = -1);
    $alias(self, "prepend", "unshift");
    
    Opal.def(self, '$values_at', $Array_values_at$119 = function $$values_at($a) {
      var $post_args, args, $$120, self = this, out = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      out = [];
      $send(args, 'each', [], ($$120 = function(elem){var self = $$120.$$s == null ? this : $$120.$$s, $$121, finish = nil, start = nil, i = nil;

        
        
        if (elem == null) {
          elem = nil;
        };
        if ($truthy(elem['$is_a?']($$($nesting, 'Range')))) {
          
          finish = $coerce_to(elem.$last(), $$($nesting, 'Integer'), 'to_int');
          start = $coerce_to(elem.$first(), $$($nesting, 'Integer'), 'to_int');
          
          if (start < 0) {
            start = start + self.length;
            return nil;;
          }
        ;
          
          if (finish < 0) {
            finish = finish + self.length;
          }
          if (elem['$exclude_end?']()) {
            finish--;
          }
          if (finish < start) {
            return nil;;
          }
        ;
          return $send(start, 'upto', [finish], ($$121 = function(i){var self = $$121.$$s == null ? this : $$121.$$s;

            
            
            if (i == null) {
              i = nil;
            };
            return out['$<<'](self.$at(i));}, $$121.$$s = self, $$121.$$arity = 1, $$121));
        } else {
          
          i = $coerce_to(elem, $$($nesting, 'Integer'), 'to_int');
          return out['$<<'](self.$at(i));
        };}, $$120.$$s = self, $$120.$$arity = 1, $$120));
      return out;
    }, $Array_values_at$119.$$arity = -1);
    
    Opal.def(self, '$zip', $Array_zip$122 = function $$zip($a) {
      var $iter = $Array_zip$122.$$p, block = $iter || nil, $post_args, others, self = this, $ret_or_7 = nil;

      if ($iter) $Array_zip$122.$$p = null;
      
      
      if ($iter) $Array_zip$122.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var result = [], size = self.length, part, o, i, j, jj;

      for (j = 0, jj = others.length; j < jj; j++) {
        o = others[j];
        if (o.$$is_array) {
          continue;
        }
        if (o.$$is_range || o.$$is_enumerator) {
          others[j] = o.$take(size);
          continue;
        }
        others[j] = (function() {if ($truthy(($ret_or_7 = $$($nesting, 'Opal')['$coerce_to?'](o, $$($nesting, 'Array'), "to_ary")))) {
        return $ret_or_7
      } else {
        return $$($nesting, 'Opal')['$coerce_to!'](o, $$($nesting, 'Enumerator'), "to_enum", "each")
      }; return nil; })().$to_a();
      }

      for (i = 0; i < size; i++) {
        part = [self[i]];

        for (j = 0, jj = others.length; j < jj; j++) {
          o = others[j][i];

          if (o == null) {
            o = nil;
          }

          part[j + 1] = o;
        }

        result[i] = part;
      }

      if (block !== nil) {
        for (i = 0; i < size; i++) {
          block(result[i]);
        }

        return nil;
      }

      return result;
    ;
    }, $Array_zip$122.$$arity = -1);
    Opal.defs(self, '$inherited', $Array_inherited$123 = function $$inherited(klass) {
      var self = this;

      
      klass.$$prototype.$to_a = function() {
        return this.slice(0, this.length);
      }
    
    }, $Array_inherited$123.$$arity = 1);
    
    Opal.def(self, '$instance_variables', $Array_instance_variables$124 = function $$instance_variables() {
      var $$125, $iter = $Array_instance_variables$124.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Array_instance_variables$124.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      return $send($send2(self, Opal.find_super_dispatcher(self, 'instance_variables', $Array_instance_variables$124, false, true), 'instance_variables', $zuper, $iter), 'reject', [], ($$125 = function(ivar){var self = $$125.$$s == null ? this : $$125.$$s, $ret_or_8 = nil;

        
        
        if (ivar == null) {
          ivar = nil;
        };
        if ($truthy(($ret_or_8 = /^@\d+$/.test(ivar)))) {
          return $ret_or_8
        } else {
          return ivar['$==']("@length")
        };}, $$125.$$s = self, $$125.$$arity = 1, $$125))
    }, $Array_instance_variables$124.$$arity = 0);
    $$($nesting, 'Opal').$pristine(self.$singleton_class(), "allocate");
    $$($nesting, 'Opal').$pristine(self, "copy_instance_variables", "initialize_dup");
    return (Opal.def(self, '$pack', $Array_pack$126 = function $$pack($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      return self.$raise("To use Array#pack, you must first require 'corelib/array/pack'.");
    }, $Array_pack$126.$$arity = -1), nil) && 'pack';
  })($nesting[0], Array, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/hash"] = function(Opal) {
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, $hash2 = Opal.hash2, $truthy = Opal.truthy, $alias = Opal.alias;

  Opal.add_stubs(['$require', '$include', '$coerce_to?', '$[]', '$merge!', '$allocate', '$raise', '$coerce_to!', '$each', '$fetch', '$>=', '$>', '$==', '$compare_by_identity', '$lambda?', '$abs', '$arity', '$enum_for', '$size', '$respond_to?', '$class', '$dig', '$except!', '$dup', '$delete', '$new', '$inspect', '$map', '$to_proc', '$flatten', '$eql?', '$default', '$default_proc', '$default_proc=', '$-', '$default=', '$to_h', '$proc']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Hash');

    var $nesting = [self].concat($parent_nesting), $Hash_$$$1, $Hash_allocate$2, $Hash_try_convert$3, $Hash_initialize$4, $Hash_$eq_eq$5, $Hash_$gt_eq$6, $Hash_$gt$8, $Hash_$lt$9, $Hash_$lt_eq$10, $Hash_$$$11, $Hash_$$$eq$12, $Hash_assoc$13, $Hash_clear$14, $Hash_clone$15, $Hash_compact$16, $Hash_compact$excl$17, $Hash_compare_by_identity$18, $Hash_compare_by_identity$ques$19, $Hash_default$20, $Hash_default$eq$21, $Hash_default_proc$22, $Hash_default_proc$eq$23, $Hash_delete$24, $Hash_delete_if$25, $Hash_dig$27, $Hash_each$28, $Hash_each_key$30, $Hash_each_value$32, $Hash_empty$ques$34, $Hash_except$35, $Hash_except$excl$36, $Hash_fetch$38, $Hash_fetch_values$39, $Hash_flatten$41, $Hash_has_key$ques$42, $Hash_has_value$ques$43, $Hash_hash$44, $Hash_index$45, $Hash_indexes$46, $Hash_inspect$47, $Hash_invert$48, $Hash_keep_if$49, $Hash_keys$51, $Hash_length$52, $Hash_merge$53, $Hash_merge$excl$54, $Hash_rassoc$55, $Hash_rehash$56, $Hash_reject$57, $Hash_reject$excl$59, $Hash_replace$61, $Hash_select$62, $Hash_select$excl$64, $Hash_shift$66, $Hash_slice$67, $Hash_to_a$68, $Hash_to_h$69, $Hash_to_hash$70, $Hash_to_proc$71, $Hash_transform_keys$73, $Hash_transform_keys$excl$75, $Hash_transform_values$77, $Hash_transform_values$excl$79, $Hash_values$81;

    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_hash = true;
    Opal.defs(self, '$[]', $Hash_$$$1 = function($a) {
      var $post_args, argv, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      argv = $post_args;;
      
      var hash, argc = argv.length, i;

      if (argc === 1) {
        hash = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Hash'), "to_hash");
        if (hash !== nil) {
          return self.$allocate()['$merge!'](hash);
        }

        argv = $$($nesting, 'Opal')['$coerce_to?'](argv['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if (argv === nil) {
          self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
        }

        argc = argv.length;
        hash = self.$allocate();

        for (i = 0; i < argc; i++) {
          if (!argv[i].$$is_array) continue;
          switch(argv[i].length) {
          case 1:
            hash.$store(argv[i][0], nil);
            break;
          case 2:
            hash.$store(argv[i][0], argv[i][1]);
            break;
          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid number of elements (" + (argv[i].length) + " for 1..2)")
          }
        }

        return hash;
      }

      if (argc % 2 !== 0) {
        self.$raise($$($nesting, 'ArgumentError'), "odd number of arguments for Hash")
      }

      hash = self.$allocate();

      for (i = 0; i < argc; i += 2) {
        hash.$store(argv[i], argv[i + 1]);
      }

      return hash;
    ;
    }, $Hash_$$$1.$$arity = -1);
    Opal.defs(self, '$allocate', $Hash_allocate$2 = function $$allocate() {
      var self = this;

      
      var hash = new self.$$constructor();

      Opal.hash_init(hash);

      hash.$$none = nil;
      hash.$$proc = nil;

      return hash;
    
    }, $Hash_allocate$2.$$arity = 0);
    Opal.defs(self, '$try_convert', $Hash_try_convert$3 = function $$try_convert(obj) {
      var self = this;

      return $$($nesting, 'Opal')['$coerce_to?'](obj, $$($nesting, 'Hash'), "to_hash")
    }, $Hash_try_convert$3.$$arity = 1);
    
    Opal.def(self, '$initialize', $Hash_initialize$4 = function $$initialize(defaults) {
      var $iter = $Hash_initialize$4.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_initialize$4.$$p = null;
      
      
      if ($iter) $Hash_initialize$4.$$p = null;;
      ;
      
      if (defaults !== undefined && block !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "wrong number of arguments (1 for 0)")
      }
      self.$$none = (defaults === undefined ? nil : defaults);
      self.$$proc = block;

      return self;
    ;
    }, $Hash_initialize$4.$$arity = -1);
    
    Opal.def(self, '$==', $Hash_$eq_eq$5 = function(other) {
      var self = this;

      
      if (self === other) {
        return true;
      }

      if (!other.$$is_hash) {
        return false;
      }

      if (self.$$keys.length !== other.$$keys.length) {
        return false;
      }

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, other_value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
          other_value = other.$$smap[key];
        } else {
          value = key.value;
          other_value = Opal.hash_get(other, key.key);
        }

        if (other_value === undefined || !value['$eql?'](other_value)) {
          return false;
        }
      }

      return true;
    
    }, $Hash_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$>=', $Hash_$gt_eq$6 = function(other) {
      var $$7, self = this, result = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length < other.$$keys.length) {
        return false
      }
    ;
      result = true;
      $send(other, 'each', [], ($$7 = function(other_key, other_val){var self = $$7.$$s == null ? this : $$7.$$s, val = nil;

        
        
        if (other_key == null) {
          other_key = nil;
        };
        
        if (other_val == null) {
          other_val = nil;
        };
        val = self.$fetch(other_key, null);
        
        if (val == null || val !== other_val) {
          result = false;
          return;
        }
      ;}, $$7.$$s = self, $$7.$$arity = 2, $$7));
      return result;
    }, $Hash_$gt_eq$6.$$arity = 1);
    
    Opal.def(self, '$>', $Hash_$gt$8 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      if (self.$$keys.length <= other.$$keys.length) {
        return false
      }
    ;
      return $rb_ge(self, other);
    }, $Hash_$gt$8.$$arity = 1);
    
    Opal.def(self, '$<', $Hash_$lt$9 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_gt(other, self);
    }, $Hash_$lt$9.$$arity = 1);
    
    Opal.def(self, '$<=', $Hash_$lt_eq$10 = function(other) {
      var self = this;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      return $rb_ge(other, self);
    }, $Hash_$lt_eq$10.$$arity = 1);
    
    Opal.def(self, '$[]', $Hash_$$$11 = function(key) {
      var self = this;

      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      return self.$default(key);
    
    }, $Hash_$$$11.$$arity = 1);
    
    Opal.def(self, '$[]=', $Hash_$$$eq$12 = function(key, value) {
      var self = this;

      
      Opal.hash_put(self, key, value);
      return value;
    
    }, $Hash_$$$eq$12.$$arity = 2);
    
    Opal.def(self, '$assoc', $Hash_assoc$13 = function $$assoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          if ((key)['$=='](object)) {
            return [key, self.$$smap[key]];
          }
        } else {
          if ((key.key)['$=='](object)) {
            return [key.key, key.value];
          }
        }
      }

      return nil;
    
    }, $Hash_assoc$13.$$arity = 1);
    
    Opal.def(self, '$clear', $Hash_clear$14 = function $$clear() {
      var self = this;

      
      Opal.hash_init(self);
      return self;
    
    }, $Hash_clear$14.$$arity = 0);
    
    Opal.def(self, '$clone', $Hash_clone$15 = function $$clone() {
      var self = this;

      
      var hash = new self.$$class();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    
    }, $Hash_clone$15.$$arity = 0);
    
    Opal.def(self, '$compact', $Hash_compact$16 = function $$compact() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    
    }, $Hash_compact$16.$$arity = 0);
    
    Opal.def(self, '$compact!', $Hash_compact$excl$17 = function() {
      var self = this;

      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if (value === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    
    }, $Hash_compact$excl$17.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity', $Hash_compare_by_identity$18 = function $$compare_by_identity() {
      var self = this;

      
      var i, ii, key, keys = self.$$keys, identity_hash;

      if (self.$$by_identity) return self;
      if (self.$$keys.length === 0) {
        self.$$by_identity = true
        return self;
      }

      identity_hash = $hash2([], {}).$compare_by_identity();
      for(i = 0, ii = keys.length; i < ii; i++) {
        key = keys[i];
        if (!key.$$is_string) key = key.key;
        Opal.hash_put(identity_hash, key, Opal.hash_get(self, key));
      }

      self.$$by_identity = true;
      self.$$map = identity_hash.$$map;
      self.$$smap = identity_hash.$$smap;
      return self;
    
    }, $Hash_compare_by_identity$18.$$arity = 0);
    
    Opal.def(self, '$compare_by_identity?', $Hash_compare_by_identity$ques$19 = function() {
      var self = this;

      return self.$$by_identity === true;
    }, $Hash_compare_by_identity$ques$19.$$arity = 0);
    
    Opal.def(self, '$default', $Hash_default$20 = function(key) {
      var self = this;

      
      ;
      
      if (key !== undefined && self.$$proc !== nil && self.$$proc !== undefined) {
        return self.$$proc.$call(self, key);
      }
      if (self.$$none === undefined) {
        return nil;
      }
      return self.$$none;
    ;
    }, $Hash_default$20.$$arity = -1);
    
    Opal.def(self, '$default=', $Hash_default$eq$21 = function(object) {
      var self = this;

      
      self.$$proc = nil;
      self.$$none = object;

      return object;
    
    }, $Hash_default$eq$21.$$arity = 1);
    
    Opal.def(self, '$default_proc', $Hash_default_proc$22 = function $$default_proc() {
      var self = this;

      
      if (self.$$proc !== undefined) {
        return self.$$proc;
      }
      return nil;
    
    }, $Hash_default_proc$22.$$arity = 0);
    
    Opal.def(self, '$default_proc=', $Hash_default_proc$eq$23 = function(default_proc) {
      var self = this;

      
      var proc = default_proc;

      if (proc !== nil) {
        proc = $$($nesting, 'Opal')['$coerce_to!'](proc, $$($nesting, 'Proc'), "to_proc");

        if ((proc)['$lambda?']() && (proc).$arity().$abs() !== 2) {
          self.$raise($$($nesting, 'TypeError'), "default_proc takes two arguments");
        }
      }

      self.$$none = nil;
      self.$$proc = proc;

      return default_proc;
    
    }, $Hash_default_proc$eq$23.$$arity = 1);
    
    Opal.def(self, '$delete', $Hash_delete$24 = function(key) {
      var $iter = $Hash_delete$24.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_delete$24.$$p = null;
      
      
      if ($iter) $Hash_delete$24.$$p = null;;
      
      var value = Opal.hash_delete(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return Opal.yield1(block, key);
      }

      return nil;
    ;
    }, $Hash_delete$24.$$arity = 1);
    
    Opal.def(self, '$delete_if', $Hash_delete_if$25 = function $$delete_if() {
      var $iter = $Hash_delete_if$25.$$p, block = $iter || nil, $$26, self = this;

      if ($iter) $Hash_delete_if$25.$$p = null;
      
      
      if ($iter) $Hash_delete_if$25.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["delete_if"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_delete_if$25.$$arity = 0);
    $alias(self, "dup", "clone");
    
    Opal.def(self, '$dig', $Hash_dig$27 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = self['$[]'](key);
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Hash_dig$27.$$arity = -2);
    
    Opal.def(self, '$each', $Hash_each$28 = function $$each() {
      var $iter = $Hash_each$28.$$p, block = $iter || nil, $$29, self = this;

      if ($iter) $Hash_each$28.$$p = null;
      
      
      if ($iter) $Hash_each$28.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$29 = function(){var self = $$29.$$s == null ? this : $$29.$$s;

          return self.$size()}, $$29.$$s = self, $$29.$$arity = 0, $$29))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.yield1(block, [key, value]);
      }

      return self;
    ;
    }, $Hash_each$28.$$arity = 0);
    
    Opal.def(self, '$each_key', $Hash_each_key$30 = function $$each_key() {
      var $iter = $Hash_each_key$30.$$p, block = $iter || nil, $$31, self = this;

      if ($iter) $Hash_each_key$30.$$p = null;
      
      
      if ($iter) $Hash_each_key$30.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_key"], ($$31 = function(){var self = $$31.$$s == null ? this : $$31.$$s;

          return self.$size()}, $$31.$$s = self, $$31.$$arity = 0, $$31))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? key : key.key);
      }

      return self;
    ;
    }, $Hash_each_key$30.$$arity = 0);
    $alias(self, "each_pair", "each");
    
    Opal.def(self, '$each_value', $Hash_each_value$32 = function $$each_value() {
      var $iter = $Hash_each_value$32.$$p, block = $iter || nil, $$33, self = this;

      if ($iter) $Hash_each_value$32.$$p = null;
      
      
      if ($iter) $Hash_each_value$32.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["each_value"], ($$33 = function(){var self = $$33.$$s == null ? this : $$33.$$s;

          return self.$size()}, $$33.$$s = self, $$33.$$arity = 0, $$33))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        block(key.$$is_string ? self.$$smap[key] : key.value);
      }

      return self;
    ;
    }, $Hash_each_value$32.$$arity = 0);
    
    Opal.def(self, '$empty?', $Hash_empty$ques$34 = function() {
      var self = this;

      return self.$$keys.length === 0;
    }, $Hash_empty$ques$34.$$arity = 0);
    $alias(self, "eql?", "==");
    
    Opal.def(self, '$except', $Hash_except$35 = function $$except($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(self.$dup(), 'except!', Opal.to_a(keys));
    }, $Hash_except$35.$$arity = -1);
    
    Opal.def(self, '$except!', $Hash_except$excl$36 = function($a) {
      var $post_args, keys, $$37, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      $send(keys, 'each', [], ($$37 = function(key){var self = $$37.$$s == null ? this : $$37.$$s;

        
        
        if (key == null) {
          key = nil;
        };
        return self.$delete(key);}, $$37.$$s = self, $$37.$$arity = 1, $$37));
      return self;
    }, $Hash_except$excl$36.$$arity = -1);
    
    Opal.def(self, '$fetch', $Hash_fetch$38 = function $$fetch(key, defaults) {
      var $iter = $Hash_fetch$38.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_fetch$38.$$p = null;
      
      
      if ($iter) $Hash_fetch$38.$$p = null;;
      ;
      
      var value = Opal.hash_get(self, key);

      if (value !== undefined) {
        return value;
      }

      if (block !== nil) {
        return block(key);
      }

      if (defaults !== undefined) {
        return defaults;
      }
    ;
      return self.$raise($$($nesting, 'KeyError').$new("" + "key not found: " + (key.$inspect()), $hash2(["key", "receiver"], {"key": key, "receiver": self})));
    }, $Hash_fetch$38.$$arity = -2);
    
    Opal.def(self, '$fetch_values', $Hash_fetch_values$39 = function $$fetch_values($a) {
      var $iter = $Hash_fetch_values$39.$$p, block = $iter || nil, $post_args, keys, $$40, self = this;

      if ($iter) $Hash_fetch_values$39.$$p = null;
      
      
      if ($iter) $Hash_fetch_values$39.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      return $send(keys, 'map', [], ($$40 = function(key){var self = $$40.$$s == null ? this : $$40.$$s;

        
        
        if (key == null) {
          key = nil;
        };
        return $send(self, 'fetch', [key], block.$to_proc());}, $$40.$$s = self, $$40.$$arity = 1, $$40));
    }, $Hash_fetch_values$39.$$arity = -1);
    
    Opal.def(self, '$flatten', $Hash_flatten$41 = function $$flatten(level) {
      var self = this;

      
      
      if (level == null) {
        level = 1;
      };
      level = $$($nesting, 'Opal')['$coerce_to!'](level, $$($nesting, 'Integer'), "to_int");
      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push(key);

        if (value.$$is_array) {
          if (level === 1) {
            result.push(value);
            continue;
          }

          result = result.concat((value).$flatten(level - 2));
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_flatten$41.$$arity = -1);
    
    Opal.def(self, '$has_key?', $Hash_has_key$ques$42 = function(key) {
      var self = this;

      return Opal.hash_get(self, key) !== undefined;
    }, $Hash_has_key$ques$42.$$arity = 1);
    
    Opal.def(self, '$has_value?', $Hash_has_value$ques$43 = function(value) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (((key.$$is_string ? self.$$smap[key] : key.value))['$=='](value)) {
          return true;
        }
      }

      return false;
    
    }, $Hash_has_value$ques$43.$$arity = 1);
    
    Opal.def(self, '$hash', $Hash_hash$44 = function $$hash() {
      var self = this;

      
      var top = (Opal.hash_ids === undefined),
          hash_id = self.$object_id(),
          result = ['Hash'],
          key, item;

      try {
        if (top) {
          Opal.hash_ids = Object.create(null);
        }

        if (Opal[hash_id]) {
          return 'self';
        }

        for (key in Opal.hash_ids) {
          item = Opal.hash_ids[key];
          if (self['$eql?'](item)) {
            return 'self';
          }
        }

        Opal.hash_ids[hash_id] = self;

        for (var i = 0, keys = self.$$keys, length = keys.length; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            result.push([key, self.$$smap[key].$hash()]);
          } else {
            result.push([key.key_hash, key.value.$hash()]);
          }
        }

        return result.sort().join();

      } finally {
        if (top) {
          Opal.hash_ids = undefined;
        }
      }
    
    }, $Hash_hash$44.$$arity = 0);
    $alias(self, "include?", "has_key?");
    
    Opal.def(self, '$index', $Hash_index$45 = function $$index(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return key;
        }
      }

      return nil;
    
    }, $Hash_index$45.$$arity = 1);
    
    Opal.def(self, '$indexes', $Hash_indexes$46 = function $$indexes($a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      var result = [];

      for (var i = 0, length = args.length, key, value; i < length; i++) {
        key = args[i];
        value = Opal.hash_get(self, key);

        if (value === undefined) {
          result.push(self.$default());
          continue;
        }

        result.push(value);
      }

      return result;
    ;
    }, $Hash_indexes$46.$$arity = -1);
    $alias(self, "indices", "indexes");
    var inspect_ids;
    
    Opal.def(self, '$inspect', $Hash_inspect$47 = function $$inspect() {
      var self = this;

      
      var top = (inspect_ids === undefined),
          hash_id = self.$object_id(),
          result = [];

      try {
        if (top) {
          inspect_ids = {};
        }

        if (inspect_ids.hasOwnProperty(hash_id)) {
          return '{...}';
        }

        inspect_ids[hash_id] = true;

        for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
          key = keys[i];

          if (key.$$is_string) {
            value = self.$$smap[key];
          } else {
            value = key.value;
            key = key.key;
          }

          result.push(key.$inspect() + '=>' + value.$inspect());
        }

        return '{' + result.join(', ') + '}';

      } finally {
        if (top) {
          inspect_ids = undefined;
        }
      }
    
    }, $Hash_inspect$47.$$arity = 0);
    
    Opal.def(self, '$invert', $Hash_invert$48 = function $$invert() {
      var self = this;

      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        Opal.hash_put(hash, value, key);
      }

      return hash;
    
    }, $Hash_invert$48.$$arity = 0);
    
    Opal.def(self, '$keep_if', $Hash_keep_if$49 = function $$keep_if() {
      var $iter = $Hash_keep_if$49.$$p, block = $iter || nil, $$50, self = this;

      if ($iter) $Hash_keep_if$49.$$p = null;
      
      
      if ($iter) $Hash_keep_if$49.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["keep_if"], ($$50 = function(){var self = $$50.$$s == null ? this : $$50.$$s;

          return self.$size()}, $$50.$$s = self, $$50.$$arity = 0, $$50))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
        }
      }

      return self;
    ;
    }, $Hash_keep_if$49.$$arity = 0);
    $alias(self, "key", "index");
    $alias(self, "key?", "has_key?");
    
    Opal.def(self, '$keys', $Hash_keys$51 = function $$keys() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(key);
        } else {
          result.push(key.key);
        }
      }

      return result;
    
    }, $Hash_keys$51.$$arity = 0);
    
    Opal.def(self, '$length', $Hash_length$52 = function $$length() {
      var self = this;

      return self.$$keys.length;
    }, $Hash_length$52.$$arity = 0);
    $alias(self, "member?", "has_key?");
    
    Opal.def(self, '$merge', $Hash_merge$53 = function $$merge($a) {
      var $iter = $Hash_merge$53.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Hash_merge$53.$$p = null;
      
      
      if ($iter) $Hash_merge$53.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      return $send(self.$dup(), 'merge!', Opal.to_a(others), block.$to_proc());
    }, $Hash_merge$53.$$arity = -1);
    
    Opal.def(self, '$merge!', $Hash_merge$excl$54 = function($a) {
      var $iter = $Hash_merge$excl$54.$$p, block = $iter || nil, $post_args, others, self = this;

      if ($iter) $Hash_merge$excl$54.$$p = null;
      
      
      if ($iter) $Hash_merge$excl$54.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      others = $post_args;;
      
      var i, j, other, other_keys, length, key, value, other_value;
      for (i = 0; i < others.length; ++i) {
        other = $$($nesting, 'Opal')['$coerce_to!'](others[i], $$($nesting, 'Hash'), "to_hash");
        other_keys = other.$$keys, length = other_keys.length;

        if (block === nil) {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            Opal.hash_put(self, key, other_value);
          }
        } else {
          for (j = 0; j < length; j++) {
            key = other_keys[j];

            if (key.$$is_string) {
              other_value = other.$$smap[key];
            } else {
              other_value = key.value;
              key = key.key;
            }

            value = Opal.hash_get(self, key);

            if (value === undefined) {
              Opal.hash_put(self, key, other_value);
              continue;
            }

            Opal.hash_put(self, key, block(key, value, other_value));
          }
        }
      }

      return self;
    ;
    }, $Hash_merge$excl$54.$$arity = -1);
    
    Opal.def(self, '$rassoc', $Hash_rassoc$55 = function $$rassoc(object) {
      var self = this;

      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        if ((value)['$=='](object)) {
          return [key, value];
        }
      }

      return nil;
    
    }, $Hash_rassoc$55.$$arity = 1);
    
    Opal.def(self, '$rehash', $Hash_rehash$56 = function $$rehash() {
      var self = this;

      
      Opal.hash_rehash(self);
      return self;
    
    }, $Hash_rehash$56.$$arity = 0);
    
    Opal.def(self, '$reject', $Hash_reject$57 = function $$reject() {
      var $iter = $Hash_reject$57.$$p, block = $iter || nil, $$58, self = this;

      if ($iter) $Hash_reject$57.$$p = null;
      
      
      if ($iter) $Hash_reject$57.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject"], ($$58 = function(){var self = $$58.$$s == null ? this : $$58.$$s;

          return self.$size()}, $$58.$$s = self, $$58.$$arity = 0, $$58))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_reject$57.$$arity = 0);
    
    Opal.def(self, '$reject!', $Hash_reject$excl$59 = function() {
      var $iter = $Hash_reject$excl$59.$$p, block = $iter || nil, $$60, self = this;

      if ($iter) $Hash_reject$excl$59.$$p = null;
      
      
      if ($iter) $Hash_reject$excl$59.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["reject!"], ($$60 = function(){var self = $$60.$$s == null ? this : $$60.$$s;

          return self.$size()}, $$60.$$s = self, $$60.$$arity = 0, $$60))
      };
      
      var changes_were_made = false;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            changes_were_made = true;
            length--;
            i--;
          }
        }
      }

      return changes_were_made ? self : nil;
    ;
    }, $Hash_reject$excl$59.$$arity = 0);
    
    Opal.def(self, '$replace', $Hash_replace$61 = function $$replace(other) {
      var self = this, $writer = nil;

      
      other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Hash'), "to_hash");
      
      Opal.hash_init(self);

      for (var i = 0, other_keys = other.$$keys, length = other_keys.length, key, value, other_value; i < length; i++) {
        key = other_keys[i];

        if (key.$$is_string) {
          other_value = other.$$smap[key];
        } else {
          other_value = key.value;
          key = key.key;
        }

        Opal.hash_put(self, key, other_value);
      }
    ;
      if ($truthy(other.$default_proc())) {
        
        $writer = [other.$default_proc()];
        $send(self, 'default_proc=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      } else {
        
        $writer = [other.$default()];
        $send(self, 'default=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];
      };
      return self;
    }, $Hash_replace$61.$$arity = 1);
    
    Opal.def(self, '$select', $Hash_select$62 = function $$select() {
      var $iter = $Hash_select$62.$$p, block = $iter || nil, $$63, self = this;

      if ($iter) $Hash_select$62.$$p = null;
      
      
      if ($iter) $Hash_select$62.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select"], ($$63 = function(){var self = $$63.$$s == null ? this : $$63.$$s;

          return self.$size()}, $$63.$$s = self, $$63.$$arity = 0, $$63))
      };
      
      var hash = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj !== false && obj !== nil) {
          Opal.hash_put(hash, key, value);
        }
      }

      return hash;
    ;
    }, $Hash_select$62.$$arity = 0);
    
    Opal.def(self, '$select!', $Hash_select$excl$64 = function() {
      var $iter = $Hash_select$excl$64.$$p, block = $iter || nil, $$65, self = this;

      if ($iter) $Hash_select$excl$64.$$p = null;
      
      
      if ($iter) $Hash_select$excl$64.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["select!"], ($$65 = function(){var self = $$65.$$s == null ? this : $$65.$$s;

          return self.$size()}, $$65.$$s = self, $$65.$$arity = 0, $$65))
      };
      
      var result = nil;

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value, obj; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        obj = block(key, value);

        if (obj === false || obj === nil) {
          if (Opal.hash_delete(self, key) !== undefined) {
            length--;
            i--;
          }
          result = self;
        }
      }

      return result;
    ;
    }, $Hash_select$excl$64.$$arity = 0);
    $alias(self, "filter", "select");
    $alias(self, "filter!", "select!");
    
    Opal.def(self, '$shift', $Hash_shift$66 = function $$shift() {
      var self = this;

      
      var keys = self.$$keys,
          key;

      if (keys.length > 0) {
        key = keys[0];

        key = key.$$is_string ? key : key.key;

        return [key, Opal.hash_delete(self, key)];
      }

      return self.$default(nil);
    
    }, $Hash_shift$66.$$arity = 0);
    $alias(self, "size", "length");
    
    Opal.def(self, '$slice', $Hash_slice$67 = function $$slice($a) {
      var $post_args, keys, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      keys = $post_args;;
      
      var result = Opal.hash();

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i], value = Opal.hash_get(self, key);

        if (value !== undefined) {
          Opal.hash_put(result, key, value);
        }
      }

      return result;
    ;
    }, $Hash_slice$67.$$arity = -1);
    $alias(self, "store", "[]=");
    
    Opal.def(self, '$to_a', $Hash_to_a$68 = function $$to_a() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        result.push([key, value]);
      }

      return result;
    
    }, $Hash_to_a$68.$$arity = 0);
    
    Opal.def(self, '$to_h', $Hash_to_h$69 = function $$to_h() {
      var $iter = $Hash_to_h$69.$$p, block = $iter || nil, self = this;

      if ($iter) $Hash_to_h$69.$$p = null;
      
      
      if ($iter) $Hash_to_h$69.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'map', [], block.$to_proc()).$to_h()};
      
      if (self.$$class === Opal.Hash) {
        return self;
      }

      var hash = new Opal.Hash();

      Opal.hash_init(hash);
      Opal.hash_clone(self, hash);

      return hash;
    ;
    }, $Hash_to_h$69.$$arity = 0);
    
    Opal.def(self, '$to_hash', $Hash_to_hash$70 = function $$to_hash() {
      var self = this;

      return self
    }, $Hash_to_hash$70.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Hash_to_proc$71 = function $$to_proc() {
      var $$72, self = this;

      return $send(self, 'proc', [], ($$72 = function(key){var self = $$72.$$s == null ? this : $$72.$$s;

        
        ;
        
        if (key == null) {
          self.$raise($$($nesting, 'ArgumentError'), "no key given")
        }
      ;
        return self['$[]'](key);}, $$72.$$s = self, $$72.$$arity = -1, $$72))
    }, $Hash_to_proc$71.$$arity = 0);
    $alias(self, "to_s", "inspect");
    
    Opal.def(self, '$transform_keys', $Hash_transform_keys$73 = function $$transform_keys() {
      var $iter = $Hash_transform_keys$73.$$p, block = $iter || nil, $$74, self = this;

      if ($iter) $Hash_transform_keys$73.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$73.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys"], ($$74 = function(){var self = $$74.$$s == null ? this : $$74.$$s;

          return self.$size()}, $$74.$$s = self, $$74.$$arity = 0, $$74))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        key = Opal.yield1(block, key);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_keys$73.$$arity = 0);
    
    Opal.def(self, '$transform_keys!', $Hash_transform_keys$excl$75 = function() {
      var $iter = $Hash_transform_keys$excl$75.$$p, block = $iter || nil, $$76, self = this;

      if ($iter) $Hash_transform_keys$excl$75.$$p = null;
      
      
      if ($iter) $Hash_transform_keys$excl$75.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_keys!"], ($$76 = function(){var self = $$76.$$s == null ? this : $$76.$$s;

          return self.$size()}, $$76.$$s = self, $$76.$$arity = 0, $$76))
      };
      
      var keys = Opal.slice.call(self.$$keys),
          i, length = keys.length, key, value, new_key;

      for (i = 0; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        new_key = Opal.yield1(block, key);

        Opal.hash_delete(self, key);
        Opal.hash_put(self, new_key, value);
      }

      return self;
    ;
    }, $Hash_transform_keys$excl$75.$$arity = 0);
    
    Opal.def(self, '$transform_values', $Hash_transform_values$77 = function $$transform_values() {
      var $iter = $Hash_transform_values$77.$$p, block = $iter || nil, $$78, self = this;

      if ($iter) $Hash_transform_values$77.$$p = null;
      
      
      if ($iter) $Hash_transform_values$77.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values"], ($$78 = function(){var self = $$78.$$s == null ? this : $$78.$$s;

          return self.$size()}, $$78.$$s = self, $$78.$$arity = 0, $$78))
      };
      
      var result = Opal.hash();

      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(result, key, value);
      }

      return result;
    ;
    }, $Hash_transform_values$77.$$arity = 0);
    
    Opal.def(self, '$transform_values!', $Hash_transform_values$excl$79 = function() {
      var $iter = $Hash_transform_values$excl$79.$$p, block = $iter || nil, $$80, self = this;

      if ($iter) $Hash_transform_values$excl$79.$$p = null;
      
      
      if ($iter) $Hash_transform_values$excl$79.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["transform_values!"], ($$80 = function(){var self = $$80.$$s == null ? this : $$80.$$s;

          return self.$size()}, $$80.$$s = self, $$80.$$arity = 0, $$80))
      };
      
      for (var i = 0, keys = self.$$keys, length = keys.length, key, value; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          value = self.$$smap[key];
        } else {
          value = key.value;
          key = key.key;
        }

        value = Opal.yield1(block, value);

        Opal.hash_put(self, key, value);
      }

      return self;
    ;
    }, $Hash_transform_values$excl$79.$$arity = 0);
    $alias(self, "update", "merge!");
    $alias(self, "value?", "has_value?");
    $alias(self, "values_at", "indexes");
    return (Opal.def(self, '$values', $Hash_values$81 = function $$values() {
      var self = this;

      
      var result = [];

      for (var i = 0, keys = self.$$keys, length = keys.length, key; i < length; i++) {
        key = keys[i];

        if (key.$$is_string) {
          result.push(self.$$smap[key]);
        } else {
          result.push(key.value);
        }
      }

      return result;
    
    }, $Hash_values$81.$$arity = 0), nil) && 'values';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/number"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $alias = Opal.alias, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send;

  Opal.add_stubs(['$require', '$bridge', '$raise', '$name', '$class', '$Float', '$respond_to?', '$coerce_to!', '$__coerced__', '$===', '$!', '$>', '$**', '$new', '$<', '$to_f', '$==', '$nan?', '$infinite?', '$enum_for', '$+', '$-', '$gcd', '$lcm', '$%', '$/', '$frexp', '$to_i', '$ldexp', '$rationalize', '$*', '$<<', '$to_r', '$truncate', '$-@', '$size', '$<=', '$>=']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $Number_coerce$2, $Number___id__$3, $Number_$plus$4, $Number_$minus$5, $Number_$$6, $Number_$slash$7, $Number_$percent$8, $Number_$$9, $Number_$$10, $Number_$$11, $Number_$lt$12, $Number_$lt_eq$13, $Number_$gt$14, $Number_$gt_eq$15, $Number_$lt_eq_gt$16, $Number_$lt$lt$17, $Number_$gt$gt$18, $Number_$$$19, $Number_$plus$$20, $Number_$minus$$21, $Number_$$22, $Number_$$$23, $Number_$eq_eq_eq$24, $Number_$eq_eq$25, $Number_abs$26, $Number_abs2$27, $Number_allbits$ques$28, $Number_anybits$ques$29, $Number_angle$30, $Number_bit_length$31, $Number_ceil$32, $Number_chr$33, $Number_denominator$34, $Number_downto$35, $Number_equal$ques$37, $Number_even$ques$38, $Number_floor$39, $Number_gcd$40, $Number_gcdlcm$41, $Number_integer$ques$42, $Number_is_a$ques$43, $Number_instance_of$ques$44, $Number_lcm$45, $Number_next$46, $Number_nobits$ques$47, $Number_nonzero$ques$48, $Number_numerator$49, $Number_odd$ques$50, $Number_ord$51, $Number_pow$52, $Number_pred$53, $Number_quo$54, $Number_rationalize$55, $Number_remainder$56, $Number_round$57, $Number_times$58, $Number_to_f$60, $Number_to_i$61, $Number_to_r$62, $Number_to_s$63, $Number_truncate$64, $Number_digits$65, $Number_divmod$66, $Number_upto$67, $Number_zero$ques$69, $Number_size$70, $Number_nan$ques$71, $Number_finite$ques$72, $Number_infinite$ques$73, $Number_positive$ques$74, $Number_negative$ques$75;

    
    $$($nesting, 'Opal').$bridge(Number, self);
    Opal.defineProperty(self.$$prototype, '$$is_number', true);
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$1;

      
      
      Opal.def(self, '$allocate', $allocate$1 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$1.$$arity = 0);
      
      
      Opal.udef(self, '$' + "new");;
      return nil;;
    })(Opal.get_singleton_class(self), $nesting);
    
    Opal.def(self, '$coerce', $Number_coerce$2 = function $$coerce(other) {
      var self = this;

      
      if (other === nil) {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
      else if (other.$$is_string) {
        return [self.$Float(other), self];
      }
      else if (other['$respond_to?']("to_f")) {
        return [$$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Float'), "to_f"), self];
      }
      else if (other.$$is_number) {
        return [other, self];
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't convert " + (other.$class()) + " into Float");
      }
    
    }, $Number_coerce$2.$$arity = 1);
    
    Opal.def(self, '$__id__', $Number___id__$3 = function $$__id__() {
      var self = this;

      return (self * 2) + 1;
    }, $Number___id__$3.$$arity = 0);
    $alias(self, "object_id", "__id__");
    
    Opal.def(self, '$+', $Number_$plus$4 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self + other;
      }
      else {
        return self.$__coerced__("+", other);
      }
    
    }, $Number_$plus$4.$$arity = 1);
    
    Opal.def(self, '$-', $Number_$minus$5 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self - other;
      }
      else {
        return self.$__coerced__("-", other);
      }
    
    }, $Number_$minus$5.$$arity = 1);
    
    Opal.def(self, '$*', $Number_$$6 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self * other;
      }
      else {
        return self.$__coerced__("*", other);
      }
    
    }, $Number_$$6.$$arity = 1);
    
    Opal.def(self, '$/', $Number_$slash$7 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self / other;
      }
      else {
        return self.$__coerced__("/", other);
      }
    
    }, $Number_$slash$7.$$arity = 1);
    $alias(self, "fdiv", "/");
    
    Opal.def(self, '$%', $Number_$percent$8 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        if (other == -Infinity) {
          return other;
        }
        else if (other == 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0");
        }
        else if (other < 0 || self < 0) {
          return (self % other + other) % other;
        }
        else {
          return self % other;
        }
      }
      else {
        return self.$__coerced__("%", other);
      }
    
    }, $Number_$percent$8.$$arity = 1);
    
    Opal.def(self, '$&', $Number_$$9 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self & other;
      }
      else {
        return self.$__coerced__("&", other);
      }
    
    }, $Number_$$9.$$arity = 1);
    
    Opal.def(self, '$|', $Number_$$10 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self | other;
      }
      else {
        return self.$__coerced__("|", other);
      }
    
    }, $Number_$$10.$$arity = 1);
    
    Opal.def(self, '$^', $Number_$$11 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self ^ other;
      }
      else {
        return self.$__coerced__("^", other);
      }
    
    }, $Number_$$11.$$arity = 1);
    
    Opal.def(self, '$<', $Number_$lt$12 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self < other;
      }
      else {
        return self.$__coerced__("<", other);
      }
    
    }, $Number_$lt$12.$$arity = 1);
    
    Opal.def(self, '$<=', $Number_$lt_eq$13 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self <= other;
      }
      else {
        return self.$__coerced__("<=", other);
      }
    
    }, $Number_$lt_eq$13.$$arity = 1);
    
    Opal.def(self, '$>', $Number_$gt$14 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self > other;
      }
      else {
        return self.$__coerced__(">", other);
      }
    
    }, $Number_$gt$14.$$arity = 1);
    
    Opal.def(self, '$>=', $Number_$gt_eq$15 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self >= other;
      }
      else {
        return self.$__coerced__(">=", other);
      }
    
    }, $Number_$gt_eq$15.$$arity = 1);
    
    var spaceship_operator = function(self, other) {
      if (other.$$is_number) {
        if (isNaN(self) || isNaN(other)) {
          return nil;
        }

        if (self > other) {
          return 1;
        } else if (self < other) {
          return -1;
        } else {
          return 0;
        }
      }
      else {
        return self.$__coerced__("<=>", other);
      }
    }
  ;
    
    Opal.def(self, '$<=>', $Number_$lt_eq_gt$16 = function(other) {
      var self = this;

      try {
        return spaceship_operator(self, other);
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, $Number_$lt_eq_gt$16.$$arity = 1);
    
    Opal.def(self, '$<<', $Number_$lt$lt$17 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self << count : self >> -count;
    }, $Number_$lt$lt$17.$$arity = 1);
    
    Opal.def(self, '$>>', $Number_$gt$gt$18 = function(count) {
      var self = this;

      
      count = $$($nesting, 'Opal')['$coerce_to!'](count, $$($nesting, 'Integer'), "to_int");
      return count > 0 ? self >> count : self << -count;
    }, $Number_$gt$gt$18.$$arity = 1);
    
    Opal.def(self, '$[]', $Number_$$$19 = function(bit) {
      var self = this;

      
      bit = $$($nesting, 'Opal')['$coerce_to!'](bit, $$($nesting, 'Integer'), "to_int");
      
      if (bit < 0) {
        return 0;
      }
      if (bit >= 32) {
        return self < 0 ? 1 : 0;
      }
      return (self >> bit) & 1;
    ;
    }, $Number_$$$19.$$arity = 1);
    
    Opal.def(self, '$+@', $Number_$plus$$20 = function() {
      var self = this;

      return +self;
    }, $Number_$plus$$20.$$arity = 0);
    
    Opal.def(self, '$-@', $Number_$minus$$21 = function() {
      var self = this;

      return -self;
    }, $Number_$minus$$21.$$arity = 0);
    
    Opal.def(self, '$~', $Number_$$22 = function() {
      var self = this;

      return ~self;
    }, $Number_$$22.$$arity = 0);
    
    Opal.def(self, '$**', $Number_$$$23 = function(other) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_1 = $$($nesting, 'Integer')['$==='](self)['$!']()))) {
          return $ret_or_1
        } else {
          return $rb_gt(other, 0)
        }; return nil; })())) {
          return Math.pow(self, other);
        } else {
          return $$($nesting, 'Rational').$new(self, 1)['$**'](other)
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_2 = $rb_lt(self, 0)))) {
        
        if ($truthy(($ret_or_3 = $$($nesting, 'Float')['$==='](other)))) {
          return $ret_or_3
        } else {
          return $$($nesting, 'Rational')['$==='](other)
        };
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return $$($nesting, 'Complex').$new(self, 0)['$**'](other.$to_f())
      } else if ($truthy(other.$$is_number != null)) {
        return Math.pow(self, other);
      } else {
        return self.$__coerced__("**", other)
      }
    }, $Number_$$$23.$$arity = 1);
    
    Opal.def(self, '$===', $Number_$eq_eq_eq$24 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq_eq$24.$$arity = 1);
    
    Opal.def(self, '$==', $Number_$eq_eq$25 = function(other) {
      var self = this;

      
      if (other.$$is_number) {
        return self.valueOf() === other.valueOf();
      }
      else if (other['$respond_to?']("==")) {
        return other['$=='](self);
      }
      else {
        return false;
      }
    
    }, $Number_$eq_eq$25.$$arity = 1);
    
    Opal.def(self, '$abs', $Number_abs$26 = function $$abs() {
      var self = this;

      return Math.abs(self);
    }, $Number_abs$26.$$arity = 0);
    
    Opal.def(self, '$abs2', $Number_abs2$27 = function $$abs2() {
      var self = this;

      return Math.abs(self * self);
    }, $Number_abs2$27.$$arity = 0);
    
    Opal.def(self, '$allbits?', $Number_allbits$ques$28 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == mask;;
    }, $Number_allbits$ques$28.$$arity = 1);
    
    Opal.def(self, '$anybits?', $Number_anybits$ques$29 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) !== 0;;
    }, $Number_anybits$ques$29.$$arity = 1);
    
    Opal.def(self, '$angle', $Number_angle$30 = function $$angle() {
      var self = this;

      
      if ($truthy(self['$nan?']())) {
        return self};
      
      if (self == 0) {
        if (1 / self > 0) {
          return 0;
        }
        else {
          return Math.PI;
        }
      }
      else if (self < 0) {
        return Math.PI;
      }
      else {
        return 0;
      }
    ;
    }, $Number_angle$30.$$arity = 0);
    $alias(self, "arg", "angle");
    $alias(self, "phase", "angle");
    
    Opal.def(self, '$bit_length', $Number_bit_length$31 = function $$bit_length() {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
      } else {
        self.$raise($$($nesting, 'NoMethodError').$new("" + "undefined method `bit_length` for " + (self) + ":Float", "bit_length"))
      };
      
      if (self === 0 || self === -1) {
        return 0;
      }

      var result = 0,
          value  = self < 0 ? ~self : self;

      while (value != 0) {
        result   += 1;
        value  >>>= 1;
      }

      return result;
    ;
    }, $Number_bit_length$31.$$arity = 0);
    
    Opal.def(self, '$ceil', $Number_ceil$32 = function $$ceil(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.ceil(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_ceil$32.$$arity = -1);
    
    Opal.def(self, '$chr', $Number_chr$33 = function $$chr(encoding) {
      var self = this;

      
      ;
      return Opal.enc(String.fromCharCode(self), encoding || "BINARY");;
    }, $Number_chr$33.$$arity = -1);
    
    Opal.def(self, '$denominator', $Number_denominator$34 = function $$denominator() {
      var $iter = $Number_denominator$34.$$p, $yield = $iter || nil, self = this, $ret_or_4 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_denominator$34.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_4 = self['$nan?']()))) {
        return $ret_or_4
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return 1
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'denominator', $Number_denominator$34, false, true), 'denominator', $zuper, $iter)
      }
    }, $Number_denominator$34.$$arity = 0);
    
    Opal.def(self, '$downto', $Number_downto$35 = function $$downto(stop) {
      var $iter = $Number_downto$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $Number_downto$35.$$p = null;
      
      
      if ($iter) $Number_downto$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["downto", stop], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

          
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_gt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(self, stop), 1)
          };}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i >= stop; i--) {
        block(i);
      }
    ;
      return self;
    }, $Number_downto$35.$$arity = 1);
    $alias(self, "eql?", "==");
    
    Opal.def(self, '$equal?', $Number_equal$ques$37 = function(other) {
      var self = this, $ret_or_5 = nil;

      if ($truthy(($ret_or_5 = self['$=='](other)))) {
        return $ret_or_5
      } else {
        return isNaN(self) && isNaN(other);
      }
    }, $Number_equal$ques$37.$$arity = 1);
    
    Opal.def(self, '$even?', $Number_even$ques$38 = function() {
      var self = this;

      return self % 2 === 0;
    }, $Number_even$ques$38.$$arity = 0);
    
    Opal.def(self, '$floor', $Number_floor$39 = function $$floor(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = Math.floor(f * factor) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_floor$39.$$arity = -1);
    
    Opal.def(self, '$gcd', $Number_gcd$40 = function $$gcd(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      var min = Math.abs(self),
          max = Math.abs(other);

      while (min > 0) {
        var tmp = min;

        min = max % min;
        max = tmp;
      }

      return max;
    ;
    }, $Number_gcd$40.$$arity = 1);
    
    Opal.def(self, '$gcdlcm', $Number_gcdlcm$41 = function $$gcdlcm(other) {
      var self = this;

      return [self.$gcd(other), self.$lcm(other)]
    }, $Number_gcdlcm$41.$$arity = 1);
    
    Opal.def(self, '$integer?', $Number_integer$ques$42 = function() {
      var self = this;

      return self % 1 === 0;
    }, $Number_integer$ques$42.$$arity = 0);
    
    Opal.def(self, '$is_a?', $Number_is_a$ques$43 = function(klass) {
      var $iter = $Number_is_a$ques$43.$$p, $yield = $iter || nil, self = this, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_is_a$ques$43.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_6 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_6
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_7 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_8 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'is_a?', $Number_is_a$ques$43, false, true), 'is_a?', $zuper, $iter);
    }, $Number_is_a$ques$43.$$arity = 1);
    $alias(self, "kind_of?", "is_a?");
    
    Opal.def(self, '$instance_of?', $Number_instance_of$ques$44 = function(klass) {
      var $iter = $Number_instance_of$ques$44.$$p, $yield = $iter || nil, self = this, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_instance_of$ques$44.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy((function() {if ($truthy(($ret_or_9 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_9
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_10 = klass['$==']($$($nesting, 'Integer'))))) {
        return $$($nesting, 'Integer')['$==='](self)
      } else {
        return $ret_or_10
      }; return nil; })())) {
        return true};
      if ($truthy((function() {if ($truthy(($ret_or_11 = klass['$==']($$($nesting, 'Float'))))) {
        return $$($nesting, 'Float')['$==='](self)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return true};
      return $send2(self, Opal.find_super_dispatcher(self, 'instance_of?', $Number_instance_of$ques$44, false, true), 'instance_of?', $zuper, $iter);
    }, $Number_instance_of$ques$44.$$arity = 1);
    
    Opal.def(self, '$lcm', $Number_lcm$45 = function $$lcm(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an integer")
      };
      
      if (self == 0 || other == 0) {
        return 0;
      }
      else {
        return Math.abs(self * other / self.$gcd(other));
      }
    ;
    }, $Number_lcm$45.$$arity = 1);
    $alias(self, "magnitude", "abs");
    $alias(self, "modulo", "%");
    
    Opal.def(self, '$next', $Number_next$46 = function $$next() {
      var self = this;

      return self + 1;
    }, $Number_next$46.$$arity = 0);
    
    Opal.def(self, '$nobits?', $Number_nobits$ques$47 = function(mask) {
      var self = this;

      
      mask = $$($nesting, 'Opal')['$coerce_to!'](mask, $$($nesting, 'Integer'), "to_int");
      return (self & mask) == 0;;
    }, $Number_nobits$ques$47.$$arity = 1);
    
    Opal.def(self, '$nonzero?', $Number_nonzero$ques$48 = function() {
      var self = this;

      return self == 0 ? nil : self;
    }, $Number_nonzero$ques$48.$$arity = 0);
    
    Opal.def(self, '$numerator', $Number_numerator$49 = function $$numerator() {
      var $iter = $Number_numerator$49.$$p, $yield = $iter || nil, self = this, $ret_or_12 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_numerator$49.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_12 = self['$nan?']()))) {
        return $ret_or_12
      } else {
        return self['$infinite?']()
      }; return nil; })())) {
        return self
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'numerator', $Number_numerator$49, false, true), 'numerator', $zuper, $iter)
      }
    }, $Number_numerator$49.$$arity = 0);
    
    Opal.def(self, '$odd?', $Number_odd$ques$50 = function() {
      var self = this;

      return self % 2 !== 0;
    }, $Number_odd$ques$50.$$arity = 0);
    
    Opal.def(self, '$ord', $Number_ord$51 = function $$ord() {
      var self = this;

      return self
    }, $Number_ord$51.$$arity = 0);
    
    Opal.def(self, '$pow', $Number_pow$52 = function $$pow(b, m) {
      var self = this;

      
      ;
      
      if (self == 0) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      }

      if (m === undefined) {
        return self['$**'](b);
      } else {
        if (!($$($nesting, 'Integer')['$==='](b))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless a 1st argument is integer")
        }

        if (b < 0) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 1st argument cannot be negative when 2nd argument specified")
        }

        if (!($$($nesting, 'Integer')['$==='](m))) {
          self.$raise($$($nesting, 'TypeError'), "Integer#pow() 2nd argument not allowed unless all arguments are integers")
        }

        if (m === 0) {
          self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
        }

        return self['$**'](b)['$%'](m)
      }
    ;
    }, $Number_pow$52.$$arity = -2);
    
    Opal.def(self, '$pred', $Number_pred$53 = function $$pred() {
      var self = this;

      return self - 1;
    }, $Number_pred$53.$$arity = 0);
    
    Opal.def(self, '$quo', $Number_quo$54 = function $$quo(other) {
      var $iter = $Number_quo$54.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_quo$54.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $send2(self, Opal.find_super_dispatcher(self, 'quo', $Number_quo$54, false, true), 'quo', $zuper, $iter)
      } else {
        return $rb_divide(self, other)
      }
    }, $Number_quo$54.$$arity = 1);
    
    Opal.def(self, '$rationalize', $Number_rationalize$55 = function $$rationalize(eps) {
      var $a, $b, self = this, f = nil, n = nil;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else if ($truthy(self['$nan?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(eps == null)) {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (n = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        n = $rb_minus(n, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $$($nesting, 'Rational').$new($rb_times(2, f), (1)['$<<']($rb_minus(1, n))).$rationalize($$($nesting, 'Rational').$new(1, (1)['$<<']($rb_minus(1, n))));
      } else {
        return self.$to_r().$rationalize(eps)
      };
    }, $Number_rationalize$55.$$arity = -1);
    
    Opal.def(self, '$remainder', $Number_remainder$56 = function $$remainder(y) {
      var self = this;

      return $rb_minus(self, $rb_times(y, $rb_divide(self, y).$truncate()))
    }, $Number_remainder$56.$$arity = 1);
    
    Opal.def(self, '$round', $Number_round$57 = function $$round(ndigits) {
      var $a, $b, self = this, $ret_or_13 = nil, $ret_or_14 = nil, $ret_or_15 = nil, _ = nil, exp = nil;

      
      ;
      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        
        if ($truthy(ndigits == null)) {
          return self};
        if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Float')['$==='](ndigits)))) {
          return ndigits['$infinite?']()
        } else {
          return $ret_or_13
        }; return nil; })())) {
          self.$raise($$($nesting, 'RangeError'), "Infinity")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_lt(ndigits, $$$($$($nesting, 'Integer'), 'MIN')))) {
          self.$raise($$($nesting, 'RangeError'), "out of bounds")};
        if ($truthy(ndigits >= 0)) {
          return self};
        ndigits = ndigits['$-@']();
        
        if (0.415241 * ndigits - 0.125 > self.$size()) {
          return 0;
        }

        var f = Math.pow(10, ndigits),
            x = Math.floor((Math.abs(self) + f / 2) / f) * f;

        return self < 0 ? -x : x;
      ;
      } else {
        
        if ($truthy((function() {if ($truthy(($ret_or_14 = self['$nan?']()))) {
          return ndigits == null;
        } else {
          return $ret_or_14
        }; return nil; })())) {
          self.$raise($$($nesting, 'FloatDomainError'), "NaN")};
        ndigits = $$($nesting, 'Opal')['$coerce_to!'](ndigits || 0, $$($nesting, 'Integer'), "to_int");
        if ($truthy($rb_le(ndigits, 0))) {
          if ($truthy(self['$nan?']())) {
            self.$raise($$($nesting, 'RangeError'), "NaN")
          } else if ($truthy(self['$infinite?']())) {
            self.$raise($$($nesting, 'FloatDomainError'), "Infinity")}
        } else if (ndigits['$=='](0)) {
          return Math.round(self)
        } else if ($truthy((function() {if ($truthy(($ret_or_15 = self['$nan?']()))) {
          return $ret_or_15
        } else {
          return self['$infinite?']()
        }; return nil; })())) {
          return self};
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (_ = ($a[0] == null ? nil : $a[0])), (exp = ($a[1] == null ? nil : $a[1])), $b;
        if ($truthy($rb_ge(ndigits, $rb_minus($rb_plus($$$($$($nesting, 'Float'), 'DIG'), 2), (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_divide(exp, 4)
        } else {
          return $rb_minus($rb_divide(exp, 3), 1)
        }; return nil; })())))) {
          return self};
        if ($truthy($rb_lt(ndigits, (function() {if ($truthy($rb_gt(exp, 0))) {
          return $rb_plus($rb_divide(exp, 3), 1)
        } else {
          return $rb_divide(exp, 4)
        }; return nil; })()['$-@']()))) {
          return 0};
        return Math.round(self * Math.pow(10, ndigits)) / Math.pow(10, ndigits);;
      };
    }, $Number_round$57.$$arity = -1);
    $alias(self, "succ", "next");
    
    Opal.def(self, '$times', $Number_times$58 = function $$times() {
      var $iter = $Number_times$58.$$p, block = $iter || nil, $$59, self = this;

      if ($iter) $Number_times$58.$$p = null;
      
      
      if ($iter) $Number_times$58.$$p = null;;
      if ($truthy(block)) {
      } else {
        return $send(self, 'enum_for', ["times"], ($$59 = function(){var self = $$59.$$s == null ? this : $$59.$$s;

          return self}, $$59.$$s = self, $$59.$$arity = 0, $$59))
      };
      
      for (var i = 0; i < self; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_times$58.$$arity = 0);
    
    Opal.def(self, '$to_f', $Number_to_f$60 = function $$to_f() {
      var self = this;

      return self
    }, $Number_to_f$60.$$arity = 0);
    
    Opal.def(self, '$to_i', $Number_to_i$61 = function $$to_i() {
      var self = this;

      return self < 0 ? Math.ceil(self) : Math.floor(self);
    }, $Number_to_i$61.$$arity = 0);
    $alias(self, "to_int", "to_i");
    
    Opal.def(self, '$to_r', $Number_to_r$62 = function $$to_r() {
      var $a, $b, self = this, f = nil, e = nil;

      if ($truthy($$($nesting, 'Integer')['$==='](self))) {
        return $$($nesting, 'Rational').$new(self, 1)
      } else {
        
        $b = $$($nesting, 'Math').$frexp(self), $a = Opal.to_ary($b), (f = ($a[0] == null ? nil : $a[0])), (e = ($a[1] == null ? nil : $a[1])), $b;
        f = $$($nesting, 'Math').$ldexp(f, $$$($$($nesting, 'Float'), 'MANT_DIG')).$to_i();
        e = $rb_minus(e, $$$($$($nesting, 'Float'), 'MANT_DIG'));
        return $rb_times(f, $$$($$($nesting, 'Float'), 'RADIX')['$**'](e)).$to_r();
      }
    }, $Number_to_r$62.$$arity = 0);
    
    Opal.def(self, '$to_s', $Number_to_s$63 = function $$to_s(base) {
      var self = this, $ret_or_16 = nil;

      
      
      if (base == null) {
        base = 10;
      };
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy((function() {if ($truthy(($ret_or_16 = $rb_lt(base, 2)))) {
        return $ret_or_16
      } else {
        return $rb_gt(base, 36)
      }; return nil; })())) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      return self.toString(base);;
    }, $Number_to_s$63.$$arity = -1);
    
    Opal.def(self, '$truncate', $Number_truncate$64 = function $$truncate(ndigits) {
      var self = this;

      
      
      if (ndigits == null) {
        ndigits = 0;
      };
      
      var f = self.$to_f();

      if (f % 1 === 0 && ndigits >= 0) {
        return f;
      }

      var factor = Math.pow(10, ndigits),
          result = parseInt(f * factor, 10) / factor;

      if (f % 1 === 0) {
        result = Math.round(result);
      }

      return result;
    ;
    }, $Number_truncate$64.$$arity = -1);
    $alias(self, "inspect", "to_s");
    
    Opal.def(self, '$digits', $Number_digits$65 = function $$digits(base) {
      var self = this;

      
      
      if (base == null) {
        base = 10;
      };
      if ($rb_lt(self, 0)) {
        self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "out of domain")};
      base = $$($nesting, 'Opal')['$coerce_to!'](base, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(base, 2))) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "invalid radix " + (base))};
      
      var value = self, result = [];

      while (value !== 0) {
        result.push(value % base);
        value = parseInt(value / base, 10);
      }

      return result;
    ;
    }, $Number_digits$65.$$arity = -1);
    
    Opal.def(self, '$divmod', $Number_divmod$66 = function $$divmod(other) {
      var $iter = $Number_divmod$66.$$p, $yield = $iter || nil, self = this, $ret_or_17 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Number_divmod$66.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy((function() {if ($truthy(($ret_or_17 = self['$nan?']()))) {
        return $ret_or_17
      } else {
        return other['$nan?']()
      }; return nil; })())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "NaN")
      } else if ($truthy(self['$infinite?']())) {
        return self.$raise($$($nesting, 'FloatDomainError'), "Infinity")
      } else {
        return $send2(self, Opal.find_super_dispatcher(self, 'divmod', $Number_divmod$66, false, true), 'divmod', $zuper, $iter)
      }
    }, $Number_divmod$66.$$arity = 1);
    
    Opal.def(self, '$upto', $Number_upto$67 = function $$upto(stop) {
      var $iter = $Number_upto$67.$$p, block = $iter || nil, $$68, self = this;

      if ($iter) $Number_upto$67.$$p = null;
      
      
      if ($iter) $Number_upto$67.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["upto", stop], ($$68 = function(){var self = $$68.$$s == null ? this : $$68.$$s;

          
          if ($truthy($$($nesting, 'Numeric')['$==='](stop))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
          };
          if ($truthy($rb_lt(stop, self))) {
            return 0
          } else {
            return $rb_plus($rb_minus(stop, self), 1)
          };}, $$68.$$s = self, $$68.$$arity = 0, $$68))
      };
      
      if (!stop.$$is_number) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "comparison of " + (self.$class()) + " with " + (stop.$class()) + " failed")
      }
      for (var i = self; i <= stop; i++) {
        block(i);
      }
    ;
      return self;
    }, $Number_upto$67.$$arity = 1);
    
    Opal.def(self, '$zero?', $Number_zero$ques$69 = function() {
      var self = this;

      return self == 0;
    }, $Number_zero$ques$69.$$arity = 0);
    
    Opal.def(self, '$size', $Number_size$70 = function $$size() {
      var self = this;

      return 4
    }, $Number_size$70.$$arity = 0);
    
    Opal.def(self, '$nan?', $Number_nan$ques$71 = function() {
      var self = this;

      return isNaN(self);
    }, $Number_nan$ques$71.$$arity = 0);
    
    Opal.def(self, '$finite?', $Number_finite$ques$72 = function() {
      var self = this;

      return self != Infinity && self != -Infinity && !isNaN(self);
    }, $Number_finite$ques$72.$$arity = 0);
    
    Opal.def(self, '$infinite?', $Number_infinite$ques$73 = function() {
      var self = this;

      
      if (self == Infinity) {
        return +1;
      }
      else if (self == -Infinity) {
        return -1;
      }
      else {
        return nil;
      }
    
    }, $Number_infinite$ques$73.$$arity = 0);
    
    Opal.def(self, '$positive?', $Number_positive$ques$74 = function() {
      var self = this;

      return self != 0 && (self == Infinity || 1 / self > 0);
    }, $Number_positive$ques$74.$$arity = 0);
    return (Opal.def(self, '$negative?', $Number_negative$ques$75 = function() {
      var self = this;

      return self == -Infinity || 1 / self < 0;
    }, $Number_negative$ques$75.$$arity = 0), nil) && 'negative?';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  Opal.const_set($nesting[0], 'Fixnum', $$($nesting, 'Number'));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Integer');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    self.$$is_integer_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$76, $sqrt$77;

      
      
      Opal.def(self, '$allocate', $allocate$76 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$76.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$sqrt', $sqrt$77 = function $$sqrt(n) {
        var self = this;

        
        n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
        
        if (n < 0) {
          self.$raise($$$($$($nesting, 'Math'), 'DomainError'), "Numerical argument is out of domain - \"isqrt\"")
        }

        return parseInt(Math.sqrt(n), 10);
      ;
      }, $sqrt$77.$$arity = 1), nil) && 'sqrt';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'MAX', Math.pow(2, 30) - 1);
    return Opal.const_set($nesting[0], 'MIN', -Math.pow(2, 30));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Float');

    var $nesting = [self].concat($parent_nesting);

    
    self.$$is_number_class = true;
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $allocate$78, $eq_eq_eq$79;

      
      
      Opal.def(self, '$allocate', $allocate$78 = function $$allocate() {
        var self = this;

        return self.$raise($$($nesting, 'TypeError'), "" + "allocator undefined for " + (self.$name()))
      }, $allocate$78.$$arity = 0);
      
      Opal.udef(self, '$' + "new");;
      return (Opal.def(self, '$===', $eq_eq_eq$79 = function(other) {
        var self = this;

        return !!other.$$is_number;
      }, $eq_eq_eq$79.$$arity = 1), nil) && '===';
    })(Opal.get_singleton_class(self), $nesting);
    Opal.const_set($nesting[0], 'INFINITY', Infinity);
    Opal.const_set($nesting[0], 'MAX', Number.MAX_VALUE);
    Opal.const_set($nesting[0], 'MIN', Number.MIN_VALUE);
    Opal.const_set($nesting[0], 'NAN', NaN);
    Opal.const_set($nesting[0], 'DIG', 15);
    Opal.const_set($nesting[0], 'MANT_DIG', 53);
    Opal.const_set($nesting[0], 'RADIX', 2);
    return Opal.const_set($nesting[0], 'EPSILON', Number.EPSILON || 2.2204460492503130808472633361816E-16);
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/range"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $send2 = Opal.send2, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs(['$require', '$include', '$attr_reader', '$raise', '$<=>', '$nil?', '$include?', '$!', '$<', '$<=', '$enum_for', '$size', '$upto', '$to_proc', '$respond_to?', '$class', '$succ', '$==', '$===', '$exclude_end?', '$eql?', '$begin', '$end', '$last', '$to_a', '$>', '$-@', '$-', '$to_i', '$coerce_to!', '$ceil', '$/', '$loop', '$+', '$*', '$>=', '$each_with_index', '$%', '$bsearch', '$inspect', '$[]', '$hash']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Range');

    var $nesting = [self].concat($parent_nesting), $Range_initialize$1, $Range_$eq_eq_eq$2, $Range_count$3, $Range_to_a$4, $Range_cover$ques$5, $Range_each$6, $Range_eql$ques$8, $Range_exclude_end$ques$9, $Range_first$10, $Range_last$11, $Range_max$12, $Range_min$13, $Range_size$14, $Range_step$15, $Range_bsearch$19, $Range_to_s$20, $Range_inspect$21, $Range_marshal_load$22, $Range_hash$23;

    self.$$prototype.begin = self.$$prototype.end = self.$$prototype.excl = nil;
    
    self.$include($$($nesting, 'Enumerable'));
    self.$$prototype.$$is_range = true;
    self.$attr_reader("begin", "end");
    
    Opal.def(self, '$initialize', $Range_initialize$1 = function $$initialize(first, last, exclude) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      
      if (exclude == null) {
        exclude = false;
      };
      if ($truthy(self.begin)) {
        self.$raise($$($nesting, 'NameError'), "'initialize' called twice")};
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = first['$<=>'](last)))) {
        return $ret_or_2
      } else {
        return first['$nil?']()
      }; return nil; })()))) {
        return $ret_or_1
      } else {
        return last['$nil?']()
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "bad value for range")
      };
      self.begin = first;
      self.end = last;
      return (self.excl = exclude);
    }, $Range_initialize$1.$$arity = -3);
    
    Opal.def(self, '$===', $Range_$eq_eq_eq$2 = function(value) {
      var self = this;

      return self['$include?'](value)
    }, $Range_$eq_eq_eq$2.$$arity = 1);
    
    function is_infinite(self) {
      if (self.begin === nil || self.end === nil ||
          self.begin === -Infinity || self.end === Infinity ||
          self.begin === Infinity || self.end === -Infinity) return true;
      return false;
    }
  ;
    
    Opal.def(self, '$count', $Range_count$3 = function $$count() {
      var $iter = $Range_count$3.$$p, block = $iter || nil, self = this, $ret_or_3 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_count$3.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      
      if ($iter) $Range_count$3.$$p = null;;
      if ($truthy((function() {if ($truthy(($ret_or_3 = (block !== nil)['$!']()))) {
        return is_infinite(self);
      } else {
        return $ret_or_3
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')};
      return $send2(self, Opal.find_super_dispatcher(self, 'count', $Range_count$3, false, true), 'count', $zuper, $iter);
    }, $Range_count$3.$$arity = 0);
    
    Opal.def(self, '$to_a', $Range_to_a$4 = function $$to_a() {
      var $iter = $Range_to_a$4.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_to_a$4.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      if ($truthy(is_infinite(self))) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert endless range to an array")};
      return $send2(self, Opal.find_super_dispatcher(self, 'to_a', $Range_to_a$4, false, true), 'to_a', $zuper, $iter);
    }, $Range_to_a$4.$$arity = 0);
    
    Opal.def(self, '$cover?', $Range_cover$ques$5 = function(value) {
      var self = this, beg_cmp = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, end_cmp = nil, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil, $ret_or_11 = nil, $ret_or_12 = nil, $ret_or_13 = nil;

      
      beg_cmp = (function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = self.begin['$nil?']()))) {
        return -1
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        
        return self.begin['$<=>'](value);
      }; return nil; })()))) {
        return $ret_or_4
      } else {
        return false
      }; return nil; })();
      end_cmp = (function() {if ($truthy(($ret_or_7 = (function() {if ($truthy(($ret_or_8 = (function() {if ($truthy(($ret_or_9 = self.end['$nil?']()))) {
        return -1
      } else {
        return $ret_or_9
      }; return nil; })()))) {
        return $ret_or_8
      } else {
        
        return value['$<=>'](self.end);
      }; return nil; })()))) {
        return $ret_or_7
      } else {
        return false
      }; return nil; })();
      if ($truthy(($ret_or_10 = (function() {if ($truthy(($ret_or_11 = (function() {if ($truthy(self.excl)) {
        if ($truthy(($ret_or_12 = end_cmp))) {
          return $rb_lt(end_cmp, 0)
        } else {
          return $ret_or_12
        }
      } else if ($truthy(($ret_or_13 = end_cmp))) {
        return $rb_le(end_cmp, 0)
      } else {
        return $ret_or_13
      }; return nil; })()))) {
        return beg_cmp
      } else {
        return $ret_or_11
      }; return nil; })()))) {
        return $rb_le(beg_cmp, 0)
      } else {
        return $ret_or_10
      };
    }, $Range_cover$ques$5.$$arity = 1);
    
    Opal.def(self, '$each', $Range_each$6 = function $$each() {
      var $iter = $Range_each$6.$$p, block = $iter || nil, $$7, $a, self = this, current = nil, last = nil, $ret_or_14 = nil, $ret_or_15 = nil;

      if ($iter) $Range_each$6.$$p = null;
      
      
      if ($iter) $Range_each$6.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

          return self.$size()}, $$7.$$s = self, $$7.$$arity = 0, $$7))
      };
      
      var i, limit;

      if (self.begin.$$is_number && self.end.$$is_number) {
        if (self.begin % 1 !== 0 || self.end % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "can't iterate from Float")
        }

        for (i = self.begin, limit = self.end + (function() {if ($truthy(self.excl)) {
        return 0
      } else {
        return 1
      }; return nil; })(); i < limit; i++) {
          block(i);
        }

        return self;
      }

      if (self.begin.$$is_string && self.end.$$is_string) {
        $send(self.begin, 'upto', [self.end, self.excl], block.$to_proc())
        return self;
      }
    ;
      current = self.begin;
      last = self.end;
      if ($truthy(current['$respond_to?']("succ"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't iterate from " + (current.$class()))
      };
      while ($truthy((function() {if ($truthy(($ret_or_14 = self.end['$nil?']()))) {
        return $ret_or_14
      } else {
        return $rb_lt(current['$<=>'](last), 0)
      }; return nil; })())) {
        
        Opal.yield1(block, current);
        current = current.$succ();
      };
      if ($truthy((function() {if ($truthy(($ret_or_15 = self.excl['$!']()))) {
        return current['$=='](last)
      } else {
        return $ret_or_15
      }; return nil; })())) {
        Opal.yield1(block, current)};
      return self;
    }, $Range_each$6.$$arity = 0);
    
    Opal.def(self, '$eql?', $Range_eql$ques$8 = function(other) {
      var self = this, $ret_or_16 = nil, $ret_or_17 = nil;

      
      if ($truthy($$($nesting, 'Range')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = self.excl['$==='](other['$exclude_end?']())))) {
        return self.begin['$eql?'](other.$begin())
      } else {
        return $ret_or_17
      }; return nil; })()))) {
        return self.end['$eql?'](other.$end())
      } else {
        return $ret_or_16
      };
    }, $Range_eql$ques$8.$$arity = 1);
    $alias(self, "==", "eql?");
    
    Opal.def(self, '$exclude_end?', $Range_exclude_end$ques$9 = function() {
      var self = this;

      return self.excl
    }, $Range_exclude_end$ques$9.$$arity = 0);
    
    Opal.def(self, '$first', $Range_first$10 = function $$first(n) {
      var $iter = $Range_first$10.$$p, $yield = $iter || nil, self = this, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_first$10.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      
      ;
      if ($truthy(self.begin['$nil?']())) {
        self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range")};
      if ($truthy(n == null)) {
        return self.begin};
      return $send2(self, Opal.find_super_dispatcher(self, 'first', $Range_first$10, false, true), 'first', $zuper, $iter);
    }, $Range_first$10.$$arity = -1);
    $alias(self, "include?", "cover?");
    
    Opal.def(self, '$last', $Range_last$11 = function $$last(n) {
      var self = this;

      
      ;
      if ($truthy(self.end['$nil?']())) {
        self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range")};
      if ($truthy(n == null)) {
        return self.end};
      return self.$to_a().$last(n);
    }, $Range_last$11.$$arity = -1);
    
    Opal.def(self, '$max', $Range_max$12 = function $$max() {
      var $iter = $Range_max$12.$$p, $yield = $iter || nil, self = this, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_max$12.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(self.end['$nil?']())) {
        return self.$raise($$($nesting, 'RangeError'), "cannot get the maximum of endless range")
      } else if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'max', $Range_max$12, false, true), 'max', $zuper, $iter)
      } else if ($truthy((function() {if ($truthy(($ret_or_18 = self.begin['$nil?']()['$!']()))) {
        
        if ($truthy(($ret_or_19 = $rb_gt(self.begin, self.end)))) {
          return $ret_or_19
        } else if ($truthy(($ret_or_20 = self.excl))) {
          return self.begin['$=='](self.end)
        } else {
          return $ret_or_20
        };
      } else {
        return $ret_or_18
      }; return nil; })())) {
        return nil
      } else {
        return self.excl ? self.end - 1 : self.end
      }
    }, $Range_max$12.$$arity = 0);
    $alias(self, "member?", "cover?");
    
    Opal.def(self, '$min', $Range_min$13 = function $$min() {
      var $iter = $Range_min$13.$$p, $yield = $iter || nil, self = this, $ret_or_21 = nil, $ret_or_22 = nil, $ret_or_23 = nil, $zuper = nil, $zuper_i = nil, $zuper_ii = nil;

      if ($iter) $Range_min$13.$$p = null;
      // Prepare super implicit arguments
      for($zuper_i = 0, $zuper_ii = arguments.length, $zuper = new Array($zuper_ii); $zuper_i < $zuper_ii; $zuper_i++) {
        $zuper[$zuper_i] = arguments[$zuper_i];
      }
      if ($truthy(self.begin['$nil?']())) {
        return self.$raise($$($nesting, 'RangeError'), "cannot get the minimum of beginless range")
      } else if (($yield !== nil)) {
        return $send2(self, Opal.find_super_dispatcher(self, 'min', $Range_min$13, false, true), 'min', $zuper, $iter)
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = self.end['$nil?']()['$!']()))) {
        
        if ($truthy(($ret_or_22 = $rb_gt(self.begin, self.end)))) {
          return $ret_or_22
        } else if ($truthy(($ret_or_23 = self.excl))) {
          return self.begin['$=='](self.end)
        } else {
          return $ret_or_23
        };
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return nil
      } else {
        return self.begin
      }
    }, $Range_min$13.$$arity = 0);
    
    Opal.def(self, '$size', $Range_size$14 = function $$size() {
      var self = this, infinity = nil, $ret_or_24 = nil, $ret_or_25 = nil, $ret_or_26 = nil, $ret_or_27 = nil, range_begin = nil, range_end = nil;

      
      infinity = $$$($$($nesting, 'Float'), 'INFINITY');
      if ($truthy((function() {if ($truthy(($ret_or_24 = (function() {if ($truthy(($ret_or_25 = self.begin['$=='](infinity)))) {
        return self.end['$nil?']()['$!']()
      } else {
        return $ret_or_25
      }; return nil; })()))) {
        return $ret_or_24
      } else {
        
        if ($truthy(($ret_or_26 = self.end['$=='](infinity['$-@']())))) {
          return self.begin['$nil?']()['$!']()
        } else {
          return $ret_or_26
        };
      }; return nil; })())) {
        return 0};
      if ($truthy(is_infinite(self))) {
        return infinity};
      if ($truthy((function() {if ($truthy(($ret_or_27 = $$($nesting, 'Numeric')['$==='](self.begin)))) {
        return $$($nesting, 'Numeric')['$==='](self.end)
      } else {
        return $ret_or_27
      }; return nil; })())) {
      } else {
        return nil
      };
      range_begin = self.begin;
      range_end = self.end;
      if ($truthy(self.excl)) {
        range_end = $rb_minus(range_end, 1)};
      if ($truthy($rb_lt(range_end, range_begin))) {
        return 0};
      return (Math.abs(range_end - range_begin) + 1).$to_i();
    }, $Range_size$14.$$arity = 0);
    
    Opal.def(self, '$step', $Range_step$15 = function $$step(n) {
      var $$16, $$17, $$18, $iter = $Range_step$15.$$p, $yield = $iter || nil, self = this, i = nil;

      if ($iter) $Range_step$15.$$p = null;
      
      
      if (n == null) {
        n = 1;
      };
      
      function coerceStepSize() {
        if (!n.$$is_number) {
          n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int")
        }

        if (n < 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be negative")
        } else if (n === 0) {
          self.$raise($$($nesting, 'ArgumentError'), "step can't be 0")
        }
      }

      function enumeratorSize() {
        if (!self.begin['$respond_to?']("succ")) {
          return nil;
        }

        if (self.begin.$$is_string && self.end.$$is_string) {
          return nil;
        }

        if (n % 1 === 0) {
          return $rb_divide(self.$size(), n).$ceil();
        } else {
          // n is a float
          var begin = self.begin, end = self.end,
              abs = Math.abs, floor = Math.floor,
              err = (abs(begin) + abs(end) + abs(end - begin)) / abs(n) * $$$($$($nesting, 'Float'), 'EPSILON'),
              size;

          if (err > 0.5) {
            err = 0.5;
          }

          if (self.excl) {
            size = floor((end - begin) / n - err);
            if (size * n + begin < end) {
              size++;
            }
          } else {
            size = floor((end - begin) / n + err) + 1
          }

          return size;
        }
      }
    ;
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["step", n], ($$16 = function(){var self = $$16.$$s == null ? this : $$16.$$s;

          
          coerceStepSize();
          return enumeratorSize();
        }, $$16.$$s = self, $$16.$$arity = 0, $$16))
      };
      coerceStepSize();
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
        
        i = 0;
        (function(){var $brk = Opal.new_brk(); try {return $send(self, 'loop', [], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, current = nil;
          if (self.begin == null) self.begin = nil;
          if (self.excl == null) self.excl = nil;
          if (self.end == null) self.end = nil;

          
          current = $rb_plus(self.begin, $rb_times(i, n));
          if ($truthy(self.excl)) {
            if ($truthy($rb_ge(current, self.end))) {
              
              Opal.brk(nil, $brk)}
          } else if ($truthy($rb_gt(current, self.end))) {
            
            Opal.brk(nil, $brk)};
          Opal.yield1($yield, current);
          return (i = $rb_plus(i, 1));}, $$17.$$s = self, $$17.$$brk = $brk, $$17.$$arity = 0, $$17))
        } catch (err) { if (err === $brk) { return err.$v } else { throw err } }})();
      } else {
        
        
        if (self.begin.$$is_string && self.end.$$is_string && n % 1 !== 0) {
          self.$raise($$($nesting, 'TypeError'), "no implicit conversion to float from string")
        }
      ;
        $send(self, 'each_with_index', [], ($$18 = function(value, idx){var self = $$18.$$s == null ? this : $$18.$$s;

          
          
          if (value == null) {
            value = nil;
          };
          
          if (idx == null) {
            idx = nil;
          };
          if (idx['$%'](n)['$=='](0)) {
            return Opal.yield1($yield, value);
          } else {
            return nil
          };}, $$18.$$s = self, $$18.$$arity = 2, $$18));
      };
      return self;
    }, $Range_step$15.$$arity = -1);
    
    Opal.def(self, '$bsearch', $Range_bsearch$19 = function $$bsearch() {
      var $iter = $Range_bsearch$19.$$p, block = $iter || nil, self = this;

      if ($iter) $Range_bsearch$19.$$p = null;
      
      
      if ($iter) $Range_bsearch$19.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("bsearch")
      };
      if ($truthy(is_infinite(self) && (self.begin.$$is_number || self.end.$$is_number))) {
        self.$raise($$($nesting, 'NotImplementedError'), "Can't #bsearch an infinite range")};
      if ($truthy(self.begin.$$is_number && self.end.$$is_number)) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't do binary search for " + (self.begin.$class()))
      };
      return $send(self.$to_a(), 'bsearch', [], block.$to_proc());
    }, $Range_bsearch$19.$$arity = 0);
    
    Opal.def(self, '$to_s', $Range_to_s$20 = function $$to_s() {
      var self = this, $ret_or_28 = nil, $ret_or_29 = nil;

      return "" + ((function() {if ($truthy(($ret_or_28 = self.begin))) {
        return $ret_or_28
      } else {
        return ""
      }; return nil; })()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + ((function() {if ($truthy(($ret_or_29 = self.end))) {
        return $ret_or_29
      } else {
        return ""
      }; return nil; })())
    }, $Range_to_s$20.$$arity = 0);
    
    Opal.def(self, '$inspect', $Range_inspect$21 = function $$inspect() {
      var self = this, $ret_or_30 = nil, $ret_or_31 = nil;

      return "" + ((function() {if ($truthy(($ret_or_30 = self.begin))) {
        return self.begin.$inspect()
      } else {
        return $ret_or_30
      }; return nil; })()) + ((function() {if ($truthy(self.excl)) {
        return "..."
      } else {
        return ".."
      }; return nil; })()) + ((function() {if ($truthy(($ret_or_31 = self.end))) {
        return self.end.$inspect()
      } else {
        return $ret_or_31
      }; return nil; })())
    }, $Range_inspect$21.$$arity = 0);
    
    Opal.def(self, '$marshal_load', $Range_marshal_load$22 = function $$marshal_load(args) {
      var self = this;

      
      self.begin = args['$[]']("begin");
      self.end = args['$[]']("end");
      return (self.excl = args['$[]']("excl"));
    }, $Range_marshal_load$22.$$arity = 1);
    return (Opal.def(self, '$hash', $Range_hash$23 = function $$hash() {
      var self = this;

      return [self.begin, self.end, self.excl].$hash()
    }, $Range_hash$23.$$arity = 0), nil) && 'hash';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/proc"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $send = Opal.send;

  Opal.add_stubs(['$raise', '$proc', '$call', '$to_proc', '$coerce_to!']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Proc');

    var $nesting = [self].concat($parent_nesting), $Proc_new$1, $Proc_call$2, $Proc_$gt$gt$3, $Proc_$lt$lt$5, $Proc_to_proc$7, $Proc_lambda$ques$8, $Proc_arity$9, $Proc_source_location$10, $Proc_binding$11, $Proc_parameters$12, $Proc_curry$13, $Proc_dup$14;

    
    Opal.defineProperty(self.$$prototype, '$$is_proc', true);
    Opal.defineProperty(self.$$prototype, '$$is_lambda', false);
    Opal.defs(self, '$new', $Proc_new$1 = function() {
      var $iter = $Proc_new$1.$$p, block = $iter || nil, self = this;

      if ($iter) $Proc_new$1.$$p = null;
      
      
      if ($iter) $Proc_new$1.$$p = null;;
      if ($truthy(block)) {
      } else {
        self.$raise($$($nesting, 'ArgumentError'), "tried to create a Proc object without a block")
      };
      return block;
    }, $Proc_new$1.$$arity = 0);
    
    Opal.def(self, '$call', $Proc_call$2 = function $$call($a) {
      var $iter = $Proc_call$2.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Proc_call$2.$$p = null;
      
      
      if ($iter) $Proc_call$2.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      if (block !== nil) {
        self.$$p = block;
      }

      var result, $brk = self.$$brk;

      if ($brk) {
        try {
          if (self.$$is_lambda) {
            result = self.apply(null, args);
          }
          else {
            result = Opal.yieldX(self, args);
          }
        } catch (err) {
          if (err === $brk) {
            return $brk.$v
          }
          else {
            throw err
          }
        }
      }
      else {
        if (self.$$is_lambda) {
          result = self.apply(null, args);
        }
        else {
          result = Opal.yieldX(self, args);
        }
      }

      return result;
    ;
    }, $Proc_call$2.$$arity = -1);
    $alias(self, "[]", "call");
    $alias(self, "===", "call");
    $alias(self, "yield", "call");
    
    Opal.def(self, '$>>', $Proc_$gt$gt$3 = function(other) {
      var $$4, $iter = $Proc_$gt$gt$3.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$gt$gt$3.$$p = null;
      return $send(self, 'proc', [], ($$4 = function($a){var self = $$4.$$s == null ? this : $$4.$$s, $iter = $$4.$$p, block = $iter || nil, $post_args, args, out = nil;

        
        
        if ($iter) $$4.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(self, 'call', Opal.to_a(args), block.$to_proc());
        return other.$call(out);}, $$4.$$s = self, $$4.$$arity = -1, $$4))
    }, $Proc_$gt$gt$3.$$arity = 1);
    
    Opal.def(self, '$<<', $Proc_$lt$lt$5 = function(other) {
      var $$6, $iter = $Proc_$lt$lt$5.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Proc_$lt$lt$5.$$p = null;
      return $send(self, 'proc', [], ($$6 = function($a){var self = $$6.$$s == null ? this : $$6.$$s, $iter = $$6.$$p, block = $iter || nil, $post_args, args, out = nil;

        
        
        if ($iter) $$6.$$p = null;;
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        args = $post_args;;
        out = $send(other, 'call', Opal.to_a(args), block.$to_proc());
        return self.$call(out);}, $$6.$$s = self, $$6.$$arity = -1, $$6))
    }, $Proc_$lt$lt$5.$$arity = 1);
    
    Opal.def(self, '$to_proc', $Proc_to_proc$7 = function $$to_proc() {
      var self = this;

      return self
    }, $Proc_to_proc$7.$$arity = 0);
    
    Opal.def(self, '$lambda?', $Proc_lambda$ques$8 = function() {
      var self = this;

      return !!self.$$is_lambda;
    }, $Proc_lambda$ques$8.$$arity = 0);
    
    Opal.def(self, '$arity', $Proc_arity$9 = function $$arity() {
      var self = this;

      
      if (self.$$is_curried) {
        return -1;
      } else {
        return self.$$arity;
      }
    
    }, $Proc_arity$9.$$arity = 0);
    
    Opal.def(self, '$source_location', $Proc_source_location$10 = function $$source_location() {
      var self = this;

      
      if (self.$$is_curried) { return nil; };
      return nil;
    }, $Proc_source_location$10.$$arity = 0);
    
    Opal.def(self, '$binding', $Proc_binding$11 = function $$binding() {
      var self = this;

      
      if (self.$$is_curried) { self.$raise($$($nesting, 'ArgumentError'), "Can't create Binding") };
      return nil;
    }, $Proc_binding$11.$$arity = 0);
    
    Opal.def(self, '$parameters', $Proc_parameters$12 = function $$parameters() {
      var self = this;

      
      if (self.$$is_curried) {
        return [["rest"]];
      } else if (self.$$parameters) {
        if (self.$$is_lambda) {
          return self.$$parameters;
        } else {
          var result = [], i, length;

          for (i = 0, length = self.$$parameters.length; i < length; i++) {
            var parameter = self.$$parameters[i];

            if (parameter[0] === 'req') {
              // required arguments always have name
              parameter = ['opt', parameter[1]];
            }

            result.push(parameter);
          }

          return result;
        }
      } else {
        return [];
      }
    
    }, $Proc_parameters$12.$$arity = 0);
    
    Opal.def(self, '$curry', $Proc_curry$13 = function $$curry(arity) {
      var self = this;

      
      ;
      
      if (arity === undefined) {
        arity = self.length;
      }
      else {
        arity = $$($nesting, 'Opal')['$coerce_to!'](arity, $$($nesting, 'Integer'), "to_int");
        if (self.$$is_lambda && arity !== self.length) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arity) + " for " + (self.length) + ")")
        }
      }

      function curried () {
        var args = $slice.call(arguments),
            length = args.length,
            result;

        if (length > arity && self.$$is_lambda && !self.$$is_curried) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (length) + " for " + (arity) + ")")
        }

        if (length >= arity) {
          return self.$call.apply(self, args);
        }

        result = function () {
          return curried.apply(null,
            args.concat($slice.call(arguments)));
        }
        result.$$is_lambda = self.$$is_lambda;
        result.$$is_curried = true;

        return result;
      };

      curried.$$is_lambda = self.$$is_lambda;
      curried.$$is_curried = true;
      return curried;
    ;
    }, $Proc_curry$13.$$arity = -1);
    
    Opal.def(self, '$dup', $Proc_dup$14 = function $$dup() {
      var self = this;

      
      var original_proc = self.$$original_proc || self,
          proc = function () {
            return original_proc.apply(this, arguments);
          };

      for (var prop in self) {
        if (self.hasOwnProperty(prop)) {
          proc[prop] = self[prop];
        }
      }

      return proc;
    
    }, $Proc_dup$14.$$arity = 0);
    return $alias(self, "clone", "dup");
  })($nesting[0], Function, $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/method"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias;

  Opal.add_stubs(['$attr_reader', '$arity', '$>>', '$<<', '$new', '$class', '$join', '$source_location', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Method');

    var $nesting = [self].concat($parent_nesting), $Method_initialize$1, $Method_arity$2, $Method_parameters$3, $Method_source_location$4, $Method_comments$5, $Method_call$6, $Method_$gt$gt$7, $Method_$lt$lt$8, $Method_unbind$9, $Method_to_proc$10, $Method_inspect$11;

    self.$$prototype.method = self.$$prototype.receiver = self.$$prototype.owner = self.$$prototype.name = nil;
    
    self.$attr_reader("owner", "receiver", "name");
    
    Opal.def(self, '$initialize', $Method_initialize$1 = function $$initialize(receiver, owner, method, name) {
      var self = this;

      
      self.receiver = receiver;
      self.owner = owner;
      self.name = name;
      return (self.method = method);
    }, $Method_initialize$1.$$arity = 4);
    
    Opal.def(self, '$arity', $Method_arity$2 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $Method_arity$2.$$arity = 0);
    
    Opal.def(self, '$parameters', $Method_parameters$3 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $Method_parameters$3.$$arity = 0);
    
    Opal.def(self, '$source_location', $Method_source_location$4 = function $$source_location() {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = self.method.$$source_location))) {
        return $ret_or_1
      } else {
        return ["(eval)", 0]
      }
    }, $Method_source_location$4.$$arity = 0);
    
    Opal.def(self, '$comments', $Method_comments$5 = function $$comments() {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = self.method.$$comments))) {
        return $ret_or_2
      } else {
        return []
      }
    }, $Method_comments$5.$$arity = 0);
    
    Opal.def(self, '$call', $Method_call$6 = function $$call($a) {
      var $iter = $Method_call$6.$$p, block = $iter || nil, $post_args, args, self = this;

      if ($iter) $Method_call$6.$$p = null;
      
      
      if ($iter) $Method_call$6.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      self.method.$$p = block;

      return self.method.apply(self.receiver, args);
    ;
    }, $Method_call$6.$$arity = -1);
    $alias(self, "[]", "call");
    
    Opal.def(self, '$>>', $Method_$gt$gt$7 = function(other) {
      var self = this;

      return self.method['$>>'](other)
    }, $Method_$gt$gt$7.$$arity = 1);
    
    Opal.def(self, '$<<', $Method_$lt$lt$8 = function(other) {
      var self = this;

      return self.method['$<<'](other)
    }, $Method_$lt$lt$8.$$arity = 1);
    
    Opal.def(self, '$unbind', $Method_unbind$9 = function $$unbind() {
      var self = this;

      return $$($nesting, 'UnboundMethod').$new(self.receiver.$class(), self.owner, self.method, self.name)
    }, $Method_unbind$9.$$arity = 0);
    
    Opal.def(self, '$to_proc', $Method_to_proc$10 = function $$to_proc() {
      var self = this;

      
      var proc = self.$call.bind(self);
      proc.$$unbound = self.method;
      proc.$$is_lambda = true;
      proc.$$arity = self.method.$$arity;
      proc.$$parameters = self.method.$$parameters;
      return proc;
    
    }, $Method_to_proc$10.$$arity = 0);
    return (Opal.def(self, '$inspect', $Method_inspect$11 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.receiver.$class()) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $Method_inspect$11.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'UnboundMethod');

    var $nesting = [self].concat($parent_nesting), $UnboundMethod_initialize$12, $UnboundMethod_arity$13, $UnboundMethod_parameters$14, $UnboundMethod_source_location$15, $UnboundMethod_comments$16, $UnboundMethod_bind$17, $UnboundMethod_inspect$18;

    self.$$prototype.method = self.$$prototype.owner = self.$$prototype.name = self.$$prototype.source = nil;
    
    self.$attr_reader("source", "owner", "name");
    
    Opal.def(self, '$initialize', $UnboundMethod_initialize$12 = function $$initialize(source, owner, method, name) {
      var self = this;

      
      self.source = source;
      self.owner = owner;
      self.method = method;
      return (self.name = name);
    }, $UnboundMethod_initialize$12.$$arity = 4);
    
    Opal.def(self, '$arity', $UnboundMethod_arity$13 = function $$arity() {
      var self = this;

      return self.method.$arity()
    }, $UnboundMethod_arity$13.$$arity = 0);
    
    Opal.def(self, '$parameters', $UnboundMethod_parameters$14 = function $$parameters() {
      var self = this;

      return self.method.$$parameters
    }, $UnboundMethod_parameters$14.$$arity = 0);
    
    Opal.def(self, '$source_location', $UnboundMethod_source_location$15 = function $$source_location() {
      var self = this, $ret_or_3 = nil;

      if ($truthy(($ret_or_3 = self.method.$$source_location))) {
        return $ret_or_3
      } else {
        return ["(eval)", 0]
      }
    }, $UnboundMethod_source_location$15.$$arity = 0);
    
    Opal.def(self, '$comments', $UnboundMethod_comments$16 = function $$comments() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.method.$$comments))) {
        return $ret_or_4
      } else {
        return []
      }
    }, $UnboundMethod_comments$16.$$arity = 0);
    
    Opal.def(self, '$bind', $UnboundMethod_bind$17 = function $$bind(object) {
      var self = this;

      
      if (self.owner.$$is_module || Opal.is_a(object, self.owner)) {
        return $$($nesting, 'Method').$new(object, self.owner, self.method, self.name);
      }
      else {
        self.$raise($$($nesting, 'TypeError'), "" + "can't bind singleton method to a different class (expected " + (object) + ".kind_of?(" + (self.owner) + " to be true)");
      }
    
    }, $UnboundMethod_bind$17.$$arity = 1);
    return (Opal.def(self, '$inspect', $UnboundMethod_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "#<" + (self.$class()) + ": " + (self.source) + "#" + (self.name) + " (defined in " + (self.owner) + " in " + (self.$source_location().$join(":")) + ")>"
    }, $UnboundMethod_inspect$18.$$arity = 0), nil) && 'inspect';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/variables"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $gvars = Opal.gvars, $hash2 = Opal.hash2;

  Opal.add_stubs(['$new']);
  
  $gvars['&'] = $gvars['~'] = $gvars['`'] = $gvars["'"] = nil;
  $gvars.LOADED_FEATURES = ($gvars["\""] = Opal.loaded_features);
  $gvars.LOAD_PATH = ($gvars[":"] = []);
  $gvars["/"] = "\n";
  $gvars[","] = nil;
  Opal.const_set($nesting[0], 'ARGV', []);
  Opal.const_set($nesting[0], 'ARGF', $$($nesting, 'Object').$new());
  Opal.const_set($nesting[0], 'ENV', $hash2([], {}));
  $gvars.VERBOSE = false;
  $gvars.DEBUG = false;
  return ($gvars.SAFE = 0);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/io"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $gvars = Opal.gvars, $range = Opal.range, $send = Opal.send, $hash2 = Opal.hash2, $writer = nil;

  Opal.add_stubs(['$include?', '$!', '$match?', '$attr_accessor', '$size', '$attr_reader', '$write', '$String', '$chomp', '$sysread_noraise', '$+', '$!=', '$[]', '$ord', '$getc', '$readchar', '$raise', '$gets', '$==', '$to_str', '$split', '$length', '$sub', '$sysread', '$>', '$to_a', '$each_line', '$enum_for', '$getbyte', '$closed_write?', '$closed_read?', '$new', '$write_proc=', '$-', '$read_proc=']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_initialize$1, $IO_tty$ques$2, $IO_write$3, $IO_flush$4, $IO_$lt$lt$5, $IO_print$6, $IO_puts$7, $IO_getc$8, $IO_getbyte$9, $IO_readbyte$10, $IO_readchar$11, $IO_readline$12, $IO_gets$13, $IO_sysread$14, $IO_sysread_noraise$15, $IO_readpartial$16, $IO_read$17, $IO_readlines$18, $IO_each$19, $IO_each_byte$20, $IO_each_char$21, $IO_close$22, $IO_close_read$23, $IO_close_write$24, $IO_closed$ques$25, $IO_closed_read$ques$26, $IO_closed_write$ques$27, $IO_check_writable$28, $IO_check_readable$29;

    self.$$prototype.read_buffer = self.$$prototype.closed = nil;
    
    Opal.const_set($nesting[0], 'SEEK_SET', 0);
    Opal.const_set($nesting[0], 'SEEK_CUR', 1);
    Opal.const_set($nesting[0], 'SEEK_END', 2);
    Opal.const_set($nesting[0], 'SEEK_DATA', 3);
    Opal.const_set($nesting[0], 'SEEK_HOLE', 4);
    Opal.const_set($nesting[0], 'READABLE', 1);
    Opal.const_set($nesting[0], 'WRITABLE', 4);
    
    Opal.def(self, '$initialize', $IO_initialize$1 = function $$initialize(fd, flags) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

      
      
      if (flags == null) {
        flags = "r";
      };
      self.fd = fd;
      self.flags = flags;
      self.eof = false;
      if ($truthy((function() {if ($truthy(($ret_or_1 = flags['$include?']("r")))) {
        return flags['$match?'](/[wa+]/)['$!']()
      } else {
        return $ret_or_1
      }; return nil; })())) {
        return (self.closed = "write")
      } else if ($truthy((function() {if ($truthy(($ret_or_2 = flags['$match?'](/[wa]/)))) {
        return flags['$match?'](/[r+]/)['$!']()
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return (self.closed = "read")
      } else {
        return nil
      };
    }, $IO_initialize$1.$$arity = -2);
    
    Opal.def(self, '$tty?', $IO_tty$ques$2 = function() {
      var self = this;

      return self.tty == true;
    }, $IO_tty$ques$2.$$arity = 0);
    self.$attr_accessor("write_proc");
    self.$attr_accessor("read_proc");
    
    Opal.def(self, '$write', $IO_write$3 = function $$write(string) {
      var self = this;

      
      self.write_proc(string);
      return string.$size();
    }, $IO_write$3.$$arity = 1);
    self.$attr_accessor("sync", "tty");
    self.$attr_reader("eof");
    $alias(self, "eof?", "eof");
    
    Opal.def(self, '$flush', $IO_flush$4 = function $$flush() {
      var self = this;

      return nil
    }, $IO_flush$4.$$arity = 0);
    
    Opal.def(self, '$<<', $IO_$lt$lt$5 = function(string) {
      var self = this;

      
      self.$write(string);
      return self;
    }, $IO_$lt$lt$5.$$arity = 1);
    
    Opal.def(self, '$print', $IO_print$6 = function $$print($a) {
      var $post_args, args, self = this;
      if ($gvars[","] == null) $gvars[","] = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = self.$String(args[i])
      }
      self.$write(args.join($gvars[","]));
    ;
      return nil;
    }, $IO_print$6.$$arity = -1);
    
    Opal.def(self, '$puts', $IO_puts$7 = function $$puts($a) {
      var $post_args, args, self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      
      for (var i = 0, ii = args.length; i < ii; i++) {
        args[i] = self.$String(args[i]).$chomp()
      }
      self.$write(args.concat([nil]).join($gvars["/"]));
    ;
      return nil;
    }, $IO_puts$7.$$arity = -1);
    
    Opal.def(self, '$getc', $IO_getc$8 = function $$getc() {
      var $a, self = this, $ret_or_3 = nil, parts = nil, ret = nil;

      
      self.read_buffer = (function() {if ($truthy(($ret_or_3 = self.read_buffer))) {
        return $ret_or_3
      } else {
        return ""
      }; return nil; })();
      parts = "";
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($truthy(self.read_buffer['$!='](""))) {
          
          ret = self.read_buffer['$[]'](0);
          self.read_buffer = self.read_buffer['$[]']($range(1, -1, false));
          return ret;};
      } while ($truthy((parts = self.$sysread_noraise(1))));;
      return nil;
    }, $IO_getc$8.$$arity = 0);
    
    Opal.def(self, '$getbyte', $IO_getbyte$9 = function $$getbyte() {
      var $a, self = this;

      return ($a = self.$getc(), ($a === nil || $a == null) ? nil : $send($a, 'ord', []))
    }, $IO_getbyte$9.$$arity = 0);
    
    Opal.def(self, '$readbyte', $IO_readbyte$10 = function $$readbyte() {
      var self = this;

      return self.$readchar().$ord()
    }, $IO_readbyte$10.$$arity = 0);
    
    Opal.def(self, '$readchar', $IO_readchar$11 = function $$readchar() {
      var self = this, $ret_or_4 = nil;

      if ($truthy(($ret_or_4 = self.$getc()))) {
        return $ret_or_4
      } else {
        return self.$raise($$($nesting, 'EOFError'), "end of file reached")
      }
    }, $IO_readchar$11.$$arity = 0);
    
    Opal.def(self, '$readline', $IO_readline$12 = function $$readline($a) {
      var $post_args, args, self = this, $ret_or_5 = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(($ret_or_5 = $send(self, 'gets', Opal.to_a(args))))) {
        return $ret_or_5
      } else {
        return self.$raise($$($nesting, 'EOFError'), "end of file reached")
      };
    }, $IO_readline$12.$$arity = -1);
    
    Opal.def(self, '$gets', $IO_gets$13 = function $$gets(sep, limit, opts) {
      var $a, $b, $c, self = this, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil, $ret_or_9 = nil, orig_sep = nil, $ret_or_10 = nil, seplen = nil, $ret_or_11 = nil, data = nil, ret = nil, $ret_or_12 = nil, orig_buffer = nil, $ret_or_13 = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (sep == null) {
        sep = false;
      };
      
      if (limit == null) {
        limit = nil;
      };
      
      if (opts == null) {
        opts = $hash2([], {});
      };
      if ($truthy((function() {if ($truthy(($ret_or_6 = sep.$$is_number))) {
        return limit['$!']()
      } else {
        return $ret_or_6
      }; return nil; })())) {
        $a = [false, sep, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a};
      if ($truthy((function() {if ($truthy(($ret_or_7 = (function() {if ($truthy(($ret_or_8 = sep.$$is_hash))) {
        return limit['$!']()
      } else {
        return $ret_or_8
      }; return nil; })()))) {
        return opts['$==']($hash2([], {}))
      } else {
        return $ret_or_7
      }; return nil; })())) {
        $a = [false, nil, sep], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a
      } else if ($truthy((function() {if ($truthy(($ret_or_9 = limit.$$is_hash))) {
        return opts['$==']($hash2([], {}))
      } else {
        return $ret_or_9
      }; return nil; })())) {
        $a = [sep, nil, limit], (sep = $a[0]), (limit = $a[1]), (opts = $a[2]), $a};
      orig_sep = sep;
      if (sep['$=='](false)) {
        sep = $gvars["/"]};
      if (sep['$==']("")) {
        sep = /\r?\n\r?\n/};
      sep = (function() {if ($truthy(($ret_or_10 = sep))) {
        return $ret_or_10
      } else {
        return ""
      }; return nil; })();
      if (orig_sep['$==']("")) {
      } else {
        sep = sep.$to_str()
      };
      seplen = orig_sep == '' ? 2 : sep.length;
      if (sep['$=='](" ")) {
        sep = / /};
      self.read_buffer = (function() {if ($truthy(($ret_or_11 = self.read_buffer))) {
        return $ret_or_11
      } else {
        return ""
      }; return nil; })();
      data = "";
      ret = nil;
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, data);
        if ($truthy((function() {if ($truthy(($ret_or_12 = sep['$!=']("")))) {
          
          if ($truthy(sep.$$is_regexp)) {
            return self.read_buffer['$match?'](sep)
          } else {
            return self.read_buffer['$include?'](sep)
          };
        } else {
          return $ret_or_12
        }; return nil; })())) {
          
          orig_buffer = self.read_buffer;
          $c = self.read_buffer.$split(sep, 2), $b = Opal.to_ary($c), (ret = ($b[0] == null ? nil : $b[0])), (self.read_buffer = ($b[1] == null ? nil : $b[1])), $c;
          if ($truthy(ret['$!='](orig_buffer))) {
            ret = $rb_plus(ret, orig_buffer['$[]'](ret.$length(), seplen))};
          break;;};
      } while ($truthy((data = self.$sysread_noraise((function() {if (sep['$==']("")) {
        return 65536
      } else {
        return 1
      }; return nil; })()))));;
      if ($truthy(ret)) {
      } else {
        
        $a = [(function() {if ($truthy(($ret_or_13 = self.read_buffer))) {
          return $ret_or_13
        } else {
          return ""
        }; return nil; })(), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
        if (ret['$==']("")) {
          ret = nil};
      };
      if ($truthy(ret)) {
        
        if ($truthy(limit)) {
          
          ret = ret['$[]'](Opal.Range.$new(0,limit, true));
          self.read_buffer = $rb_plus(ret['$[]'](Opal.Range.$new(limit, -1, false)), self.read_buffer);};
        if ($truthy(opts['$[]']("chomp"))) {
          ret = ret.$sub(/\r?\n$/, "")};
        if (orig_sep['$==']("")) {
          ret = ret.$sub(/^[\r\n]+/, "")};};
      if (orig_sep['$=='](false)) {
        $gvars._ = ret};
      return ret;
    }, $IO_gets$13.$$arity = -1);
    
    Opal.def(self, '$sysread', $IO_sysread$14 = function $$sysread(integer) {
      var self = this, $ret_or_14 = nil;

      if ($truthy(($ret_or_14 = self.read_proc(integer)))) {
        return $ret_or_14
      } else {
        
        self.eof = true;
        return self.$raise($$($nesting, 'EOFError'), "end of file reached");
      }
    }, $IO_sysread$14.$$arity = 1);
    
    Opal.def(self, '$sysread_noraise', $IO_sysread_noraise$15 = function $$sysread_noraise(integer) {
      var self = this;

      try {
        return self.$sysread(integer)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'EOFError')])) {
          try {
            return nil
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, $IO_sysread_noraise$15.$$arity = 1);
    
    Opal.def(self, '$readpartial', $IO_readpartial$16 = function $$readpartial(integer) {
      var $a, self = this, $ret_or_15 = nil, part = nil, $ret_or_16 = nil, ret = nil;

      
      self.read_buffer = (function() {if ($truthy(($ret_or_15 = self.read_buffer))) {
        return $ret_or_15
      } else {
        return ""
      }; return nil; })();
      part = self.$sysread(integer);
      $a = [$rb_plus(self.read_buffer, (function() {if ($truthy(($ret_or_16 = part))) {
        return $ret_or_16
      } else {
        return ""
      }; return nil; })()), ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      if (ret['$==']("")) {
        ret = nil};
      return ret;
    }, $IO_readpartial$16.$$arity = 1);
    
    Opal.def(self, '$read', $IO_read$17 = function $$read(integer) {
      var $a, $b, self = this, $ret_or_17 = nil, parts = nil, ret = nil, $ret_or_18 = nil, $ret_or_19 = nil;

      
      
      if (integer == null) {
        integer = nil;
      };
      self.read_buffer = (function() {if ($truthy(($ret_or_17 = self.read_buffer))) {
        return $ret_or_17
      } else {
        return ""
      }; return nil; })();
      parts = "";
      ret = nil;
      do {
        
        self.read_buffer = $rb_plus(self.read_buffer, parts);
        if ($truthy((function() {if ($truthy(($ret_or_19 = integer))) {
          return $rb_gt(self.read_buffer.$length(), integer)
        } else {
          return $ret_or_19
        }; return nil; })())) {
          
          $b = [self.read_buffer['$[]'](Opal.Range.$new(0,integer, true)), self.read_buffer['$[]'](Opal.Range.$new(integer, -1, false))], (ret = $b[0]), (self.read_buffer = $b[1]), $b;
          return ret;};
      } while ($truthy((parts = self.$sysread_noraise((function() {if ($truthy(($ret_or_18 = integer))) {
        return $ret_or_18
      } else {
        return 65536
      }; return nil; })()))));;
      $a = [self.read_buffer, ""], (ret = $a[0]), (self.read_buffer = $a[1]), $a;
      return ret;
    }, $IO_read$17.$$arity = -1);
    
    Opal.def(self, '$readlines', $IO_readlines$18 = function $$readlines(separator) {
      var self = this;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      
      
      if (separator == null) {
        separator = $gvars["/"];
      };
      return self.$each_line(separator).$to_a();
    }, $IO_readlines$18.$$arity = -1);
    
    Opal.def(self, '$each', $IO_each$19 = function $$each($a, $b) {
      var $iter = $IO_each$19.$$p, block = $iter || nil, $post_args, sep, args, $c, self = this, s = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      if ($iter) $IO_each$19.$$p = null;
      
      
      if ($iter) $IO_each$19.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      if ($post_args.length > 0) {
        sep = $post_args[0];
        $post_args.splice(0, 1);
      }
      if (sep == null) {
        sep = $gvars["/"];
      };
      
      args = $post_args;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each", sep].concat(Opal.to_a(args)))
      };
      while ($truthy((s = $send(self, 'gets', [sep].concat(Opal.to_a(args)))))) {
        Opal.yield1(block, s)
      };
      return self;
    }, $IO_each$19.$$arity = -1);
    $alias(self, "each_line", "each");
    
    Opal.def(self, '$each_byte', $IO_each_byte$20 = function $$each_byte() {
      var $iter = $IO_each_byte$20.$$p, block = $iter || nil, $a, self = this, s = nil;

      if ($iter) $IO_each_byte$20.$$p = null;
      
      
      if ($iter) $IO_each_byte$20.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_byte")
      };
      while ($truthy((s = self.$getbyte()))) {
        Opal.yield1(block, s)
      };
      return self;
    }, $IO_each_byte$20.$$arity = 0);
    
    Opal.def(self, '$each_char', $IO_each_char$21 = function $$each_char() {
      var $iter = $IO_each_char$21.$$p, block = $iter || nil, $a, self = this, s = nil;

      if ($iter) $IO_each_char$21.$$p = null;
      
      
      if ($iter) $IO_each_char$21.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_char")
      };
      while ($truthy((s = self.$getc()))) {
        Opal.yield1(block, s)
      };
      return self;
    }, $IO_each_char$21.$$arity = 0);
    
    Opal.def(self, '$close', $IO_close$22 = function $$close() {
      var self = this;

      return (self.closed = "both")
    }, $IO_close$22.$$arity = 0);
    
    Opal.def(self, '$close_read', $IO_close_read$23 = function $$close_read() {
      var self = this;

      if (self.closed['$==']("write")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "read")
      }
    }, $IO_close_read$23.$$arity = 0);
    
    Opal.def(self, '$close_write', $IO_close_write$24 = function $$close_write() {
      var self = this;

      if (self.closed['$==']("read")) {
        return (self.closed = "both")
      } else {
        return (self.closed = "write")
      }
    }, $IO_close_write$24.$$arity = 0);
    
    Opal.def(self, '$closed?', $IO_closed$ques$25 = function() {
      var self = this;

      return self.closed['$==']("both")
    }, $IO_closed$ques$25.$$arity = 0);
    
    Opal.def(self, '$closed_read?', $IO_closed_read$ques$26 = function() {
      var self = this, $ret_or_20 = nil;

      if ($truthy(($ret_or_20 = self.closed['$==']("read")))) {
        return $ret_or_20
      } else {
        return self.closed['$==']("both")
      }
    }, $IO_closed_read$ques$26.$$arity = 0);
    
    Opal.def(self, '$closed_write?', $IO_closed_write$ques$27 = function() {
      var self = this, $ret_or_21 = nil;

      if ($truthy(($ret_or_21 = self.closed['$==']("write")))) {
        return $ret_or_21
      } else {
        return self.closed['$==']("both")
      }
    }, $IO_closed_write$ques$27.$$arity = 0);
    
    Opal.def(self, '$check_writable', $IO_check_writable$28 = function $$check_writable() {
      var self = this;

      if ($truthy(self['$closed_write?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for writing")
      } else {
        return nil
      }
    }, $IO_check_writable$28.$$arity = 0);
    return (Opal.def(self, '$check_readable', $IO_check_readable$29 = function $$check_readable() {
      var self = this;

      if ($truthy(self['$closed_read?']())) {
        return self.$raise($$($nesting, 'IOError'), "not opened for reading")
      } else {
        return nil
      }
    }, $IO_check_readable$29.$$arity = 0), nil) && 'check_readable';
  })($nesting[0], null, $nesting);
  Opal.const_set($nesting[0], 'STDIN', ($gvars.stdin = $$($nesting, 'IO').$new(0, "r")));
  Opal.const_set($nesting[0], 'STDOUT', ($gvars.stdout = $$($nesting, 'IO').$new(1, "w")));
  Opal.const_set($nesting[0], 'STDERR', ($gvars.stderr = $$($nesting, 'IO').$new(2, "w")));
  var console = Opal.global.console;
  
  $writer = [typeof(process) === 'object' && typeof(process.stdout) === 'object' ? function(s){process.stdout.write(s)} : function(s){console.log(s)}];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [typeof(process) === 'object' && typeof(process.stderr) === 'object' ? function(s){process.stderr.write(s)} : function(s){console.warn(s)}];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [function(s) { var p = prompt(); if (p !== null) return p + "\n"; return nil; }];
  $send($$($nesting, 'STDIN'), 'read_proc=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["opal/regexp_anchors"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$new']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Opal');

    var $nesting = [self].concat($parent_nesting);

    
    Opal.const_set($nesting[0], 'REGEXP_START', "^");
    Opal.const_set($nesting[0], 'REGEXP_END', "$");
    Opal.const_set($nesting[0], 'FORBIDDEN_STARTING_IDENTIFIER_CHARS', "\\u0001-\\u002F\\u003A-\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'FORBIDDEN_ENDING_IDENTIFIER_CHARS', "\\u0001-\\u0020\\u0022-\\u002F\\u003A-\\u003E\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    Opal.const_set($nesting[0], 'INLINE_IDENTIFIER_REGEXP', $$($nesting, 'Regexp').$new("" + "[^" + ($$($nesting, 'FORBIDDEN_STARTING_IDENTIFIER_CHARS')) + "]*[^" + ($$($nesting, 'FORBIDDEN_ENDING_IDENTIFIER_CHARS')) + "]"));
    Opal.const_set($nesting[0], 'FORBIDDEN_CONST_NAME_CHARS', "\\u0001-\\u0020\\u0021-\\u002F\\u003B-\\u003F\\u0040\\u005B-\\u005E\\u0060\\u007B-\\u007F");
    return Opal.const_set($nesting[0], 'CONST_NAME_REGEXP', $$($nesting, 'Regexp').$new("" + ($$($nesting, 'REGEXP_START')) + "(::)?[A-Z][^" + ($$($nesting, 'FORBIDDEN_CONST_NAME_CHARS')) + "]*" + ($$($nesting, 'REGEXP_END'))));
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["opal/mini"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("corelib/nil");
  self.$require("corelib/boolean");
  self.$require("corelib/string");
  self.$require("corelib/comparable");
  self.$require("corelib/enumerable");
  self.$require("corelib/enumerator");
  self.$require("corelib/array");
  self.$require("corelib/hash");
  self.$require("corelib/number");
  self.$require("corelib/range");
  self.$require("corelib/proc");
  self.$require("corelib/method");
  self.$require("corelib/regexp");
  self.$require("corelib/variables");
  self.$require("corelib/io");
  return self.$require("opal/regexp_anchors");
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/kernel/format"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $coerce_to = Opal.coerce_to, $module = Opal.module, $truthy = Opal.truthy, $gvars = Opal.gvars, $alias = Opal.alias;

  Opal.add_stubs(['$==', '$length', '$respond_to?', '$[]', '$coerce_to?', '$nil?', '$to_a', '$raise', '$to_int', '$fetch', '$Integer', '$Float', '$to_ary', '$to_str', '$inspect', '$to_s']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_format$1;

    
    
    Opal.def(self, '$format', $Kernel_format$1 = function $$format(format_string, $a) {
      var $post_args, args, self = this, $ret_or_1 = nil, ary = nil;
      if ($gvars.DEBUG == null) $gvars.DEBUG = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      if ($truthy((function() {if ($truthy(($ret_or_1 = args.$length()['$=='](1)))) {
        return args['$[]'](0)['$respond_to?']("to_ary")
      } else {
        return $ret_or_1
      }; return nil; })())) {
        
        ary = $$($nesting, 'Opal')['$coerce_to?'](args['$[]'](0), $$($nesting, 'Array'), "to_ary");
        if ($truthy(ary['$nil?']())) {
        } else {
          args = ary.$to_a()
        };};
      
      var result = '',
          //used for slicing:
          begin_slice = 0,
          end_slice,
          //used for iterating over the format string:
          i,
          len = format_string.length,
          //used for processing field values:
          arg,
          str,
          //used for processing %g and %G fields:
          exponent,
          //used for keeping track of width and precision:
          width,
          precision,
          //used for holding temporary values:
          tmp_num,
          //used for processing %{} and %<> fileds:
          hash_parameter_key,
          closing_brace_char,
          //used for processing %b, %B, %o, %x, and %X fields:
          base_number,
          base_prefix,
          base_neg_zero_regex,
          base_neg_zero_digit,
          //used for processing arguments:
          next_arg,
          seq_arg_num = 1,
          pos_arg_num = 0,
          //used for keeping track of flags:
          flags,
          FNONE  = 0,
          FSHARP = 1,
          FMINUS = 2,
          FPLUS  = 4,
          FZERO  = 8,
          FSPACE = 16,
          FWIDTH = 32,
          FPREC  = 64,
          FPREC0 = 128;

      function CHECK_FOR_FLAGS() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "flag after width") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "flag after precision") }
      }

      function CHECK_FOR_WIDTH() {
        if (flags&FWIDTH) { self.$raise($$($nesting, 'ArgumentError'), "width given twice") }
        if (flags&FPREC0) { self.$raise($$($nesting, 'ArgumentError'), "width after precision") }
      }

      function GET_NTH_ARG(num) {
        if (num >= args.length) { self.$raise($$($nesting, 'ArgumentError'), "too few arguments") }
        return args[num];
      }

      function GET_NEXT_ARG() {
        switch (pos_arg_num) {
        case -1: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with numbered") // raise
        case -2: self.$raise($$($nesting, 'ArgumentError'), "" + "unnumbered(" + (seq_arg_num) + ") mixed with named") // raise
        }
        pos_arg_num = seq_arg_num++;
        return GET_NTH_ARG(pos_arg_num - 1);
      }

      function GET_POS_ARG(num) {
        if (pos_arg_num > 0) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after unnumbered(" + (pos_arg_num) + ")")
        }
        if (pos_arg_num === -2) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "numbered(" + (num) + ") after named")
        }
        if (num < 1) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "invalid index - " + (num) + "$")
        }
        pos_arg_num = -1;
        return GET_NTH_ARG(num - 1);
      }

      function GET_ARG() {
        return (next_arg === undefined ? GET_NEXT_ARG() : next_arg);
      }

      function READ_NUM(label) {
        var num, str = '';
        for (;; i++) {
          if (i === len) {
            self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %*[0-9]")
          }
          if (format_string.charCodeAt(i) < 48 || format_string.charCodeAt(i) > 57) {
            i--;
            num = parseInt(str, 10) || 0;
            if (num > 2147483647) {
              self.$raise($$($nesting, 'ArgumentError'), "" + (label) + " too big")
            }
            return num;
          }
          str += format_string.charAt(i);
        }
      }

      function READ_NUM_AFTER_ASTER(label) {
        var arg, num = READ_NUM(label);
        if (format_string.charAt(i + 1) === '$') {
          i++;
          arg = GET_POS_ARG(num);
        } else {
          arg = GET_NEXT_ARG();
        }
        return (arg).$to_int();
      }

      for (i = format_string.indexOf('%'); i !== -1; i = format_string.indexOf('%', i)) {
        str = undefined;

        flags = FNONE;
        width = -1;
        precision = -1;
        next_arg = undefined;

        end_slice = i;

        i++;

        switch (format_string.charAt(i)) {
        case '%':
          begin_slice = i;
          // no-break
        case '':
        case '\n':
        case '\0':
          i++;
          continue;
        }

        format_sequence: for (; i < len; i++) {
          switch (format_string.charAt(i)) {

          case ' ':
            CHECK_FOR_FLAGS();
            flags |= FSPACE;
            continue format_sequence;

          case '#':
            CHECK_FOR_FLAGS();
            flags |= FSHARP;
            continue format_sequence;

          case '+':
            CHECK_FOR_FLAGS();
            flags |= FPLUS;
            continue format_sequence;

          case '-':
            CHECK_FOR_FLAGS();
            flags |= FMINUS;
            continue format_sequence;

          case '0':
            CHECK_FOR_FLAGS();
            flags |= FZERO;
            continue format_sequence;

          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            tmp_num = READ_NUM('width');
            if (format_string.charAt(i + 1) === '$') {
              if (i + 2 === len) {
                str = '%';
                i++;
                break format_sequence;
              }
              if (next_arg !== undefined) {
                self.$raise($$($nesting, 'ArgumentError'), "" + "value given twice - %" + (tmp_num) + "$")
              }
              next_arg = GET_POS_ARG(tmp_num);
              i++;
            } else {
              CHECK_FOR_WIDTH();
              flags |= FWIDTH;
              width = tmp_num;
            }
            continue format_sequence;

          case '<':
          case '\{':
            closing_brace_char = (format_string.charAt(i) === '<' ? '>' : '\}');
            hash_parameter_key = '';

            i++;

            for (;; i++) {
              if (i === len) {
                self.$raise($$($nesting, 'ArgumentError'), "malformed name - unmatched parenthesis")
              }
              if (format_string.charAt(i) === closing_brace_char) {

                if (pos_arg_num > 0) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after unnumbered(" + (pos_arg_num) + ")")
                }
                if (pos_arg_num === -1) {
                  self.$raise($$($nesting, 'ArgumentError'), "" + "named " + (hash_parameter_key) + " after numbered")
                }
                pos_arg_num = -2;

                if (args[0] === undefined || !args[0].$$is_hash) {
                  self.$raise($$($nesting, 'ArgumentError'), "one hash required")
                }

                next_arg = (args[0]).$fetch(hash_parameter_key);

                if (closing_brace_char === '>') {
                  continue format_sequence;
                } else {
                  str = next_arg.toString();
                  if (precision !== -1) { str = str.slice(0, precision); }
                  if (flags&FMINUS) {
                    while (str.length < width) { str = str + ' '; }
                  } else {
                    while (str.length < width) { str = ' ' + str; }
                  }
                  break format_sequence;
                }
              }
              hash_parameter_key += format_string.charAt(i);
            }
            // raise

          case '*':
            i++;
            CHECK_FOR_WIDTH();
            flags |= FWIDTH;
            width = READ_NUM_AFTER_ASTER('width');
            if (width < 0) {
              flags |= FMINUS;
              width = -width;
            }
            continue format_sequence;

          case '.':
            if (flags&FPREC0) {
              self.$raise($$($nesting, 'ArgumentError'), "precision given twice")
            }
            flags |= FPREC|FPREC0;
            precision = 0;
            i++;
            if (format_string.charAt(i) === '*') {
              i++;
              precision = READ_NUM_AFTER_ASTER('precision');
              if (precision < 0) {
                flags &= ~FPREC;
              }
              continue format_sequence;
            }
            precision = READ_NUM('precision');
            continue format_sequence;

          case 'd':
          case 'i':
          case 'u':
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              str = (-arg).toString();
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            break format_sequence;

          case 'b':
          case 'B':
          case 'o':
          case 'x':
          case 'X':
            switch (format_string.charAt(i)) {
            case 'b':
            case 'B':
              base_number = 2;
              base_prefix = '0b';
              base_neg_zero_regex = /^1+/;
              base_neg_zero_digit = '1';
              break;
            case 'o':
              base_number = 8;
              base_prefix = '0';
              base_neg_zero_regex = /^3?7+/;
              base_neg_zero_digit = '7';
              break;
            case 'x':
            case 'X':
              base_number = 16;
              base_prefix = '0x';
              base_neg_zero_regex = /^f+/;
              base_neg_zero_digit = 'f';
              break;
            }
            arg = self.$Integer(GET_ARG());
            if (arg >= 0) {
              str = arg.toString(base_number);
              while (str.length < precision) { str = '0' + str; }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && precision === -1) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0) - ((flags&FSHARP && arg !== 0) ? base_prefix.length : 0)) { str = '0' + str; }
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FSHARP && arg !== 0) { str = base_prefix + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (flags&FPLUS || flags&FSPACE) {
                str = (-arg).toString(base_number);
                while (str.length < precision) { str = '0' + str; }
                if (flags&FMINUS) {
                  if (flags&FSHARP) { str = base_prefix + str; }
                  str = '-' + str;
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 1 - (flags&FSHARP ? 2 : 0)) { str = '0' + str; }
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                  } else {
                    if (flags&FSHARP) { str = base_prefix + str; }
                    str = '-' + str;
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              } else {
                str = (arg >>> 0).toString(base_number).replace(base_neg_zero_regex, base_neg_zero_digit);
                while (str.length < precision - 2) { str = base_neg_zero_digit + str; }
                if (flags&FMINUS) {
                  str = '..' + str;
                  if (flags&FSHARP) { str = base_prefix + str; }
                  while (str.length < width) { str = str + ' '; }
                } else {
                  if (flags&FZERO && precision === -1) {
                    while (str.length < width - 2 - (flags&FSHARP ? base_prefix.length : 0)) { str = base_neg_zero_digit + str; }
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                  } else {
                    str = '..' + str;
                    if (flags&FSHARP) { str = base_prefix + str; }
                    while (str.length < width) { str = ' ' + str; }
                  }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase()) {
              str = str.toUpperCase();
            }
            break format_sequence;

          case 'f':
          case 'e':
          case 'E':
          case 'g':
          case 'G':
            arg = self.$Float(GET_ARG());
            if (arg >= 0 || isNaN(arg)) {
              if (arg === Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = arg.toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = arg.toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = arg.toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = arg.toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== Infinity && !isNaN(arg)) {
                  while (str.length < width - ((flags&FPLUS || flags&FSPACE) ? 1 : 0)) { str = '0' + str; }
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                } else {
                  if (flags&FPLUS || flags&FSPACE) { str = (flags&FPLUS ? '+' : ' ') + str; }
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            } else {
              if (arg === -Infinity) {
                str = 'Inf';
              } else {
                switch (format_string.charAt(i)) {
                case 'f':
                  str = (-arg).toFixed(precision === -1 ? 6 : precision);
                  break;
                case 'e':
                case 'E':
                  str = (-arg).toExponential(precision === -1 ? 6 : precision);
                  break;
                case 'g':
                case 'G':
                  str = (-arg).toExponential();
                  exponent = parseInt(str.split('e')[1], 10);
                  if (!(exponent < -4 || exponent >= (precision === -1 ? 6 : precision))) {
                    str = (-arg).toPrecision(precision === -1 ? (flags&FSHARP ? 6 : undefined) : precision);
                  }
                  break;
                }
              }
              if (flags&FMINUS) {
                str = '-' + str;
                while (str.length < width) { str = str + ' '; }
              } else {
                if (flags&FZERO && arg !== -Infinity) {
                  while (str.length < width - 1) { str = '0' + str; }
                  str = '-' + str;
                } else {
                  str = '-' + str;
                  while (str.length < width) { str = ' ' + str; }
                }
              }
            }
            if (format_string.charAt(i) === format_string.charAt(i).toUpperCase() && arg !== Infinity && arg !== -Infinity && !isNaN(arg)) {
              str = str.toUpperCase();
            }
            str = str.replace(/([eE][-+]?)([0-9])$/, '$10$2');
            break format_sequence;

          case 'a':
          case 'A':
            // Not implemented because there are no specs for this field type.
            self.$raise($$($nesting, 'NotImplementedError'), "`A` and `a` format field types are not implemented in Opal yet")
            // raise

          case 'c':
            arg = GET_ARG();
            if ((arg)['$respond_to?']("to_ary")) { arg = (arg).$to_ary()[0]; }
            if ((arg)['$respond_to?']("to_str")) {
              str = (arg).$to_str();
            } else {
              str = String.fromCharCode($coerce_to(arg, $$($nesting, 'Integer'), 'to_int'));
            }
            if (str.length !== 1) {
              self.$raise($$($nesting, 'ArgumentError'), "%c requires a character")
            }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 'p':
            str = (GET_ARG()).$inspect();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          case 's':
            str = (GET_ARG()).$to_s();
            if (precision !== -1) { str = str.slice(0, precision); }
            if (flags&FMINUS) {
              while (str.length < width) { str = str + ' '; }
            } else {
              while (str.length < width) { str = ' ' + str; }
            }
            break format_sequence;

          default:
            self.$raise($$($nesting, 'ArgumentError'), "" + "malformed format string - %" + (format_string.charAt(i)))
          }
        }

        if (str === undefined) {
          self.$raise($$($nesting, 'ArgumentError'), "malformed format string - %")
        }

        result += format_string.slice(begin_slice, end_slice) + str;
        begin_slice = i + 1;
      }

      if ($gvars.DEBUG && pos_arg_num >= 0 && seq_arg_num < args.length) {
        self.$raise($$($nesting, 'ArgumentError'), "too many arguments for format string")
      }

      return result + format_string.slice(begin_slice);
    ;
    }, $Kernel_format$1.$$arity = -2);
    return $alias(self, "sprintf", "format");
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/string/encoding"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$14, $$17, $$20, $$22, $$25, $$27, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $alias = Opal.alias, $writer = nil;

  Opal.add_stubs(['$require', '$+', '$[]', '$clone', '$initialize', '$new', '$instance_eval', '$to_proc', '$each', '$const_set', '$tr', '$==', '$default_external', '$attr_accessor', '$singleton_class', '$attr_reader', '$raise', '$register', '$length', '$bytes', '$force_encoding', '$dup', '$bytesize', '$enum_for', '$each_byte', '$to_a', '$each_char', '$each_codepoint', '$coerce_to!', '$find', '$<', '$default_external=', '$-']);
  
  self.$require("corelib/string");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Encoding');

    var $nesting = [self].concat($parent_nesting), $Encoding_register$1, $Encoding_find$3, $Encoding_initialize$4, $Encoding_ascii_compatible$ques$5, $Encoding_dummy$ques$6, $Encoding_binary$ques$7, $Encoding_to_s$8, $Encoding_inspect$9, $Encoding_charsize$10, $Encoding_each_char$11, $Encoding_each_byte$12, $Encoding_bytesize$13;

    self.$$prototype.ascii = self.$$prototype.dummy = self.$$prototype.name = nil;
    
    Opal.defs(self, '$register', $Encoding_register$1 = function $$register(name, options) {
      var $iter = $Encoding_register$1.$$p, block = $iter || nil, $$2, self = this, names = nil, $ret_or_1 = nil, ascii = nil, $ret_or_2 = nil, dummy = nil, $ret_or_3 = nil, encoding = nil, register = nil;

      if ($iter) $Encoding_register$1.$$p = null;
      
      
      if ($iter) $Encoding_register$1.$$p = null;;
      
      if (options == null) {
        options = $hash2([], {});
      };
      names = $rb_plus([name], (function() {if ($truthy(($ret_or_1 = options['$[]']("aliases")))) {
        return $ret_or_1
      } else {
        return []
      }; return nil; })());
      ascii = (function() {if ($truthy(($ret_or_2 = options['$[]']("ascii")))) {
        return $ret_or_2
      } else {
        return false
      }; return nil; })();
      dummy = (function() {if ($truthy(($ret_or_3 = options['$[]']("dummy")))) {
        return $ret_or_3
      } else {
        return false
      }; return nil; })();
      if ($truthy(options['$[]']("inherits"))) {
        
        encoding = options['$[]']("inherits").$clone();
        encoding.$initialize(name, names, ascii, dummy);
      } else {
        encoding = self.$new(name, names, ascii, dummy)
      };
      if ((block !== nil)) {
        $send(encoding, 'instance_eval', [], block.$to_proc())};
      register = Opal.encodings;
      return $send(names, 'each', [], ($$2 = function(encoding_name){var self = $$2.$$s == null ? this : $$2.$$s;

        
        
        if (encoding_name == null) {
          encoding_name = nil;
        };
        self.$const_set(encoding_name.$tr("-", "_"), encoding);
        return register[encoding_name] = encoding;}, $$2.$$s = self, $$2.$$arity = 1, $$2));
    }, $Encoding_register$1.$$arity = -2);
    Opal.defs(self, '$find', $Encoding_find$3 = function $$find(name) {
      var self = this;

      
      if (name['$==']("default_external")) {
        return self.$default_external()};
      return Opal.find_encoding(name);;
    }, $Encoding_find$3.$$arity = 1);
    self.$singleton_class().$attr_accessor("default_external");
    self.$attr_reader("name", "names");
    
    Opal.def(self, '$initialize', $Encoding_initialize$4 = function $$initialize(name, names, ascii, dummy) {
      var self = this;

      
      self.name = name;
      self.names = names;
      self.ascii = ascii;
      return (self.dummy = dummy);
    }, $Encoding_initialize$4.$$arity = 4);
    
    Opal.def(self, '$ascii_compatible?', $Encoding_ascii_compatible$ques$5 = function() {
      var self = this;

      return self.ascii
    }, $Encoding_ascii_compatible$ques$5.$$arity = 0);
    
    Opal.def(self, '$dummy?', $Encoding_dummy$ques$6 = function() {
      var self = this;

      return self.dummy
    }, $Encoding_dummy$ques$6.$$arity = 0);
    
    Opal.def(self, '$binary?', $Encoding_binary$ques$7 = function() {
      var self = this;

      return false
    }, $Encoding_binary$ques$7.$$arity = 0);
    
    Opal.def(self, '$to_s', $Encoding_to_s$8 = function $$to_s() {
      var self = this;

      return self.name
    }, $Encoding_to_s$8.$$arity = 0);
    
    Opal.def(self, '$inspect', $Encoding_inspect$9 = function $$inspect() {
      var self = this;

      return "" + "#<Encoding:" + (self.name) + ((function() {if ($truthy(self.dummy)) {
        return " (dummy)"
      } else {
        return nil
      }; return nil; })()) + ">"
    }, $Encoding_inspect$9.$$arity = 0);
    
    Opal.def(self, '$charsize', $Encoding_charsize$10 = function $$charsize(string) {
      var self = this;

      
      var len = 0;
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        if (!(charcode >= 0xD800 && charcode <= 0xDBFF)) {
          len++;
        }
      }
      return len;
    
    }, $Encoding_charsize$10.$$arity = 1);
    
    Opal.def(self, '$each_char', $Encoding_each_char$11 = function $$each_char(string) {
      var $iter = $Encoding_each_char$11.$$p, block = $iter || nil, self = this;

      if ($iter) $Encoding_each_char$11.$$p = null;
      
      
      if ($iter) $Encoding_each_char$11.$$p = null;;
      
      var low_surrogate = "";
      for (var i = 0, length = string.length; i < length; i++) {
        var charcode = string.charCodeAt(i);
        var chr = string.charAt(i);
        if (charcode >= 0xDC00 && charcode <= 0xDFFF) {
          low_surrogate = chr;
          continue;
        }
        else if (charcode >= 0xD800 && charcode <= 0xDBFF) {
          chr = low_surrogate + chr;
        }
        if (string.encoding.name != "UTF-8") {
          chr = new String(chr);
          chr.encoding = string.encoding;
        }
        Opal.yield1(block, chr);
      }
    ;
    }, $Encoding_each_char$11.$$arity = 1);
    
    Opal.def(self, '$each_byte', $Encoding_each_byte$12 = function $$each_byte($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_each_byte$12.$$arity = -1);
    
    Opal.def(self, '$bytesize', $Encoding_bytesize$13 = function $$bytesize($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'));
    }, $Encoding_bytesize$13.$$arity = -1);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'EncodingError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'StandardError'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'CompatibilityError');

      var $nesting = [self].concat($parent_nesting);

      return nil
    })($nesting[0], $$($nesting, 'EncodingError'), $nesting);
  })($nesting[0], null, $nesting);
  $send($$($nesting, 'Encoding'), 'register', ["UTF-8", $hash2(["aliases", "ascii"], {"aliases": ["CP65001"], "ascii": true})], ($$14 = function(){var self = $$14.$$s == null ? this : $$14.$$s, $each_byte$15, $bytesize$16;

    
    
    Opal.def(self, '$each_byte', $each_byte$15 = function $$each_byte(string) {
      var $iter = $each_byte$15.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$15.$$p = null;
      
      
      if ($iter) $each_byte$15.$$p = null;;
      
      // Taken from: https://github.com/feross/buffer/blob/f52dffd9df0445b93c0c9065c2f8f0f46b2c729a/index.js#L1954-L2032
      var units = Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) {
                Opal.yield1(block, 0xEF);
                Opal.yield1(block, 0xBF);
                Opal.yield1(block, 0xBD);
              }
              continue;
            }

            // valid lead
            leadSurrogate = codePoint;

            continue;
          }

          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) {
              Opal.yield1(block, 0xEF);
              Opal.yield1(block, 0xBF);
              Opal.yield1(block, 0xBD);
            }
            leadSurrogate = codePoint;
            continue;
          }

          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) {
            Opal.yield1(block, 0xEF);
            Opal.yield1(block, 0xBF);
            Opal.yield1(block, 0xBD);
          }
        }

        leadSurrogate = null;

        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          Opal.yield1(block, codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          Opal.yield1(block, codePoint >> 0x6 | 0xC0);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          Opal.yield1(block, codePoint >> 0xC | 0xE0);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          Opal.yield1(block, codePoint >> 0x12 | 0xF0);
          Opal.yield1(block, codePoint >> 0xC & 0x3F | 0x80);
          Opal.yield1(block, codePoint >> 0x6 & 0x3F | 0x80);
          Opal.yield1(block, codePoint & 0x3F | 0x80);
        } else {
          // Invalid code point
        }
      }
    ;
    }, $each_byte$15.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$16 = function $$bytesize(string) {
      var self = this;

      return string.$bytes().$length()
    }, $bytesize$16.$$arity = 1), nil) && 'bytesize';}, $$14.$$s = self, $$14.$$arity = 0, $$14));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16LE"], ($$17 = function(){var self = $$17.$$s == null ? this : $$17.$$s, $each_byte$18, $bytesize$19;

    
    
    Opal.def(self, '$each_byte', $each_byte$18 = function $$each_byte(string) {
      var $iter = $each_byte$18.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$18.$$p = null;
      
      
      if ($iter) $each_byte$18.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
      }
    ;
    }, $each_byte$18.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$19 = function $$bytesize(string) {
      var self = this;

      return string.length * 2;
    }, $bytesize$19.$$arity = 1), nil) && 'bytesize';}, $$17.$$s = self, $$17.$$arity = 0, $$17));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-16BE", $hash2(["inherits"], {"inherits": $$$($$($nesting, 'Encoding'), 'UTF_16LE')})], ($$20 = function(){var self = $$20.$$s == null ? this : $$20.$$s, $each_byte$21;

    return (Opal.def(self, '$each_byte', $each_byte$21 = function $$each_byte(string) {
      var $iter = $each_byte$21.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$21.$$p = null;
      
      
      if ($iter) $each_byte$21.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$21.$$arity = 1), nil) && 'each_byte'}, $$20.$$s = self, $$20.$$arity = 0, $$20));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32LE"], ($$22 = function(){var self = $$22.$$s == null ? this : $$22.$$s, $each_byte$23, $bytesize$24;

    
    
    Opal.def(self, '$each_byte', $each_byte$23 = function $$each_byte(string) {
      var $iter = $each_byte$23.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$23.$$p = null;
      
      
      if ($iter) $each_byte$23.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, code & 0xff);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
      }
    ;
    }, $each_byte$23.$$arity = 1);
    return (Opal.def(self, '$bytesize', $bytesize$24 = function $$bytesize(string) {
      var self = this;

      return string.length * 4;
    }, $bytesize$24.$$arity = 1), nil) && 'bytesize';}, $$22.$$s = self, $$22.$$arity = 0, $$22));
  $send($$($nesting, 'Encoding'), 'register', ["UTF-32BE", $hash2(["inherits"], {"inherits": $$$($$($nesting, 'Encoding'), 'UTF_32LE')})], ($$25 = function(){var self = $$25.$$s == null ? this : $$25.$$s, $each_byte$26;

    return (Opal.def(self, '$each_byte', $each_byte$26 = function $$each_byte(string) {
      var $iter = $each_byte$26.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$26.$$p = null;
      
      
      if ($iter) $each_byte$26.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);

        Opal.yield1(block, 0);
        Opal.yield1(block, 0);
        Opal.yield1(block, code >> 8);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$26.$$arity = 1), nil) && 'each_byte'}, $$25.$$s = self, $$25.$$arity = 0, $$25));
  $send($$($nesting, 'Encoding'), 'register', ["ASCII-8BIT", $hash2(["aliases", "ascii"], {"aliases": ["BINARY"], "ascii": true})], ($$27 = function(){var self = $$27.$$s == null ? this : $$27.$$s, $each_char$28, $charsize$29, $each_byte$30, $bytesize$31, $binary$ques$32;

    
    
    Opal.def(self, '$each_char', $each_char$28 = function $$each_char(string) {
      var $iter = $each_char$28.$$p, block = $iter || nil, self = this;

      if ($iter) $each_char$28.$$p = null;
      
      
      if ($iter) $each_char$28.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var chr = new String(string.charAt(i));
        chr.encoding = string.encoding;
        Opal.yield1(block, chr);
      }
    ;
    }, $each_char$28.$$arity = 1);
    
    Opal.def(self, '$charsize', $charsize$29 = function $$charsize(string) {
      var self = this;

      return string.length;
    }, $charsize$29.$$arity = 1);
    
    Opal.def(self, '$each_byte', $each_byte$30 = function $$each_byte(string) {
      var $iter = $each_byte$30.$$p, block = $iter || nil, self = this;

      if ($iter) $each_byte$30.$$p = null;
      
      
      if ($iter) $each_byte$30.$$p = null;;
      
      for (var i = 0, length = string.length; i < length; i++) {
        var code = string.charCodeAt(i);
        Opal.yield1(block, code & 0xff);
      }
    ;
    }, $each_byte$30.$$arity = 1);
    
    Opal.def(self, '$bytesize', $bytesize$31 = function $$bytesize(string) {
      var self = this;

      return string.length;
    }, $bytesize$31.$$arity = 1);
    return (Opal.def(self, '$binary?', $binary$ques$32 = function() {
      var self = this;

      return true
    }, $binary$ques$32.$$arity = 0), nil) && 'binary?';}, $$27.$$s = self, $$27.$$arity = 0, $$27));
  $$($nesting, 'Encoding').$register("ISO-8859-1", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ISO8859-1"], "ascii": true, "inherits": $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')}));
  $$($nesting, 'Encoding').$register("US-ASCII", $hash2(["aliases", "ascii", "inherits"], {"aliases": ["ASCII"], "ascii": true, "inherits": $$$($$($nesting, 'Encoding'), 'ASCII_8BIT')}));
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_b$33, $String_bytesize$34, $String_each_byte$35, $String_bytes$37, $String_each_char$38, $String_chars$40, $String_each_codepoint$41, $String_codepoints$42, $String_encode$43, $String_force_encoding$44, $String_getbyte$45, $String_initialize_copy$46, $String_length$47, $String_valid_encoding$ques$48;

    self.$$prototype.internal_encoding = self.$$prototype.bytes = self.$$prototype.encoding = nil;
    
    self.$attr_reader("encoding");
    self.$attr_reader("internal_encoding");
    Opal.defineProperty(String.prototype, 'bytes', nil);
    Opal.defineProperty(String.prototype, 'encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    Opal.defineProperty(String.prototype, 'internal_encoding', $$$($$($nesting, 'Encoding'), 'UTF_8'));
    
    Opal.def(self, '$b', $String_b$33 = function $$b() {
      var self = this;

      return self.$dup().$force_encoding("binary")
    }, $String_b$33.$$arity = 0);
    
    Opal.def(self, '$bytesize', $String_bytesize$34 = function $$bytesize() {
      var self = this;

      return self.internal_encoding.$bytesize(self)
    }, $String_bytesize$34.$$arity = 0);
    
    Opal.def(self, '$each_byte', $String_each_byte$35 = function $$each_byte() {
      var $iter = $String_each_byte$35.$$p, block = $iter || nil, $$36, self = this;

      if ($iter) $String_each_byte$35.$$p = null;
      
      
      if ($iter) $String_each_byte$35.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_byte"], ($$36 = function(){var self = $$36.$$s == null ? this : $$36.$$s;

          return self.$bytesize()}, $$36.$$s = self, $$36.$$arity = 0, $$36))
      };
      $send(self.internal_encoding, 'each_byte', [self], block.$to_proc());
      return self;
    }, $String_each_byte$35.$$arity = 0);
    
    Opal.def(self, '$bytes', $String_bytes$37 = function $$bytes() {
      var self = this, $ret_or_4 = nil;

      
      
      if (typeof self === 'string') {
        return (new String(self)).$each_byte().$to_a();
      }
    ;
      self.bytes = (function() {if ($truthy(($ret_or_4 = self.bytes))) {
        return $ret_or_4
      } else {
        return self.$each_byte().$to_a()
      }; return nil; })();
      return self.bytes.$dup();
    }, $String_bytes$37.$$arity = 0);
    
    Opal.def(self, '$each_char', $String_each_char$38 = function $$each_char() {
      var $iter = $String_each_char$38.$$p, block = $iter || nil, $$39, self = this;

      if ($iter) $String_each_char$38.$$p = null;
      
      
      if ($iter) $String_each_char$38.$$p = null;;
      if ((block !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_char"], ($$39 = function(){var self = $$39.$$s == null ? this : $$39.$$s;

          return self.$length()}, $$39.$$s = self, $$39.$$arity = 0, $$39))
      };
      $send(self.encoding, 'each_char', [self], block.$to_proc());
      return self;
    }, $String_each_char$38.$$arity = 0);
    
    Opal.def(self, '$chars', $String_chars$40 = function $$chars() {
      var $iter = $String_chars$40.$$p, block = $iter || nil, self = this;

      if ($iter) $String_chars$40.$$p = null;
      
      
      if ($iter) $String_chars$40.$$p = null;;
      if ($truthy(block)) {
      } else {
        return self.$each_char().$to_a()
      };
      return $send(self, 'each_char', [], block.$to_proc());
    }, $String_chars$40.$$arity = 0);
    
    Opal.def(self, '$each_codepoint', $String_each_codepoint$41 = function $$each_codepoint() {
      var $iter = $String_each_codepoint$41.$$p, block = $iter || nil, self = this;

      if ($iter) $String_each_codepoint$41.$$p = null;
      
      
      if ($iter) $String_each_codepoint$41.$$p = null;;
      if ((block !== nil)) {
      } else {
        return self.$enum_for("each_codepoint")
      };
      
      for (var i = 0, length = self.length; i < length; i++) {
        Opal.yield1(block, self.codePointAt(i));
      }
    ;
      return self;
    }, $String_each_codepoint$41.$$arity = 0);
    
    Opal.def(self, '$codepoints', $String_codepoints$42 = function $$codepoints() {
      var $iter = $String_codepoints$42.$$p, block = $iter || nil, self = this;

      if ($iter) $String_codepoints$42.$$p = null;
      
      
      if ($iter) $String_codepoints$42.$$p = null;;
      if ((block !== nil)) {
        return $send(self, 'each_codepoint', [], block.$to_proc())};
      return self.$each_codepoint().$to_a();
    }, $String_codepoints$42.$$arity = 0);
    
    Opal.def(self, '$encode', $String_encode$43 = function $$encode(encoding) {
      var self = this;

      return Opal.enc(self, encoding);
    }, $String_encode$43.$$arity = 1);
    
    Opal.def(self, '$force_encoding', $String_force_encoding$44 = function $$force_encoding(encoding) {
      var self = this;

      
      var str = self;

      if (encoding === str.encoding) { return str; }

      encoding = $$($nesting, 'Opal')['$coerce_to!'](encoding, $$($nesting, 'String'), "to_s");
      encoding = $$($nesting, 'Encoding').$find(encoding);

      if (encoding === str.encoding) { return str; }

      str = Opal.set_encoding(str, encoding);

      return str;
    
    }, $String_force_encoding$44.$$arity = 1);
    
    Opal.def(self, '$getbyte', $String_getbyte$45 = function $$getbyte(idx) {
      var self = this, string_bytes = nil;

      
      string_bytes = self.$bytes();
      idx = $$($nesting, 'Opal')['$coerce_to!'](idx, $$($nesting, 'Integer'), "to_int");
      if ($truthy($rb_lt(string_bytes.$length(), idx))) {
        return nil};
      return string_bytes['$[]'](idx);
    }, $String_getbyte$45.$$arity = 1);
    
    Opal.def(self, '$initialize_copy', $String_initialize_copy$46 = function $$initialize_copy(other) {
      var self = this;

      return "" + "\n" + "      self.encoding = other.encoding;\n" + "      self.internal_encoding = other.internal_encoding;\n" + "    "
    }, $String_initialize_copy$46.$$arity = 1);
    
    Opal.def(self, '$length', $String_length$47 = function $$length() {
      var self = this;

      return self.length;
    }, $String_length$47.$$arity = 0);
    $alias(self, "size", "length");
    return (Opal.def(self, '$valid_encoding?', $String_valid_encoding$ques$48 = function() {
      var self = this;

      return true
    }, $String_valid_encoding$ques$48.$$arity = 0), nil) && 'valid_encoding?';
  })($nesting[0], null, $nesting);
  
  $writer = [$$$($$($nesting, 'Encoding'), 'UTF_8')];
  $send($$($nesting, 'Encoding'), 'default_external=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/math"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $type_error = Opal.type_error, $module = Opal.module, $truthy = Opal.truthy;

  Opal.add_stubs(['$new', '$raise', '$Float', '$Integer', '$module_function', '$checked', '$float!', '$===', '$gamma', '$-', '$integer!', '$/', '$infinite?']);
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Math');

    var $nesting = [self].concat($parent_nesting), $Math_checked$1, $Math_float$excl$2, $Math_integer$excl$3, $Math_acos$4, $Math_acosh$5, $Math_asin$6, $Math_asinh$7, $Math_atan$8, $Math_atan2$9, $Math_atanh$10, $Math_cbrt$11, $Math_cos$12, $Math_cosh$13, $Math_erf$14, $Math_erfc$15, $Math_exp$16, $Math_frexp$17, $Math_gamma$18, $Math_hypot$19, $Math_ldexp$20, $Math_lgamma$21, $Math_log$22, $Math_log10$23, $Math_log2$24, $Math_sin$25, $Math_sinh$26, $Math_sqrt$27, $Math_tan$28, $Math_tanh$29;

    
    Opal.const_set($nesting[0], 'E', Math.E);
    Opal.const_set($nesting[0], 'PI', Math.PI);
    Opal.const_set($nesting[0], 'DomainError', $$($nesting, 'Class').$new($$($nesting, 'StandardError')));
    Opal.defs(self, '$checked', $Math_checked$1 = function $$checked(method, $a) {
      var $post_args, args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      args = $post_args;;
      
      if (isNaN(args[0]) || (args.length == 2 && isNaN(args[1]))) {
        return NaN;
      }

      var result = Math[method].apply(null, args);

      if (isNaN(result)) {
        self.$raise($$($nesting, 'DomainError'), "" + "Numerical argument is out of domain - \"" + (method) + "\"");
      }

      return result;
    ;
    }, $Math_checked$1.$$arity = -2);
    Opal.defs(self, '$float!', $Math_float$excl$2 = function(value) {
      var self = this;

      try {
        return self.$Float(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Float')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, $Math_float$excl$2.$$arity = 1);
    Opal.defs(self, '$integer!', $Math_integer$excl$3 = function(value) {
      var self = this;

      try {
        return self.$Integer(value)
      } catch ($err) {
        if (Opal.rescue($err, [$$($nesting, 'ArgumentError')])) {
          try {
            return self.$raise($type_error(value, $$($nesting, 'Integer')))
          } finally { Opal.pop_exception(); }
        } else { throw $err; }
      }
    }, $Math_integer$excl$3.$$arity = 1);
    self.$module_function();
    
    Opal.def(self, '$acos', $Math_acos$4 = function $$acos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acos$4.$$arity = 1);
    if ($truthy((typeof(Math.acosh) !== "undefined"))) {
    } else {
      
      Math.acosh = function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      }
    
    };
    
    Opal.def(self, '$acosh', $Math_acosh$5 = function $$acosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("acosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_acosh$5.$$arity = 1);
    
    Opal.def(self, '$asin', $Math_asin$6 = function $$asin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asin$6.$$arity = 1);
    if ($truthy((typeof(Math.asinh) !== "undefined"))) {
    } else {
      
      Math.asinh = function(x) {
        return Math.log(x + Math.sqrt(x * x + 1))
      }
    
    };
    
    Opal.def(self, '$asinh', $Math_asinh$7 = function $$asinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("asinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_asinh$7.$$arity = 1);
    
    Opal.def(self, '$atan', $Math_atan$8 = function $$atan(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan$8.$$arity = 1);
    
    Opal.def(self, '$atan2', $Math_atan2$9 = function $$atan2(y, x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atan2", $$($nesting, 'Math')['$float!'](y), $$($nesting, 'Math')['$float!'](x))
    }, $Math_atan2$9.$$arity = 2);
    if ($truthy((typeof(Math.atanh) !== "undefined"))) {
    } else {
      
      Math.atanh = function(x) {
        return 0.5 * Math.log((1 + x) / (1 - x));
      }
    
    };
    
    Opal.def(self, '$atanh', $Math_atanh$10 = function $$atanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("atanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_atanh$10.$$arity = 1);
    if ($truthy((typeof(Math.cbrt) !== "undefined"))) {
    } else {
      
      Math.cbrt = function(x) {
        if (x == 0) {
          return 0;
        }

        if (x < 0) {
          return -Math.cbrt(-x);
        }

        var r  = x,
            ex = 0;

        while (r < 0.125) {
          r *= 8;
          ex--;
        }

        while (r > 1.0) {
          r *= 0.125;
          ex++;
        }

        r = (-0.46946116 * r + 1.072302) * r + 0.3812513;

        while (ex < 0) {
          r *= 0.5;
          ex++;
        }

        while (ex > 0) {
          r *= 2;
          ex--;
        }

        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);
        r = (2.0 / 3.0) * r + (1.0 / 3.0) * x / (r * r);

        return r;
      }
    
    };
    
    Opal.def(self, '$cbrt', $Math_cbrt$11 = function $$cbrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cbrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cbrt$11.$$arity = 1);
    
    Opal.def(self, '$cos', $Math_cos$12 = function $$cos(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cos", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cos$12.$$arity = 1);
    if ($truthy((typeof(Math.cosh) !== "undefined"))) {
    } else {
      
      Math.cosh = function(x) {
        return (Math.exp(x) + Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$cosh', $Math_cosh$13 = function $$cosh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("cosh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_cosh$13.$$arity = 1);
    if ($truthy((typeof(Math.erf) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erf', function(x) {
        var A1 =  0.254829592,
            A2 = -0.284496736,
            A3 =  1.421413741,
            A4 = -1.453152027,
            A5 =  1.061405429,
            P  =  0.3275911;

        var sign = 1;

        if (x < 0) {
            sign = -1;
        }

        x = Math.abs(x);

        var t = 1.0 / (1.0 + P * x);
        var y = 1.0 - (((((A5 * t + A4) * t) + A3) * t + A2) * t + A1) * t * Math.exp(-x * x);

        return sign * y;
      });
    
    };
    
    Opal.def(self, '$erf', $Math_erf$14 = function $$erf(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erf", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erf$14.$$arity = 1);
    if ($truthy((typeof(Math.erfc) !== "undefined"))) {
    } else {
      
      Opal.defineProperty(Math, 'erfc', function(x) {
        var z = Math.abs(x),
            t = 1.0 / (0.5 * z + 1.0);

        var A1 = t * 0.17087277 + -0.82215223,
            A2 = t * A1 + 1.48851587,
            A3 = t * A2 + -1.13520398,
            A4 = t * A3 + 0.27886807,
            A5 = t * A4 + -0.18628806,
            A6 = t * A5 + 0.09678418,
            A7 = t * A6 + 0.37409196,
            A8 = t * A7 + 1.00002368,
            A9 = t * A8,
            A10 = -z * z - 1.26551223 + A9;

        var a = t * Math.exp(A10);

        if (x < 0.0) {
          return 2.0 - a;
        }
        else {
          return a;
        }
      });
    
    };
    
    Opal.def(self, '$erfc', $Math_erfc$15 = function $$erfc(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("erfc", $$($nesting, 'Math')['$float!'](x))
    }, $Math_erfc$15.$$arity = 1);
    
    Opal.def(self, '$exp', $Math_exp$16 = function $$exp(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("exp", $$($nesting, 'Math')['$float!'](x))
    }, $Math_exp$16.$$arity = 1);
    
    Opal.def(self, '$frexp', $Math_frexp$17 = function $$frexp(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      
      if (isNaN(x)) {
        return [NaN, 0];
      }

      var ex   = Math.floor(Math.log(Math.abs(x)) / Math.log(2)) + 1,
          frac = x / Math.pow(2, ex);

      return [frac, ex];
    ;
    }, $Math_frexp$17.$$arity = 1);
    
    Opal.def(self, '$gamma', $Math_gamma$18 = function $$gamma(n) {
      var self = this;

      
      n = $$($nesting, 'Math')['$float!'](n);
      
      var i, t, x, value, result, twoN, threeN, fourN, fiveN;

      var G = 4.7421875;

      var P = [
         0.99999999999999709182,
         57.156235665862923517,
        -59.597960355475491248,
         14.136097974741747174,
        -0.49191381609762019978,
         0.33994649984811888699e-4,
         0.46523628927048575665e-4,
        -0.98374475304879564677e-4,
         0.15808870322491248884e-3,
        -0.21026444172410488319e-3,
         0.21743961811521264320e-3,
        -0.16431810653676389022e-3,
         0.84418223983852743293e-4,
        -0.26190838401581408670e-4,
         0.36899182659531622704e-5
      ];


      if (isNaN(n)) {
        return NaN;
      }

      if (n === 0 && 1 / n < 0) {
        return -Infinity;
      }

      if (n === -1 || n === -Infinity) {
        self.$raise($$($nesting, 'DomainError'), "Numerical argument is out of domain - \"gamma\"");
      }

      if ($$($nesting, 'Integer')['$==='](n)) {
        if (n <= 0) {
          return isFinite(n) ? Infinity : NaN;
        }

        if (n > 171) {
          return Infinity;
        }

        value  = n - 2;
        result = n - 1;

        while (value > 1) {
          result *= value;
          value--;
        }

        if (result == 0) {
          result = 1;
        }

        return result;
      }

      if (n < 0.5) {
        return Math.PI / (Math.sin(Math.PI * n) * $$($nesting, 'Math').$gamma($rb_minus(1, n)));
      }

      if (n >= 171.35) {
        return Infinity;
      }

      if (n > 85.0) {
        twoN   = n * n;
        threeN = twoN * n;
        fourN  = threeN * n;
        fiveN  = fourN * n;

        return Math.sqrt(2 * Math.PI / n) * Math.pow((n / Math.E), n) *
          (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) -
          571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) +
          5246819 / (75246796800 * fiveN * n));
      }

      n -= 1;
      x  = P[0];

      for (i = 1; i < P.length; ++i) {
        x += P[i] / (n + i);
      }

      t = n + G + 0.5;

      return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
    ;
    }, $Math_gamma$18.$$arity = 1);
    if ($truthy((typeof(Math.hypot) !== "undefined"))) {
    } else {
      
      Math.hypot = function(x, y) {
        return Math.sqrt(x * x + y * y)
      }
    
    };
    
    Opal.def(self, '$hypot', $Math_hypot$19 = function $$hypot(x, y) {
      var self = this;

      return $$($nesting, 'Math').$checked("hypot", $$($nesting, 'Math')['$float!'](x), $$($nesting, 'Math')['$float!'](y))
    }, $Math_hypot$19.$$arity = 2);
    
    Opal.def(self, '$ldexp', $Math_ldexp$20 = function $$ldexp(mantissa, exponent) {
      var self = this;

      
      mantissa = $$($nesting, 'Math')['$float!'](mantissa);
      exponent = $$($nesting, 'Math')['$integer!'](exponent);
      
      if (isNaN(exponent)) {
        self.$raise($$($nesting, 'RangeError'), "float NaN out of range of integer");
      }

      return mantissa * Math.pow(2, exponent);
    ;
    }, $Math_ldexp$20.$$arity = 2);
    
    Opal.def(self, '$lgamma', $Math_lgamma$21 = function $$lgamma(n) {
      var self = this;

      
      if (n == -1) {
        return [Infinity, 1];
      }
      else {
        return [Math.log(Math.abs($$($nesting, 'Math').$gamma(n))), $$($nesting, 'Math').$gamma(n) < 0 ? -1 : 1];
      }
    
    }, $Math_lgamma$21.$$arity = 1);
    
    Opal.def(self, '$log', $Math_log$22 = function $$log(x, base) {
      var self = this;

      
      ;
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      if ($truthy(base == null)) {
        return $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x))
      } else {
        
        if ($truthy($$($nesting, 'String')['$==='](base))) {
          self.$raise($type_error(base, $$($nesting, 'Float')))};
        return $rb_divide($$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](x)), $$($nesting, 'Math').$checked("log", $$($nesting, 'Math')['$float!'](base)));
      };
    }, $Math_log$22.$$arity = -2);
    if ($truthy((typeof(Math.log10) !== "undefined"))) {
    } else {
      
      Math.log10 = function(x) {
        return Math.log(x) / Math.LN10;
      }
    
    };
    
    Opal.def(self, '$log10', $Math_log10$23 = function $$log10(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log10", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log10$23.$$arity = 1);
    if ($truthy((typeof(Math.log2) !== "undefined"))) {
    } else {
      
      Math.log2 = function(x) {
        return Math.log(x) / Math.LN2;
      }
    
    };
    
    Opal.def(self, '$log2', $Math_log2$24 = function $$log2(x) {
      var self = this;

      
      if ($truthy($$($nesting, 'String')['$==='](x))) {
        self.$raise($type_error(x, $$($nesting, 'Float')))};
      return $$($nesting, 'Math').$checked("log2", $$($nesting, 'Math')['$float!'](x));
    }, $Math_log2$24.$$arity = 1);
    
    Opal.def(self, '$sin', $Math_sin$25 = function $$sin(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sin", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sin$25.$$arity = 1);
    if ($truthy((typeof(Math.sinh) !== "undefined"))) {
    } else {
      
      Math.sinh = function(x) {
        return (Math.exp(x) - Math.exp(-x)) / 2;
      }
    
    };
    
    Opal.def(self, '$sinh', $Math_sinh$26 = function $$sinh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sinh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sinh$26.$$arity = 1);
    
    Opal.def(self, '$sqrt', $Math_sqrt$27 = function $$sqrt(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("sqrt", $$($nesting, 'Math')['$float!'](x))
    }, $Math_sqrt$27.$$arity = 1);
    
    Opal.def(self, '$tan', $Math_tan$28 = function $$tan(x) {
      var self = this;

      
      x = $$($nesting, 'Math')['$float!'](x);
      if ($truthy(x['$infinite?']())) {
        return $$$($$($nesting, 'Float'), 'NAN')};
      return $$($nesting, 'Math').$checked("tan", $$($nesting, 'Math')['$float!'](x));
    }, $Math_tan$28.$$arity = 1);
    if ($truthy((typeof(Math.tanh) !== "undefined"))) {
    } else {
      
      Math.tanh = function(x) {
        if (x == Infinity) {
          return 1;
        }
        else if (x == -Infinity) {
          return -1;
        }
        else {
          return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
        }
      }
    
    };
    return (Opal.def(self, '$tanh', $Math_tanh$29 = function $$tanh(x) {
      var self = this;

      return $$($nesting, 'Math').$checked("tanh", $$($nesting, 'Math')['$float!'](x))
    }, $Math_tanh$29.$$arity = 1), nil) && 'tanh';
  })($nesting[0], $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/complex"] = function(Opal) {
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $module = Opal.module;

  Opal.add_stubs(['$require', '$===', '$real?', '$raise', '$new', '$*', '$cos', '$sin', '$attr_reader', '$class', '$==', '$real', '$imag', '$Complex', '$-@', '$+', '$__coerced__', '$-', '$nan?', '$/', '$conj', '$abs2', '$quo', '$polar', '$exp', '$log', '$>', '$!=', '$divmod', '$**', '$hypot', '$atan2', '$lcm', '$denominator', '$finite?', '$infinite?', '$numerator', '$abs', '$arg', '$rationalize', '$to_f', '$to_i', '$to_r', '$inspect', '$positive?', '$zero?', '$Rational']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Complex');

    var $nesting = [self].concat($parent_nesting), $Complex_rect$1, $Complex_polar$2, $Complex_initialize$3, $Complex_coerce$4, $Complex_$eq_eq$5, $Complex_$minus$$6, $Complex_$plus$7, $Complex_$minus$8, $Complex_$$9, $Complex_$slash$10, $Complex_$$$11, $Complex_abs$12, $Complex_abs2$13, $Complex_angle$14, $Complex_conj$15, $Complex_denominator$16, $Complex_eql$ques$17, $Complex_fdiv$18, $Complex_finite$ques$19, $Complex_hash$20, $Complex_infinite$ques$21, $Complex_inspect$22, $Complex_numerator$23, $Complex_polar$24, $Complex_rationalize$25, $Complex_real$ques$26, $Complex_rect$27, $Complex_to_f$28, $Complex_to_i$29, $Complex_to_r$30, $Complex_to_s$31;

    self.$$prototype.real = self.$$prototype.imag = nil;
    
    Opal.defs(self, '$rect', $Complex_rect$1 = function $$rect(real, imag) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

      
      
      if (imag == null) {
        imag = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_1 = (function() {if ($truthy(($ret_or_2 = (function() {if ($truthy(($ret_or_3 = $$($nesting, 'Numeric')['$==='](real)))) {
        return real['$real?']()
      } else {
        return $ret_or_3
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](imag)
      } else {
        return $ret_or_2
      }; return nil; })()))) {
        return imag['$real?']()
      } else {
        return $ret_or_1
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new(real, imag);
    }, $Complex_rect$1.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      return $alias(self, "rectangular", "rect")
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$polar', $Complex_polar$2 = function $$polar(r, theta) {
      var self = this, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil;

      
      
      if (theta == null) {
        theta = 0;
      };
      if ($truthy((function() {if ($truthy(($ret_or_4 = (function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Numeric')['$==='](r)))) {
        return r['$real?']()
      } else {
        return $ret_or_6
      }; return nil; })()))) {
        return $$($nesting, 'Numeric')['$==='](theta)
      } else {
        return $ret_or_5
      }; return nil; })()))) {
        return theta['$real?']()
      } else {
        return $ret_or_4
      }; return nil; })())) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not a real")
      };
      return self.$new($rb_times(r, $$($nesting, 'Math').$cos(theta)), $rb_times(r, $$($nesting, 'Math').$sin(theta)));
    }, $Complex_polar$2.$$arity = -2);
    self.$attr_reader("real", "imag");
    
    Opal.def(self, '$initialize', $Complex_initialize$3 = function $$initialize(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = 0;
      };
      self.real = real;
      return (self.imag = imag);
    }, $Complex_initialize$3.$$arity = -2);
    
    Opal.def(self, '$coerce', $Complex_coerce$4 = function $$coerce(other) {
      var self = this, $ret_or_7 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return [other, self]
      } else if ($truthy((function() {if ($truthy(($ret_or_7 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return [$$($nesting, 'Complex').$new(other, 0), self]
      } else {
        return self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      }
    }, $Complex_coerce$4.$$arity = 1);
    
    Opal.def(self, '$==', $Complex_$eq_eq$5 = function(other) {
      var self = this, $ret_or_8 = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy(($ret_or_8 = self.real['$=='](other.$real())))) {
          return self.imag['$=='](other.$imag())
        } else {
          return $ret_or_8
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_9 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_9
      }; return nil; })())) {
        if ($truthy(($ret_or_10 = self.real['$=='](other)))) {
          return self.imag['$=='](0)
        } else {
          return $ret_or_10
        }
      } else {
        return other['$=='](self)
      }
    }, $Complex_$eq_eq$5.$$arity = 1);
    
    Opal.def(self, '$-@', $Complex_$minus$$6 = function() {
      var self = this;

      return self.$Complex(self.real['$-@'](), self.imag['$-@']())
    }, $Complex_$minus$$6.$$arity = 0);
    
    Opal.def(self, '$+', $Complex_$plus$7 = function(other) {
      var self = this, $ret_or_11 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_plus(self.real, other.$real()), $rb_plus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_11 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return self.$Complex($rb_plus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("+", other)
      }
    }, $Complex_$plus$7.$$arity = 1);
    
    Opal.def(self, '$-', $Complex_$minus$8 = function(other) {
      var self = this, $ret_or_12 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus(self.real, other.$real()), $rb_minus(self.imag, other.$imag()))
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$Complex($rb_minus(self.real, other), self.imag)
      } else {
        return self.$__coerced__("-", other)
      }
    }, $Complex_$minus$8.$$arity = 1);
    
    Opal.def(self, '$*', $Complex_$$9 = function(other) {
      var self = this, $ret_or_13 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        return self.$Complex($rb_minus($rb_times(self.real, other.$real()), $rb_times(self.imag, other.$imag())), $rb_plus($rb_times(self.real, other.$imag()), $rb_times(self.imag, other.$real())))
      } else if ($truthy((function() {if ($truthy(($ret_or_13 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_13
      }; return nil; })())) {
        return self.$Complex($rb_times(self.real, other), $rb_times(self.imag, other))
      } else {
        return self.$__coerced__("*", other)
      }
    }, $Complex_$$9.$$arity = 1);
    
    Opal.def(self, '$/', $Complex_$slash$10 = function(other) {
      var self = this, $ret_or_14 = nil, $ret_or_15 = nil, $ret_or_16 = nil, $ret_or_17 = nil, $ret_or_18 = nil, $ret_or_19 = nil, $ret_or_20 = nil, $ret_or_21 = nil;

      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        if ($truthy((function() {if ($truthy(($ret_or_14 = (function() {if ($truthy(($ret_or_15 = (function() {if ($truthy(($ret_or_16 = (function() {if ($truthy(($ret_or_17 = $$($nesting, 'Number')['$==='](self.real)))) {
          return self.real['$nan?']()
        } else {
          return $ret_or_17
        }; return nil; })()))) {
          return $ret_or_16
        } else {
          
          if ($truthy(($ret_or_18 = $$($nesting, 'Number')['$==='](self.imag)))) {
            return self.imag['$nan?']()
          } else {
            return $ret_or_18
          };
        }; return nil; })()))) {
          return $ret_or_15
        } else {
          
          if ($truthy(($ret_or_19 = $$($nesting, 'Number')['$==='](other.$real())))) {
            return other.$real()['$nan?']()
          } else {
            return $ret_or_19
          };
        }; return nil; })()))) {
          return $ret_or_14
        } else {
          
          if ($truthy(($ret_or_20 = $$($nesting, 'Number')['$==='](other.$imag())))) {
            return other.$imag()['$nan?']()
          } else {
            return $ret_or_20
          };
        }; return nil; })())) {
          return $$($nesting, 'Complex').$new($$$($$($nesting, 'Float'), 'NAN'), $$$($$($nesting, 'Float'), 'NAN'))
        } else {
          return $rb_divide($rb_times(self, other.$conj()), other.$abs2())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_21 = $$($nesting, 'Numeric')['$==='](other)))) {
        return other['$real?']()
      } else {
        return $ret_or_21
      }; return nil; })())) {
        return self.$Complex(self.real.$quo(other), self.imag.$quo(other))
      } else {
        return self.$__coerced__("/", other)
      }
    }, $Complex_$slash$10.$$arity = 1);
    
    Opal.def(self, '$**', $Complex_$$$11 = function(other) {
      var $a, $b, $c, $d, self = this, r = nil, theta = nil, ore = nil, oim = nil, nr = nil, ntheta = nil, x = nil, z = nil, n = nil, div = nil, mod = nil, $ret_or_22 = nil;

      
      if (other['$=='](0)) {
        return $$($nesting, 'Complex').$new(1, 0)};
      if ($truthy($$($nesting, 'Complex')['$==='](other))) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        ore = other.$real();
        oim = other.$imag();
        nr = $$($nesting, 'Math').$exp($rb_minus($rb_times(ore, $$($nesting, 'Math').$log(r)), $rb_times(oim, theta)));
        ntheta = $rb_plus($rb_times(theta, ore), $rb_times(oim, $$($nesting, 'Math').$log(r)));
        return $$($nesting, 'Complex').$polar(nr, ntheta);
      } else if ($truthy($$($nesting, 'Integer')['$==='](other))) {
        if ($truthy($rb_gt(other, 0))) {
          
          x = self;
          z = x;
          n = $rb_minus(other, 1);
          while ($truthy(n['$!='](0))) {
            
            $c = n.$divmod(2), $b = Opal.to_ary($c), (div = ($b[0] == null ? nil : $b[0])), (mod = ($b[1] == null ? nil : $b[1])), $c;
            while (mod['$=='](0)) {
              
              x = self.$Complex($rb_minus($rb_times(x.$real(), x.$real()), $rb_times(x.$imag(), x.$imag())), $rb_times($rb_times(2, x.$real()), x.$imag()));
              n = div;
              $d = n.$divmod(2), $c = Opal.to_ary($d), (div = ($c[0] == null ? nil : $c[0])), (mod = ($c[1] == null ? nil : $c[1])), $d;
            };
            z = $rb_times(z, x);
            n = $rb_minus(n, 1);
          };
          return z;
        } else {
          return $rb_divide($$($nesting, 'Rational').$new(1, 1), self)['$**'](other['$-@']())
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_22 = $$($nesting, 'Float')['$==='](other)))) {
        return $ret_or_22
      } else {
        return $$($nesting, 'Rational')['$==='](other)
      }; return nil; })())) {
        
        $b = self.$polar(), $a = Opal.to_ary($b), (r = ($a[0] == null ? nil : $a[0])), (theta = ($a[1] == null ? nil : $a[1])), $b;
        return $$($nesting, 'Complex').$polar(r['$**'](other), $rb_times(theta, other));
      } else {
        return self.$__coerced__("**", other)
      };
    }, $Complex_$$$11.$$arity = 1);
    
    Opal.def(self, '$abs', $Complex_abs$12 = function $$abs() {
      var self = this;

      return $$($nesting, 'Math').$hypot(self.real, self.imag)
    }, $Complex_abs$12.$$arity = 0);
    
    Opal.def(self, '$abs2', $Complex_abs2$13 = function $$abs2() {
      var self = this;

      return $rb_plus($rb_times(self.real, self.real), $rb_times(self.imag, self.imag))
    }, $Complex_abs2$13.$$arity = 0);
    
    Opal.def(self, '$angle', $Complex_angle$14 = function $$angle() {
      var self = this;

      return $$($nesting, 'Math').$atan2(self.imag, self.real)
    }, $Complex_angle$14.$$arity = 0);
    $alias(self, "arg", "angle");
    
    Opal.def(self, '$conj', $Complex_conj$15 = function $$conj() {
      var self = this;

      return self.$Complex(self.real, self.imag['$-@']())
    }, $Complex_conj$15.$$arity = 0);
    $alias(self, "conjugate", "conj");
    
    Opal.def(self, '$denominator', $Complex_denominator$16 = function $$denominator() {
      var self = this;

      return self.real.$denominator().$lcm(self.imag.$denominator())
    }, $Complex_denominator$16.$$arity = 0);
    $alias(self, "divide", "/");
    
    Opal.def(self, '$eql?', $Complex_eql$ques$17 = function(other) {
      var self = this, $ret_or_23 = nil, $ret_or_24 = nil;

      if ($truthy(($ret_or_23 = (function() {if ($truthy(($ret_or_24 = $$($nesting, 'Complex')['$==='](other)))) {
        return self.real.$class()['$=='](self.imag.$class())
      } else {
        return $ret_or_24
      }; return nil; })()))) {
        return self['$=='](other)
      } else {
        return $ret_or_23
      }
    }, $Complex_eql$ques$17.$$arity = 1);
    
    Opal.def(self, '$fdiv', $Complex_fdiv$18 = function $$fdiv(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Numeric')['$==='](other))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (other.$class()) + " can't be coerced into Complex")
      };
      return $rb_divide(self, other);
    }, $Complex_fdiv$18.$$arity = 1);
    
    Opal.def(self, '$finite?', $Complex_finite$ques$19 = function() {
      var self = this, $ret_or_25 = nil;

      if ($truthy(($ret_or_25 = self.real['$finite?']()))) {
        return self.imag['$finite?']()
      } else {
        return $ret_or_25
      }
    }, $Complex_finite$ques$19.$$arity = 0);
    
    Opal.def(self, '$hash', $Complex_hash$20 = function $$hash() {
      var self = this;

      return "" + "Complex:" + (self.real) + ":" + (self.imag)
    }, $Complex_hash$20.$$arity = 0);
    $alias(self, "imaginary", "imag");
    
    Opal.def(self, '$infinite?', $Complex_infinite$ques$21 = function() {
      var self = this, $ret_or_26 = nil;

      if ($truthy(($ret_or_26 = self.real['$infinite?']()))) {
        return $ret_or_26
      } else {
        return self.imag['$infinite?']()
      }
    }, $Complex_infinite$ques$21.$$arity = 0);
    
    Opal.def(self, '$inspect', $Complex_inspect$22 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Complex_inspect$22.$$arity = 0);
    $alias(self, "magnitude", "abs");
    
    Opal.udef(self, '$' + "negative?");;
    
    Opal.def(self, '$numerator', $Complex_numerator$23 = function $$numerator() {
      var self = this, d = nil;

      
      d = self.$denominator();
      return self.$Complex($rb_times(self.real.$numerator(), $rb_divide(d, self.real.$denominator())), $rb_times(self.imag.$numerator(), $rb_divide(d, self.imag.$denominator())));
    }, $Complex_numerator$23.$$arity = 0);
    $alias(self, "phase", "arg");
    
    Opal.def(self, '$polar', $Complex_polar$24 = function $$polar() {
      var self = this;

      return [self.$abs(), self.$arg()]
    }, $Complex_polar$24.$$arity = 0);
    
    Opal.udef(self, '$' + "positive?");;
    $alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Complex_rationalize$25 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }
    ;
      if ($truthy(self.imag['$!='](0))) {
        self.$raise($$($nesting, 'RangeError'), "" + "can't' convert " + (self) + " into Rational")};
      return self.$real().$rationalize(eps);
    }, $Complex_rationalize$25.$$arity = -1);
    
    Opal.def(self, '$real?', $Complex_real$ques$26 = function() {
      var self = this;

      return false
    }, $Complex_real$ques$26.$$arity = 0);
    
    Opal.def(self, '$rect', $Complex_rect$27 = function $$rect() {
      var self = this;

      return [self.real, self.imag]
    }, $Complex_rect$27.$$arity = 0);
    $alias(self, "rectangular", "rect");
    
    Opal.udef(self, '$' + "step");;
    
    Opal.def(self, '$to_f', $Complex_to_f$28 = function $$to_f() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Float")
      };
      return self.real.$to_f();
    }, $Complex_to_f$28.$$arity = 0);
    
    Opal.def(self, '$to_i', $Complex_to_i$29 = function $$to_i() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Integer")
      };
      return self.real.$to_i();
    }, $Complex_to_i$29.$$arity = 0);
    
    Opal.def(self, '$to_r', $Complex_to_r$30 = function $$to_r() {
      var self = this;

      
      if (self.imag['$=='](0)) {
      } else {
        self.$raise($$($nesting, 'RangeError'), "" + "can't convert " + (self) + " into Rational")
      };
      return self.real.$to_r();
    }, $Complex_to_r$30.$$arity = 0);
    
    Opal.def(self, '$to_s', $Complex_to_s$31 = function $$to_s() {
      var self = this, result = nil, $ret_or_27 = nil, $ret_or_28 = nil, $ret_or_29 = nil, $ret_or_30 = nil, $ret_or_31 = nil;

      
      result = self.real.$inspect();
      result = $rb_plus(result, (function() {if ($truthy((function() {if ($truthy(($ret_or_27 = (function() {if ($truthy(($ret_or_28 = (function() {if ($truthy(($ret_or_29 = $$($nesting, 'Number')['$==='](self.imag)))) {
        return self.imag['$nan?']()
      } else {
        return $ret_or_29
      }; return nil; })()))) {
        return $ret_or_28
      } else {
        return self.imag['$positive?']()
      }; return nil; })()))) {
        return $ret_or_27
      } else {
        return self.imag['$zero?']()
      }; return nil; })())) {
        return "+"
      } else {
        return "-"
      }; return nil; })());
      result = $rb_plus(result, self.imag.$abs().$inspect());
      if ($truthy((function() {if ($truthy(($ret_or_30 = $$($nesting, 'Number')['$==='](self.imag)))) {
        
        if ($truthy(($ret_or_31 = self.imag['$nan?']()))) {
          return $ret_or_31
        } else {
          return self.imag['$infinite?']()
        };
      } else {
        return $ret_or_30
      }; return nil; })())) {
        result = $rb_plus(result, "*")};
      return $rb_plus(result, "i");
    }, $Complex_to_s$31.$$arity = 0);
    return Opal.const_set($nesting[0], 'I', self.$new(0, 1));
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Complex$32;

    return (Opal.def(self, '$Complex', $Kernel_Complex$32 = function $$Complex(real, imag) {
      var self = this;

      
      
      if (imag == null) {
        imag = nil;
      };
      if ($truthy(imag)) {
        return $$($nesting, 'Complex').$new(real, imag)
      } else {
        return $$($nesting, 'Complex').$new(real, 0)
      };
    }, $Kernel_Complex$32.$$arity = -2), nil) && 'Complex'
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_c$33;

    return (Opal.def(self, '$to_c', $String_to_c$33 = function $$to_c() {
      var self = this;

      
      var str = self,
          re = /[+-]?[\d_]+(\.[\d_]+)?(e\d+)?/,
          match = str.match(re),
          real, imag, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      // handles both floats and rationals
      function cutNumber() {
        if (isFloat()) {
          var numerator = parseFloat(cutFloat());

          if (str[0] === '/') {
            // rational real part
            str = str.slice(1);

            if (isFloat()) {
              var denominator = parseFloat(cutFloat());
              return self.$Rational(numerator, denominator);
            } else {
              // reverting '/'
              str = '/' + str;
              return numerator;
            }
          } else {
            // float real part, no denominator
            return numerator;
          }
        } else {
          return null;
        }
      }

      real = cutNumber();

      if (!real) {
        if (str[0] === 'i') {
          // i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        if (str[0] === '-' && str[1] === 'i') {
          // -i => Complex(0, -1)
          return self.$Complex(0, -1);
        }
        if (str[0] === '+' && str[1] === 'i') {
          // +i => Complex(0, 1)
          return self.$Complex(0, 1);
        }
        // anything => Complex(0, 0)
        return self.$Complex(0, 0);
      }

      imag = cutNumber();
      if (!imag) {
        if (str[0] === 'i') {
          // 3i => Complex(0, 3)
          return self.$Complex(0, real);
        } else {
          // 3 => Complex(3, 0)
          return self.$Complex(real, 0);
        }
      } else {
        // 3+2i => Complex(3, 2)
        return self.$Complex(real, imag);
      }
    
    }, $String_to_c$33.$$arity = 0), nil) && 'to_c'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/rational"] = function(Opal) {
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_times(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs * rhs : lhs['$*'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $module = Opal.module;

  Opal.add_stubs(['$require', '$to_i', '$==', '$raise', '$<', '$-@', '$new', '$gcd', '$/', '$nil?', '$===', '$reduce', '$to_r', '$equal?', '$!', '$coerce_to!', '$to_f', '$numerator', '$denominator', '$<=>', '$-', '$*', '$__coerced__', '$+', '$Rational', '$>', '$**', '$abs', '$ceil', '$with_precision', '$floor', '$<=', '$truncate', '$send', '$convert']);
  
  self.$require("corelib/numeric");
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Rational');

    var $nesting = [self].concat($parent_nesting), $Rational_reduce$1, $Rational_convert$2, $Rational_initialize$3, $Rational_numerator$4, $Rational_denominator$5, $Rational_coerce$6, $Rational_$eq_eq$7, $Rational_$lt_eq_gt$8, $Rational_$plus$9, $Rational_$minus$10, $Rational_$$11, $Rational_$slash$12, $Rational_$$$13, $Rational_abs$14, $Rational_ceil$15, $Rational_floor$16, $Rational_hash$17, $Rational_inspect$18, $Rational_rationalize$19, $Rational_round$20, $Rational_to_f$21, $Rational_to_i$22, $Rational_to_r$23, $Rational_to_s$24, $Rational_truncate$25, $Rational_with_precision$26;

    self.$$prototype.num = self.$$prototype.den = nil;
    
    Opal.defs(self, '$reduce', $Rational_reduce$1 = function $$reduce(num, den) {
      var self = this, gcd = nil;

      
      num = num.$to_i();
      den = den.$to_i();
      if (den['$=='](0)) {
        self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else if ($truthy($rb_lt(den, 0))) {
        
        num = num['$-@']();
        den = den['$-@']();
      } else if (den['$=='](1)) {
        return self.$new(num, den)};
      gcd = num.$gcd(den);
      return self.$new($rb_divide(num, gcd), $rb_divide(den, gcd));
    }, $Rational_reduce$1.$$arity = 2);
    Opal.defs(self, '$convert', $Rational_convert$2 = function $$convert(num, den) {
      var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, $ret_or_6 = nil, $ret_or_7 = nil, $ret_or_8 = nil;

      
      if ($truthy((function() {if ($truthy(($ret_or_1 = num['$nil?']()))) {
        return $ret_or_1
      } else {
        return den['$nil?']()
      }; return nil; })())) {
        self.$raise($$($nesting, 'TypeError'), "cannot convert nil into Rational")};
      if ($truthy((function() {if ($truthy(($ret_or_2 = $$($nesting, 'Integer')['$==='](num)))) {
        return $$($nesting, 'Integer')['$==='](den)
      } else {
        return $ret_or_2
      }; return nil; })())) {
        return self.$reduce(num, den)};
      if ($truthy((function() {if ($truthy(($ret_or_3 = (function() {if ($truthy(($ret_or_4 = $$($nesting, 'Float')['$==='](num)))) {
        return $ret_or_4
      } else {
        return $$($nesting, 'String')['$==='](num)
      }; return nil; })()))) {
        return $ret_or_3
      } else {
        return $$($nesting, 'Complex')['$==='](num)
      }; return nil; })())) {
        num = num.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_5 = (function() {if ($truthy(($ret_or_6 = $$($nesting, 'Float')['$==='](den)))) {
        return $ret_or_6
      } else {
        return $$($nesting, 'String')['$==='](den)
      }; return nil; })()))) {
        return $ret_or_5
      } else {
        return $$($nesting, 'Complex')['$==='](den)
      }; return nil; })())) {
        den = den.$to_r()};
      if ($truthy((function() {if ($truthy(($ret_or_7 = den['$equal?'](1)))) {
        return $$($nesting, 'Integer')['$==='](num)['$!']()
      } else {
        return $ret_or_7
      }; return nil; })())) {
        return $$($nesting, 'Opal')['$coerce_to!'](num, $$($nesting, 'Rational'), "to_r")
      } else if ($truthy((function() {if ($truthy(($ret_or_8 = $$($nesting, 'Numeric')['$==='](num)))) {
        return $$($nesting, 'Numeric')['$==='](den)
      } else {
        return $ret_or_8
      }; return nil; })())) {
        return $rb_divide(num, den)
      } else {
        return self.$reduce(num, den)
      };
    }, $Rational_convert$2.$$arity = 2);
    
    Opal.def(self, '$initialize', $Rational_initialize$3 = function $$initialize(num, den) {
      var self = this;

      
      self.num = num;
      return (self.den = den);
    }, $Rational_initialize$3.$$arity = 2);
    
    Opal.def(self, '$numerator', $Rational_numerator$4 = function $$numerator() {
      var self = this;

      return self.num
    }, $Rational_numerator$4.$$arity = 0);
    
    Opal.def(self, '$denominator', $Rational_denominator$5 = function $$denominator() {
      var self = this;

      return self.den
    }, $Rational_denominator$5.$$arity = 0);
    
    Opal.def(self, '$coerce', $Rational_coerce$6 = function $$coerce(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return [other, self]}
      else if ($$($nesting, 'Integer')['$===']($case)) {return [other.$to_r(), self]}
      else if ($$($nesting, 'Float')['$===']($case)) {return [other, self.$to_f()]}
      else { return nil }})()
    }, $Rational_coerce$6.$$arity = 1);
    
    Opal.def(self, '$==', $Rational_$eq_eq$7 = function(other) {
      var self = this, $case = nil, $ret_or_9 = nil, $ret_or_10 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {if ($truthy(($ret_or_9 = self.num['$=='](other.$numerator())))) {
        return self.den['$=='](other.$denominator())
      } else {
        return $ret_or_9
      }}
      else if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy(($ret_or_10 = self.num['$=='](other)))) {
        return self.den['$=='](1)
      } else {
        return $ret_or_10
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$=='](other)}
      else {return other['$=='](self)}})()
    }, $Rational_$eq_eq$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Rational_$lt_eq_gt$8 = function(other) {
      var self = this, $case = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {return $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()))['$<=>'](0)}
      else if ($$($nesting, 'Integer')['$===']($case)) {return $rb_minus(self.num, $rb_times(self.den, other))['$<=>'](0)}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$<=>'](other)}
      else {return self.$__coerced__("<=>", other)}})()
    }, $Rational_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$+', $Rational_$plus$9 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_plus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_plus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_plus(self.$to_f(), other)}
      else {return self.$__coerced__("+", other)}})()
    }, $Rational_$plus$9.$$arity = 1);
    
    Opal.def(self, '$-', $Rational_$minus$10 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_minus($rb_times(self.num, other.$denominator()), $rb_times(self.den, other.$numerator()));
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_minus(self.num, $rb_times(other, self.den)), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_minus(self.$to_f(), other)}
      else {return self.$__coerced__("-", other)}})()
    }, $Rational_$minus$10.$$arity = 1);
    
    Opal.def(self, '$*', $Rational_$$11 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$numerator());
      den = $rb_times(self.den, other.$denominator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {return self.$Rational($rb_times(self.num, other), self.den)}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_times(self.$to_f(), other)}
      else {return self.$__coerced__("*", other)}})()
    }, $Rational_$$11.$$arity = 1);
    
    Opal.def(self, '$/', $Rational_$slash$12 = function(other) {
      var self = this, $case = nil, num = nil, den = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Rational')['$===']($case)) {
      num = $rb_times(self.num, other.$denominator());
      den = $rb_times(self.den, other.$numerator());
      return self.$Rational(num, den);}
      else if ($$($nesting, 'Integer')['$===']($case)) {if (other['$=='](0)) {
        return $rb_divide(self.$to_f(), 0.0)
      } else {
        return self.$Rational(self.num, $rb_times(self.den, other))
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return $rb_divide(self.$to_f(), other)}
      else {return self.$__coerced__("/", other)}})()
    }, $Rational_$slash$12.$$arity = 1);
    
    Opal.def(self, '$**', $Rational_$$$13 = function(other) {
      var self = this, $case = nil, $ret_or_11 = nil, $ret_or_12 = nil;

      return (function() {$case = other;
      if ($$($nesting, 'Integer')['$===']($case)) {if ($truthy((function() {if ($truthy(($ret_or_11 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_11
      }; return nil; })())) {
        return $$$($$($nesting, 'Float'), 'INFINITY')
      } else if ($truthy($rb_gt(other, 0))) {
        return self.$Rational(self.num['$**'](other), self.den['$**'](other))
      } else if ($truthy($rb_lt(other, 0))) {
        return self.$Rational(self.den['$**'](other['$-@']()), self.num['$**'](other['$-@']()))
      } else {
        return self.$Rational(1, 1)
      }}
      else if ($$($nesting, 'Float')['$===']($case)) {return self.$to_f()['$**'](other)}
      else if ($$($nesting, 'Rational')['$===']($case)) {if (other['$=='](0)) {
        return self.$Rational(1, 1)
      } else if (other.$denominator()['$=='](1)) {
        if ($truthy($rb_lt(other, 0))) {
          return self.$Rational(self.den['$**'](other.$numerator().$abs()), self.num['$**'](other.$numerator().$abs()))
        } else {
          return self.$Rational(self.num['$**'](other.$numerator()), self.den['$**'](other.$numerator()))
        }
      } else if ($truthy((function() {if ($truthy(($ret_or_12 = self['$=='](0)))) {
        return $rb_lt(other, 0)
      } else {
        return $ret_or_12
      }; return nil; })())) {
        return self.$raise($$($nesting, 'ZeroDivisionError'), "divided by 0")
      } else {
        return self.$to_f()['$**'](other)
      }}
      else {return self.$__coerced__("**", other)}})()
    }, $Rational_$$$13.$$arity = 1);
    
    Opal.def(self, '$abs', $Rational_abs$14 = function $$abs() {
      var self = this;

      return self.$Rational(self.num.$abs(), self.den.$abs())
    }, $Rational_abs$14.$$arity = 0);
    
    Opal.def(self, '$ceil', $Rational_ceil$15 = function $$ceil(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$ceil()
      } else {
        return self.$with_precision("ceil", precision)
      };
    }, $Rational_ceil$15.$$arity = -1);
    $alias(self, "divide", "/");
    
    Opal.def(self, '$floor', $Rational_floor$16 = function $$floor(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        return $rb_divide(self.num['$-@'](), self.den)['$-@']().$floor()
      } else {
        return self.$with_precision("floor", precision)
      };
    }, $Rational_floor$16.$$arity = -1);
    
    Opal.def(self, '$hash', $Rational_hash$17 = function $$hash() {
      var self = this;

      return "" + "Rational:" + (self.num) + ":" + (self.den)
    }, $Rational_hash$17.$$arity = 0);
    
    Opal.def(self, '$inspect', $Rational_inspect$18 = function $$inspect() {
      var self = this;

      return "" + "(" + (self) + ")"
    }, $Rational_inspect$18.$$arity = 0);
    $alias(self, "quo", "/");
    
    Opal.def(self, '$rationalize', $Rational_rationalize$19 = function $$rationalize(eps) {
      var self = this;

      
      ;
      
      if (arguments.length > 1) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (" + (arguments.length) + " for 0..1)");
      }

      if (eps == null) {
        return self;
      }

      var e = eps.$abs(),
          a = $rb_minus(self, e),
          b = $rb_plus(self, e);

      var p0 = 0,
          p1 = 1,
          q0 = 1,
          q1 = 0,
          p2, q2;

      var c, k, t;

      while (true) {
        c = (a).$ceil();

        if ($rb_le(c, b)) {
          break;
        }

        k  = c - 1;
        p2 = k * p1 + p0;
        q2 = k * q1 + q0;
        t  = $rb_divide(1, $rb_minus(b, k));
        b  = $rb_divide(1, $rb_minus(a, k));
        a  = t;

        p0 = p1;
        q0 = q1;
        p1 = p2;
        q1 = q2;
      }

      return self.$Rational(c * p1 + p0, c * q1 + q0);
    ;
    }, $Rational_rationalize$19.$$arity = -1);
    
    Opal.def(self, '$round', $Rational_round$20 = function $$round(precision) {
      var self = this, num = nil, den = nil, approx = nil;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
      } else {
        return self.$with_precision("round", precision)
      };
      if (self.num['$=='](0)) {
        return 0};
      if (self.den['$=='](1)) {
        return self.num};
      num = $rb_plus($rb_times(self.num.$abs(), 2), self.den);
      den = $rb_times(self.den, 2);
      approx = $rb_divide(num, den).$truncate();
      if ($truthy($rb_lt(self.num, 0))) {
        return approx['$-@']()
      } else {
        return approx
      };
    }, $Rational_round$20.$$arity = -1);
    
    Opal.def(self, '$to_f', $Rational_to_f$21 = function $$to_f() {
      var self = this;

      return $rb_divide(self.num, self.den)
    }, $Rational_to_f$21.$$arity = 0);
    
    Opal.def(self, '$to_i', $Rational_to_i$22 = function $$to_i() {
      var self = this;

      return self.$truncate()
    }, $Rational_to_i$22.$$arity = 0);
    
    Opal.def(self, '$to_r', $Rational_to_r$23 = function $$to_r() {
      var self = this;

      return self
    }, $Rational_to_r$23.$$arity = 0);
    
    Opal.def(self, '$to_s', $Rational_to_s$24 = function $$to_s() {
      var self = this;

      return "" + (self.num) + "/" + (self.den)
    }, $Rational_to_s$24.$$arity = 0);
    
    Opal.def(self, '$truncate', $Rational_truncate$25 = function $$truncate(precision) {
      var self = this;

      
      
      if (precision == null) {
        precision = 0;
      };
      if (precision['$=='](0)) {
        if ($truthy($rb_lt(self.num, 0))) {
          return self.$ceil()
        } else {
          return self.$floor()
        }
      } else {
        return self.$with_precision("truncate", precision)
      };
    }, $Rational_truncate$25.$$arity = -1);
    return (Opal.def(self, '$with_precision', $Rational_with_precision$26 = function $$with_precision(method, precision) {
      var self = this, p = nil, s = nil;

      
      if ($truthy($$($nesting, 'Integer')['$==='](precision))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "not an Integer")
      };
      p = (10)['$**'](precision);
      s = $rb_times(self, p);
      if ($truthy($rb_lt(precision, 1))) {
        return $rb_divide(s.$send(method), p).$to_i()
      } else {
        return self.$Rational(s.$send(method), p)
      };
    }, $Rational_with_precision$26.$$arity = 2), nil) && 'with_precision';
  })($nesting[0], $$($nesting, 'Numeric'), $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_Rational$27;

    return (Opal.def(self, '$Rational', $Kernel_Rational$27 = function $$Rational(numerator, denominator) {
      var self = this;

      
      
      if (denominator == null) {
        denominator = 1;
      };
      return $$($nesting, 'Rational').$convert(numerator, denominator);
    }, $Kernel_Rational$27.$$arity = -2), nil) && 'Rational'
  })($nesting[0], $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_to_r$28;

    return (Opal.def(self, '$to_r', $String_to_r$28 = function $$to_r() {
      var self = this;

      
      var str = self.trimLeft(),
          re = /^[+-]?[\d_]+(\.[\d_]+)?/,
          match = str.match(re),
          numerator, denominator;

      function isFloat() {
        return re.test(str);
      }

      function cutFloat() {
        var match = str.match(re);
        var number = match[0];
        str = str.slice(number.length);
        return number.replace(/_/g, '');
      }

      if (isFloat()) {
        numerator = parseFloat(cutFloat());

        if (str[0] === '/') {
          // rational real part
          str = str.slice(1);

          if (isFloat()) {
            denominator = parseFloat(cutFloat());
            return self.$Rational(numerator, denominator);
          } else {
            return self.$Rational(numerator, 1);
          }
        } else {
          return self.$Rational(numerator, 1);
        }
      } else {
        return self.$Rational(0, 1);
      }
    
    }, $String_to_r$28.$$arity = 0), nil) && 'to_r'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/time"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_le(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs <= rhs : lhs['$<='](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $slice = Opal.slice, $klass = Opal.klass, $alias = Opal.alias, $truthy = Opal.truthy, $range = Opal.range;

  Opal.add_stubs(['$require', '$include', '$===', '$raise', '$coerce_to!', '$respond_to?', '$to_str', '$to_i', '$new', '$<=>', '$to_f', '$nil?', '$>', '$<', '$strftime', '$year', '$month', '$day', '$+', '$round', '$/', '$-', '$copy_instance_variables', '$initialize_dup', '$is_a?', '$zero?', '$wday', '$utc?', '$mon', '$yday', '$hour', '$min', '$sec', '$rjust', '$ljust', '$zone', '$to_s', '$[]', '$cweek_cyear', '$isdst', '$<=', '$!=', '$==', '$ceil']);
  
  self.$require("corelib/comparable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Time');

    var $nesting = [self].concat($parent_nesting), $Time_at$1, $Time_new$2, $Time_local$3, $Time_gm$4, $Time_now$5, $Time_$plus$6, $Time_$minus$7, $Time_$lt_eq_gt$8, $Time_$eq_eq$9, $Time_asctime$10, $Time_day$11, $Time_yday$12, $Time_isdst$13, $Time_dup$14, $Time_eql$ques$15, $Time_friday$ques$16, $Time_hash$17, $Time_hour$18, $Time_inspect$19, $Time_min$20, $Time_mon$21, $Time_monday$ques$22, $Time_saturday$ques$23, $Time_sec$24, $Time_succ$25, $Time_usec$26, $Time_zone$27, $Time_getgm$28, $Time_gmtime$29, $Time_gmt$ques$30, $Time_gmt_offset$31, $Time_strftime$32, $Time_sunday$ques$33, $Time_thursday$ques$34, $Time_to_a$35, $Time_to_f$36, $Time_to_i$37, $Time_tuesday$ques$38, $Time_wday$39, $Time_wednesday$ques$40, $Time_year$41, $Time_cweek_cyear$42;

    
    self.$include($$($nesting, 'Comparable'));
    
    var days_of_week = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
        short_days   = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        short_months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        long_months  = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  ;
    Opal.defs(self, '$at', $Time_at$1 = function $$at(seconds, frac) {
      var self = this;

      
      ;
      
      var result;

      if ($$($nesting, 'Time')['$==='](seconds)) {
        if (frac !== undefined) {
          self.$raise($$($nesting, 'TypeError'), "can't convert Time into an exact number")
        }
        result = new Date(seconds.getTime());
        result.is_utc = seconds.is_utc;
        return result;
      }

      if (!seconds.$$is_number) {
        seconds = $$($nesting, 'Opal')['$coerce_to!'](seconds, $$($nesting, 'Integer'), "to_int");
      }

      if (frac === undefined) {
        return new Date(seconds * 1000);
      }

      if (!frac.$$is_number) {
        frac = $$($nesting, 'Opal')['$coerce_to!'](frac, $$($nesting, 'Integer'), "to_int");
      }

      return new Date(seconds * 1000 + (frac / 1000));
    ;
    }, $Time_at$1.$$arity = -2);
    
    function time_params(year, month, day, hour, min, sec) {
      if (year.$$is_string) {
        year = parseInt(year, 10);
      } else {
        year = $$($nesting, 'Opal')['$coerce_to!'](year, $$($nesting, 'Integer'), "to_int");
      }

      if (month === nil) {
        month = 1;
      } else if (!month.$$is_number) {
        if ((month)['$respond_to?']("to_str")) {
          month = (month).$to_str();
          switch (month.toLowerCase()) {
          case 'jan': month =  1; break;
          case 'feb': month =  2; break;
          case 'mar': month =  3; break;
          case 'apr': month =  4; break;
          case 'may': month =  5; break;
          case 'jun': month =  6; break;
          case 'jul': month =  7; break;
          case 'aug': month =  8; break;
          case 'sep': month =  9; break;
          case 'oct': month = 10; break;
          case 'nov': month = 11; break;
          case 'dec': month = 12; break;
          default: month = (month).$to_i();
          }
        } else {
          month = $$($nesting, 'Opal')['$coerce_to!'](month, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (month < 1 || month > 12) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "month out of range: " + (month))
      }
      month = month - 1;

      if (day === nil) {
        day = 1;
      } else if (day.$$is_string) {
        day = parseInt(day, 10);
      } else {
        day = $$($nesting, 'Opal')['$coerce_to!'](day, $$($nesting, 'Integer'), "to_int");
      }

      if (day < 1 || day > 31) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "day out of range: " + (day))
      }

      if (hour === nil) {
        hour = 0;
      } else if (hour.$$is_string) {
        hour = parseInt(hour, 10);
      } else {
        hour = $$($nesting, 'Opal')['$coerce_to!'](hour, $$($nesting, 'Integer'), "to_int");
      }

      if (hour < 0 || hour > 24) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "hour out of range: " + (hour))
      }

      if (min === nil) {
        min = 0;
      } else if (min.$$is_string) {
        min = parseInt(min, 10);
      } else {
        min = $$($nesting, 'Opal')['$coerce_to!'](min, $$($nesting, 'Integer'), "to_int");
      }

      if (min < 0 || min > 59) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "min out of range: " + (min))
      }

      if (sec === nil) {
        sec = 0;
      } else if (!sec.$$is_number) {
        if (sec.$$is_string) {
          sec = parseInt(sec, 10);
        } else {
          sec = $$($nesting, 'Opal')['$coerce_to!'](sec, $$($nesting, 'Integer'), "to_int");
        }
      }

      if (sec < 0 || sec > 60) {
        self.$raise($$($nesting, 'ArgumentError'), "" + "sec out of range: " + (sec))
      }

      return [year, month, day, hour, min, sec];
    }
  ;
    Opal.defs(self, '$new', $Time_new$2 = function(year, month, day, hour, min, sec, utc_offset) {
      var self = this;

      
      ;
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (utc_offset == null) {
        utc_offset = nil;
      };
      
      var args, result;

      if (year === undefined) {
        return new Date();
      }

      if (utc_offset !== nil) {
        self.$raise($$($nesting, 'ArgumentError'), "Opal does not support explicitly specifying UTC offset for Time")
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_new$2.$$arity = -1);
    Opal.defs(self, '$local', $Time_local$3 = function $$local(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(year, month, day, hour, min, 0, sec * 1000);
      if (year < 100) {
        result.setFullYear(year);
      }
      return result;
    ;
    }, $Time_local$3.$$arity = -2);
    Opal.defs(self, '$gm', $Time_gm$4 = function $$gm(year, month, day, hour, min, sec, millisecond, _dummy1, _dummy2, _dummy3) {
      var self = this;

      
      
      if (month == null) {
        month = nil;
      };
      
      if (day == null) {
        day = nil;
      };
      
      if (hour == null) {
        hour = nil;
      };
      
      if (min == null) {
        min = nil;
      };
      
      if (sec == null) {
        sec = nil;
      };
      
      if (millisecond == null) {
        millisecond = nil;
      };
      
      if (_dummy1 == null) {
        _dummy1 = nil;
      };
      
      if (_dummy2 == null) {
        _dummy2 = nil;
      };
      
      if (_dummy3 == null) {
        _dummy3 = nil;
      };
      
      var args, result;

      if (arguments.length === 10) {
        args  = $slice.call(arguments);
        year  = args[5];
        month = args[4];
        day   = args[3];
        hour  = args[2];
        min   = args[1];
        sec   = args[0];
      }

      args  = time_params(year, month, day, hour, min, sec);
      year  = args[0];
      month = args[1];
      day   = args[2];
      hour  = args[3];
      min   = args[4];
      sec   = args[5];

      result = new Date(Date.UTC(year, month, day, hour, min, 0, sec * 1000));
      if (year < 100) {
        result.setUTCFullYear(year);
      }
      result.is_utc = true;
      return result;
    ;
    }, $Time_gm$4.$$arity = -2);
    (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting);

      
      $alias(self, "mktime", "local");
      return $alias(self, "utc", "gm");
    })(Opal.get_singleton_class(self), $nesting);
    Opal.defs(self, '$now', $Time_now$5 = function $$now() {
      var self = this;

      return self.$new()
    }, $Time_now$5.$$arity = 0);
    
    Opal.def(self, '$+', $Time_$plus$6 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        self.$raise($$($nesting, 'TypeError'), "time + time?")};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() + (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$plus$6.$$arity = 1);
    
    Opal.def(self, '$-', $Time_$minus$7 = function(other) {
      var self = this;

      
      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return (self.getTime() - other.getTime()) / 1000};
      
      if (!other.$$is_number) {
        other = $$($nesting, 'Opal')['$coerce_to!'](other, $$($nesting, 'Integer'), "to_int");
      }
      var result = new Date(self.getTime() - (other * 1000));
      result.is_utc = self.is_utc;
      return result;
    ;
    }, $Time_$minus$7.$$arity = 1);
    
    Opal.def(self, '$<=>', $Time_$lt_eq_gt$8 = function(other) {
      var self = this, r = nil;

      if ($truthy($$($nesting, 'Time')['$==='](other))) {
        return self.$to_f()['$<=>'](other.$to_f())
      } else {
        
        r = other['$<=>'](self);
        if ($truthy(r['$nil?']())) {
          return nil
        } else if ($truthy($rb_gt(r, 0))) {
          return -1
        } else if ($truthy($rb_lt(r, 0))) {
          return 1
        } else {
          return 0
        };
      }
    }, $Time_$lt_eq_gt$8.$$arity = 1);
    
    Opal.def(self, '$==', $Time_$eq_eq$9 = function(other) {
      var self = this, $ret_or_1 = nil;

      if ($truthy(($ret_or_1 = $$($nesting, 'Time')['$==='](other)))) {
        return self.$to_f() === other.$to_f()
      } else {
        return $ret_or_1
      }
    }, $Time_$eq_eq$9.$$arity = 1);
    
    Opal.def(self, '$asctime', $Time_asctime$10 = function $$asctime() {
      var self = this;

      return self.$strftime("%a %b %e %H:%M:%S %Y")
    }, $Time_asctime$10.$$arity = 0);
    $alias(self, "ctime", "asctime");
    
    Opal.def(self, '$day', $Time_day$11 = function $$day() {
      var self = this;

      return self.is_utc ? self.getUTCDate() : self.getDate();
    }, $Time_day$11.$$arity = 0);
    
    Opal.def(self, '$yday', $Time_yday$12 = function $$yday() {
      var self = this, start_of_year = nil, start_of_day = nil, one_day = nil;

      
      start_of_year = $$($nesting, 'Time').$new(self.$year()).$to_i();
      start_of_day = $$($nesting, 'Time').$new(self.$year(), self.$month(), self.$day()).$to_i();
      one_day = 86400;
      return $rb_plus($rb_divide($rb_minus(start_of_day, start_of_year), one_day).$round(), 1);
    }, $Time_yday$12.$$arity = 0);
    
    Opal.def(self, '$isdst', $Time_isdst$13 = function $$isdst() {
      var self = this;

      
      var jan = new Date(self.getFullYear(), 0, 1),
          jul = new Date(self.getFullYear(), 6, 1);
      return self.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
    
    }, $Time_isdst$13.$$arity = 0);
    $alias(self, "dst?", "isdst");
    
    Opal.def(self, '$dup', $Time_dup$14 = function $$dup() {
      var self = this, copy = nil;

      
      copy = new Date(self.getTime());
      copy.$copy_instance_variables(self);
      copy.$initialize_dup(self);
      return copy;
    }, $Time_dup$14.$$arity = 0);
    
    Opal.def(self, '$eql?', $Time_eql$ques$15 = function(other) {
      var self = this, $ret_or_2 = nil;

      if ($truthy(($ret_or_2 = other['$is_a?']($$($nesting, 'Time'))))) {
        return self['$<=>'](other)['$zero?']()
      } else {
        return $ret_or_2
      }
    }, $Time_eql$ques$15.$$arity = 1);
    
    Opal.def(self, '$friday?', $Time_friday$ques$16 = function() {
      var self = this;

      return self.$wday() == 5
    }, $Time_friday$ques$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Time_hash$17 = function $$hash() {
      var self = this;

      return 'Time:' + self.getTime();
    }, $Time_hash$17.$$arity = 0);
    
    Opal.def(self, '$hour', $Time_hour$18 = function $$hour() {
      var self = this;

      return self.is_utc ? self.getUTCHours() : self.getHours();
    }, $Time_hour$18.$$arity = 0);
    
    Opal.def(self, '$inspect', $Time_inspect$19 = function $$inspect() {
      var self = this;

      if ($truthy(self['$utc?']())) {
        return self.$strftime("%Y-%m-%d %H:%M:%S UTC")
      } else {
        return self.$strftime("%Y-%m-%d %H:%M:%S %z")
      }
    }, $Time_inspect$19.$$arity = 0);
    $alias(self, "mday", "day");
    
    Opal.def(self, '$min', $Time_min$20 = function $$min() {
      var self = this;

      return self.is_utc ? self.getUTCMinutes() : self.getMinutes();
    }, $Time_min$20.$$arity = 0);
    
    Opal.def(self, '$mon', $Time_mon$21 = function $$mon() {
      var self = this;

      return (self.is_utc ? self.getUTCMonth() : self.getMonth()) + 1;
    }, $Time_mon$21.$$arity = 0);
    
    Opal.def(self, '$monday?', $Time_monday$ques$22 = function() {
      var self = this;

      return self.$wday() == 1
    }, $Time_monday$ques$22.$$arity = 0);
    $alias(self, "month", "mon");
    
    Opal.def(self, '$saturday?', $Time_saturday$ques$23 = function() {
      var self = this;

      return self.$wday() == 6
    }, $Time_saturday$ques$23.$$arity = 0);
    
    Opal.def(self, '$sec', $Time_sec$24 = function $$sec() {
      var self = this;

      return self.is_utc ? self.getUTCSeconds() : self.getSeconds();
    }, $Time_sec$24.$$arity = 0);
    
    Opal.def(self, '$succ', $Time_succ$25 = function $$succ() {
      var self = this;

      
      var result = new Date(self.getTime() + 1000);
      result.is_utc = self.is_utc;
      return result;
    
    }, $Time_succ$25.$$arity = 0);
    
    Opal.def(self, '$usec', $Time_usec$26 = function $$usec() {
      var self = this;

      return self.getMilliseconds() * 1000;
    }, $Time_usec$26.$$arity = 0);
    
    Opal.def(self, '$zone', $Time_zone$27 = function $$zone() {
      var self = this;

      
      var string = self.toString(),
          result;

      if (string.indexOf('(') == -1) {
        result = string.match(/[A-Z]{3,4}/)[0];
      }
      else {
        result = string.match(/\((.+)\)(?:\s|$)/)[1]
      }

      if (result == "GMT" && /(GMT\W*\d{4})/.test(string)) {
        return RegExp.$1;
      }
      else {
        return result;
      }
    
    }, $Time_zone$27.$$arity = 0);
    
    Opal.def(self, '$getgm', $Time_getgm$28 = function $$getgm() {
      var self = this;

      
      var result = new Date(self.getTime());
      result.is_utc = true;
      return result;
    
    }, $Time_getgm$28.$$arity = 0);
    $alias(self, "getutc", "getgm");
    
    Opal.def(self, '$gmtime', $Time_gmtime$29 = function $$gmtime() {
      var self = this;

      
      self.is_utc = true;
      return self;
    
    }, $Time_gmtime$29.$$arity = 0);
    $alias(self, "utc", "gmtime");
    
    Opal.def(self, '$gmt?', $Time_gmt$ques$30 = function() {
      var self = this;

      return self.is_utc === true;
    }, $Time_gmt$ques$30.$$arity = 0);
    
    Opal.def(self, '$gmt_offset', $Time_gmt_offset$31 = function $$gmt_offset() {
      var self = this;

      return self.is_utc ? 0 : -self.getTimezoneOffset() * 60;
    }, $Time_gmt_offset$31.$$arity = 0);
    
    Opal.def(self, '$strftime', $Time_strftime$32 = function $$strftime(format) {
      var self = this;

      
      return format.replace(/%([\-_#^0]*:{0,2})(\d+)?([EO]*)(.)/g, function(full, flags, width, _, conv) {
        var result = "",
            zero   = flags.indexOf('0') !== -1,
            pad    = flags.indexOf('-') === -1,
            blank  = flags.indexOf('_') !== -1,
            upcase = flags.indexOf('^') !== -1,
            invert = flags.indexOf('#') !== -1,
            colons = (flags.match(':') || []).length;

        width = parseInt(width, 10);

        if (zero && blank) {
          if (flags.indexOf('0') < flags.indexOf('_')) {
            zero = false;
          }
          else {
            blank = false;
          }
        }

        switch (conv) {
          case 'Y':
            result += self.$year();
            break;

          case 'C':
            zero    = !blank;
            result += Math.round(self.$year() / 100);
            break;

          case 'y':
            zero    = !blank;
            result += (self.$year() % 100);
            break;

          case 'm':
            zero    = !blank;
            result += self.$mon();
            break;

          case 'B':
            result += long_months[self.$mon() - 1];
            break;

          case 'b':
          case 'h':
            blank   = !zero;
            result += short_months[self.$mon() - 1];
            break;

          case 'd':
            zero    = !blank
            result += self.$day();
            break;

          case 'e':
            blank   = !zero
            result += self.$day();
            break;

          case 'j':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.$yday();
            break;

          case 'H':
            zero    = !blank;
            result += self.$hour();
            break;

          case 'k':
            blank   = !zero;
            result += self.$hour();
            break;

          case 'I':
            zero    = !blank;
            result += (self.$hour() % 12 || 12);
            break;

          case 'l':
            blank   = !zero;
            result += (self.$hour() % 12 || 12);
            break;

          case 'P':
            result += (self.$hour() >= 12 ? "pm" : "am");
            break;

          case 'p':
            result += (self.$hour() >= 12 ? "PM" : "AM");
            break;

          case 'M':
            zero    = !blank;
            result += self.$min();
            break;

          case 'S':
            zero    = !blank;
            result += self.$sec()
            break;

          case 'L':
            zero    = !blank;
            width   = isNaN(width) ? 3 : width;
            result += self.getMilliseconds();
            break;

          case 'N':
            width   = isNaN(width) ? 9 : width;
            result += (self.getMilliseconds().toString()).$rjust(3, "0");
            result  = (result).$ljust(width, "0");
            break;

          case 'z':
            var offset  = self.getTimezoneOffset(),
                hours   = Math.floor(Math.abs(offset) / 60),
                minutes = Math.abs(offset) % 60;

            result += offset < 0 ? "+" : "-";
            result += hours < 10 ? "0" : "";
            result += hours;

            if (colons > 0) {
              result += ":";
            }

            result += minutes < 10 ? "0" : "";
            result += minutes;

            if (colons > 1) {
              result += ":00";
            }

            break;

          case 'Z':
            result += self.$zone();
            break;

          case 'A':
            result += days_of_week[self.$wday()];
            break;

          case 'a':
            result += short_days[self.$wday()];
            break;

          case 'u':
            result += (self.$wday() + 1);
            break;

          case 'w':
            result += self.$wday();
            break;

          case 'V':
            result += self.$cweek_cyear()['$[]'](0).$to_s().$rjust(2, "0");
            break;

          case 'G':
            result += self.$cweek_cyear()['$[]'](1);
            break;

          case 'g':
            result += self.$cweek_cyear()['$[]'](1)['$[]']($range(-2, -1, false));
            break;

          case 's':
            result += self.$to_i();
            break;

          case 'n':
            result += "\n";
            break;

          case 't':
            result += "\t";
            break;

          case '%':
            result += "%";
            break;

          case 'c':
            result += self.$strftime("%a %b %e %T %Y");
            break;

          case 'D':
          case 'x':
            result += self.$strftime("%m/%d/%y");
            break;

          case 'F':
            result += self.$strftime("%Y-%m-%d");
            break;

          case 'v':
            result += self.$strftime("%e-%^b-%4Y");
            break;

          case 'r':
            result += self.$strftime("%I:%M:%S %p");
            break;

          case 'R':
            result += self.$strftime("%H:%M");
            break;

          case 'T':
          case 'X':
            result += self.$strftime("%H:%M:%S");
            break;

          default:
            return full;
        }

        if (upcase) {
          result = result.toUpperCase();
        }

        if (invert) {
          result = result.replace(/[A-Z]/, function(c) { c.toLowerCase() }).
                          replace(/[a-z]/, function(c) { c.toUpperCase() });
        }

        if (pad && (zero || blank)) {
          result = (result).$rjust(isNaN(width) ? 2 : width, blank ? " " : "0");
        }

        return result;
      });
    
    }, $Time_strftime$32.$$arity = 1);
    
    Opal.def(self, '$sunday?', $Time_sunday$ques$33 = function() {
      var self = this;

      return self.$wday() == 0
    }, $Time_sunday$ques$33.$$arity = 0);
    
    Opal.def(self, '$thursday?', $Time_thursday$ques$34 = function() {
      var self = this;

      return self.$wday() == 4
    }, $Time_thursday$ques$34.$$arity = 0);
    
    Opal.def(self, '$to_a', $Time_to_a$35 = function $$to_a() {
      var self = this;

      return [self.$sec(), self.$min(), self.$hour(), self.$day(), self.$month(), self.$year(), self.$wday(), self.$yday(), self.$isdst(), self.$zone()]
    }, $Time_to_a$35.$$arity = 0);
    
    Opal.def(self, '$to_f', $Time_to_f$36 = function $$to_f() {
      var self = this;

      return self.getTime() / 1000;
    }, $Time_to_f$36.$$arity = 0);
    
    Opal.def(self, '$to_i', $Time_to_i$37 = function $$to_i() {
      var self = this;

      return parseInt(self.getTime() / 1000, 10);
    }, $Time_to_i$37.$$arity = 0);
    $alias(self, "to_s", "inspect");
    
    Opal.def(self, '$tuesday?', $Time_tuesday$ques$38 = function() {
      var self = this;

      return self.$wday() == 2
    }, $Time_tuesday$ques$38.$$arity = 0);
    $alias(self, "tv_sec", "to_i");
    $alias(self, "tv_usec", "usec");
    $alias(self, "utc?", "gmt?");
    $alias(self, "gmtoff", "gmt_offset");
    $alias(self, "utc_offset", "gmt_offset");
    
    Opal.def(self, '$wday', $Time_wday$39 = function $$wday() {
      var self = this;

      return self.is_utc ? self.getUTCDay() : self.getDay();
    }, $Time_wday$39.$$arity = 0);
    
    Opal.def(self, '$wednesday?', $Time_wednesday$ques$40 = function() {
      var self = this;

      return self.$wday() == 3
    }, $Time_wednesday$ques$40.$$arity = 0);
    
    Opal.def(self, '$year', $Time_year$41 = function $$year() {
      var self = this;

      return self.is_utc ? self.getUTCFullYear() : self.getFullYear();
    }, $Time_year$41.$$arity = 0);
    return (Opal.def(self, '$cweek_cyear', $Time_cweek_cyear$42 = function $$cweek_cyear() {
      var self = this, jan01 = nil, jan01_wday = nil, first_monday = nil, year = nil, $ret_or_3 = nil, offset = nil, week = nil, dec31 = nil, dec31_wday = nil, $ret_or_4 = nil;

      
      jan01 = $$($nesting, 'Time').$new(self.$year(), 1, 1);
      jan01_wday = jan01.$wday();
      first_monday = 0;
      year = self.$year();
      if ($truthy((function() {if ($truthy(($ret_or_3 = $rb_le(jan01_wday, 4)))) {
        return jan01_wday['$!='](0)
      } else {
        return $ret_or_3
      }; return nil; })())) {
        offset = $rb_minus(jan01_wday, 1)
      } else {
        
        offset = $rb_minus($rb_minus(jan01_wday, 7), 1);
        if (offset['$=='](-8)) {
          offset = -1};
      };
      week = $rb_divide($rb_plus(self.$yday(), offset), 7.0).$ceil();
      if ($truthy($rb_le(week, 0))) {
        return $$($nesting, 'Time').$new($rb_minus(self.$year(), 1), 12, 31).$cweek_cyear()
      } else if (week['$=='](53)) {
        
        dec31 = $$($nesting, 'Time').$new(self.$year(), 12, 31);
        dec31_wday = dec31.$wday();
        if ($truthy((function() {if ($truthy(($ret_or_4 = $rb_le(dec31_wday, 3)))) {
          return dec31_wday['$!='](0)
        } else {
          return $ret_or_4
        }; return nil; })())) {
          
          week = 1;
          year = $rb_plus(year, 1);};};
      return [week, year];
    }, $Time_cweek_cyear$42.$$arity = 0), nil) && 'cweek_cyear';
  })($nesting[0], Date, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/struct"] = function(Opal) {
  function $rb_gt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs > rhs : lhs['$>'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_lt(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs < rhs : lhs['$<'](rhs);
  }
  function $rb_ge(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs >= rhs : lhs['$>='](rhs);
  }
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $hash2 = Opal.hash2, $truthy = Opal.truthy, $send = Opal.send, $alias = Opal.alias;

  Opal.add_stubs(['$require', '$include', '$==', '$class', '$!=', '$upcase', '$[]', '$unshift', '$const_name!', '$map', '$coerce_to!', '$new', '$each', '$define_struct_attribute', '$allocate', '$initialize', '$alias_method', '$module_eval', '$to_proc', '$const_set', '$raise', '$<<', '$members', '$define_method', '$instance_eval', '$last', '$>', '$length', '$-', '$keys', '$any?', '$join', '$[]=', '$each_with_index', '$hash', '$===', '$<', '$-@', '$size', '$>=', '$include?', '$to_sym', '$instance_of?', '$__id__', '$eql?', '$enum_for', '$name', '$+', '$each_pair', '$inspect', '$to_h', '$args', '$each_with_object', '$flatten', '$to_a', '$respond_to?', '$dig']);
  
  self.$require("corelib/enumerable");
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Struct');

    var $nesting = [self].concat($parent_nesting), $Struct_new$1, $Struct_define_struct_attribute$6, $Struct_members$9, $Struct_inherited$10, $Struct_initialize$12, $Struct_initialize_copy$15, $Struct_members$16, $Struct_hash$17, $Struct_$$$18, $Struct_$$$eq$19, $Struct_$eq_eq$20, $Struct_eql$ques$21, $Struct_each$22, $Struct_each_pair$25, $Struct_length$28, $Struct_to_a$29, $Struct_inspect$31, $Struct_to_h$33, $Struct_values_at$35, $Struct_dig$37;

    
    self.$include($$($nesting, 'Enumerable'));
    Opal.defs(self, '$new', $Struct_new$1 = function(const_name, $a, $b) {
      var $iter = $Struct_new$1.$$p, block = $iter || nil, $post_args, $kwargs, args, keyword_init, $$2, $$3, self = this, $ret_or_1 = nil, klass = nil;

      if ($iter) $Struct_new$1.$$p = null;
      
      
      if ($iter) $Struct_new$1.$$p = null;;
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      $kwargs = Opal.extract_kwargs($post_args);
      
      if ($kwargs == null) {
        $kwargs = $hash2([], {});
      } else if (!$kwargs.$$is_hash) {
        throw Opal.ArgumentError.$new('expected kwargs');
      };
      
      args = $post_args;;
      
      keyword_init = $kwargs.$$smap["keyword_init"];
      if (keyword_init == null) {
        keyword_init = false
      };
      if ($truthy(const_name)) {
        if ($truthy((function() {if ($truthy(($ret_or_1 = const_name.$class()['$==']($$($nesting, 'String'))))) {
          return const_name['$[]'](0).$upcase()['$!='](const_name['$[]'](0))
        } else {
          return $ret_or_1
        }; return nil; })())) {
          
          args.$unshift(const_name);
          const_name = nil;
        } else {
          
          try {
            const_name = $$($nesting, 'Opal')['$const_name!'](const_name)
          } catch ($err) {
            if (Opal.rescue($err, [$$($nesting, 'TypeError'), $$($nesting, 'NameError')])) {
              try {
                
                args.$unshift(const_name);
                const_name = nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          };
        }};
      $send(args, 'map', [], ($$2 = function(arg){var self = $$2.$$s == null ? this : $$2.$$s;

        
        
        if (arg == null) {
          arg = nil;
        };
        return $$($nesting, 'Opal')['$coerce_to!'](arg, $$($nesting, 'String'), "to_str");}, $$2.$$s = self, $$2.$$arity = 1, $$2));
      klass = $send($$($nesting, 'Class'), 'new', [self], ($$3 = function(){var self = $$3.$$s == null ? this : $$3.$$s, $$4;

        
        $send(args, 'each', [], ($$4 = function(arg){var self = $$4.$$s == null ? this : $$4.$$s;

          
          
          if (arg == null) {
            arg = nil;
          };
          return self.$define_struct_attribute(arg);}, $$4.$$s = self, $$4.$$arity = 1, $$4));
        return (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $new$5;

          
          
          Opal.def(self, '$new', $new$5 = function($a) {
            var $post_args, args, self = this, instance = nil;

            
            
            $post_args = Opal.slice.call(arguments, 0, arguments.length);
            
            args = $post_args;;
            instance = self.$allocate();
            instance.$$data = {};
            $send(instance, 'initialize', Opal.to_a(args));
            return instance;
          }, $new$5.$$arity = -1);
          return self.$alias_method("[]", "new");
        })(Opal.get_singleton_class(self), $nesting);}, $$3.$$s = self, $$3.$$arity = 0, $$3));
      if ($truthy(block)) {
        $send(klass, 'module_eval', [], block.$to_proc())};
      klass.$$keyword_init = keyword_init;
      if ($truthy(const_name)) {
        $$($nesting, 'Struct').$const_set(const_name, klass)};
      return klass;
    }, $Struct_new$1.$$arity = -2);
    Opal.defs(self, '$define_struct_attribute', $Struct_define_struct_attribute$6 = function $$define_struct_attribute(name) {
      var $$7, $$8, self = this;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "you cannot define attributes to the Struct class")};
      self.$members()['$<<'](name);
      $send(self, 'define_method', [name], ($$7 = function(){var self = $$7.$$s == null ? this : $$7.$$s;

        return self.$$data[name];}, $$7.$$s = self, $$7.$$arity = 0, $$7));
      return $send(self, 'define_method', ["" + (name) + "="], ($$8 = function(value){var self = $$8.$$s == null ? this : $$8.$$s;

        
        
        if (value == null) {
          value = nil;
        };
        return self.$$data[name] = value;;}, $$8.$$s = self, $$8.$$arity = 1, $$8));
    }, $Struct_define_struct_attribute$6.$$arity = 1);
    Opal.defs(self, '$members', $Struct_members$9 = function $$members() {
      var self = this, $ret_or_2 = nil;
      if (self.members == null) self.members = nil;

      
      if (self['$==']($$($nesting, 'Struct'))) {
        self.$raise($$($nesting, 'ArgumentError'), "the Struct class has no members")};
      return (self.members = (function() {if ($truthy(($ret_or_2 = self.members))) {
        return $ret_or_2
      } else {
        return []
      }; return nil; })());
    }, $Struct_members$9.$$arity = 0);
    Opal.defs(self, '$inherited', $Struct_inherited$10 = function $$inherited(klass) {
      var $$11, self = this, members = nil;
      if (self.members == null) self.members = nil;

      
      members = self.members;
      return $send(klass, 'instance_eval', [], ($$11 = function(){var self = $$11.$$s == null ? this : $$11.$$s;

        return (self.members = members)}, $$11.$$s = self, $$11.$$arity = 0, $$11));
    }, $Struct_inherited$10.$$arity = 1);
    
    Opal.def(self, '$initialize', $Struct_initialize$12 = function $$initialize($a) {
      var $post_args, args, $$13, $$14, self = this, kwargs = nil, $ret_or_3 = nil, $ret_or_4 = nil, extra = nil;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      if ($truthy(self.$class().$$keyword_init)) {
        
        kwargs = (function() {if ($truthy(($ret_or_3 = args.$last()))) {
          return $ret_or_3
        } else {
          return $hash2([], {})
        }; return nil; })();
        if ($truthy((function() {if ($truthy(($ret_or_4 = $rb_gt(args.$length(), 1)))) {
          return $ret_or_4
        } else {
          return (args.length === 1 && !kwargs.$$is_hash);
        }; return nil; })())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "wrong number of arguments (given " + (args.$length()) + ", expected 0)")};
        extra = $rb_minus(kwargs.$keys(), self.$class().$members());
        if ($truthy(extra['$any?']())) {
          self.$raise($$($nesting, 'ArgumentError'), "" + "unknown keywords: " + (extra.$join(", ")))};
        return $send(self.$class().$members(), 'each', [], ($$13 = function(name){var self = $$13.$$s == null ? this : $$13.$$s, $writer = nil;

          
          
          if (name == null) {
            name = nil;
          };
          $writer = [name, kwargs['$[]'](name)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$13.$$s = self, $$13.$$arity = 1, $$13));
      } else {
        
        if ($truthy($rb_gt(args.$length(), self.$class().$members().$length()))) {
          self.$raise($$($nesting, 'ArgumentError'), "struct size differs")};
        return $send(self.$class().$members(), 'each_with_index', [], ($$14 = function(name, index){var self = $$14.$$s == null ? this : $$14.$$s, $writer = nil;

          
          
          if (name == null) {
            name = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          $writer = [name, args['$[]'](index)];
          $send(self, '[]=', Opal.to_a($writer));
          return $writer[$rb_minus($writer["length"], 1)];}, $$14.$$s = self, $$14.$$arity = 2, $$14));
      };
    }, $Struct_initialize$12.$$arity = -1);
    
    Opal.def(self, '$initialize_copy', $Struct_initialize_copy$15 = function $$initialize_copy(from) {
      var self = this;

      
      self.$$data = {}
      var keys = Object.keys(from.$$data), i, max, name;
      for (i = 0, max = keys.length; i < max; i++) {
        name = keys[i];
        self.$$data[name] = from.$$data[name];
      }
    
    }, $Struct_initialize_copy$15.$$arity = 1);
    
    Opal.def(self, '$members', $Struct_members$16 = function $$members() {
      var self = this;

      return self.$class().$members()
    }, $Struct_members$16.$$arity = 0);
    
    Opal.def(self, '$hash', $Struct_hash$17 = function $$hash() {
      var self = this;

      return $$($nesting, 'Hash').$new(self.$$data).$hash()
    }, $Struct_hash$17.$$arity = 0);
    
    Opal.def(self, '$[]', $Struct_$$$18 = function(name) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        
        if(!self.$$data.hasOwnProperty(name)) {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name];;
    }, $Struct_$$$18.$$arity = 1);
    
    Opal.def(self, '$[]=', $Struct_$$$eq$19 = function(name, value) {
      var self = this;

      
      if ($truthy($$($nesting, 'Integer')['$==='](name))) {
        
        if ($truthy($rb_lt(name, self.$class().$members().$size()['$-@']()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too small for struct(size:" + (self.$class().$members().$size()) + ")")};
        if ($truthy($rb_ge(name, self.$class().$members().$size()))) {
          self.$raise($$($nesting, 'IndexError'), "" + "offset " + (name) + " too large for struct(size:" + (self.$class().$members().$size()) + ")")};
        name = self.$class().$members()['$[]'](name);
      } else if ($truthy($$($nesting, 'String')['$==='](name))) {
        if ($truthy(self.$class().$members()['$include?'](name.$to_sym()))) {
        } else {
          self.$raise($$($nesting, 'NameError').$new("" + "no member '" + (name) + "' in struct", name))
        }
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + (name.$class()) + " into Integer")
      };
      name = $$($nesting, 'Opal')['$coerce_to!'](name, $$($nesting, 'String'), "to_str");
      return self.$$data[name] = value;;
    }, $Struct_$$$eq$19.$$arity = 2);
    
    Opal.def(self, '$==', $Struct_$eq_eq$20 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$=='](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_$eq_eq$20.$$arity = 1);
    
    Opal.def(self, '$eql?', $Struct_eql$ques$21 = function(other) {
      var self = this;

      
      if ($truthy(other['$instance_of?'](self.$class()))) {
      } else {
        return false
      };
      
      var recursed1 = {}, recursed2 = {};

      function _eqeq(struct, other) {
        var key, a, b;

        recursed1[(struct).$__id__()] = true;
        recursed2[(other).$__id__()] = true;

        for (key in struct.$$data) {
          a = struct.$$data[key];
          b = other.$$data[key];

          if ($$($nesting, 'Struct')['$==='](a)) {
            if (!recursed1.hasOwnProperty((a).$__id__()) || !recursed2.hasOwnProperty((b).$__id__())) {
              if (!_eqeq(a, b)) {
                return false;
              }
            }
          } else {
            if (!(a)['$eql?'](b)) {
              return false;
            }
          }
        }

        return true;
      }

      return _eqeq(self, other);
    ;
    }, $Struct_eql$ques$21.$$arity = 1);
    
    Opal.def(self, '$each', $Struct_each$22 = function $$each() {
      var $$23, $$24, $iter = $Struct_each$22.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each$22.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each"], ($$23 = function(){var self = $$23.$$s == null ? this : $$23.$$s;

          return self.$size()}, $$23.$$s = self, $$23.$$arity = 0, $$23))
      };
      $send(self.$class().$members(), 'each', [], ($$24 = function(name){var self = $$24.$$s == null ? this : $$24.$$s;

        
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, self['$[]'](name));;}, $$24.$$s = self, $$24.$$arity = 1, $$24));
      return self;
    }, $Struct_each$22.$$arity = 0);
    
    Opal.def(self, '$each_pair', $Struct_each_pair$25 = function $$each_pair() {
      var $$26, $$27, $iter = $Struct_each_pair$25.$$p, $yield = $iter || nil, self = this;

      if ($iter) $Struct_each_pair$25.$$p = null;
      
      if (($yield !== nil)) {
      } else {
        return $send(self, 'enum_for', ["each_pair"], ($$26 = function(){var self = $$26.$$s == null ? this : $$26.$$s;

          return self.$size()}, $$26.$$s = self, $$26.$$arity = 0, $$26))
      };
      $send(self.$class().$members(), 'each', [], ($$27 = function(name){var self = $$27.$$s == null ? this : $$27.$$s;

        
        
        if (name == null) {
          name = nil;
        };
        return Opal.yield1($yield, [name, self['$[]'](name)]);;}, $$27.$$s = self, $$27.$$arity = 1, $$27));
      return self;
    }, $Struct_each_pair$25.$$arity = 0);
    
    Opal.def(self, '$length', $Struct_length$28 = function $$length() {
      var self = this;

      return self.$class().$members().$length()
    }, $Struct_length$28.$$arity = 0);
    $alias(self, "size", "length");
    
    Opal.def(self, '$to_a', $Struct_to_a$29 = function $$to_a() {
      var $$30, self = this;

      return $send(self.$class().$members(), 'map', [], ($$30 = function(name){var self = $$30.$$s == null ? this : $$30.$$s;

        
        
        if (name == null) {
          name = nil;
        };
        return self['$[]'](name);}, $$30.$$s = self, $$30.$$arity = 1, $$30))
    }, $Struct_to_a$29.$$arity = 0);
    $alias(self, "values", "to_a");
    
    Opal.def(self, '$inspect', $Struct_inspect$31 = function $$inspect() {
      var $$32, self = this, result = nil, $ret_or_5 = nil;

      
      result = "#<struct ";
      if ($truthy((function() {if ($truthy(($ret_or_5 = $$($nesting, 'Struct')['$==='](self)))) {
        return self.$class().$name()
      } else {
        return $ret_or_5
      }; return nil; })())) {
        result = $rb_plus(result, "" + (self.$class()) + " ")};
      result = $rb_plus(result, $send(self.$each_pair(), 'map', [], ($$32 = function(name, value){var self = $$32.$$s == null ? this : $$32.$$s;

        
        
        if (name == null) {
          name = nil;
        };
        
        if (value == null) {
          value = nil;
        };
        return "" + (name) + "=" + (value.$inspect());}, $$32.$$s = self, $$32.$$arity = 2, $$32)).$join(", "));
      result = $rb_plus(result, ">");
      return result;
    }, $Struct_inspect$31.$$arity = 0);
    $alias(self, "to_s", "inspect");
    
    Opal.def(self, '$to_h', $Struct_to_h$33 = function $$to_h() {
      var $iter = $Struct_to_h$33.$$p, block = $iter || nil, $$34, self = this;

      if ($iter) $Struct_to_h$33.$$p = null;
      
      
      if ($iter) $Struct_to_h$33.$$p = null;;
      if ((block !== nil)) {
        return $send($send(self, 'map', [], block.$to_proc()), 'to_h', Opal.to_a(self.$args()))};
      return $send(self.$class().$members(), 'each_with_object', [$hash2([], {})], ($$34 = function(name, h){var self = $$34.$$s == null ? this : $$34.$$s, $writer = nil;

        
        
        if (name == null) {
          name = nil;
        };
        
        if (h == null) {
          h = nil;
        };
        $writer = [name, self['$[]'](name)];
        $send(h, '[]=', Opal.to_a($writer));
        return $writer[$rb_minus($writer["length"], 1)];}, $$34.$$s = self, $$34.$$arity = 2, $$34));
    }, $Struct_to_h$33.$$arity = 0);
    
    Opal.def(self, '$values_at', $Struct_values_at$35 = function $$values_at($a) {
      var $post_args, args, $$36, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      args = $post_args;;
      args = $send(args, 'map', [], ($$36 = function(arg){var self = $$36.$$s == null ? this : $$36.$$s;

        
        
        if (arg == null) {
          arg = nil;
        };
        return arg.$$is_range ? arg.$to_a() : arg;}, $$36.$$s = self, $$36.$$arity = 1, $$36)).$flatten();
      
      var result = [];
      for (var i = 0, len = args.length; i < len; i++) {
        if (!args[i].$$is_number) {
          self.$raise($$($nesting, 'TypeError'), "" + "no implicit conversion of " + ((args[i]).$class()) + " into Integer")
        }
        result.push(self['$[]'](args[i]));
      }
      return result;
    ;
    }, $Struct_values_at$35.$$arity = -1);
    return (Opal.def(self, '$dig', $Struct_dig$37 = function $$dig(key, $a) {
      var $post_args, keys, self = this, item = nil;

      
      
      $post_args = Opal.slice.call(arguments, 1, arguments.length);
      
      keys = $post_args;;
      item = (function() {if ($truthy(key.$$is_string && self.$$data.hasOwnProperty(key))) {
        return self.$$data[key] || nil;
      } else {
        return nil
      }; return nil; })();
      
      if (item === nil || keys.length === 0) {
        return item;
      }
    ;
      if ($truthy(item['$respond_to?']("dig"))) {
      } else {
        self.$raise($$($nesting, 'TypeError'), "" + (item.$class()) + " does not have #dig method")
      };
      return $send(item, 'dig', Opal.to_a(keys));
    }, $Struct_dig$37.$$arity = -2), nil) && 'dig';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/main"] = function(Opal) {
  var $to_s$1, $include$2, $using$3, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$include', '$raise']);
  
  Opal.defs(self, '$to_s', $to_s$1 = function $$to_s() {
    var self = this;

    return "main"
  }, $to_s$1.$$arity = 0);
  Opal.defs(self, '$include', $include$2 = function $$include(mod) {
    var self = this;

    return $$($nesting, 'Object').$include(mod)
  }, $include$2.$$arity = 1);
  return (Opal.defs(self, '$using', $using$3 = function $$using(mod) {
    var self = this;

    return self.$raise("main.using is permitted only at toplevel")
  }, $using$3.$$arity = 1), nil) && 'using';
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/dir"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $alias = Opal.alias, $truthy = Opal.truthy;

  Opal.add_stubs(['$[]']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Dir');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $chdir$1, $pwd$2, $home$3;

      
      
      Opal.def(self, '$chdir', $chdir$1 = function $$chdir(dir) {
        var $iter = $chdir$1.$$p, $yield = $iter || nil, self = this, prev_cwd = nil;

        if ($iter) $chdir$1.$$p = null;
        return (function() { try {
        
        prev_cwd = Opal.current_dir;
        Opal.current_dir = dir;
        return Opal.yieldX($yield, []);;
        } finally {
          Opal.current_dir = prev_cwd
        }; })()
      }, $chdir$1.$$arity = 1);
      
      Opal.def(self, '$pwd', $pwd$2 = function $$pwd() {
        var self = this;

        return Opal.current_dir || '.';
      }, $pwd$2.$$arity = 0);
      $alias(self, "getwd", "pwd");
      return (Opal.def(self, '$home', $home$3 = function $$home() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = $$($nesting, 'ENV')['$[]']("HOME")))) {
          return $ret_or_1
        } else {
          return "."
        }
      }, $home$3.$$arity = 0), nil) && 'home';
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/file"] = function(Opal) {
  function $rb_plus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs + rhs : lhs['$+'](rhs);
  }
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $klass = Opal.klass, $alias = Opal.alias, $range = Opal.range, $send = Opal.send;

  Opal.add_stubs(['$respond_to?', '$to_path', '$pwd', '$split', '$sub', '$+', '$unshift', '$join', '$home', '$raise', '$start_with?', '$absolute_path', '$coerce_to!', '$basename', '$empty?', '$rindex', '$[]', '$nil?', '$==', '$-', '$length', '$gsub', '$find', '$=~', '$map', '$each_with_index', '$flatten', '$reject', '$to_proc', '$end_with?']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), windows_root_rx = nil;

    
    Opal.const_set($nesting[0], 'Separator', Opal.const_set($nesting[0], 'SEPARATOR', "/"));
    Opal.const_set($nesting[0], 'ALT_SEPARATOR', nil);
    Opal.const_set($nesting[0], 'PATH_SEPARATOR', ":");
    Opal.const_set($nesting[0], 'FNM_SYSCASE', 0);
    windows_root_rx = /^[a-zA-Z]:(?:\\|\/)/;
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $absolute_path$1, $expand_path$2, $dirname$3, $basename$4, $extname$5, $exist$ques$6, $directory$ques$7, $join$9, $split$12;

      
      
      Opal.def(self, '$absolute_path', $absolute_path$1 = function $$absolute_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, new_parts = nil, $ret_or_1 = nil, path_abs = nil, basedir_abs = nil, parts = nil, leading_sep = nil, abs = nil, new_path = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        new_parts = [];
        path = (function() {if ($truthy(path['$respond_to?']("to_path"))) {
          return path.$to_path()
        } else {
          return path
        }; return nil; })();
        basedir = (function() {if ($truthy(($ret_or_1 = basedir))) {
          return $ret_or_1
        } else {
          return $$($nesting, 'Dir').$pwd()
        }; return nil; })();
        path_abs = path.substr(0, sep.length) === sep || windows_root_rx.test(path);
        basedir_abs = basedir.substr(0, sep.length) === sep || windows_root_rx.test(basedir);
        if ($truthy(path_abs)) {
          
          parts = path.$split(Opal.regexp(["[", sep_chars, "]"]));
          leading_sep = windows_root_rx.test(path) ? '' : path.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = true;
        } else {
          
          parts = $rb_plus(basedir.$split(Opal.regexp(["[", sep_chars, "]"])), path.$split(Opal.regexp(["[", sep_chars, "]"])));
          leading_sep = windows_root_rx.test(basedir) ? '' : basedir.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          abs = basedir_abs;
        };
        
        var part;
        for (var i = 0, ii = parts.length; i < ii; i++) {
          part = parts[i];

          if (
            (part === nil) ||
            (part === ''  && ((new_parts.length === 0) || abs)) ||
            (part === '.' && ((new_parts.length === 0) || abs))
          ) {
            continue;
          }
          if (part === '..') {
            new_parts.pop();
          } else {
            new_parts.push(part);
          }
        }

        if (!abs && parts[0] !== '.') {
          new_parts.$unshift(".")
        }
      ;
        new_path = new_parts.$join(sep);
        if ($truthy(abs)) {
          new_path = $rb_plus(leading_sep, new_path)};
        return new_path;
      }, $absolute_path$1.$$arity = -2);
      
      Opal.def(self, '$expand_path', $expand_path$2 = function $$expand_path(path, basedir) {
        var self = this, sep = nil, sep_chars = nil, home = nil, leading_sep = nil, home_path_regexp = nil;

        
        
        if (basedir == null) {
          basedir = nil;
        };
        sep = $$($nesting, 'SEPARATOR');
        sep_chars = $sep_chars();
        if ($truthy(path[0] === '~' || (basedir && basedir[0] === '~'))) {
          
          home = $$($nesting, 'Dir').$home();
          if ($truthy(home)) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "couldn't find HOME environment -- expanding `~'")
          };
          leading_sep = windows_root_rx.test(home) ? '' : home.$sub(Opal.regexp(["^([", sep_chars, "]+).*$"]), "\\1");
          if ($truthy(home['$start_with?'](leading_sep))) {
          } else {
            self.$raise($$($nesting, 'ArgumentError'), "non-absolute home")
          };
          home = $rb_plus(home, sep);
          home_path_regexp = Opal.regexp(["^\\~(?:", sep, "|$)"]);
          path = path.$sub(home_path_regexp, home);
          if ($truthy(basedir)) {
            basedir = basedir.$sub(home_path_regexp, home)};};
        return self.$absolute_path(path, basedir);
      }, $expand_path$2.$$arity = -2);
      $alias(self, "realpath", "expand_path");
      
      // Coerce a given path to a path string using #to_path and #to_str
      function $coerce_to_path(path) {
        if ($truthy((path)['$respond_to?']("to_path"))) {
          path = path.$to_path();
        }

        path = $$($nesting, 'Opal')['$coerce_to!'](path, $$($nesting, 'String'), "to_str");

        return path;
      }

      // Return a RegExp compatible char class
      function $sep_chars() {
        if ($$($nesting, 'ALT_SEPARATOR') === nil) {
          return Opal.escape_regexp($$($nesting, 'SEPARATOR'));
        } else {
          return Opal.escape_regexp($rb_plus($$($nesting, 'SEPARATOR'), $$($nesting, 'ALT_SEPARATOR')));
        }
      }
    ;
      
      Opal.def(self, '$dirname', $dirname$3 = function $$dirname(path) {
        var self = this, sep_chars = nil;

        
        sep_chars = $sep_chars();
        path = $coerce_to_path(path);
        
        var absolute = path.match(new RegExp("" + "^[" + (sep_chars) + "]"));

        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove trailing separators
        path = path.replace(new RegExp("" + "[^" + (sep_chars) + "]+$"), ''); // remove trailing basename
        path = path.replace(new RegExp("" + "[" + (sep_chars) + "]+$"), ''); // remove final trailing separators

        if (path === '') {
          return absolute ? '/' : '.';
        }

        return path;
      ;
      }, $dirname$3.$$arity = 1);
      
      Opal.def(self, '$basename', $basename$4 = function $$basename(name, suffix) {
        var self = this, sep_chars = nil;

        
        
        if (suffix == null) {
          suffix = nil;
        };
        sep_chars = $sep_chars();
        name = $coerce_to_path(name);
        
        if (name.length == 0) {
          return name;
        }

        if (suffix !== nil) {
          suffix = $$($nesting, 'Opal')['$coerce_to!'](suffix, $$($nesting, 'String'), "to_str")
        } else {
          suffix = null;
        }

        name = name.replace(new RegExp("" + "(.)[" + (sep_chars) + "]*$"), '$1');
        name = name.replace(new RegExp("" + "^(?:.*[" + (sep_chars) + "])?([^" + (sep_chars) + "]+)$"), '$1');

        if (suffix === ".*") {
          name = name.replace(/\.[^\.]+$/, '');
        } else if(suffix !== null) {
          suffix = Opal.escape_regexp(suffix);
          name = name.replace(new RegExp("" + (suffix) + "$"), '');
        }

        return name;
      ;
      }, $basename$4.$$arity = -2);
      
      Opal.def(self, '$extname', $extname$5 = function $$extname(path) {
        var self = this, filename = nil, last_dot_idx = nil, $ret_or_2 = nil;

        
        path = $coerce_to_path(path);
        filename = self.$basename(path);
        if ($truthy(filename['$empty?']())) {
          return ""};
        last_dot_idx = filename['$[]']($range(1, -1, false)).$rindex(".");
        if ($truthy((function() {if ($truthy(($ret_or_2 = last_dot_idx['$nil?']()))) {
          return $ret_or_2
        } else {
          return $rb_plus(last_dot_idx, 1)['$==']($rb_minus(filename.$length(), 1))
        }; return nil; })())) {
          return ""
        } else {
          return filename['$[]'](Opal.Range.$new($rb_plus(last_dot_idx, 1), -1, false))
        };
      }, $extname$5.$$arity = 1);
      
      Opal.def(self, '$exist?', $exist$ques$6 = function(path) {
        var self = this;

        return Opal.modules[path] != null
      }, $exist$ques$6.$$arity = 1);
      $alias(self, "exists?", "exist?");
      
      Opal.def(self, '$directory?', $directory$ques$7 = function(path) {
        var $$8, self = this, files = nil, file = nil;

        
        files = [];
        
        for (var key in Opal.modules) {
          files.push(key)
        }
      ;
        path = path.$gsub(Opal.regexp(["(^.", $$($nesting, 'SEPARATOR'), "+|", $$($nesting, 'SEPARATOR'), "+$)"]));
        file = $send(files, 'find', [], ($$8 = function(f){var self = $$8.$$s == null ? this : $$8.$$s;

          
          
          if (f == null) {
            f = nil;
          };
          return f['$=~'](Opal.regexp(["^", path]));}, $$8.$$s = self, $$8.$$arity = 1, $$8));
        return file;
      }, $directory$ques$7.$$arity = 1);
      
      Opal.def(self, '$join', $join$9 = function $$join($a) {
        var $post_args, paths, $$10, $$11, self = this, result = nil;

        
        
        $post_args = Opal.slice.call(arguments, 0, arguments.length);
        
        paths = $post_args;;
        if ($truthy(paths['$empty?']())) {
          return ""};
        result = "";
        paths = $send(paths.$flatten().$each_with_index(), 'map', [], ($$10 = function(item, index){var self = $$10.$$s == null ? this : $$10.$$s, $ret_or_3 = nil, $ret_or_4 = nil;

          
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          if ($truthy((function() {if ($truthy(($ret_or_3 = index['$=='](0)))) {
            return item['$empty?']()
          } else {
            return $ret_or_3
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else if ($truthy((function() {if ($truthy(($ret_or_4 = paths.$length()['$==']($rb_plus(index, 1))))) {
            return item['$empty?']()
          } else {
            return $ret_or_4
          }; return nil; })())) {
            return $$($nesting, 'SEPARATOR')
          } else {
            return item
          };}, $$10.$$s = self, $$10.$$arity = 2, $$10));
        paths = $send(paths, 'reject', [], "empty?".$to_proc());
        $send(paths, 'each_with_index', [], ($$11 = function(item, index){var self = $$11.$$s == null ? this : $$11.$$s, next_item = nil, $ret_or_5 = nil, $ret_or_6 = nil;

          
          
          if (item == null) {
            item = nil;
          };
          
          if (index == null) {
            index = nil;
          };
          next_item = paths['$[]']($rb_plus(index, 1));
          if ($truthy(next_item['$nil?']())) {
            return (result = "" + (result) + (item))
          } else {
            
            if ($truthy((function() {if ($truthy(($ret_or_5 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            } else {
              return $ret_or_5
            }; return nil; })())) {
              item = item.$sub(Opal.regexp([$$($nesting, 'SEPARATOR'), "+$"]), "")};
            return (result = (function() {if ($truthy((function() {if ($truthy(($ret_or_6 = item['$end_with?']($$($nesting, 'SEPARATOR'))))) {
              return $ret_or_6
            } else {
              return next_item['$start_with?']($$($nesting, 'SEPARATOR'))
            }; return nil; })())) {
              return "" + (result) + (item)
            } else {
              return "" + (result) + (item) + ($$($nesting, 'SEPARATOR'))
            }; return nil; })());
          };}, $$11.$$s = self, $$11.$$arity = 2, $$11));
        return result;
      }, $join$9.$$arity = -1);
      return (Opal.def(self, '$split', $split$12 = function $$split(path) {
        var self = this;

        return path.$split($$($nesting, 'SEPARATOR'))
      }, $split$12.$$arity = 1), nil) && 'split';
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], $$($nesting, 'IO'), $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/process"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $truthy = Opal.truthy;

  Opal.add_stubs(['$const_set', '$size', '$<<', '$__register_clock__', '$to_f', '$now', '$new', '$[]', '$raise']);
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Process');

    var $nesting = [self].concat($parent_nesting), $Process___register_clock__$1, $Process_pid$2, $Process_times$3, $Process_clock_gettime$4, monotonic = nil;

    
    self.__clocks__ = [];
    Opal.defs(self, '$__register_clock__', $Process___register_clock__$1 = function $$__register_clock__(name, func) {
      var self = this;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      self.$const_set(name, self.__clocks__.$size());
      return self.__clocks__['$<<'](func);
    }, $Process___register_clock__$1.$$arity = 2);
    self.$__register_clock__("CLOCK_REALTIME", function() { return Date.now() });
    monotonic = false;
    
    if (Opal.global.performance) {
      monotonic = function() {
        return performance.now()
      };
    }
    else if (Opal.global.process && process.hrtime) {
      // let now be the base to get smaller numbers
      var hrtime_base = process.hrtime();

      monotonic = function() {
        var hrtime = process.hrtime(hrtime_base);
        var us = (hrtime[1] / 1000) | 0; // cut below microsecs;
        return ((hrtime[0] * 1000) + (us / 1000));
      };
    }
  ;
    if ($truthy(monotonic)) {
      self.$__register_clock__("CLOCK_MONOTONIC", monotonic)};
    Opal.defs(self, '$pid', $Process_pid$2 = function $$pid() {
      var self = this;

      return 0
    }, $Process_pid$2.$$arity = 0);
    Opal.defs(self, '$times', $Process_times$3 = function $$times() {
      var self = this, t = nil;

      
      t = $$($nesting, 'Time').$now().$to_f();
      return $$$($$($nesting, 'Benchmark'), 'Tms').$new(t, t, t, t, t);
    }, $Process_times$3.$$arity = 0);
    return (Opal.defs(self, '$clock_gettime', $Process_clock_gettime$4 = function $$clock_gettime(clock_id, unit) {
      var self = this, $ret_or_1 = nil, clock = nil;
      if (self.__clocks__ == null) self.__clocks__ = nil;

      
      
      if (unit == null) {
        unit = "float_second";
      };
      if ($truthy(($ret_or_1 = (clock = self.__clocks__['$[]'](clock_id))))) {
        $ret_or_1
      } else {
        self.$raise($$$($$($nesting, 'Errno'), 'EINVAL'), "" + "clock_gettime(" + (clock_id) + ") " + (self.__clocks__['$[]'](clock_id)))
      };
      
      var ms = clock();
      switch (unit) {
        case 'float_second':      return  (ms / 1000);         // number of seconds as a float (default)
        case 'float_millisecond': return  (ms / 1);            // number of milliseconds as a float
        case 'float_microsecond': return  (ms * 1000);         // number of microseconds as a float
        case 'second':            return ((ms / 1000)    | 0); // number of seconds as an integer
        case 'millisecond':       return ((ms / 1)       | 0); // number of milliseconds as an integer
        case 'microsecond':       return ((ms * 1000)    | 0); // number of microseconds as an integer
        case 'nanosecond':        return ((ms * 1000000) | 0); // number of nanoseconds as an integer
        default: self.$raise($$($nesting, 'ArgumentError'), "" + "unexpected unit: " + (unit))
      }
    ;
    }, $Process_clock_gettime$4.$$arity = -2), nil) && 'clock_gettime';
  })($nesting[0], null, $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Signal');

    var $nesting = [self].concat($parent_nesting), $Signal_trap$5;

    return (Opal.defs(self, '$trap', $Signal_trap$5 = function $$trap($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Signal_trap$5.$$arity = -1), nil) && 'trap'
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'GC');

    var $nesting = [self].concat($parent_nesting), $GC_start$6;

    return (Opal.defs(self, '$start', $GC_start$6 = function $$start() {
      var self = this;

      return nil
    }, $GC_start$6.$$arity = 0), nil) && 'start'
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/random/formatter"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  function $rb_divide(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs / rhs : lhs['$/'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $send = Opal.send, $range = Opal.range;

  Opal.add_stubs(['$_verify_count', '$bytes', '$encode', '$strict_encode64', '$random_bytes', '$urlsafe_encode64', '$split', '$hex', '$[]=', '$-', '$[]', '$map', '$to_proc', '$join', '$times', '$<<', '$|', '$ord', '$/', '$abs', '$random_float', '$raise', '$coerce_to!', '$flatten', '$new', '$random_number', '$length', '$include', '$extend']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $Formatter_hex$1, $Formatter_random_bytes$2, $Formatter_base64$3, $Formatter_urlsafe_base64$4, $Formatter_uuid$5, $Formatter_random_float$6, $Formatter_random_number$8, $Formatter_alphanumeric$9;

      
      
      Opal.def(self, '$hex', $Formatter_hex$1 = function $$hex(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        count = $$($nesting, 'Random').$_verify_count(count);
        
        var bytes = self.$bytes(count);
        var out = "";
        for (var i = 0; i < count; i++) {
          out += bytes.charCodeAt(i).toString(16).padStart(2, '0');
        }
        return (out).$encode("US-ASCII");
      ;
      }, $Formatter_hex$1.$$arity = -1);
      
      Opal.def(self, '$random_bytes', $Formatter_random_bytes$2 = function $$random_bytes(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        return self.$bytes(count);
      }, $Formatter_random_bytes$2.$$arity = -1);
      
      Opal.def(self, '$base64', $Formatter_base64$3 = function $$base64(count) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        return $$($nesting, 'Base64').$strict_encode64(self.$random_bytes(count)).$encode("US-ASCII");
      }, $Formatter_base64$3.$$arity = -1);
      
      Opal.def(self, '$urlsafe_base64', $Formatter_urlsafe_base64$4 = function $$urlsafe_base64(count, padding) {
        var self = this;

        
        
        if (count == null) {
          count = nil;
        };
        
        if (padding == null) {
          padding = false;
        };
        return $$($nesting, 'Base64').$urlsafe_encode64(self.$random_bytes(count), padding).$encode("US-ASCII");
      }, $Formatter_urlsafe_base64$4.$$arity = -1);
      
      Opal.def(self, '$uuid', $Formatter_uuid$5 = function $$uuid() {
        var self = this, str = nil, $writer = nil;

        
        str = self.$hex(16).$split("");
        
        $writer = [12, "4"];
        $send(str, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        
        $writer = [16, (parseInt(str['$[]'](16), 16) & 3 | 8).toString(16)];
        $send(str, '[]=', Opal.to_a($writer));
        $writer[$rb_minus($writer["length"], 1)];;
        str = [str['$[]']($range(0, 8, true)), str['$[]']($range(8, 12, true)), str['$[]']($range(12, 16, true)), str['$[]']($range(16, 20, true)), str['$[]']($range(20, 32, true))];
        str = $send(str, 'map', [], "join".$to_proc());
        return str.$join("-");
      }, $Formatter_uuid$5.$$arity = 0);
      
      Opal.def(self, '$random_float', $Formatter_random_float$6 = function $$random_float() {
        var $$7, self = this, bs = nil, num = nil;

        
        bs = self.$bytes(4);
        num = 0;
        $send((4), 'times', [], ($$7 = function(i){var self = $$7.$$s == null ? this : $$7.$$s;

          
          
          if (i == null) {
            i = nil;
          };
          num = num['$<<'](8);
          return (num = num['$|'](bs['$[]'](i).$ord()));}, $$7.$$s = self, $$7.$$arity = 1, $$7));
        return $rb_divide(num.$abs(), 2147483647);
      }, $Formatter_random_float$6.$$arity = 0);
      
      Opal.def(self, '$random_number', $Formatter_random_number$8 = function $$random_number(limit) {
        var self = this;

        
        ;
        
        function randomFloat() {
          return self.$random_float();
        }

        function randomInt(max) {
          return Math.floor(randomFloat() * max);
        }

        function randomRange() {
          var min = limit.begin,
              max = limit.end;

          if (min === nil || max === nil) {
            return nil;
          }

          var length = max - min;

          if (length < 0) {
            return nil;
          }

          if (length === 0) {
            return min;
          }

          if (max % 1 === 0 && min % 1 === 0 && !limit.excl) {
            length++;
          }

          return randomInt(length) + min;
        }

        if (limit == null) {
          return randomFloat();
        } else if (limit.$$is_range) {
          return randomRange();
        } else if (limit.$$is_number) {
          if (limit <= 0) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
          }

          if (limit % 1 === 0) {
            // integer
            return randomInt(limit);
          } else {
            return randomFloat() * limit;
          }
        } else {
          limit = $$($nesting, 'Opal')['$coerce_to!'](limit, $$($nesting, 'Integer'), "to_int");

          if (limit <= 0) {
            self.$raise($$($nesting, 'ArgumentError'), "" + "invalid argument - " + (limit))
          }

          return randomInt(limit);
        }
      ;
      }, $Formatter_random_number$8.$$arity = -1);
      return (Opal.def(self, '$alphanumeric', $Formatter_alphanumeric$9 = function $$alphanumeric(count) {
        var $$10, self = this, map = nil;

        
        
        if (count == null) {
          count = nil;
        };
        count = $$($nesting, 'Random').$_verify_count(count);
        map = $send([$range("0", "9", false), $range("a", "z", false), $range("A", "Z", false)], 'map', [], "to_a".$to_proc()).$flatten();
        return $send($$($nesting, 'Array'), 'new', [count], ($$10 = function(i){var self = $$10.$$s == null ? this : $$10.$$s;

          
          
          if (i == null) {
            i = nil;
          };
          return map['$[]'](self.$random_number(map.$length()));}, $$10.$$s = self, $$10.$$arity = 1, $$10)).$join();
      }, $Formatter_alphanumeric$9.$$arity = -1), nil) && 'alphanumeric';
    })($nesting[0], $nesting);
    self.$include($$$($$($nesting, 'Random'), 'Formatter'));
    return self.$extend($$$($$($nesting, 'Random'), 'Formatter'));
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/random"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $falsy = Opal.falsy, $klass = Opal.klass, $truthy = Opal.truthy, $send = Opal.send;

  Opal.add_stubs(['$attr_reader', '$to_int', '$raise', '$new_seed', '$coerce_to!', '$reseed', '$rand', '$seed', '$bytes', '$===', '$==', '$state', '$_verify_count', '$encode', '$join', '$new', '$chr', '$random_number', '$random_float', '$const_defined?', '$const_set']);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $Random__verify_count$1, $Random_initialize$2, $Random_reseed$3, $Random_new_seed$4, $Random_rand$5, $Random_srand$6, $Random_urandom$7, $Random_$eq_eq$8, $Random_bytes$9, $Random_bytes$11, $Random_rand$12, $Random_random_float$13, $Random_random_float$14, $Random_generator$eq$15;

    
    self.$attr_reader("seed", "state");
    Opal.defs(self, '$_verify_count', $Random__verify_count$1 = function $$_verify_count(count) {
      var self = this;

      
      if ($falsy(count)) count = 16;
      if (typeof count !== "number") count = (count).$to_int();
      if (count < 0) self.$raise($$($nesting, 'ArgumentError'), "negative string size (or size too big)");
      count = Math.floor(count);
      return count;
    
    }, $Random__verify_count$1.$$arity = 1);
    
    Opal.def(self, '$initialize', $Random_initialize$2 = function $$initialize(seed) {
      var self = this;

      
      
      if (seed == null) {
        seed = $$($nesting, 'Random').$new_seed();
      };
      seed = $$($nesting, 'Opal')['$coerce_to!'](seed, $$($nesting, 'Integer'), "to_int");
      self.state = seed;
      return self.$reseed(seed);
    }, $Random_initialize$2.$$arity = -1);
    
    Opal.def(self, '$reseed', $Random_reseed$3 = function $$reseed(seed) {
      var self = this;

      
      self.seed = seed;
      return self.$rng = Opal.$$rand.reseed(seed);;
    }, $Random_reseed$3.$$arity = 1);
    Opal.defs(self, '$new_seed', $Random_new_seed$4 = function $$new_seed() {
      var self = this;

      return Opal.$$rand.new_seed();
    }, $Random_new_seed$4.$$arity = 0);
    Opal.defs(self, '$rand', $Random_rand$5 = function $$rand(limit) {
      var self = this;

      
      ;
      return $$($nesting, 'DEFAULT').$rand(limit);
    }, $Random_rand$5.$$arity = -1);
    Opal.defs(self, '$srand', $Random_srand$6 = function $$srand(n) {
      var self = this, previous_seed = nil;

      
      
      if (n == null) {
        n = $$($nesting, 'Random').$new_seed();
      };
      n = $$($nesting, 'Opal')['$coerce_to!'](n, $$($nesting, 'Integer'), "to_int");
      previous_seed = $$($nesting, 'DEFAULT').$seed();
      $$($nesting, 'DEFAULT').$reseed(n);
      return previous_seed;
    }, $Random_srand$6.$$arity = -1);
    Opal.defs(self, '$urandom', $Random_urandom$7 = function $$urandom(size) {
      var self = this;

      return $$$('::', 'SecureRandom').$bytes(size)
    }, $Random_urandom$7.$$arity = 1);
    
    Opal.def(self, '$==', $Random_$eq_eq$8 = function(other) {
      var self = this, $ret_or_1 = nil;

      
      if ($truthy($$($nesting, 'Random')['$==='](other))) {
      } else {
        return false
      };
      if ($truthy(($ret_or_1 = self.$seed()['$=='](other.$seed())))) {
        return self.$state()['$=='](other.$state())
      } else {
        return $ret_or_1
      };
    }, $Random_$eq_eq$8.$$arity = 1);
    
    Opal.def(self, '$bytes', $Random_bytes$9 = function $$bytes(length) {
      var $$10, self = this;

      
      length = $$($nesting, 'Random').$_verify_count(length);
      return $send($$($nesting, 'Array'), 'new', [length], ($$10 = function(){var self = $$10.$$s == null ? this : $$10.$$s;

        return self.$rand(255).$chr()}, $$10.$$s = self, $$10.$$arity = 0, $$10)).$join().$encode("ASCII-8BIT");
    }, $Random_bytes$9.$$arity = 1);
    Opal.defs(self, '$bytes', $Random_bytes$11 = function $$bytes(length) {
      var self = this;

      return $$($nesting, 'DEFAULT').$bytes(length)
    }, $Random_bytes$11.$$arity = 1);
    
    Opal.def(self, '$rand', $Random_rand$12 = function $$rand(limit) {
      var self = this;

      
      ;
      return self.$random_number(limit);
    }, $Random_rand$12.$$arity = -1);
    
    Opal.def(self, '$random_float', $Random_random_float$13 = function $$random_float() {
      var self = this;

      
      self.state++;
      return Opal.$$rand.rand(self.$rng);
    
    }, $Random_random_float$13.$$arity = 0);
    Opal.defs(self, '$random_float', $Random_random_float$14 = function $$random_float() {
      var self = this;

      return $$($nesting, 'DEFAULT').$random_float()
    }, $Random_random_float$14.$$arity = 0);
    return (Opal.defs(self, '$generator=', $Random_generator$eq$15 = function(generator) {
      var self = this;

      
      Opal.$$rand = generator;
      if ($truthy(self['$const_defined?']("DEFAULT"))) {
        return $$($nesting, 'DEFAULT').$reseed()
      } else {
        return self.$const_set("DEFAULT", self.$new(self.$new_seed()))
      };
    }, $Random_generator$eq$15.$$arity = 1), nil) && 'generator=';
  })($nesting[0], null, $nesting)
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/random/mersenne_twister"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $send = Opal.send, mersenne_twister = nil;

  Opal.add_stubs(['$generator=', '$-']);
  
  mersenne_twister = (function() {
  /* Period parameters */
  var N = 624;
  var M = 397;
  var MATRIX_A = 0x9908b0df;      /* constant vector a */
  var UMASK = 0x80000000;         /* most significant w-r bits */
  var LMASK = 0x7fffffff;         /* least significant r bits */
  var MIXBITS = function(u,v) { return ( ((u) & UMASK) | ((v) & LMASK) ); };
  var TWIST = function(u,v) { return (MIXBITS((u),(v)) >>> 1) ^ ((v & 0x1) ? MATRIX_A : 0x0); };

  function init(s) {
    var mt = {left: 0, next: N, state: new Array(N)};
    init_genrand(mt, s);
    return mt;
  }

  /* initializes mt[N] with a seed */
  function init_genrand(mt, s) {
    var j, i;
    mt.state[0] = s >>> 0;
    for (j=1; j<N; j++) {
      mt.state[j] = (1812433253 * ((mt.state[j-1] ^ (mt.state[j-1] >> 30) >>> 0)) + j);
      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
      /* In the previous versions, MSBs of the seed affect   */
      /* only MSBs of the array state[].                     */
      /* 2002/01/09 modified by Makoto Matsumoto             */
      mt.state[j] &= 0xffffffff;  /* for >32 bit machines */
    }
    mt.left = 1;
    mt.next = N;
  }

  /* generate N words at one time */
  function next_state(mt) {
    var p = 0, _p = mt.state;
    var j;

    mt.left = N;
    mt.next = 0;

    for (j=N-M+1; --j; p++)
      _p[p] = _p[p+(M)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    for (j=M; --j; p++)
      _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[p+(1)]);

    _p[p] = _p[p+(M-N)] ^ TWIST(_p[p+(0)], _p[0]);
  }

  /* generates a random number on [0,0xffffffff]-interval */
  function genrand_int32(mt) {
    /* mt must be initialized */
    var y;

    if (--mt.left <= 0) next_state(mt);
    y = mt.state[mt.next++];

    /* Tempering */
    y ^= (y >>> 11);
    y ^= (y << 7) & 0x9d2c5680;
    y ^= (y << 15) & 0xefc60000;
    y ^= (y >>> 18);

    return y >>> 0;
  }

  function int_pair_to_real_exclusive(a, b) {
    a >>>= 5;
    b >>>= 6;
    return(a*67108864.0+b)*(1.0/9007199254740992.0);
  }

  // generates a random number on [0,1) with 53-bit resolution
  function genrand_real(mt) {
    /* mt must be initialized */
    var a = genrand_int32(mt), b = genrand_int32(mt);
    return int_pair_to_real_exclusive(a, b);
  }

  return { genrand_real: genrand_real, init: init };
})();
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Random');

    var $nesting = [self].concat($parent_nesting), $writer = nil;

    
    var MAX_INT = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
    Opal.const_set($nesting[0], 'MERSENNE_TWISTER_GENERATOR', {
    new_seed: function() { return Math.round(Math.random() * MAX_INT); },
    reseed: function(seed) { return mersenne_twister.init(seed); },
    rand: function(mt) { return mersenne_twister.genrand_real(mt); }
  });
    
    $writer = [$$($nesting, 'MERSENNE_TWISTER_GENERATOR')];
    $send(self, 'generator=', Opal.to_a($writer));
    return $writer[$rb_minus($writer["length"], 1)];;
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["corelib/unsupported"] = function(Opal) {
  var $public$35, $private$36, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $module = Opal.module, $alias = Opal.alias;

  Opal.add_stubs(['$raise', '$warn', '$%']);
  
  
  var warnings = {};

  function handle_unsupported_feature(message) {
    switch (Opal.config.unsupported_features_severity) {
    case 'error':
      $$($nesting, 'Kernel').$raise($$($nesting, 'NotImplementedError'), message)
      break;
    case 'warning':
      warn(message)
      break;
    default: // ignore
      // noop
    }
  }

  function warn(string) {
    if (warnings[string]) {
      return;
    }

    warnings[string] = true;
    self.$warn(string);
  }
;
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'String');

    var $nesting = [self].concat($parent_nesting), $String_$lt$lt$1, $String_capitalize$excl$2, $String_chomp$excl$3, $String_chop$excl$4, $String_downcase$excl$5, $String_gsub$excl$6, $String_lstrip$excl$7, $String_next$excl$8, $String_reverse$excl$9, $String_slice$excl$10, $String_squeeze$excl$11, $String_strip$excl$12, $String_sub$excl$13, $String_succ$excl$14, $String_swapcase$excl$15, $String_tr$excl$16, $String_tr_s$excl$17, $String_upcase$excl$18, $String_prepend$19, $String_$$$eq$20, $String_clear$21, $String_encode$excl$22, $String_unicode_normalize$excl$23;

    
    var ERROR = "String#%s not supported. Mutable String methods are not supported in Opal.";
    
    Opal.def(self, '$<<', $String_$lt$lt$1 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("<<"));
    }, $String_$lt$lt$1.$$arity = -1);
    
    Opal.def(self, '$capitalize!', $String_capitalize$excl$2 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("capitalize!"));
    }, $String_capitalize$excl$2.$$arity = -1);
    
    Opal.def(self, '$chomp!', $String_chomp$excl$3 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chomp!"));
    }, $String_chomp$excl$3.$$arity = -1);
    
    Opal.def(self, '$chop!', $String_chop$excl$4 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("chop!"));
    }, $String_chop$excl$4.$$arity = -1);
    
    Opal.def(self, '$downcase!', $String_downcase$excl$5 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("downcase!"));
    }, $String_downcase$excl$5.$$arity = -1);
    
    Opal.def(self, '$gsub!', $String_gsub$excl$6 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("gsub!"));
    }, $String_gsub$excl$6.$$arity = -1);
    
    Opal.def(self, '$lstrip!', $String_lstrip$excl$7 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("lstrip!"));
    }, $String_lstrip$excl$7.$$arity = -1);
    
    Opal.def(self, '$next!', $String_next$excl$8 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("next!"));
    }, $String_next$excl$8.$$arity = -1);
    
    Opal.def(self, '$reverse!', $String_reverse$excl$9 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("reverse!"));
    }, $String_reverse$excl$9.$$arity = -1);
    
    Opal.def(self, '$slice!', $String_slice$excl$10 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("slice!"));
    }, $String_slice$excl$10.$$arity = -1);
    
    Opal.def(self, '$squeeze!', $String_squeeze$excl$11 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("squeeze!"));
    }, $String_squeeze$excl$11.$$arity = -1);
    
    Opal.def(self, '$strip!', $String_strip$excl$12 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("strip!"));
    }, $String_strip$excl$12.$$arity = -1);
    
    Opal.def(self, '$sub!', $String_sub$excl$13 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("sub!"));
    }, $String_sub$excl$13.$$arity = -1);
    
    Opal.def(self, '$succ!', $String_succ$excl$14 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("succ!"));
    }, $String_succ$excl$14.$$arity = -1);
    
    Opal.def(self, '$swapcase!', $String_swapcase$excl$15 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("swapcase!"));
    }, $String_swapcase$excl$15.$$arity = -1);
    
    Opal.def(self, '$tr!', $String_tr$excl$16 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr!"));
    }, $String_tr$excl$16.$$arity = -1);
    
    Opal.def(self, '$tr_s!', $String_tr_s$excl$17 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("tr_s!"));
    }, $String_tr_s$excl$17.$$arity = -1);
    
    Opal.def(self, '$upcase!', $String_upcase$excl$18 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("upcase!"));
    }, $String_upcase$excl$18.$$arity = -1);
    
    Opal.def(self, '$prepend', $String_prepend$19 = function $$prepend($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("prepend"));
    }, $String_prepend$19.$$arity = -1);
    
    Opal.def(self, '$[]=', $String_$$$eq$20 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("[]="));
    }, $String_$$$eq$20.$$arity = -1);
    
    Opal.def(self, '$clear', $String_clear$21 = function $$clear($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("clear"));
    }, $String_clear$21.$$arity = -1);
    
    Opal.def(self, '$encode!', $String_encode$excl$22 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("encode!"));
    }, $String_encode$excl$22.$$arity = -1);
    return (Opal.def(self, '$unicode_normalize!', $String_unicode_normalize$excl$23 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), (ERROR)['$%']("unicode_normalize!"));
    }, $String_unicode_normalize$excl$23.$$arity = -1), nil) && 'unicode_normalize!';
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_freeze$24, $Kernel_frozen$ques$25;

    
    var ERROR = "Object freezing is not supported by Opal";
    
    Opal.def(self, '$freeze', $Kernel_freeze$24 = function $$freeze() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_freeze$24.$$arity = 0);
    return (Opal.def(self, '$frozen?', $Kernel_frozen$ques$25 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_frozen$ques$25.$$arity = 0), nil) && 'frozen?';
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_taint$26, $Kernel_untaint$27, $Kernel_tainted$ques$28;

    
    var ERROR = "Object tainting is not supported by Opal";
    
    Opal.def(self, '$taint', $Kernel_taint$26 = function $$taint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_taint$26.$$arity = 0);
    
    Opal.def(self, '$untaint', $Kernel_untaint$27 = function $$untaint() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return self;
    }, $Kernel_untaint$27.$$arity = 0);
    return (Opal.def(self, '$tainted?', $Kernel_tainted$ques$28 = function() {
      var self = this;

      
      handle_unsupported_feature(ERROR);
      return false;
    }, $Kernel_tainted$ques$28.$$arity = 0), nil) && 'tainted?';
  })($nesting[0], $nesting);
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Module');

    var $nesting = [self].concat($parent_nesting), $Module_public$29, $Module_private_class_method$30, $Module_private_method_defined$ques$31, $Module_private_constant$32;

    
    
    Opal.def(self, '$public', $Module_public$29 = function($a) {
      var $post_args, methods, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      
      methods = $post_args;;
      
      if (methods.length === 0) {
        self.$$module_function = false;
      }

      return nil;
    ;
    }, $Module_public$29.$$arity = -1);
    $alias(self, "private", "public");
    $alias(self, "protected", "public");
    $alias(self, "nesting", "public");
    
    Opal.def(self, '$private_class_method', $Module_private_class_method$30 = function $$private_class_method($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self;
    }, $Module_private_class_method$30.$$arity = -1);
    $alias(self, "public_class_method", "private_class_method");
    
    Opal.def(self, '$private_method_defined?', $Module_private_method_defined$ques$31 = function(obj) {
      var self = this;

      return false
    }, $Module_private_method_defined$ques$31.$$arity = 1);
    
    Opal.def(self, '$private_constant', $Module_private_constant$32 = function $$private_constant($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return nil;
    }, $Module_private_constant$32.$$arity = -1);
    $alias(self, "protected_method_defined?", "private_method_defined?");
    $alias(self, "public_instance_methods", "instance_methods");
    $alias(self, "public_instance_method", "instance_method");
    return $alias(self, "public_method_defined?", "method_defined?");
  })($nesting[0], null, $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_private_methods$33;

    
    
    Opal.def(self, '$private_methods', $Kernel_private_methods$33 = function $$private_methods($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return [];
    }, $Kernel_private_methods$33.$$arity = -1);
    return $alias(self, "private_instance_methods", "private_methods");
  })($nesting[0], $nesting);
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_eval$34;

    return (Opal.def(self, '$eval', $Kernel_eval$34 = function($a) {
      var $post_args, self = this;

      
      
      $post_args = Opal.slice.call(arguments, 0, arguments.length);
      ;
      return self.$raise($$($nesting, 'NotImplementedError'), "" + "To use Kernel#eval, you must first require 'opal-parser'. " + ("" + "See https://github.com/opal/opal/blob/" + ($$($nesting, 'RUBY_ENGINE_VERSION')) + "/docs/opal_parser.md for details."));
    }, $Kernel_eval$34.$$arity = -1), nil) && 'eval'
  })($nesting[0], $nesting);
  Opal.defs(self, '$public', $public$35 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $public$35.$$arity = -1);
  return (Opal.defs(self, '$private', $private$36 = function($a) {
    var $post_args, self = this;

    
    
    $post_args = Opal.slice.call(arguments, 0, arguments.length);
    ;
    return nil;
  }, $private$36.$$arity = -1), nil) && 'private';
};

/* Generated by Opal 1.3.0.dev */
(function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("opal/base");
  self.$require("opal/mini");
  self.$require("corelib/kernel/format");
  self.$require("corelib/string/encoding");
  self.$require("corelib/math");
  self.$require("corelib/complex");
  self.$require("corelib/rational");
  self.$require("corelib/time");
  self.$require("corelib/struct");
  self.$require("corelib/io");
  self.$require("corelib/main");
  self.$require("corelib/dir");
  self.$require("corelib/file");
  self.$require("corelib/process");
  self.$require("corelib/random/formatter");
  self.$require("corelib/random");
  self.$require("corelib/random/mersenne_twister");
  return self.$require("corelib/unsupported");
})(Opal);

(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.sourceMapSupport = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var toString = Object.prototype.toString

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom

},{}],2:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":11}],3:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":4}],4:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],5:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],6:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":11}],7:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],8:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":2,"./base64-vlq":3,"./binary-search":5,"./quick-sort":7,"./util":11}],9:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":2,"./base64-vlq":3,"./mapping-list":6,"./util":11}],10:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":9,"./util":11}],11:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],12:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":8,"./lib/source-map-generator":9,"./lib/source-node":10}],"/lib/opal/cli_runners/source-map-support.js":[function(require,module,exports){
// IMPORTANT NOTICE:
// Remember to update the browser version whenever this file is changed,
// to do so, `run bin/build-browser-source-map-support`

// The following is taken and adapted from the work of Evan Wallace
// https://github.com/evanw/node-source-map-support v0.5.19

// The MIT License (MIT)
//
// Copyright (c) 2014 Evan Wallace
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var SourceMapConsumer = require('source-map').SourceMapConsumer;
var path = require('path');

var fs;
try {
  fs = require('fs');
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {
  /* nop */
}

var bufferFrom = require('buffer-from');

/**
 * Requires a module which is protected against bundler minification.
 *
 * @param {NodeModule} mod
 * @param {string} request
 */
function dynamicRequire(mod, request) {
  return mod.require(request);
}  

// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser")
    return true;
  if (environment === "node")
    return false;
  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (/^file:/.test(path)) {
    // existsSync/readFileSync can't handle file protocol, but once stripped, it works
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ?
        '' : // file:///C:/dir/file -> C:/dir/file
        '/'; // file:///root-dir/file -> /root-dir/file
    });
  }
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = '';
  try {
    if (!fs) {
      // Use SJAX if we are in the browser
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, /** async */ false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) {
        contents = xhr.responseText;
      }
    } else if (fs.existsSync(path)) {
      // Otherwise, use the filesystem
      contents = fs.readFileSync(path, 'utf8');
    }
  } catch (er) {
    /* ignore any errors */
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
  // Force file to null otherwise it will relativize locations to the current file
  file = null

  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  var startPath = dir.slice(protocol.length);
  if (protocol && /^\/\w\:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/';
    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
  }
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
     try {
       var xhr = new XMLHttpRequest();
       xhr.open('GET', source, false);
       xhr.send(null);
       fileData = xhr.readyState === 4 ? xhr.responseText : null;

       // Support providing a sourceMappingURL via the SourceMap header
       var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                             xhr.getResponseHeader("X-SourceMap");
       if (sourceMapHeader) {
         return sourceMapHeader;
       }
     } catch (e) {
     }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval from ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval from ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval from ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval from ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }

    if (fileLocation.startsWith("corelib/")) {
      fileLocation = "<internal:" + fileLocation + ">";
    } else if (fileLocation.endsWith(".js")) {
      fileLocation = "<js:" + fileLocation + ">";
    }

    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (functionName.startsWith("$$")) {
        functionName = functionName.slice(2);
      } else if (functionName.startsWith("$")) {
        functionName = functionName.slice(1);
      }
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  line = fileLocation + ":in `" + (functionName || methodName) + "'"
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  // provides interface backward compatibility
  if (state === undefined) {
    state = { nextPosition: null, curPosition: null }
  }
  if(frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
    var headerLength = noHeader.test(process.version) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    state.curPosition = position;
    frame = cloneCallSite(frame);
    var originalFunctionName = frame.getFunctionName;
    frame.getFunctionName = function() {
      if (state.nextPosition == null) {
        return originalFunctionName();
      }
      return state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// https://v8.dev/docs/stack-trace-api
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var name = error.name || 'Error';
  var message = error.message || '';
  var errorString = name + ": " + message;

  var state = { nextPosition: null, curPosition: null };
  var processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n  from ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n  from [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit (error) {
  var source = getErrorSource(error);

  // Ensure error is printed synchronously and not truncated
  if (process.stderr._handle && process.stderr._handle.setBlocking) {
    process.stderr._handle.setBlocking(true);
  }

  if (typeof error.$full_message === 'function') {
    console.error(error.$full_message().$chomp());
  }
  else {
    if (source) {
      console.error();
      console.error(source);
    }

    console.error(error.stack);
  }
  process.exit(1);
}

function shimEmitUncaughtException () {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = (arguments[1] && arguments[1].stack);
      var hasListeners = (this.listeners(type).length > 0);

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}")
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    // Use dynamicRequire to avoid including in browser bundles
    var Module = dynamicRequire(module, 'module');
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;

    // Do not override 'uncaughtException' with our own handler in Node.js
    // Worker threads. Workers pass the error to the main thread as an event,
    // rather than printing something to stderr and exiting.
    try {
      // We need to use `dynamicRequire` because `require` on it's own will be optimized by WebPack/Browserify.
      var worker_threads = dynamicRequire(module, 'worker_threads');
      if (worker_threads.isMainThread === false) {
        installHandler = false;
      }
    } catch(e) {}      

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
}

// Autoinstall.
exports.install();

// Regenerate the browser version with:
// browserify lib/opal/cli_runners/source-map-support.js -s sourceMapSupport | uglifyjs -c > lib/opal/cli_runners/source-map-support-browser.js

// = Stacktrace Examples:
//
// == Traditional Ruby stacktrace:
//
// /Users/elia/Code/opal/lib/opal/cli_runners/system_runner.rb:43:in `call': unhandled exception
//   from /Users/elia/Code/opal/lib/opal/cli_runners/nodejs.rb:14:in `call'
//   from /Users/elia/Code/opal/lib/opal/cli_runners.rb:50:in `block in register_runner'
//   from /Users/elia/Code/opal/lib/opal/cli.rb:62:in `run'
//   from /Users/elia/Code/opal/exe/opal:24:in `<top (required)>'
//   from bin/opal:4:in `load'
//   from bin/opal:4:in `<main>'
//
// == Traceback style:
//
// Traceback (most recent call last):
//   6: from bin/opal:4:in `<main>'
//   5: from bin/opal:4:in `load'
//   4: from /Users/elia/Code/opal/exe/opal:24:in `<top (required)>'
//   3: from /Users/elia/Code/opal/lib/opal/cli.rb:62:in `run'
//   2: from /Users/elia/Code/opal/lib/opal/cli_runners.rb:50:in `block in register_runner'
//   1: from /Users/elia/Code/opal/lib/opal/cli_runners/nodejs.rb:14:in `call'
// /Users/elia/Code/opal/lib/opal/cli_runners/system_runner.rb:43:in `call': unhandled exception

},{"buffer-from":1,"fs":undefined,"path":undefined,"source-map":12}]},{},[])("/lib/opal/cli_runners/source-map-support.js")
});
Opal.loaded(["opal/cli_runners/source-map-support-node.js"]);
/* Generated by Opal 1.3.0.dev */
Opal.modules["opal-platform"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, browser = nil, node = nil, nashorn = nil, headless_chrome = nil, gjs = nil, opalminiracer = nil;

  
  /* global Java, GjsFileImporter */;
  browser = typeof(document) !== "undefined";
  node = typeof(process) !== "undefined" && process.versions && process.versions.node;
  nashorn = typeof(Java) !== "undefined" && Java.type;
  headless_chrome = typeof(navigator) !== "undefined" && /\bHeadlessChrome\//.test(navigator.userAgent);
  gjs = typeof(window) !== "undefined" && typeof(GjsFileImporter) !== 'undefined';
  opalminiracer = typeof(opalminiracer) !== 'undefined';
  return Opal.const_set($nesting[0], 'OPAL_PLATFORM', (function() {if ($truthy(nashorn)) {
    return "nashorn"
  } else if ($truthy(node)) {
    return "nodejs"
  } else if ($truthy(headless_chrome)) {
    return "headless-chrome"
  } else if ($truthy(gjs)) {
    return "gjs"
  } else if ($truthy(opalminiracer)) {
    return "opal-miniracer"
  } else {
    return nil
  }; return nil; })());
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["nashorn/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $send = Opal.send, $gvars = Opal.gvars, $writer = nil;
  if ($gvars.stdout == null) $gvars.stdout = nil;
  if ($gvars.stderr == null) $gvars.stderr = nil;

  Opal.add_stubs(['$write_proc=', '$-']);
  
  
  $writer = [function(s){print(s)}];
  $send($gvars.stdout, 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [function(s){print(s)}];
  $send($gvars.stderr, 'write_proc=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["nashorn/file"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass;

  
  /* global Java */;
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $File_read$1, $File_file$ques$2, $File_readable$ques$3;

    
    Opal.defs(self, '$read', $File_read$1 = function $$read(path) {
      var self = this;

      
        var Paths = Java.type('java.nio.file.Paths');
        var Files = Java.type('java.nio.file.Files');
        var lines = Files.readAllLines(Paths.get(path), Java.type('java.nio.charset.StandardCharsets').UTF_8);
        var data = [];
        lines.forEach(function(line) { data.push(line); });
        return data.join("\n");
      
    }, $File_read$1.$$arity = 1);
    Opal.defs(self, '$file?', $File_file$ques$2 = function(path) {
      var self = this;

      
      var Files = Java.type('java.nio.file.Files');
      return Files.exists(path) && Files.isRegularFile(path);
    
    }, $File_file$ques$2.$$arity = 1);
    return (Opal.defs(self, '$readable?', $File_readable$ques$3 = function(path) {
      var self = this;

      
      var Files = Java.type('java.nio.file.Files');
      return Files.exists(path) && Files.isReadable(path);
    
    }, $File_readable$ques$3.$$arity = 1), nil) && 'readable?';
  })($nesting[0], null, $nesting);
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["nashorn"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$require']);
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Nashorn');

    var $nesting = [self].concat($parent_nesting);

    return nil
  })($nesting[0], $nesting);
  self.$require("nashorn/io");
  return self.$require("nashorn/file");
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["gjs/io"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  /* global imports */;
  
  var GLib = imports.gi.GLib;
  var ByteArray = imports.byteArray;

  var stdin = GLib.IOChannel.unix_new(0);
  var stdout = GLib.IOChannel.unix_new(1);
  var stderr = GLib.IOChannel.unix_new(2);

  Opal.gvars.stdout.write_proc = function(s) {
    var buf = ByteArray.fromString(s);
    stdout.write_chars(buf, buf.length);
    stdout.flush();
  }

  Opal.gvars.stderr.write_proc = function(s) {
    var buf = ByteArray.fromString(s);
    stderr.write_chars(buf, buf.length);
    stderr.flush();
  }

  Opal.gvars.stdin.read_proc = function(_s) {
    var out = stdin.read_line();
    if (out[0] == GLib.IOStatus.EOF) return nil;
    return out[1].toString();
  }
;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["gjs/kernel"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  /* global ARGV */;
  Opal.const_set($nesting[0], 'ARGV', ARGV);
  return Opal.exit = imports.system.exit;;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["gjs"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  Opal.add_stubs(['$require']);
  
  self.$require("gjs/io");
  return self.$require("gjs/kernel");
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["nodejs/kernel"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $module = Opal.module;

  Opal.add_stubs(['$warn', '$to_str']);
  
  Opal.exit = process.exit;
  (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $Kernel_node_require$1;

    
    Opal.const_set($nesting[0], 'NODE_REQUIRE', require);
    return (Opal.def(self, '$node_require', $Kernel_node_require$1 = function $$node_require(path) {
      var self = this;

      
      self.$warn("[DEPRECATION] node_require is deprecated. Please use `require('module')` instead.");
      return $$($nesting, 'NODE_REQUIRE')(path.$to_str());
    }, $Kernel_node_require$1.$$arity = 1), nil) && 'node_require';
  })($nesting[0], $nesting);
  return Opal.const_set($nesting[0], 'ARGV', process.argv.slice(2));
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["nodejs/io"] = function(Opal) {
  function $rb_minus(lhs, rhs) {
    return (typeof(lhs) === 'number' && typeof(rhs) === 'number') ? lhs - rhs : lhs['$-'](rhs);
  }
  var $$5, $$6, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $klass = Opal.klass, $alias = Opal.alias, $lambda = Opal.lambda, $send = Opal.send, $writer = nil;

  Opal.add_stubs(['$attr_reader', '$initialize_before_node_io', '$write', '$read', '$write_proc=', '$-', '$read_proc=', '$tty=']);
  
  
  function executeIOAction(action) {
    try {
      return action();
    } catch (error) {
      if (error.code === 'EACCES' ||
          error.code === 'EISDIR' ||
          error.code === 'EMFILE' ||
          error.code === 'ENOENT' ||
          error.code === 'EPERM') {
        throw Opal.IOError.$new(error.message)
      }
      throw error;
    }
  }
;
  var __fs__ = require('fs');
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $IO_initialize$1, $IO_write$2, $IO_read$3, $IO_binread$4;

    
    self.__fs__ = __fs__;
    self.$attr_reader("lineno");
    $alias(self, "initialize_before_node_io", "initialize");
    
    Opal.def(self, '$initialize', $IO_initialize$1 = function $$initialize(fd, flags) {
      var self = this;

      
      
      if (flags == null) {
        flags = "r";
      };
      self.lineno = 0;
      return self.$initialize_before_node_io(fd, flags);
    }, $IO_initialize$1.$$arity = -2);
    Opal.defs(self, '$write', $IO_write$2 = function $$write(path, data) {
      var self = this;

      return $$($nesting, 'File').$write(path, data)
    }, $IO_write$2.$$arity = 2);
    Opal.defs(self, '$read', $IO_read$3 = function $$read(path) {
      var self = this;

      return $$($nesting, 'File').$read(path)
    }, $IO_read$3.$$arity = 1);
    return (Opal.defs(self, '$binread', $IO_binread$4 = function $$binread(path) {
      var self = this;

      return executeIOAction(function(){return __fs__.readFileSync(path).toString('binary')})
    }, $IO_binread$4.$$arity = 1), nil) && 'binread';
  })($nesting[0], null, $nesting);
  
  $writer = [$lambda(($$5 = function(string){var self = $$5.$$s == null ? this : $$5.$$s;

    
    
    if (string == null) {
      string = nil;
    };
    return process.stdout.write(string);;}, $$5.$$s = self, $$5.$$arity = 1, $$5))];
  $send($$($nesting, 'STDOUT'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [$lambda(($$6 = function(string){var self = $$6.$$s == null ? this : $$6.$$s;

    
    
    if (string == null) {
      string = nil;
    };
    return process.stderr.write(string);;}, $$6.$$s = self, $$6.$$arity = 1, $$6))];
  $send($$($nesting, 'STDERR'), 'write_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [function(_count) {
  // Ignore count, return as much as we can get
  var buf = Buffer.alloc(65536);
  var count = __fs__.readSync(this.fd, buf, 0, 65536, null);
  if (count == 0) return nil;
  return buf.toString('utf8', 0, count);
}];
  $send($$($nesting, 'STDIN'), 'read_proc=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDIN'), 'tty=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDOUT'), 'tty=', Opal.to_a($writer));
  $writer[$rb_minus($writer["length"], 1)];;
  
  $writer = [true];
  $send($$($nesting, 'STDERR'), 'tty=', Opal.to_a($writer));
  return $writer[$rb_minus($writer["length"], 1)];;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["headless_chrome"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  Opal.exit = function(code) {
    // You can't exit from the browser.
    // The first call to Opal.exit should save an exit code.
    // All next invocations must be ignored.

    if (typeof(window.OPAL_EXIT_CODE) === "undefined") {
      window.OPAL_EXIT_CODE = code;
    }
  }

};

/* Generated by Opal 1.3.0.dev */
Opal.modules["opal/miniracer"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$;

  
  Opal.const_set($nesting[0], 'ARGV', opalminiracer.argv);
  return Opal.exit = opalminiracer.exit;;
};

/* Generated by Opal 1.3.0.dev */
Opal.modules["opal/platform"] = function(Opal) {
  var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $case = nil;

  Opal.add_stubs(['$require', '$===']);
  
  self.$require("opal-platform");
  return (function() {$case = $$($nesting, 'OPAL_PLATFORM');
  if ("nashorn"['$===']($case)) {return self.$require("nashorn")}
  else if ("gjs"['$===']($case)) {return self.$require("gjs")}
  else if ("nodejs"['$===']($case)) {
  self.$require("nodejs/kernel");
  return self.$require("nodejs/io");}
  else if ("headless-chrome"['$===']($case)) {return self.$require("headless_chrome")}
  else if ("opal-miniracer"['$===']($case)) {return self.$require("opal/miniracer")}
  else { return nil }})();
};

/* Generated by Opal 1.3.0.dev */
(function(Opal) {
  var $a, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$, $$ = Opal.$$, $truthy = Opal.truthy, $send = Opal.send, $ret_or_1 = nil, $ret_or_2 = nil, message = nil;

  Opal.add_stubs(['$require', '$[]', '$==', '$chomp', '$gets']);
  
  self.$require("opal/platform");
  
var CDP = require("chrome-remote-interface");
var fs = require("fs");

var dir = $$($nesting, 'ARGV')['$[]'](0)

var options = {
  host: (function() {if ($truthy(($ret_or_1 = $$($nesting, 'ENV')['$[]']("CHROME_HOST")))) {
    return $ret_or_1
  } else {
    return "localhost"
  }; return nil; })(),
  port: (function() {if ($truthy(($ret_or_2 = $$($nesting, 'ENV')['$[]']("CHROME_PORT")))) {
    return $ret_or_2
  } else {
    return 9222
  }; return nil; })()
};

CDP(options, function(client) {
  var Page = client.Page,
      Runtime = client.Runtime,
      Console = client.Console;

  Promise.all([
    Console.enable(),
    Page.enable(),
    Runtime.enable(),
  ]).then(function() {
    // This hook catches only the first argument of `console.log`
    // More advanced version Runtime.consoleAPICalled returns all arguments
    // but all of them are not formatted, i.e. by calling
    //   console.log('string', [1, 2, 3], {a: 'b'})
    // it returns the following data to the callback:
    //   {
    //     "type":"log",
    //     "args":[
    //       {
    //         "type":"string",
    //         "value":"string"
    //       },
    //       {
    //         "type":"object",
    //         "subtype":"array",
    //         "className":"Array",
    //         "description":"Array(3)",
    //         "objectId":"{\"injectedScriptId\":11,\"id\":1}",
    //         "preview":{
    //           "type":"object",
    //           "subtype":"array",
    //           "description":"Array(3)",
    //           "overflow":false,
    //           "properties":[
    //             {"name":"0","type":"number","value":"1"},
    //             {"name":"1","type":"number","value":"2"},
    //             {"name":"2","type":"number","value":"3"}
    //           ]
    //         }
    //       },
    //       {
    //         "type":"object",
    //         "className":"Object",
    //         "description":"Object",
    //         "objectId":"{\"injectedScriptId\":11,\"id\":2}",
    //         "preview":{
    //           "type":"object",
    //           "description":"Object",
    //           "overflow":false,
    //           "properties":[
    //             {"name":"a","type":"string","value":"b"}
    //           ]
    //         }
    //       }
    //     ],
    //     // ...
    //   }
    // Supporting this format for complex data structure is challenging, feel free to contribute!
    //
    Console.messageAdded(function(console_message) {
      process.stdout.write(console_message.message.text);
    });

    Runtime.exceptionThrown(function(exception) {
      var properties = exception.exceptionDetails.exception.preview.properties,
          stack, i;

      for (i = 0; i < properties.length; i++) {
        var property = properties[i];

        if (property.name == "stack") {
          stack = property.value;
        }
      }

      console.log(stack);

      process.exit(1);
    });

    Page.javascriptDialogOpening((dialog) => {
      (function() {if ((dialog.type)['$==']("prompt")) {
    
    message = ($a = self.$gets(), ($a === nil || $a == null) ? nil : $send($a, 'chomp', []));
    if ($truthy(message)) {
      return Page.handleJavaScriptDialog({accept: true, promptText: message})
    } else {
      return Page.handleJavaScriptDialog({accept: false});
    };
  } else {
    return nil
  }; return nil; })()
    });

    Page.loadEventFired(() => {
      Runtime.evaluate({ expression: "window.OPAL_EXIT_CODE" }).then(function(output) {
        client.close();

        if (typeof(output.result) !== "undefined" && output.result.type === "number") {
          process.exit(output.result.value);
        } else {
          process.exit(0);
        }
      })
    });

    Page.navigate({ url: "file://"+dir+"/index.html" })
  });
});
;
})(Opal);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzZWN0aW9ucyI6W3sib2Zmc2V0Ijp7ImxpbmUiOjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3J1bnRpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGdsb2JhbF9vYmplY3QpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLy8gQG5vdGVcbiAgLy8gICBBIGZldyBjb252ZW50aW9ucyBmb3IgdGhlIGRvY3VtZW50YXRpb24gb2YgdGhpcyBmaWxlOlxuICAvLyAgIDEuIEFsd2F5cyB1c2UgXCIvL1wiIChpbiBjb250cmFzdCB3aXRoIFwiLyoqL1wiKVxuICAvLyAgIDIuIFRoZSBzeW50YXggdXNlZCBpcyBZYXJkb2MgKHlhcmRvYy5vcmcpLCB3aGljaCBpcyBpbnRlbmRlZCBmb3IgUnVieSAoc2UgYmVsb3cpXG4gIC8vICAgMy4gYEBwYXJhbWAgYW5kIGBAcmV0dXJuYCB0eXBlcyBzaG91bGQgYmUgcHJlY2VkZWQgYnkgYEpTLmAgd2hlbiByZWZlcnJpbmcgdG9cbiAgLy8gICAgICBKYXZhU2NyaXB0IGNvbnN0cnVjdG9ycyAoZS5nLiBgSlMuRnVuY3Rpb25gKSBvdGhlcndpc2UgUnVieSBpcyBhc3N1bWVkLlxuICAvLyAgIDQuIGBuaWxgIGFuZCBgbnVsbGAgYmVpbmcgdW5hbWJpZ3VvdXMgcmVmZXIgdG8gdGhlIHJlc3BlY3RpdmVcbiAgLy8gICAgICBvYmplY3RzL3ZhbHVlcyBpbiBSdWJ5IGFuZCBKYXZhU2NyaXB0XG4gIC8vICAgNS4gVGhpcyBpcyBzdGlsbCBXSVAgOikgc28gcGxlYXNlIGdpdmUgZmVlZGJhY2sgYW5kIHN1Z2dlc3Rpb25zIG9uIGhvd1xuICAvLyAgICAgIHRvIGltcHJvdmUgb3IgZm9yIGFsdGVybmF0aXZlIHNvbHV0aW9uc1xuICAvL1xuICAvLyAgIFRoZSB3YXkgdGhlIGNvZGUgaXMgZGlnZXN0ZWQgYmVmb3JlIGdvaW5nIHRocm91Z2ggWWFyZG9jIGlzIGEgc2VjcmV0IGtlcHRcbiAgLy8gICBpbiB0aGUgZG9jcyByZXBvIChodHRwczovL2dpdGh1Yi5jb20vb3BhbC9kb2NzL3RyZWUvbWFzdGVyKS5cblxuICB2YXIgY29uc29sZTtcblxuICAvLyBEZXRlY3QgdGhlIGdsb2JhbCBvYmplY3RcbiAgaWYgKHR5cGVvZihnbG9iYWxUaGlzKSAhPT0gJ3VuZGVmaW5lZCcpIHsgZ2xvYmFsX29iamVjdCA9IGdsb2JhbFRoaXM7IH1cbiAgZWxzZSBpZiAodHlwZW9mKGdsb2JhbCkgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSBnbG9iYWw7IH1cbiAgZWxzZSBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnKSB7IGdsb2JhbF9vYmplY3QgPSB3aW5kb3c7IH1cblxuICAvLyBTZXR1cCBhIGR1bW15IGNvbnNvbGUgb2JqZWN0IGlmIG1pc3NpbmdcbiAgaWYgKHR5cGVvZihnbG9iYWxfb2JqZWN0LmNvbnNvbGUpID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnNvbGUgPSBnbG9iYWxfb2JqZWN0LmNvbnNvbGU7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsX29iamVjdC5jb25zb2xlID09IG51bGwpIHtcbiAgICBjb25zb2xlID0gZ2xvYmFsX29iamVjdC5jb25zb2xlID0ge307XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZSA9IHt9O1xuICB9XG5cbiAgaWYgKCEoJ2xvZycgaW4gY29uc29sZSkpIHsgY29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7fTsgfVxuICBpZiAoISgnd2FybicgaW4gY29uc29sZSkpIHsgY29uc29sZS53YXJuID0gY29uc29sZS5sb2c7IH1cblxuICBpZiAodHlwZW9mKGdsb2JhbF9vYmplY3QuT3BhbCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS53YXJuKCdPcGFsIGFscmVhZHkgbG9hZGVkLiBMb2FkaW5nIHR3aWNlIGNhbiBjYXVzZSB0cm91YmxlcywgcGxlYXNlIGZpeCB5b3VyIHNldHVwLicpO1xuICAgIHJldHVybiBnbG9iYWxfb2JqZWN0Lk9wYWw7XG4gIH1cblxuICB2YXIgbmlsO1xuXG4gIC8vIFRoZSBhY3R1YWwgY2xhc3MgZm9yIEJhc2ljT2JqZWN0XG4gIHZhciBCYXNpY09iamVjdDtcblxuICAvLyBUaGUgYWN0dWFsIE9iamVjdCBjbGFzcy5cbiAgLy8gVGhlIGxlYWRpbmcgdW5kZXJzY29yZSBpcyB0byBhdm9pZCBjb25mdXNpb24gd2l0aCB3aW5kb3cuT2JqZWN0KClcbiAgdmFyIF9PYmplY3Q7XG5cbiAgLy8gVGhlIGFjdHVhbCBNb2R1bGUgY2xhc3NcbiAgdmFyIE1vZHVsZTtcblxuICAvLyBUaGUgYWN0dWFsIENsYXNzIGNsYXNzXG4gIHZhciBDbGFzcztcblxuICAvLyBUaGUgT3BhbCBvYmplY3QgdGhhdCBpcyBleHBvc2VkIGdsb2JhbGx5XG4gIHZhciBPcGFsID0gZ2xvYmFsX29iamVjdC5PcGFsID0ge307XG5cbiAgLy8gVGhpcyBpcyBhIHVzZWZ1bCByZWZlcmVuY2UgdG8gZ2xvYmFsIG9iamVjdCBpbnNpZGUgcnVieSBmaWxlc1xuICBPcGFsLmdsb2JhbCA9IGdsb2JhbF9vYmplY3Q7XG4gIGdsb2JhbF9vYmplY3QuT3BhbCA9IE9wYWw7XG5cbiAgLy8gQ29uZmlndXJlIHJ1bnRpbWUgYmVoYXZpb3Igd2l0aCByZWdhcmRzIHRvIHJlcXVpcmUgYW5kIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gIE9wYWwuY29uZmlnID0ge1xuICAgIG1pc3NpbmdfcmVxdWlyZV9zZXZlcml0eTogJ2Vycm9yJywgICAgICAgIC8vIGVycm9yLCB3YXJuaW5nLCBpZ25vcmVcbiAgICB1bnN1cHBvcnRlZF9mZWF0dXJlc19zZXZlcml0eTogJ3dhcm5pbmcnLCAvLyBlcnJvciwgd2FybmluZywgaWdub3JlXG4gICAgZW5hYmxlX3N0YWNrX3RyYWNlOiB0cnVlICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2VcbiAgfTtcblxuICAvLyBNaW5pZnkgY29tbW9uIGZ1bmN0aW9uIGNhbGxzXG4gIHZhciAkaGFzX293biAgID0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgJGJpbmQgICAgICA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuICB2YXIgJHNldF9wcm90byA9IE9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiAgdmFyICRzbGljZSAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciAkc3BsaWNlICAgID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcblxuICAvLyBOaWwgb2JqZWN0IGlkIGlzIGFsd2F5cyA0XG4gIHZhciBuaWxfaWQgPSA0O1xuXG4gIC8vIEdlbmVyYXRlcyBldmVuIHNlcXVlbnRpYWwgbnVtYmVycyBncmVhdGVyIHRoYW4gNFxuICAvLyAobmlsX2lkKSB0byBzZXJ2ZSBhcyB1bmlxdWUgaWRzIGZvciBydWJ5IG9iamVjdHNcbiAgdmFyIHVuaXF1ZV9pZCA9IG5pbF9pZDtcblxuICAvLyBSZXR1cm4gbmV4dCB1bmlxdWUgaWRcbiAgT3BhbC51aWQgPSBmdW5jdGlvbigpIHtcbiAgICB1bmlxdWVfaWQgKz0gMjtcbiAgICByZXR1cm4gdW5pcXVlX2lkO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIG9yIGFzc2lnbiB0aGUgaWQgb2YgYW4gb2JqZWN0XG4gIE9wYWwuaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLiQkaXNfbnVtYmVyKSByZXR1cm4gKG9iaiAqIDIpKzE7XG4gICAgaWYgKG9iai4kJGlkICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmouJCRpZDtcbiAgICB9XG4gICAgJGRlZmluZVByb3BlcnR5KG9iaiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICByZXR1cm4gb2JqLiQkaWQ7XG4gIH07XG5cbiAgLy8gR2xvYmFscyB0YWJsZVxuICBPcGFsLmd2YXJzID0ge307XG5cbiAgLy8gRXhpdCBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmVwbGFjZWQgYnkgcGxhdGZvcm0gc3BlY2lmaWMgaW1wbGVtZW50YXRpb25cbiAgLy8gKFNlZSBub2RlanMgYW5kIGNocm9tZSBmb3IgZXhhbXBsZXMpXG4gIE9wYWwuZXhpdCA9IGZ1bmN0aW9uKHN0YXR1cykgeyBpZiAoT3BhbC5ndmFycy5ERUJVRykgY29uc29sZS5sb2coJ0V4aXRlZCB3aXRoIHN0YXR1cyAnK3N0YXR1cyk7IH07XG5cbiAgLy8ga2VlcHMgdHJhY2sgb2YgZXhjZXB0aW9ucyBmb3IgJCFcbiAgT3BhbC5leGNlcHRpb25zID0gW107XG5cbiAgLy8gQHByaXZhdGVcbiAgLy8gUG9wcyBhbiBleGNlcHRpb24gZnJvbSB0aGUgc3RhY2sgYW5kIHVwZGF0ZXMgYCQhYC5cbiAgT3BhbC5wb3BfZXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IE9wYWwuZXhjZXB0aW9ucy5wb3AoKTtcbiAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICBPcGFsLmd2YXJzW1wiIVwiXSA9IGV4Y2VwdGlvbjtcbiAgICAgIE9wYWwuZ3ZhcnNbXCJAXCJdID0gZXhjZXB0aW9uLiRiYWNrdHJhY2UoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmd2YXJzW1wiIVwiXSA9IE9wYWwuZ3ZhcnNbXCJAXCJdID0gbmlsO1xuICAgIH1cbiAgfTtcblxuICAvLyBJbnNwZWN0IGFueSBraW5kIG9mIG9iamVjdCwgaW5jbHVkaW5nIG5vbiBSdWJ5IG9uZXNcbiAgT3BhbC5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFvYmouJCRjbGFzcykge1xuICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBvYmouJGluc3BlY3QoKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZihvYmplY3QpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yOlxuICAgICAgLy8gICBzID0gXCJzdHJpbmdcIlxuICAgICAgLy8gICBkZWYgcy5tOyBlbmRcbiAgICAgIC8vIFN0cmluZyBjbGFzcyBpcyB0aGUgb25seSBjbGFzcyB0aGF0OlxuICAgICAgLy8gKyBjb21waWxlcyB0byBKUyBwcmltaXRpdmVcbiAgICAgIC8vICsgYWxsb3dzIG1ldGhvZCBkZWZpbml0aW9uIGRpcmVjdGx5IG9uIGluc3RhbmNlc1xuICAgICAgLy8gbnVtYmVycywgdHJ1ZSwgZmFsc2UgYW5kIG51bGwgZG8gbm90IHN1cHBvcnQgaXQuXG4gICAgICBvYmplY3RbbmFtZV0gPSBpbml0aWFsVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgdmFsdWU6IGluaXRpYWxWYWx1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE9wYWwuZGVmaW5lUHJvcGVydHkgPSAkZGVmaW5lUHJvcGVydHk7XG5cbiAgT3BhbC5zbGljZSA9ICRzbGljZTtcblxuXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS1cblxuICBPcGFsLnRydXRoeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsICE9PSBuaWwgJiYgdmFsICE9IG51bGwgJiYgKCF2YWwuJCRpc19ib29sZWFuIHx8IHZhbCA9PSB0cnVlKSk7XG4gIH07XG5cbiAgT3BhbC5mYWxzeSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodmFsID09PSBuaWwgfHwgdmFsID09IG51bGwgfHwgKHZhbC4kJGlzX2Jvb2xlYW4gJiYgdmFsID09IGZhbHNlKSlcbiAgfTtcblxuICBPcGFsLnR5cGVfZXJyb3IgPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZCkge1xuICAgIG9iamVjdCA9IG9iamVjdC4kJGNsYXNzO1xuXG4gICAgaWYgKGNvZXJjZWQgJiYgbWV0aG9kKSB7XG4gICAgICBjb2VyY2VkID0gY29lcmNlZC4kJGNsYXNzO1xuICAgICAgcmV0dXJuIE9wYWwuVHlwZUVycm9yLiRuZXcoXG4gICAgICAgIFwiY2FuJ3QgY29udmVydCBcIiArIG9iamVjdCArIFwiIGludG8gXCIgKyB0eXBlICtcbiAgICAgICAgXCIgKFwiICsgb2JqZWN0ICsgXCIjXCIgKyBtZXRob2QgKyBcIiBnaXZlcyBcIiArIGNvZXJjZWQgKyBcIilcIlxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5UeXBlRXJyb3IuJG5ldyhcbiAgICAgICAgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mIFwiICsgb2JqZWN0ICsgXCIgaW50byBcIiArIHR5cGVcbiAgICAgIClcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5jb2VyY2VfdG8gPSBmdW5jdGlvbihvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncykge1xuICAgIGlmICh0eXBlWyckPT09J10ob2JqZWN0KSkgcmV0dXJuIG9iamVjdDtcblxuICAgIGlmICghb2JqZWN0WyckcmVzcG9uZF90bz8nXShtZXRob2QpKSB7XG4gICAgICB0aHJvdyBPcGFsLnR5cGVfZXJyb3Iob2JqZWN0LCB0eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoYXJncyA9PSBudWxsKSBhcmdzID0gW107XG4gICAgcmV0dXJuIE9wYWwuc2VuZChvYmplY3QsIG1ldGhvZCwgYXJncyk7XG4gIH1cblxuICBPcGFsLnJlc3BvbmRfdG8gPSBmdW5jdGlvbihvYmosIGpzaWQsIGluY2x1ZGVfYWxsKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsIHx8ICFvYmouJCRjbGFzcykgcmV0dXJuIGZhbHNlO1xuICAgIGluY2x1ZGVfYWxsID0gISFpbmNsdWRlX2FsbDtcbiAgICB2YXIgYm9keSA9IG9ialtqc2lkXTtcblxuICAgIGlmIChvYmpbJyRyZXNwb25kX3RvPyddLiQkcHJpc3RpbmUpIHtcbiAgICAgIGlmIChvYmpbJyRyZXNwb25kX3RvX21pc3Npbmc/J10uJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuc2VuZChvYmosIG9ialsnJHJlc3BvbmRfdG9fbWlzc2luZz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT3BhbC5zZW5kKG9iaiwgb2JqWyckcmVzcG9uZF90bz8nXSwgW2pzaWQuc3Vic3RyKDEpLCBpbmNsdWRlX2FsbF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyYWNlUG9pbnQgc3VwcG9ydFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy9cbiAgLy8gU3VwcG9ydCBmb3IgYFRyYWNlUG9pbnQudHJhY2UoOmNsYXNzKSBkbyAuLi4gZW5kYFxuICBPcGFsLnRyYWNlX2NsYXNzID0gZmFsc2U7XG4gIE9wYWwudHJhY2Vyc19mb3JfY2xhc3MgPSBbXTtcblxuICBmdW5jdGlvbiBpbnZva2VfdHJhY2Vyc19mb3JfY2xhc3Moa2xhc3Nfb3JfbW9kdWxlKSB7XG4gICAgdmFyIGksIGlpLCB0cmFjZXI7XG5cbiAgICBmb3IoaSA9IDAsIGlpID0gT3BhbC50cmFjZXJzX2Zvcl9jbGFzcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICB0cmFjZXIgPSBPcGFsLnRyYWNlcnNfZm9yX2NsYXNzW2ldO1xuICAgICAgdHJhY2VyLnRyYWNlX29iamVjdCA9IGtsYXNzX29yX21vZHVsZTtcbiAgICAgIHRyYWNlci5ibG9jay4kY2FsbCh0cmFjZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbnN0YW50c1xuICAvLyAtLS0tLS0tLS1cbiAgLy9cbiAgLy8gRm9yIGZ1dHVyZSByZWZlcmVuY2U6XG4gIC8vIC0gVGhlIFJhaWxzIGF1dG9sb2FkaW5nIGd1aWRlIChodHRwOi8vZ3VpZGVzLnJ1YnlvbnJhaWxzLm9yZy92NS4wL2F1dG9sb2FkaW5nX2FuZF9yZWxvYWRpbmdfY29uc3RhbnRzLmh0bWwpXG4gIC8vIC0gQENvbnJhZElyd2luJ3MgMjAxMiBwb3N0IG9uIOKAnEV2ZXJ5dGhpbmcgeW91IGV2ZXIgd2FudGVkIHRvIGtub3cgYWJvdXQgY29uc3RhbnQgbG9va3VwIGluIFJ1YnnigJ0gKGh0dHA6Ly9jaXJ3LmluL2Jsb2cvY29uc3RhbnQtbG9va3VwLmh0bWwpXG4gIC8vXG4gIC8vIExlZ2VuZCBvZiBNUkkgY29uY2VwdHMvbmFtZXM6XG4gIC8vIC0gY29uc3RhbnQgcmVmZXJlbmNlIChjcmVmKTogdGhlIG1vZHVsZS9jbGFzcyB0aGF0IGFjdHMgYXMgYSBuYW1lc3BhY2VcbiAgLy8gLSBuZXN0aW5nOiB0aGUgbmFtZXNwYWNlcyB3cmFwcGluZyB0aGUgY3VycmVudCBzY29wZSwgZS5nLiBuZXN0aW5nIGluc2lkZVxuICAvLyAgICAgICAgICAgIGBtb2R1bGUgQTsgbW9kdWxlIEI6OkM7IGVuZDsgZW5kYCBpcyBgW0I6OkMsIEFdYFxuXG4gIC8vIEdldCB0aGUgY29uc3RhbnQgaW4gdGhlIHNjb3BlIG9mIHRoZSBjdXJyZW50IGNyZWZcbiAgZnVuY3Rpb24gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmKSByZXR1cm4gY3JlZi4kJGNvbnN0W25hbWVdO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgbmVzdGluZyBhcnJheSBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX25lc3RpbmcobmVzdGluZywgbmFtZSkge1xuICAgIHZhciBpLCBpaSwgY29uc3RhbnQ7XG5cbiAgICBpZiAobmVzdGluZy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIC8vIElmIHRoZSBuZXN0aW5nIGlzIG5vdCBlbXB0eSB0aGUgY29uc3RhbnQgaXMgbG9va2VkIHVwIGluIGl0cyBlbGVtZW50c1xuICAgIC8vIGFuZCBpbiBvcmRlci4gVGhlIGFuY2VzdG9ycyBvZiB0aG9zZSBlbGVtZW50cyBhcmUgaWdub3JlZC5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IG5lc3RpbmcubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3RhbnQgPSBuZXN0aW5nW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICBpZiAoY29uc3RhbnQgIT0gbnVsbCkgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIGFuY2VzdG9ycyBjaGFpbiBsb29raW5nIGZvciB0aGUgY29uc3RhbnRcbiAgZnVuY3Rpb24gY29uc3RfbG9va3VwX2FuY2VzdG9ycyhjcmVmLCBuYW1lKSB7XG4gICAgdmFyIGksIGlpLCBhbmNlc3RvcnM7XG5cbiAgICBpZiAoY3JlZiA9PSBudWxsKSByZXR1cm47XG5cbiAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhjcmVmKTtcblxuICAgIGZvciAoaSA9IDAsIGlpID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChhbmNlc3RvcnNbaV0uJCRjb25zdCAmJiAkaGFzX293bi5jYWxsKGFuY2VzdG9yc1tpXS4kJGNvbnN0LCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3JzW2ldLiQkY29uc3RbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2FsayB1cCBPYmplY3QncyBhbmNlc3RvcnMgY2hhaW4gbG9va2luZyBmb3IgdGhlIGNvbnN0YW50LFxuICAvLyBidXQgb25seSBpZiBjcmVmIGlzIG1pc3Npbmcgb3IgYSBtb2R1bGUuXG4gIGZ1bmN0aW9uIGNvbnN0X2xvb2t1cF9PYmplY3QoY3JlZiwgbmFtZSkge1xuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZi4kJGlzX21vZHVsZSkge1xuICAgICAgcmV0dXJuIGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbCBjb25zdF9taXNzaW5nIGlmIG5vdGhpbmcgZWxzZSB3b3JrZWRcbiAgZnVuY3Rpb24gY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICBpZiAoIXNraXBfbWlzc2luZykge1xuICAgICAgcmV0dXJuIChjcmVmIHx8IF9PYmplY3QpLiRjb25zdF9taXNzaW5nKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIExvb2sgZm9yIHRoZSBjb25zdGFudCBqdXN0IGluIHRoZSBjdXJyZW50IGNyZWYgb3IgY2FsbCBgI2NvbnN0X21pc3NpbmdgXG4gIE9wYWwuY29uc3RfZ2V0X2xvY2FsID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChjcmVmID09IG51bGwpIHJldHVybjtcblxuICAgIGlmIChjcmVmID09PSAnOjonKSBjcmVmID0gX09iamVjdDtcblxuICAgIGlmICghY3JlZi4kJGlzX21vZHVsZSAmJiAhY3JlZi4kJGlzX2NsYXNzKSB7XG4gICAgICB0aHJvdyBuZXcgT3BhbC5UeXBlRXJyb3IoY3JlZi50b1N0cmluZygpICsgXCIgaXMgbm90IGEgY2xhc3MvbW9kdWxlXCIpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IGNvbnN0X2dldF9uYW1lKGNyZWYsIG5hbWUpOyAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIHJlc3VsdCA9IGNvbnN0X21pc3NpbmcoY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKTsgaWYgKHJlc3VsdCAhPSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIExvb2sgZm9yIHRoZSBjb25zdGFudCByZWxhdGl2ZSB0byBhIGNyZWYgb3IgY2FsbCBgI2NvbnN0X21pc3NpbmdgICh3aGVuIHRoZVxuICAvLyBjb25zdGFudCBpcyBwcmVmaXhlZCBieSBgOjpgKS5cbiAgT3BhbC5jb25zdF9nZXRfcXVhbGlmaWVkID0gZnVuY3Rpb24oY3JlZiwgbmFtZSwgc2tpcF9taXNzaW5nKSB7XG4gICAgdmFyIHJlc3VsdCwgY2FjaGUsIGNhY2hlZCwgY3VycmVudF92ZXJzaW9uID0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uO1xuXG4gICAgaWYgKGNyZWYgPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKGNyZWYgPT09ICc6OicpIGNyZWYgPSBfT2JqZWN0O1xuXG4gICAgaWYgKCFjcmVmLiQkaXNfbW9kdWxlICYmICFjcmVmLiQkaXNfY2xhc3MpIHtcbiAgICAgIHRocm93IG5ldyBPcGFsLlR5cGVFcnJvcihjcmVmLnRvU3RyaW5nKCkgKyBcIiBpcyBub3QgYSBjbGFzcy9tb2R1bGVcIik7XG4gICAgfVxuXG4gICAgaWYgKChjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNyZWYsICckJGNvbnN0X2NhY2hlJywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBjYWNoZSA9IGNyZWYuJCRjb25zdF9jYWNoZTtcbiAgICB9XG4gICAgY2FjaGVkID0gY2FjaGVbbmFtZV07XG5cbiAgICBpZiAoY2FjaGVkID09IG51bGwgfHwgY2FjaGVkWzBdICE9PSBjdXJyZW50X3ZlcnNpb24pIHtcbiAgICAgICgocmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkpICAgICAgICAgICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfYW5jZXN0b3JzKGNyZWYsIG5hbWUpKSAgICAgICE9IG51bGwpO1xuICAgICAgY2FjaGVbbmFtZV0gPSBbY3VycmVudF92ZXJzaW9uLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpO1xuICB9O1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHRvcCBsZXZlbCBjb25zdGFudCBjYWNoZSBnZW5lcmF0aW9uIGNvdW50ZXJcbiAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uID0gMTtcblxuICAvLyBMb29rIGZvciB0aGUgY29uc3RhbnQgaW4gdGhlIG9wZW4gdXNpbmcgdGhlIGN1cnJlbnQgbmVzdGluZyBhbmQgdGhlIG5lYXJlc3RcbiAgLy8gY3JlZiBhbmNlc3RvcnMgb3IgY2FsbCBgI2NvbnN0X21pc3NpbmdgICh3aGVuIHRoZSBjb25zdGFudCBoYXMgbm8gOjogcHJlZml4KS5cbiAgT3BhbC5jb25zdF9nZXRfcmVsYXRpdmUgPSBmdW5jdGlvbihuZXN0aW5nLCBuYW1lLCBza2lwX21pc3NpbmcpIHtcbiAgICB2YXIgY3JlZiA9IG5lc3RpbmdbMF0sIHJlc3VsdCwgY3VycmVudF92ZXJzaW9uID0gT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uLCBjYWNoZSwgY2FjaGVkO1xuXG4gICAgaWYgKChjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZSkgPT0gbnVsbCkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KG5lc3RpbmcsICckJGNvbnN0X2NhY2hlJywgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICBjYWNoZSA9IG5lc3RpbmcuJCRjb25zdF9jYWNoZTtcbiAgICB9XG4gICAgY2FjaGVkID0gY2FjaGVbbmFtZV07XG5cbiAgICBpZiAoY2FjaGVkID09IG51bGwgfHwgY2FjaGVkWzBdICE9PSBjdXJyZW50X3ZlcnNpb24pIHtcbiAgICAgICgocmVzdWx0ID0gY29uc3RfZ2V0X25hbWUoY3JlZiwgbmFtZSkpICAgICAgICAgICAgICAhPSBudWxsKSB8fFxuICAgICAgKChyZXN1bHQgPSBjb25zdF9sb29rdXBfbmVzdGluZyhuZXN0aW5nLCBuYW1lKSkgICAgICE9IG51bGwpIHx8XG4gICAgICAoKHJlc3VsdCA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoY3JlZiwgbmFtZSkpICAgICAgIT0gbnVsbCkgfHxcbiAgICAgICgocmVzdWx0ID0gY29uc3RfbG9va3VwX09iamVjdChjcmVmLCBuYW1lKSkgICAgICAgICAhPSBudWxsKTtcblxuICAgICAgY2FjaGVbbmFtZV0gPSBbY3VycmVudF92ZXJzaW9uLCByZXN1bHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBjYWNoZWRbMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogY29uc3RfbWlzc2luZyhjcmVmLCBuYW1lLCBza2lwX21pc3NpbmcpO1xuICB9O1xuXG4gIC8vIFJlZ2lzdGVyIHRoZSBjb25zdGFudCBvbiBhIGNyZWYgYW5kIG9wcG9ydHVuaXN0aWNhbGx5IHNldCB0aGUgbmFtZSBvZlxuICAvLyB1bm5hbWVkIGNsYXNzZXMvbW9kdWxlcy5cbiAgT3BhbC5jb25zdF9zZXQgPSBmdW5jdGlvbihjcmVmLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChjcmVmID09IG51bGwgfHwgY3JlZiA9PT0gJzo6JykgY3JlZiA9IF9PYmplY3Q7XG5cbiAgICBpZiAodmFsdWUuJCRpc19hX21vZHVsZSkge1xuICAgICAgaWYgKHZhbHVlLiQkbmFtZSA9PSBudWxsIHx8IHZhbHVlLiQkbmFtZSA9PT0gbmlsKSB2YWx1ZS4kJG5hbWUgPSBuYW1lO1xuICAgICAgaWYgKHZhbHVlLiQkYmFzZV9tb2R1bGUgPT0gbnVsbCkgdmFsdWUuJCRiYXNlX21vZHVsZSA9IGNyZWY7XG4gICAgfVxuXG4gICAgY3JlZi4kJGNvbnN0ID0gKGNyZWYuJCRjb25zdCB8fCBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBjcmVmLiQkY29uc3RbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEFkZCBhIHNob3J0IGhlbHBlciB0byBuYXZpZ2F0ZSBjb25zdGFudHMgbWFudWFsbHkuXG4gICAgLy8gQGV4YW1wbGVcbiAgICAvLyAgIE9wYWwuJCQuUmVnZXhwLiQkLklHTk9SRUNBU0VcbiAgICBjcmVmLiQkID0gY3JlZi4kJGNvbnN0O1xuXG4gICAgT3BhbC5jb25zdF9jYWNoZV92ZXJzaW9uKys7XG5cbiAgICAvLyBFeHBvc2UgdG9wIGxldmVsIGNvbnN0YW50cyBvbnRvIHRoZSBPcGFsIG9iamVjdFxuICAgIGlmIChjcmVmID09PSBfT2JqZWN0KSBPcGFsW25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBOYW1lIG5ldyBjbGFzcyBkaXJlY3RseSBvbnRvIGN1cnJlbnQgc2NvcGUgKE9wYWwuRm9vLkJheiA9IGtsYXNzKVxuICAgICRkZWZpbmVQcm9wZXJ0eShjcmVmLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0IGFsbCB0aGUgY29uc3RhbnRzIHJlYWNoYWJsZSBmcm9tIGEgZ2l2ZW4gY3JlZiwgYnkgZGVmYXVsdCB3aWxsIGluY2x1ZGVcbiAgLy8gaW5oZXJpdGVkIGNvbnN0YW50cy5cbiAgT3BhbC5jb25zdGFudHMgPSBmdW5jdGlvbihjcmVmLCBpbmhlcml0KSB7XG4gICAgaWYgKGluaGVyaXQgPT0gbnVsbCkgaW5oZXJpdCA9IHRydWU7XG5cbiAgICB2YXIgbW9kdWxlLCBtb2R1bGVzID0gW2NyZWZdLCBpLCBpaSwgY29uc3RhbnRzID0ge30sIGNvbnN0YW50O1xuXG4gICAgaWYgKGluaGVyaXQpIG1vZHVsZXMgPSBtb2R1bGVzLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhjcmVmKSk7XG4gICAgaWYgKGluaGVyaXQgJiYgY3JlZi4kJGlzX21vZHVsZSkgbW9kdWxlcyA9IG1vZHVsZXMuY29uY2F0KFtPcGFsLk9iamVjdF0pLmNvbmNhdChPcGFsLmFuY2VzdG9ycyhPcGFsLk9iamVjdCkpO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG1vZHVsZSA9IG1vZHVsZXNbaV07XG5cbiAgICAgIC8vIERvIG5vdCBzaG93IE9iamVjdHMgY29uc3RhbnRzIHVubGVzcyB3ZSdyZSBxdWVyeWluZyBPYmplY3QgaXRzZWxmXG4gICAgICBpZiAoY3JlZiAhPT0gX09iamVjdCAmJiBtb2R1bGUgPT0gX09iamVjdCkgYnJlYWs7XG5cbiAgICAgIGZvciAoY29uc3RhbnQgaW4gbW9kdWxlLiQkY29uc3QpIHtcbiAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbnN0YW50cyk7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGEgY29uc3RhbnQgZnJvbSBhIGNyZWYuXG4gIE9wYWwuY29uc3RfcmVtb3ZlID0gZnVuY3Rpb24oY3JlZiwgbmFtZSkge1xuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuXG4gICAgaWYgKGNyZWYuJCRjb25zdFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICB2YXIgb2xkID0gY3JlZi4kJGNvbnN0W25hbWVdO1xuICAgICAgZGVsZXRlIGNyZWYuJCRjb25zdFtuYW1lXTtcbiAgICAgIHJldHVybiBvbGQ7XG4gICAgfVxuXG4gICAgaWYgKGNyZWYuJCRhdXRvbG9hZCAhPSBudWxsICYmIGNyZWYuJCRhdXRvbG9hZFtuYW1lXSAhPSBudWxsKSB7XG4gICAgICBkZWxldGUgY3JlZi4kJGF1dG9sb2FkW25hbWVdO1xuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG5cbiAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwiY29uc3RhbnQgXCIrY3JlZitcIjo6XCIrY3JlZi4kbmFtZSgpK1wiIG5vdCBkZWZpbmVkXCIpO1xuICB9O1xuXG4gIC8vIFNldHVwIHNvbWUgc2hvcnRjdXRzIHRvIHJlZHVjZSBjb21waWxlZCBzaXplXG4gIE9wYWwuJCQgPSBPcGFsLmNvbnN0X2dldF9yZWxhdGl2ZTtcbiAgT3BhbC4kJCQgPSBPcGFsLmNvbnN0X2dldF9xdWFsaWZpZWQ7XG5cblxuICAvLyBNb2R1bGVzICYgQ2xhc3Nlc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEEgYGNsYXNzIEZvbzsgZW5kYCBleHByZXNzaW9uIGluIHJ1YnkgaXMgY29tcGlsZWQgdG8gY2FsbCB0aGlzIHJ1bnRpbWVcbiAgLy8gbWV0aG9kIHdoaWNoIGVpdGhlciByZXR1cm5zIGFuIGV4aXN0aW5nIGNsYXNzIG9mIHRoZSBnaXZlbiBuYW1lLCBvciBjcmVhdGVzXG4gIC8vIGEgbmV3IGNsYXNzIGluIHRoZSBnaXZlbiBgYmFzZWAgc2NvcGUuXG4gIC8vXG4gIC8vIElmIGEgY29uc3RhbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMsIHRoZW4gd2UgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXRcbiAgLy8gaXQgaXMgYSBjbGFzcyBhbmQgYWxzbyB0aGF0IHRoZSBzdXBlcmNsYXNzZXMgbWF0Y2guIElmIGVpdGhlciBvZiB0aGVzZVxuICAvLyBmYWlsLCB0aGVuIHdlIHJhaXNlIGEgYFR5cGVFcnJvcmAuIE5vdGUsIGBzdXBlcmNsYXNzYCBtYXkgYmUgbnVsbCBpZiBvbmVcbiAgLy8gd2FzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHJ1YnkgY29kZS5cbiAgLy9cbiAgLy8gV2UgcGFzcyBhIGNvbnN0cnVjdG9yIHRvIHRoaXMgbWV0aG9kIG9mIHRoZSBmb3JtIGBmdW5jdGlvbiBDbGFzc05hbWUoKSB7fWBcbiAgLy8gc2ltcGx5IHNvIHRoYXQgY2xhc3NlcyBzaG93IHVwIHdpdGggbmljZWx5IGZvcm1hdHRlZCBuYW1lcyBpbnNpZGUgZGVidWdnZXJzXG4gIC8vIGluIHRoZSB3ZWIgYnJvd3NlciAob3Igbm9kZS9zcHJvY2tldHMpLlxuICAvL1xuICAvLyBUaGUgYHNjb3BlYCBpcyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgd2hlcmUgdGhlIGNsYXNzIGlzIGJlaW5nIGNyZWF0ZWRcbiAgLy8gZnJvbS4gV2UgdXNlIHRoaXMgdG8gZ2V0IHRoZSBzY29wZSBmb3Igd2hlcmUgdGhlIGNsYXNzIHNob3VsZCBiZSBjcmVhdGVkLlxuICAvLyBJZiBgc2NvcGVgIGlzIGFuIG9iamVjdCAobm90IGEgY2xhc3MvbW9kdWxlKSwgd2Ugc2ltcGxlIGdldCBpdHMgY2xhc3MgYW5kXG4gIC8vIHVzZSB0aGF0IGFzIHRoZSBzY29wZSBpbnN0ZWFkLlxuICAvL1xuICAvLyBAcGFyYW0gc2NvcGUgICAgICAgIFtPYmplY3RdIHdoZXJlIHRoZSBjbGFzcyBpcyBiZWluZyBjcmVhdGVkXG4gIC8vIEBwYXJhbSBzdXBlcmNsYXNzICBbQ2xhc3MsbnVsbF0gc3VwZXJjbGFzcyBvZiB0aGUgbmV3IGNsYXNzIChtYXkgYmUgbnVsbClcbiAgLy8gQHBhcmFtIGlkICAgICAgICAgIFtTdHJpbmddIHRoZSBuYW1lIG9mIHRoZSBjbGFzcyB0byBiZSBjcmVhdGVkXG4gIC8vIEBwYXJhbSBjb25zdHJ1Y3RvciBbSlMuRnVuY3Rpb25dIGZ1bmN0aW9uIHRvIHVzZSBhcyBjb25zdHJ1Y3RvclxuICAvL1xuICAvLyBAcmV0dXJuIG5ldyBbQ2xhc3NdICBvciBleGlzdGluZyBydWJ5IGNsYXNzXG4gIC8vXG4gIE9wYWwuYWxsb2NhdGVfY2xhc3MgPSBmdW5jdGlvbihuYW1lLCBzdXBlcmNsYXNzKSB7XG4gICAgdmFyIGtsYXNzLCBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChzdXBlcmNsYXNzICE9IG51bGwgJiYgc3VwZXJjbGFzcy4kJGJyaWRnZSkge1xuICAgICAgLy8gSW5oZXJpdGFuY2UgZnJvbSBicmlkZ2VkIGNsYXNzZXMgcmVxdWlyZXNcbiAgICAgIC8vIGNhbGxpbmcgb3JpZ2luYWwgSlMgY29uc3RydWN0b3JzXG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgICAgICBzZWxmID0gbmV3ICgkYmluZC5hcHBseShzdXBlcmNsYXNzLiQkY29uc3RydWN0b3IsIFtudWxsXS5jb25jYXQoYXJncykpKSgpO1xuXG4gICAgICAgIC8vIGFuZCByZXBsYWNpbmcgYSBfX3Byb3RvX18gbWFudWFsbHlcbiAgICAgICAgJHNldF9wcm90byhzZWxmLCBrbGFzcy4kJHByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCAnOjonK25hbWUpO1xuICAgIH1cblxuICAgIGtsYXNzID0gY29uc3RydWN0b3I7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0cnVjdG9yJywgY29uc3RydWN0b3IpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkaXNfY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRzdXBlcicsIHN1cGVyY2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRvd25faW5jbHVkZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG93bl9wcmVwZW5kZWRfbW9kdWxlcycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9ycycsIFtdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJGFuY2VzdG9yc19jYWNoZV92ZXJzaW9uJywgbnVsbCk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuXG4gICAgLy8gQnkgZGVmYXVsdCBpZiB0aGVyZSBhcmUgbm8gc2luZ2xldG9uIGNsYXNzIG1ldGhvZHNcbiAgICAvLyBfX3Byb3RvX18gaXMgQ2xhc3MucHJvdG90eXBlXG4gICAgLy8gTGF0ZXIgc2luZ2xldG9uIG1ldGhvZHMgZ2VuZXJhdGUgYSBzaW5nbGV0b25fY2xhc3NcbiAgICAvLyBhbmQgaW5qZWN0IGl0IGludG8gYW5jZXN0b3JzIGNoYWluXG4gICAgaWYgKE9wYWwuQ2xhc3MpIHtcbiAgICAgICRzZXRfcHJvdG8oa2xhc3MsIE9wYWwuQ2xhc3MucHJvdG90eXBlKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwZXJjbGFzcyAhPSBudWxsKSB7XG4gICAgICAkc2V0X3Byb3RvKGtsYXNzLiQkcHJvdG90eXBlLCBzdXBlcmNsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgaWYgKHN1cGVyY2xhc3MuJCRtZXRhKSB7XG4gICAgICAgIC8vIElmIHN1cGVyY2xhc3MgaGFzIG1ldGFjbGFzcyB0aGVuIHdlIGhhdmUgZXhwbGljaXRlbHkgaW5oZXJpdCBpdC5cbiAgICAgICAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3Moa2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfY2xhc3Moc2NvcGUsIG5hbWUpIHtcbiAgICAvLyBUcnkgdG8gZmluZCB0aGUgY2xhc3MgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICB2YXIga2xhc3MgPSBjb25zdF9nZXRfbmFtZShzY29wZSwgbmFtZSk7XG5cbiAgICAvLyBJZiB0aGUgY2xhc3MgZXhpc3RzIGluIHRoZSBzY29wZSwgdGhlbiB3ZSBtdXN0IHVzZSB0aGF0XG4gICAgaWYgKGtsYXNzKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGV4aXN0aW5nIGNvbnN0YW50IGlzIGEgY2xhc3MsIG9yIHJhaXNlIGVycm9yXG4gICAgICBpZiAoIWtsYXNzLiQkaXNfY2xhc3MpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgY2xhc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBrbGFzcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVTdXBlcmNsYXNzTWF0Y2goa2xhc3MsIHN1cGVyY2xhc3MpIHtcbiAgICBpZiAoa2xhc3MuJCRzdXBlciAhPT0gc3VwZXJjbGFzcykge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcInN1cGVyY2xhc3MgbWlzbWF0Y2ggZm9yIGNsYXNzIFwiICsga2xhc3MuJCRuYW1lKTtcbiAgICB9XG4gIH1cblxuICBPcGFsLmtsYXNzID0gZnVuY3Rpb24oc2NvcGUsIHN1cGVyY2xhc3MsIG5hbWUpIHtcbiAgICB2YXIgYnJpZGdlZDtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc3VwZXJjbGFzcyBpcyBub3QgYW4gT3BhbC1nZW5lcmF0ZWQgY2xhc3MgdGhlbiB3ZSdyZSBicmlkZ2luZyBhIG5hdGl2ZSBKUyBjbGFzc1xuICAgIGlmIChcbiAgICAgIHN1cGVyY2xhc3MgIT0gbnVsbCAmJiAoIXN1cGVyY2xhc3MuaGFzT3duUHJvcGVydHkgfHwgKFxuICAgICAgICBzdXBlcmNsYXNzLmhhc093blByb3BlcnR5ICYmICFzdXBlcmNsYXNzLmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJylcbiAgICAgICkpXG4gICAgKSB7XG4gICAgICBpZiAoc3VwZXJjbGFzcy5jb25zdHJ1Y3RvciAmJiBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJGdW5jdGlvblwiKSB7XG4gICAgICAgIGJyaWRnZWQgPSBzdXBlcmNsYXNzO1xuICAgICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzcyAoXCIgKyAoXG4gICAgICAgICAgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IgJiYgKHN1cGVyY2xhc3MuY29uc3RydWN0b3IubmFtZSB8fCBzdXBlcmNsYXNzLmNvbnN0cnVjdG9yLiQkbmFtZSkpIHx8XG4gICAgICAgICAgdHlwZW9mKHN1cGVyY2xhc3MpXG4gICAgICAgICkgKyBcIiBnaXZlbilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtsYXNzID0gZmluZF9leGlzdGluZ19jbGFzcyhzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAoa2xhc3MpIHtcbiAgICAgIGlmIChzdXBlcmNsYXNzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBleGlzdGluZyBjbGFzcyBoYXMgc2FtZSBzdXBlcmNsYXNzXG4gICAgICAgIGVuc3VyZVN1cGVyY2xhc3NNYXRjaChrbGFzcywgc3VwZXJjbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzcyk7IH1cblxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cblxuICAgIC8vIENsYXNzIGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCBnaXZlbiBzdXBlcmNsYXNzLi4uXG5cbiAgICAvLyBOb3Qgc3BlY2lmeWluZyBhIHN1cGVyY2xhc3MgbWVhbnMgd2UgY2FuIGFzc3VtZSBpdCB0byBiZSBPYmplY3RcbiAgICBpZiAoc3VwZXJjbGFzcyA9PSBudWxsKSB7XG4gICAgICBzdXBlcmNsYXNzID0gX09iamVjdDtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIGNsYXNzIG9iamVjdCAoaW5zdGFuY2Ugb2YgQ2xhc3MpXG4gICAga2xhc3MgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG5hbWUsIHN1cGVyY2xhc3MpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBrbGFzcyk7XG5cbiAgICAvLyBDYWxsIC5pbmhlcml0ZWQoKSBob29rIHdpdGggbmV3IGNsYXNzIG9uIHRoZSBzdXBlcmNsYXNzXG4gICAgaWYgKHN1cGVyY2xhc3MuJGluaGVyaXRlZCkge1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlZCkge1xuICAgICAgT3BhbC5icmlkZ2UoYnJpZGdlZCwga2xhc3MpO1xuICAgIH1cblxuICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhrbGFzcyk7IH1cblxuICAgIHJldHVybiBrbGFzcztcbiAgfTtcblxuICAvLyBEZWZpbmUgbmV3IG1vZHVsZSAob3IgcmV0dXJuIGV4aXN0aW5nIG1vZHVsZSkuIFRoZSBnaXZlbiBgc2NvcGVgIGlzIGJhc2ljYWxseVxuICAvLyB0aGUgY3VycmVudCBgc2VsZmAgdmFsdWUgdGhlIGBtb2R1bGVgIHN0YXRlbWVudCB3YXMgZGVmaW5lZCBpbi4gSWYgdGhpcyBpc1xuICAvLyBhIHJ1YnkgbW9kdWxlIG9yIGNsYXNzLCB0aGVuIGl0IGlzIHVzZWQsIG90aGVyd2lzZSBpZiB0aGUgc2NvcGUgaXMgYSBydWJ5XG4gIC8vIG9iamVjdCB0aGVuIHRoYXQgb2JqZWN0cyByZWFsIHJ1YnkgY2xhc3MgaXMgdXNlZCAoZS5nLiBpZiB0aGUgc2NvcGUgaXMgdGhlXG4gIC8vIG1haW4gb2JqZWN0LCB0aGVuIHRoZSB0b3AgbGV2ZWwgYE9iamVjdGAgY2xhc3MgaXMgdXNlZCBhcyB0aGUgc2NvcGUpLlxuICAvL1xuICAvLyBJZiBhIG1vZHVsZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpcyBhbHJlYWR5IGRlZmluZWQgaW4gdGhlIHNjb3BlLCB0aGVuIHRoYXRcbiAgLy8gaW5zdGFuY2UgaXMganVzdCByZXR1cm5lZC5cbiAgLy9cbiAgLy8gSWYgdGhlcmUgaXMgYSBjbGFzcyBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgc2NvcGUsIHRoZW4gYW4gZXJyb3IgaXNcbiAgLy8gZ2VuZXJhdGVkIGluc3RlYWQgKGNhbm5vdCBoYXZlIGEgY2xhc3MgYW5kIG1vZHVsZSBvZiBzYW1lIG5hbWUgaW4gc2FtZSBzY29wZSkuXG4gIC8vXG4gIC8vIE90aGVyd2lzZSwgYSBuZXcgbW9kdWxlIGlzIGNyZWF0ZWQgaW4gdGhlIHNjb3BlIHdpdGggdGhlIGdpdmVuIG5hbWUsIGFuZCB0aGF0XG4gIC8vIG5ldyBpbnN0YW5jZSBpcyByZXR1cm5lZCBiYWNrICh0byBiZSByZWZlcmVuY2VkIGF0IHJ1bnRpbWUpLlxuICAvL1xuICAvLyBAcGFyYW0gIHNjb3BlIFtNb2R1bGUsIENsYXNzXSBjbGFzcyBvciBtb2R1bGUgdGhpcyBkZWZpbml0aW9uIGlzIGluc2lkZVxuICAvLyBAcGFyYW0gIGlkICAgW1N0cmluZ10gdGhlIG5hbWUgb2YgdGhlIG5ldyAob3IgZXhpc3RpbmcpIG1vZHVsZVxuICAvL1xuICAvLyBAcmV0dXJuIFtNb2R1bGVdXG4gIE9wYWwuYWxsb2NhdGVfbW9kdWxlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKCl7fTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuJCRjb25zdHJ1Y3RvcicpO1xuICAgIH1cblxuICAgIHZhciBtb2R1bGUgPSBjb25zdHJ1Y3RvcjtcblxuICAgIGlmIChuYW1lKVxuICAgICAgJGRlZmluZVByb3BlcnR5KGNvbnN0cnVjdG9yLCAnZGlzcGxheU5hbWUnLCBuYW1lKycuY29uc3RydWN0b3InKTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJG5hbWUnLCBuYW1lKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRwcm90b3R5cGUnLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGNvbnN0Jywge30pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX21vZHVsZScsIHRydWUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGlzX2FfbW9kdWxlJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkY3ZhcnMnLCB7fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkaWNsYXNzZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX2luY2x1ZGVkX21vZHVsZXMnLCBbXSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1vZHVsZSwgJyQkb3duX3ByZXBlbmRlZF9tb2R1bGVzJywgW10pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShtb2R1bGUsICckJGFuY2VzdG9ycycsIFttb2R1bGVdKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbicsIG51bGwpO1xuXG4gICAgJHNldF9wcm90byhtb2R1bGUsIE9wYWwuTW9kdWxlLnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gbW9kdWxlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZpbmRfZXhpc3RpbmdfbW9kdWxlKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZSA9IGNvbnN0X2dldF9uYW1lKHNjb3BlLCBuYW1lKTtcbiAgICBpZiAobW9kdWxlID09IG51bGwgJiYgc2NvcGUgPT09IF9PYmplY3QpIG1vZHVsZSA9IGNvbnN0X2xvb2t1cF9hbmNlc3RvcnMoX09iamVjdCwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG4gICAgICBpZiAoIW1vZHVsZS4kJGlzX21vZHVsZSAmJiBtb2R1bGUgIT09IF9PYmplY3QpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhuYW1lICsgXCIgaXMgbm90IGEgbW9kdWxlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH1cblxuICBPcGFsLm1vZHVsZSA9IGZ1bmN0aW9uKHNjb3BlLCBuYW1lKSB7XG4gICAgdmFyIG1vZHVsZTtcblxuICAgIGlmIChzY29wZSA9PSBudWxsIHx8IHNjb3BlID09ICc6OicpIHtcbiAgICAgIC8vIEdsb2JhbCBzY29wZVxuICAgICAgc2NvcGUgPSBfT2JqZWN0O1xuICAgIH0gZWxzZSBpZiAoIXNjb3BlLiQkaXNfY2xhc3MgJiYgIXNjb3BlLiQkaXNfbW9kdWxlKSB7XG4gICAgICAvLyBTY29wZSBpcyBhbiBvYmplY3QsIHVzZSBpdHMgY2xhc3NcbiAgICAgIHNjb3BlID0gc2NvcGUuJCRjbGFzcztcbiAgICB9XG5cbiAgICBtb2R1bGUgPSBmaW5kX2V4aXN0aW5nX21vZHVsZShzY29wZSwgbmFtZSk7XG5cbiAgICBpZiAobW9kdWxlKSB7XG5cbiAgICAgIGlmIChPcGFsLnRyYWNlX2NsYXNzKSB7IGludm9rZV90cmFjZXJzX2Zvcl9jbGFzcyhtb2R1bGUpOyB9XG5cbiAgICAgIHJldHVybiBtb2R1bGU7XG4gICAgfVxuXG4gICAgLy8gTW9kdWxlIGRvZXNudCBleGlzdCwgY3JlYXRlIGEgbmV3IG9uZS4uLlxuICAgIG1vZHVsZSA9IE9wYWwuYWxsb2NhdGVfbW9kdWxlKG5hbWUpO1xuICAgIE9wYWwuY29uc3Rfc2V0KHNjb3BlLCBuYW1lLCBtb2R1bGUpO1xuXG4gICAgaWYgKE9wYWwudHJhY2VfY2xhc3MpIHsgaW52b2tlX3RyYWNlcnNfZm9yX2NsYXNzKG1vZHVsZSk7IH1cblxuICAgIHJldHVybiBtb2R1bGU7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBzaW5nbGV0b24gY2xhc3MgZm9yIHRoZSBwYXNzZWQgb2JqZWN0LlxuICAvL1xuICAvLyBJZiB0aGUgZ2l2ZW4gb2JqZWN0IGFscmVkeSBoYXMgYSBzaW5nbGV0b24gY2xhc3MsIHRoZW4gaXQgd2lsbCBiZSBzdG9yZWQgb25cbiAgLy8gdGhlIG9iamVjdCBhcyB0aGUgYCQkbWV0YWAgcHJvcGVydHkuIElmIHRoaXMgZXhpc3RzLCB0aGVuIGl0IGlzIHNpbXBseVxuICAvLyByZXR1cm5lZCBiYWNrLlxuICAvL1xuICAvLyBPdGhlcndpc2UsIGEgbmV3IHNpbmdsZXRvbiBvYmplY3QgZm9yIHRoZSBjbGFzcyBvciBvYmplY3QgaXMgY3JlYXRlZCwgc2V0IG9uXG4gIC8vIHRoZSBvYmplY3QgYXQgYCQkbWV0YWAgZm9yIGZ1dHVyZSB1c2UsIGFuZCB0aGVuIHJldHVybmVkLlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdIHRoZSBydWJ5IG9iamVjdFxuICAvLyBAcmV0dXJuIFtDbGFzc10gdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3Igb2JqZWN0XG4gIE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuJCRtZXRhKSB7XG4gICAgICByZXR1cm4gb2JqZWN0LiQkbWV0YTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX2NsYXNzJykpIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX2NsYXNzX3NpbmdsZXRvbl9jbGFzcyhvYmplY3QpO1xuICAgIH0gZWxzZSBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KCckJGlzX21vZHVsZScpKSB7XG4gICAgICByZXR1cm4gT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzKG9iamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3Mob2JqZWN0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQnVpbGQgdGhlIHNpbmdsZXRvbiBjbGFzcyBmb3IgYW4gZXhpc3RpbmcgY2xhc3MuIENsYXNzIG9iamVjdCBhcmUgYnVpbHRcbiAgLy8gd2l0aCB0aGVpciBzaW5nbGV0b24gY2xhc3MgYWxyZWFkeSBpbiB0aGUgcHJvdG90eXBlIGNoYWluIGFuZCBpbmhlcml0aW5nXG4gIC8vIGZyb20gdGhlaXIgc3VwZXJjbGFzcyBvYmplY3QgKHVwIHRvIGBDbGFzc2AgaXRzZWxmKS5cbiAgLy9cbiAgLy8gTk9URTogQWN0dWFsbHkgaW4gTVJJIGEgY2xhc3MnIHNpbmdsZXRvbiBjbGFzcyBpbmhlcml0cyBmcm9tIGl0c1xuICAvLyBzdXBlcmNsYXNzJyBzaW5nbGV0b24gY2xhc3Mgd2hpY2ggaW4gdHVybiBpbmhlcml0cyBmcm9tIENsYXNzLlxuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgW0NsYXNzXVxuICAvLyBAcmV0dXJuIFtDbGFzc11cbiAgT3BhbC5idWlsZF9jbGFzc19zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihrbGFzcykge1xuICAgIHZhciBzdXBlcmNsYXNzLCBtZXRhO1xuXG4gICAgaWYgKGtsYXNzLiQkbWV0YSkge1xuICAgICAgcmV0dXJuIGtsYXNzLiQkbWV0YTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2luZ2xldG9uX2NsYXNzIHN1cGVyY2xhc3MgaXMgdGhlIHNpbmdsZXRvbl9jbGFzcyBvZiBpdHMgc3VwZXJjbGFzcztcbiAgICAvLyBidXQgQmFzaWNPYmplY3QgaGFzIG5vIHN1cGVyY2xhc3MgKGl0cyBgJCRzdXBlcmAgaXMgbnVsbCksIHRodXMgd2VcbiAgICAvLyBmYWxsYmFjayBvbiBgQ2xhc3NgLlxuICAgIHN1cGVyY2xhc3MgPSBrbGFzcyA9PT0gQmFzaWNPYmplY3QgPyBDbGFzcyA6IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhrbGFzcy4kJHN1cGVyKTtcblxuICAgIG1ldGEgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKG51bGwsIHN1cGVyY2xhc3MsIGZ1bmN0aW9uKCl7fSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkaXNfc2luZ2xldG9uJywgdHJ1ZSk7XG4gICAgJGRlZmluZVByb3BlcnR5KG1ldGEsICckJHNpbmdsZXRvbl9vZicsIGtsYXNzKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJG1ldGEnLCBtZXRhKTtcbiAgICAkc2V0X3Byb3RvKGtsYXNzLCBtZXRhLiQkcHJvdG90eXBlKTtcbiAgICAvLyBSZXN0b3JpbmcgQ2xhc3NOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRjbGFzcycsIE9wYWwuQ2xhc3MpO1xuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH07XG5cbiAgT3BhbC5idWlsZF9tb2R1bGVfc2luZ2xldG9uX2NsYXNzID0gZnVuY3Rpb24obW9kKSB7XG4gICAgaWYgKG1vZC4kJG1ldGEpIHtcbiAgICAgIHJldHVybiBtb2QuJCRtZXRhO1xuICAgIH1cblxuICAgIHZhciBtZXRhID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhudWxsLCBPcGFsLk1vZHVsZSwgZnVuY3Rpb24oKXt9KTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShtZXRhLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobWV0YSwgJyQkc2luZ2xldG9uX29mJywgbW9kKTtcbiAgICAkZGVmaW5lUHJvcGVydHkobW9kLCAnJCRtZXRhJywgbWV0YSk7XG4gICAgJHNldF9wcm90byhtb2QsIG1ldGEuJCRwcm90b3R5cGUpO1xuICAgIC8vIFJlc3RvcmluZyBNb2R1bGVOYW1lLmNsYXNzXG4gICAgJGRlZmluZVByb3BlcnR5KG1vZCwgJyQkY2xhc3MnLCBPcGFsLk1vZHVsZSk7XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfTtcblxuICAvLyBCdWlsZCB0aGUgc2luZ2xldG9uIGNsYXNzIGZvciBhIFJ1YnkgKG5vbiBjbGFzcykgT2JqZWN0LlxuICAvL1xuICAvLyBAcGFyYW0gb2JqZWN0IFtPYmplY3RdXG4gIC8vIEByZXR1cm4gW0NsYXNzXVxuICBPcGFsLmJ1aWxkX29iamVjdF9zaW5nbGV0b25fY2xhc3MgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgc3VwZXJjbGFzcyA9IG9iamVjdC4kJGNsYXNzLFxuICAgICAgICBrbGFzcyA9IE9wYWwuYWxsb2NhdGVfY2xhc3MobmlsLCBzdXBlcmNsYXNzLCBmdW5jdGlvbigpe30pO1xuXG4gICAgJGRlZmluZVByb3BlcnR5KGtsYXNzLCAnJCRpc19zaW5nbGV0b24nLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MsICckJHNpbmdsZXRvbl9vZicsIG9iamVjdCk7XG5cbiAgICBkZWxldGUga2xhc3MuJCRwcm90b3R5cGUuJCRjbGFzcztcblxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsICckJG1ldGEnLCBrbGFzcyk7XG5cbiAgICAkc2V0X3Byb3RvKG9iamVjdCwgb2JqZWN0LiQkbWV0YS4kJHByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4ga2xhc3M7XG4gIH07XG5cbiAgT3BhbC5pc19tZXRob2QgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIChwcm9wWzBdID09PSAnJCcgJiYgcHJvcFsxXSAhPT0gJyQnKTtcbiAgfTtcblxuICBPcGFsLmluc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgZXhjbHVkZSA9IFtdLCByZXN1bHRzID0gW10sIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IGFuY2VzdG9yc1tpXSxcbiAgICAgICAgICBwcm90byA9IGFuY2VzdG9yLiQkcHJvdG90eXBlO1xuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkZHVtbXknKSkge1xuICAgICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxsID0gcHJvcHMubGVuZ3RoOyBqIDwgbGw7IGorKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuXG4gICAgICAgIGlmIChPcGFsLmlzX21ldGhvZChwcm9wKSkge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSksXG4gICAgICAgICAgICAgIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgICAgaWYgKG1ldGhvZC4kJHN0dWIgJiYgZXhjbHVkZS5pbmRleE9mKG1ldGhvZF9uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGUucHVzaChtZXRob2RfbmFtZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFtZXRob2QuJCRzdHViICYmIHJlc3VsdHMuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xICYmIGV4Y2x1ZGUuaW5kZXhPZihtZXRob2RfbmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2gobWV0aG9kX25hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMgPSBmdW5jdGlvbihtb2QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgICBwcm90byA9IG1vZC4kJHByb3RvdHlwZTtcblxuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG8pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHByb3RvW3Byb3BdO1xuXG4gICAgICAgIGlmICghbWV0aG9kLiQkc3R1Yikge1xuICAgICAgICAgIHZhciBtZXRob2RfbmFtZSA9IHByb3Auc2xpY2UoMSk7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKG1ldGhvZF9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIE9wYWwubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBPcGFsLmluc3RhbmNlX21ldGhvZHMoT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iaikpO1xuICB9O1xuXG4gIE9wYWwub3duX21ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gT3BhbC5vd25faW5zdGFuY2VfbWV0aG9kcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSk7XG4gIH07XG5cbiAgT3BhbC5yZWNlaXZlcl9tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG1vZCA9IE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopO1xuICAgIHZhciBzaW5nbGV0b25fbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kKTtcbiAgICB2YXIgaW5zdGFuY2VfbWV0aG9kcyA9IE9wYWwub3duX2luc3RhbmNlX21ldGhvZHMobW9kLiQkc3VwZXIpO1xuICAgIHJldHVybiBzaW5nbGV0b25fbWV0aG9kcy5jb25jYXQoaW5zdGFuY2VfbWV0aG9kcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgcGFpcnMgb2YgbmFtZXMvdmFsdWVzXG4gIC8vIGZvciBhbGwgY2xhc3MgdmFyaWFibGVzIGRlZmluZWQgaW4gcHJvdmlkZWQgK21vZHVsZStcbiAgLy8gYW5kIGl0cyBhbmNlc3RvcnMuXG4gIC8vXG4gIC8vIEBwYXJhbSBtb2R1bGUgW01vZHVsZV1cbiAgLy8gQHJldHVybiBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgICBpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGZvciAodmFyIGN2YXIgaW4gYW5jZXN0b3IuJCRjdmFycykge1xuICAgICAgICByZXN1bHRbY3Zhcl0gPSBhbmNlc3Rvci4kJGN2YXJzW2N2YXJdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgdG8gK3ZhbHVlK1xuICAvLyBpbiBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIC8vIEBwYXJhbSB2YWx1ZSBbT2JqZWN0XVxuICBPcGFsLmNsYXNzX3ZhcmlhYmxlX3NldCA9IGZ1bmN0aW9uKG1vZHVsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMobW9kdWxlKSxcbiAgICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV07XG5cbiAgICAgIGlmICgkaGFzX293bi5jYWxsKGFuY2VzdG9yLiQkY3ZhcnMsIG5hbWUpKSB7XG4gICAgICAgIGFuY2VzdG9yLiQkY3ZhcnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZHVsZS4kJGN2YXJzW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gR2V0cyBjbGFzcyB2YXJpYWJsZSB3aXRoIHNwZWNpZmllZCArbmFtZSsgZnJvbSBwcm92aWRlZCArbW9kdWxlK1xuICAvL1xuICAvLyBAcGFyYW0gbW9kdWxlIFtNb2R1bGVdXG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddXG4gIE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0ID0gZnVuY3Rpb24obW9kdWxlLCBuYW1lLCB0b2xlcmFudCkge1xuICAgIGlmICgkaGFzX293bi5jYWxsKG1vZHVsZS4kJGN2YXJzLCBuYW1lKSlcbiAgICAgIHJldHVybiBtb2R1bGUuJCRjdmFyc1tuYW1lXTtcblxuICAgIHZhciBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhtb2R1bGUpLFxuICAgICAgaSwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gYW5jZXN0b3JzW2ldO1xuXG4gICAgICBpZiAoJGhhc19vd24uY2FsbChhbmNlc3Rvci4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IuJCRjdmFyc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRvbGVyYW50KVxuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldygndW5pbml0aWFsaXplZCBjbGFzcyB2YXJpYWJsZSAnK25hbWUrJyBpbiAnK21vZHVsZS4kbmFtZSgpKTtcblxuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBmdW5jdGlvbiBpc1Jvb3QocHJvdG8pIHtcbiAgICByZXR1cm4gcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX2luY2x1ZGVkX21vZHVsZXMobW9kdWxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdLCBtb2QsIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZS4kJHByb3RvdHlwZSk7XG5cbiAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRjbGFzcycpKSB7XG4gICAgICAgIC8vIHN1cGVyY2xhc3NcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtb2QgPSBwcm90b1RvTW9kdWxlKHByb3RvKTtcbiAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobW9kKTtcbiAgICAgIH1cbiAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3duX3ByZXBlbmRlZF9tb2R1bGVzKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kLCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGUuJCRwcm90b3R5cGUpO1xuXG4gICAgaWYgKG1vZHVsZS4kJHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICB3aGlsZSAocHJvdG8pIHtcbiAgICAgICAgaWYgKHByb3RvID09PSBtb2R1bGUuJCRwcm90b3R5cGUuJCRkZWZpbmVfbWV0aG9kc19vbikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kID0gcHJvdG9Ub01vZHVsZShwcm90byk7XG4gICAgICAgIGlmIChtb2QpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuXG4gIC8vIFRoZSBhY3R1YWwgaW5jbHVzaW9uIG9mIGEgbW9kdWxlIGludG8gYSBjbGFzcy5cbiAgLy9cbiAgLy8gIyMgQ2xhc3MgYCQkcGFyZW50YCBhbmQgYGljbGFzc2BcbiAgLy9cbiAgLy8gVG8gaGFuZGxlIGBzdXBlcmAgY2FsbHMsIGV2ZXJ5IGNsYXNzIGhhcyBhIGAkJHBhcmVudGAuIFRoaXMgcGFyZW50IGlzXG4gIC8vIHVzZWQgdG8gcmVzb2x2ZSB0aGUgbmV4dCBjbGFzcyBmb3IgYSBzdXBlciBjYWxsLiBBIG5vcm1hbCBjbGFzcyB3b3VsZFxuICAvLyBoYXZlIHRoaXMgcG9pbnQgdG8gaXRzIHN1cGVyY2xhc3MuIEhvd2V2ZXIsIGlmIGEgY2xhc3MgaW5jbHVkZXMgYSBtb2R1bGVcbiAgLy8gdGhlbiB0aGlzIHdvdWxkIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIG1vZHVsZS4gVGhlIG1vZHVsZSB3b3VsZFxuICAvLyBhbHNvIGhhdmUgdG8gdGhlbiBwb2ludCBpdHMgYCQkcGFyZW50YCB0byB0aGUgYWN0dWFsIHN1cGVyY2xhc3MuIFdlXG4gIC8vIGNhbm5vdCBtb2RpZnkgbW9kdWxlcyBsaWtlIHRoaXMsIGJlY2F1c2UgaXQgbWlnaHQgYmUgaW5jbHVkZWQgaW4gbW9yZVxuICAvLyB0aGVuIG9uZSBjbGFzcy4gVG8gZml4IHRoaXMsIHdlIGFjdHVhbGx5IGluc2VydCBhbiBgaWNsYXNzYCBhcyB0aGUgY2xhc3MnXG4gIC8vIGAkJHBhcmVudGAgd2hpY2ggY2FuIHRoZW4gcG9pbnQgdG8gdGhlIHN1cGVyY2xhc3MuIFRoZSBgaWNsYXNzYCBhY3RzIGFzXG4gIC8vIGEgcHJveHkgdG8gdGhlIGFjdHVhbCBtb2R1bGUsIHNvIHRoZSBgc3VwZXJgIGNoYWluIGNhbiB0aGVuIHNlYXJjaCBpdCBmb3JcbiAgLy8gdGhlIHJlcXVpcmVkIG1ldGhvZC5cbiAgLy9cbiAgLy8gQHBhcmFtIG1vZHVsZSBbTW9kdWxlXSB0aGUgbW9kdWxlIHRvIGluY2x1ZGVcbiAgLy8gQHBhcmFtIGluY2x1ZGVyIFtNb2R1bGVdIHRoZSB0YXJnZXQgY2xhc3MgdG8gaW5jbHVkZSBtb2R1bGUgaW50b1xuICAvLyBAcmV0dXJuIFtudWxsXVxuICBPcGFsLmFwcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgaW5jbHVkZXIpIHtcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKGluY2x1ZGVyKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KCdjeWNsaWMgaW5jbHVkZSBkZXRlY3RlZCcpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBtb2R1bGVfYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBtb2R1bGVfYW5jZXN0b3JzW2ldLCBpY2xhc3MgPSBjcmVhdGVfaWNsYXNzKGFuY2VzdG9yKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsICckJGluY2x1ZGVkJywgdHJ1ZSk7XG4gICAgICBpY2xhc3Nlcy5wdXNoKGljbGFzcyk7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlcl9hbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhpbmNsdWRlciksXG4gICAgICAgIGNoYWluID0gY2hhaW5faWNsYXNzZXMoaWNsYXNzZXMpLFxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlcixcbiAgICAgICAgZW5kX2NoYWluX29uO1xuXG4gICAgaWYgKGluY2x1ZGVyX2FuY2VzdG9ycy5pbmRleE9mKG1vZHVsZSkgPT09IC0xKSB7XG4gICAgICAvLyBmaXJzdCB0aW1lIGluY2x1ZGVcblxuICAgICAgLy8gaW5jbHVkZXIgLT4gY2hhaW4uZmlyc3QgLT4gLi4uY2hhaW4uLi4gLT4gY2hhaW4ubGFzdCAtPiBpbmNsdWRlci5wYXJlbnRcbiAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICBlbmRfY2hhaW5fb24gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5jbHVkZXIuJCRwcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbW9kdWxlIGhhcyBiZWVuIGFscmVhZHkgaW5jbHVkZWQsXG4gICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHB1dCBpdCBpbnRvIHRoZSBhbmNlc3RvcnMgY2hhaW4gYWdhaW4sXG4gICAgICAvLyBidXQgdGhpcyBtb2R1bGUgbWF5IGhhdmUgbmV3IGluY2x1ZGVkIG1vZHVsZXMuXG4gICAgICAvLyBJZiBpdCdzIHRydWUgd2UgbmVlZCB0byBjb3B5IHRoZW0uXG4gICAgICAvL1xuICAgICAgLy8gVGhlIHNpbXBsZXN0IHdheSBpcyB0byByZXBsYWNlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICBgbW9kdWxlYCBpY2xhc3MgKGhhcyBhICQkcm9vdCBmbGFnKVxuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIC4uLnByZXZpb3MgY2hhaW4gb2YgbW9kdWxlLmluY2x1ZGVkX21vZHVsZXMgLi4uXG4gICAgICAvLyAgICAgICAgICAgIHxcbiAgICAgIC8vICBcIm5leHQgYW5jZXN0b3JcIiAoaGFzIGEgJCRyb290IGZsYWcgb3IgaXMgYSByZWFsIGNsYXNzKVxuICAgICAgLy9cbiAgICAgIC8vIHRvXG4gICAgICAvLyAgICAgICAgICBwYXJlbnRcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAgYG1vZHVsZWAgaWNsYXNzIChoYXMgYSAkJHJvb3QgZmxhZylcbiAgICAgIC8vICAgICAgICAgICAgfFxuICAgICAgLy8gICAuLi5yZWdlbmVyYXRlZCBjaGFpbiBvZiBtb2R1bGUuaW5jbHVkZWRfbW9kdWxlc1xuICAgICAgLy8gICAgICAgICAgICB8XG4gICAgICAvLyAgIFwibmV4dCBhbmNlc3RvclwiIChoYXMgYSAkJHJvb3QgZmxhZyBvciBpcyBhIHJlYWwgY2xhc3MpXG4gICAgICAvL1xuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBhcmUgbm8gaW50ZXJtZWRpYXRlIGNsYXNzZXMgYmV0d2VlbiBgcGFyZW50YCBhbmQgYG5leHQgYW5jZXN0b3JgLlxuICAgICAgLy8gSXQgZG9lc24ndCBicmVhayBhbnkgcHJvdG90eXBlcyBvZiBvdGhlciBvYmplY3RzIGFzIHdlIGRvbid0IGNoYW5nZSBjbGFzcyByZWZlcmVuY2VzLlxuXG4gICAgICB2YXIgcGFyZW50ID0gaW5jbHVkZXIuJCRwcm90b3R5cGUsIG1vZHVsZV9pY2xhc3MgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcblxuICAgICAgd2hpbGUgKG1vZHVsZV9pY2xhc3MgIT0gbnVsbCkge1xuICAgICAgICBpZiAobW9kdWxlX2ljbGFzcy4kJG1vZHVsZSA9PT0gbW9kdWxlICYmIGlzUm9vdChtb2R1bGVfaWNsYXNzKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gbW9kdWxlX2ljbGFzcztcbiAgICAgICAgbW9kdWxlX2ljbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihtb2R1bGVfaWNsYXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZHVsZV9pY2xhc3MpIHtcbiAgICAgICAgLy8gbW9kdWxlIGhhcyBiZWVuIGRpcmVjdGx5IGluY2x1ZGVkXG4gICAgICAgIHZhciBuZXh0X2FuY2VzdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9pY2xhc3MpO1xuXG4gICAgICAgIC8vIHNraXAgbm9uLXJvb3QgaWNsYXNzZXMgKHRoYXQgd2VyZSByZWN1cnNpdmVseSBpbmNsdWRlZClcbiAgICAgICAgd2hpbGUgKG5leHRfYW5jZXN0b3IuaGFzT3duUHJvcGVydHkoJyQkaWNsYXNzJykgJiYgIWlzUm9vdChuZXh0X2FuY2VzdG9yKSkge1xuICAgICAgICAgIG5leHRfYW5jZXN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV4dF9hbmNlc3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF9jaGFpbl9hZnRlciA9IHBhcmVudDtcbiAgICAgICAgZW5kX2NoYWluX29uID0gbmV4dF9hbmNlc3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vZHVsZSBoYXMgbm90IGJlZW4gZGlyZWN0bHkgaW5jbHVkZWQgYnV0IHdhcyBpbiBhbmNlc3RvciBjaGFpbiBiZWNhdXNlIGl0IHdhcyBpbmNsdWRlZCBieSBhbm90aGVyIG1vZHVsZVxuICAgICAgICAvLyBpbmNsdWRlIGl0IGRpcmVjdGx5XG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyID0gaW5jbHVkZXIuJCRwcm90b3R5cGU7XG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpbmNsdWRlci4kJHByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJHNldF9wcm90byhzdGFydF9jaGFpbl9hZnRlciwgY2hhaW4uZmlyc3QpO1xuICAgICRzZXRfcHJvdG8oY2hhaW4ubGFzdCwgZW5kX2NoYWluX29uKTtcblxuICAgIC8vIHJlY2FsY3VsYXRlIG93bl9pbmNsdWRlZF9tb2R1bGVzIGNhY2hlXG4gICAgaW5jbHVkZXIuJCRvd25faW5jbHVkZWRfbW9kdWxlcyA9IG93bl9pbmNsdWRlZF9tb2R1bGVzKGluY2x1ZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIE9wYWwucHJlcGVuZF9mZWF0dXJlcyA9IGZ1bmN0aW9uKG1vZHVsZSwgcHJlcGVuZGVyKSB7XG4gICAgLy8gSGVyZSB3ZSBjaGFuZ2UgdGhlIGFuY2VzdG9ycyBjaGFpbiBmcm9tXG4gICAgLy9cbiAgICAvLyAgIHByZXBlbmRlclxuICAgIC8vICAgICAgfFxuICAgIC8vICAgIHBhcmVudFxuICAgIC8vXG4gICAgLy8gdG86XG4gICAgLy9cbiAgICAvLyBkdW1teShwcmVwZW5kZXIpXG4gICAgLy8gICAgICB8XG4gICAgLy8gIGljbGFzcyhtb2R1bGUpXG4gICAgLy8gICAgICB8XG4gICAgLy8gaWNsYXNzKHByZXBlbmRlcilcbiAgICAvLyAgICAgIHxcbiAgICAvLyAgICBwYXJlbnRcbiAgICB2YXIgbW9kdWxlX2FuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZSk7XG4gICAgdmFyIGljbGFzc2VzID0gW107XG5cbiAgICBpZiAobW9kdWxlX2FuY2VzdG9ycy5pbmRleE9mKHByZXBlbmRlcikgIT09IC0xKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnY3ljbGljIHByZXBlbmQgZGV0ZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbW9kdWxlX2FuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFuY2VzdG9yID0gbW9kdWxlX2FuY2VzdG9yc1tpXSwgaWNsYXNzID0gY3JlYXRlX2ljbGFzcyhhbmNlc3Rvcik7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRwcmVwZW5kZWQnLCB0cnVlKTtcbiAgICAgIGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICB2YXIgY2hhaW4gPSBjaGFpbl9pY2xhc3NlcyhpY2xhc3NlcyksXG4gICAgICAgIGR1bW15X3ByZXBlbmRlciA9IHByZXBlbmRlci4kJHByb3RvdHlwZSxcbiAgICAgICAgcHJldmlvdXNfcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGR1bW15X3ByZXBlbmRlciksXG4gICAgICAgIHByZXBlbmRlcl9pY2xhc3MsXG4gICAgICAgIHN0YXJ0X2NoYWluX2FmdGVyLFxuICAgICAgICBlbmRfY2hhaW5fb247XG5cbiAgICBpZiAoZHVtbXlfcHJlcGVuZGVyLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIC8vIFRoZSBtb2R1bGUgYWxyZWFkeSBoYXMgc29tZSBwcmVwZW5kZWQgbW9kdWxlc1xuICAgICAgLy8gd2hpY2ggbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIHRvIG1ha2UgaXQgXCJkdW1teVwiXG4gICAgICBwcmVwZW5kZXJfaWNsYXNzID0gZHVtbXlfcHJlcGVuZGVyLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1ha2luZyB0aGUgbW9kdWxlIFwiZHVtbXlcIlxuICAgICAgcHJlcGVuZGVyX2ljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MocHJlcGVuZGVyKTtcbiAgICAgIGZsdXNoX21ldGhvZHNfaW4ocHJlcGVuZGVyKTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShkdW1teV9wcmVwZW5kZXIsICckJGR1bW15JywgdHJ1ZSk7XG4gICAgICAkZGVmaW5lUHJvcGVydHkoZHVtbXlfcHJlcGVuZGVyLCAnJCRkZWZpbmVfbWV0aG9kc19vbicsIHByZXBlbmRlcl9pY2xhc3MpO1xuXG4gICAgICAvLyBDb252ZXJ0aW5nXG4gICAgICAvLyAgIGR1bW15KHByZXBlbmRlcikgLT4gcHJldmlvdXNfcGFyZW50XG4gICAgICAvLyB0b1xuICAgICAgLy8gICBkdW1teShwcmVwZW5kZXIpIC0+IGljbGFzcyhwcmVwZW5kZXIpIC0+IHByZXZpb3VzX3BhcmVudFxuICAgICAgJHNldF9wcm90byhkdW1teV9wcmVwZW5kZXIsIHByZXBlbmRlcl9pY2xhc3MpO1xuICAgICAgJHNldF9wcm90byhwcmVwZW5kZXJfaWNsYXNzLCBwcmV2aW91c19wYXJlbnQpO1xuICAgIH1cblxuICAgIHZhciBwcmVwZW5kZXJfYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMocHJlcGVuZGVyKTtcblxuICAgIGlmIChwcmVwZW5kZXJfYW5jZXN0b3JzLmluZGV4T2YobW9kdWxlKSA9PT0gLTEpIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgcHJlcGVuZFxuXG4gICAgICBzdGFydF9jaGFpbl9hZnRlciA9IGR1bW15X3ByZXBlbmRlcjtcblxuICAgICAgLy8gbmV4dCAkJHJvb3Qgb3IgcHJlcGVuZGVyX2ljbGFzcyBvciBub24tJCRpY2xhc3NcbiAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihkdW1teV9wcmVwZW5kZXIpO1xuICAgICAgd2hpbGUgKGVuZF9jaGFpbl9vbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBlbmRfY2hhaW5fb24uaGFzT3duUHJvcGVydHkoJyQkcm9vdCcpIHx8XG4gICAgICAgICAgZW5kX2NoYWluX29uID09PSBwcmVwZW5kZXJfaWNsYXNzIHx8XG4gICAgICAgICAgIWVuZF9jaGFpbl9vbi5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKVxuICAgICAgICApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZF9jaGFpbl9vbiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihlbmRfY2hhaW5fb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwiUHJlcGVuZGluZyBhIG1vZHVsZSBtdWx0aXBsZSB0aW1lcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cblxuICAgICRzZXRfcHJvdG8oc3RhcnRfY2hhaW5fYWZ0ZXIsIGNoYWluLmZpcnN0KTtcbiAgICAkc2V0X3Byb3RvKGNoYWluLmxhc3QsIGVuZF9jaGFpbl9vbik7XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBvd25fcHJlcGVuZGVkX21vZHVsZXMgY2FjaGVcbiAgICBwcmVwZW5kZXIuJCRvd25fcHJlcGVuZGVkX21vZHVsZXMgPSBvd25fcHJlcGVuZGVkX21vZHVsZXMocHJlcGVuZGVyKTtcblxuICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGZsdXNoX21ldGhvZHNfaW4obW9kdWxlKSB7XG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlLFxuICAgICAgICBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoT3BhbC5pc19tZXRob2QocHJvcCkpIHtcbiAgICAgICAgZGVsZXRlIHByb3RvW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZV9pY2xhc3MobW9kdWxlKSB7XG4gICAgdmFyIGljbGFzcyA9IGNyZWF0ZV9kdW1teV9pY2xhc3MobW9kdWxlKTtcblxuICAgIGlmIChtb2R1bGUuJCRpc19tb2R1bGUpIHtcbiAgICAgIG1vZHVsZS4kJGljbGFzc2VzLnB1c2goaWNsYXNzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaWNsYXNzO1xuICB9XG5cbiAgLy8gRHVtbXkgaWNsYXNzIGRvZXNuJ3QgcmVjZWl2ZSB1cGRhdGVzIHdoZW4gdGhlIG1vZHVsZSBnZXRzIGEgbmV3IG1ldGhvZC5cbiAgZnVuY3Rpb24gY3JlYXRlX2R1bW15X2ljbGFzcyhtb2R1bGUpIHtcbiAgICB2YXIgaWNsYXNzID0ge30sXG4gICAgICAgIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuXG4gICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgIHByb3RvID0gcHJvdG8uJCRkZWZpbmVfbWV0aG9kc19vbjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byksXG4gICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIHByb3AsIHByb3RvW3Byb3BdKTtcbiAgICB9XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRpY2xhc3MnLCB0cnVlKTtcbiAgICAkZGVmaW5lUHJvcGVydHkoaWNsYXNzLCAnJCRtb2R1bGUnLCBtb2R1bGUpO1xuXG4gICAgcmV0dXJuIGljbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYWluX2ljbGFzc2VzKGljbGFzc2VzKSB7XG4gICAgdmFyIGxlbmd0aCA9IGljbGFzc2VzLmxlbmd0aCwgZmlyc3QgPSBpY2xhc3Nlc1swXTtcblxuICAgICRkZWZpbmVQcm9wZXJ0eShmaXJzdCwgJyQkcm9vdCcsIHRydWUpO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHsgZmlyc3Q6IGZpcnN0LCBsYXN0OiBmaXJzdCB9O1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IGZpcnN0O1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpY2xhc3Nlc1tpXTtcbiAgICAgICRzZXRfcHJvdG8ocHJldmlvdXMsIGN1cnJlbnQpO1xuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuXG4gICAgcmV0dXJuIHsgZmlyc3Q6IGljbGFzc2VzWzBdLCBsYXN0OiBpY2xhc3Nlc1tsZW5ndGggLSAxXSB9O1xuICB9XG5cbiAgLy8gRm9yIHBlcmZvcm1hbmNlLCBzb21lIGNvcmUgUnVieSBjbGFzc2VzIGFyZSB0b2xsLWZyZWUgYnJpZGdlZCB0byB0aGVpclxuICAvLyBuYXRpdmUgSmF2YVNjcmlwdCBjb3VudGVycGFydHMgKGUuZy4gYSBSdWJ5IEFycmF5IGlzIGEgSmF2YVNjcmlwdCBBcnJheSkuXG4gIC8vXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0dXAgYSBuYXRpdmUgY29uc3RydWN0b3IgKGUuZy4gQXJyYXkpLCB0byBoYXZlXG4gIC8vIGl0cyBwcm90b3R5cGUgYWN0IGxpa2UgYSBub3JtYWwgUnVieSBjbGFzcy4gRmlyc3RseSwgYSBuZXcgUnVieSBjbGFzcyBpc1xuICAvLyBjcmVhdGVkIHVzaW5nIHRoZSBuYXRpdmUgY29uc3RydWN0b3Igc28gdGhhdCBpdHMgcHJvdG90eXBlIGlzIHNldCBhcyB0aGVcbiAgLy8gdGFyZ2V0IGZvciB0aGUgbmV3IGNsYXNzLiBOb3RlOiBhbGwgYnJpZGdlZCBjbGFzc2VzIGFyZSBzZXQgdG8gaW5oZXJpdFxuICAvLyBmcm9tIE9iamVjdC5cbiAgLy9cbiAgLy8gRXhhbXBsZTpcbiAgLy9cbiAgLy8gICAgT3BhbC5icmlkZ2Uoc2VsZiwgRnVuY3Rpb24pO1xuICAvL1xuICAvLyBAcGFyYW0ga2xhc3MgICAgICAgW0NsYXNzXSB0aGUgUnVieSBjbGFzcyB0byBicmlkZ2VcbiAgLy8gQHBhcmFtIGNvbnN0cnVjdG9yIFtKUy5GdW5jdGlvbl0gbmF0aXZlIEphdmFTY3JpcHQgY29uc3RydWN0b3IgdG8gdXNlXG4gIC8vIEByZXR1cm4gW0NsYXNzXSByZXR1cm5zIHRoZSBwYXNzZWQgUnVieSBjbGFzc1xuICAvL1xuICBPcGFsLmJyaWRnZSA9IGZ1bmN0aW9uKG5hdGl2ZV9rbGFzcywga2xhc3MpIHtcbiAgICBpZiAobmF0aXZlX2tsYXNzLmhhc093blByb3BlcnR5KCckJGJyaWRnZScpKSB7XG4gICAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhcImFscmVhZHkgYnJpZGdlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBjb25zdHJ1Y3RvciBpcyBhIEpTIGZ1bmN0aW9uIHdpdGggYSBwcm90b3R5cGUgY2hhaW4gbGlrZTpcbiAgICAvLyAtIGNvbnN0cnVjdG9yXG4gICAgLy8gICAtIHN1cGVyXG4gICAgLy9cbiAgICAvLyBXaGF0IHdlIG5lZWQgdG8gZG8gaXMgdG8gaW5qZWN0IG91ciBjbGFzcyAod2l0aCBpdHMgcHJvdG90eXBlIGNoYWluKVxuICAgIC8vIGJldHdlZW4gY29uc3RydWN0b3IgYW5kIHN1cGVyLiBGb3IgZXhhbXBsZSwgYWZ0ZXIgaW5qZWN0aW5nIDo6T2JqZWN0XG4gICAgLy8gaW50byBKUyBTdHJpbmcgd2UgZ2V0OlxuICAgIC8vXG4gICAgLy8gLSBjb25zdHJ1Y3RvciAod2luZG93LlN0cmluZylcbiAgICAvLyAgIC0gT3BhbC5PYmplY3RcbiAgICAvLyAgICAgLSBPcGFsLktlcm5lbFxuICAgIC8vICAgICAgIC0gT3BhbC5CYXNpY09iamVjdFxuICAgIC8vICAgICAgICAgLSBzdXBlciAod2luZG93Lk9iamVjdClcbiAgICAvLyAgICAgICAgICAgLSBudWxsXG4gICAgLy9cbiAgICAkZGVmaW5lUHJvcGVydHkobmF0aXZlX2tsYXNzLCAnJCRicmlkZ2UnLCBrbGFzcyk7XG4gICAgJHNldF9wcm90byhuYXRpdmVfa2xhc3MucHJvdG90eXBlLCAoa2xhc3MuJCRzdXBlciB8fCBPcGFsLk9iamVjdCkuJCRwcm90b3R5cGUpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkcHJvdG90eXBlJywgbmF0aXZlX2tsYXNzLnByb3RvdHlwZSk7XG5cbiAgICAkZGVmaW5lUHJvcGVydHkoa2xhc3MuJCRwcm90b3R5cGUsICckJGNsYXNzJywga2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkY29uc3RydWN0b3InLCBuYXRpdmVfa2xhc3MpO1xuICAgICRkZWZpbmVQcm9wZXJ0eShrbGFzcywgJyQkYnJpZGdlJywgdHJ1ZSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvdG9Ub01vZHVsZShwcm90bykge1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRpY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkbW9kdWxlO1xuICAgIH0gZWxzZSBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoJyQkY2xhc3MnKSkge1xuICAgICAgcmV0dXJuIHByb3RvLiQkY2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3duX2FuY2VzdG9ycyhtb2R1bGUpIHtcbiAgICByZXR1cm4gbW9kdWxlLiQkb3duX3ByZXBlbmRlZF9tb2R1bGVzLmNvbmNhdChbbW9kdWxlXSkuY29uY2F0KG1vZHVsZS4kJG93bl9pbmNsdWRlZF9tb2R1bGVzKTtcbiAgfVxuXG4gIC8vIFRoZSBBcnJheSBvZiBhbmNlc3RvcnMgZm9yIGEgZ2l2ZW4gbW9kdWxlL2NsYXNzXG4gIE9wYWwuYW5jZXN0b3JzID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgaWYgKCFtb2R1bGUpIHsgcmV0dXJuIFtdOyB9XG5cbiAgICBpZiAobW9kdWxlLiQkYW5jZXN0b3JzX2NhY2hlX3ZlcnNpb24gPT09IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbikge1xuICAgICAgcmV0dXJuIG1vZHVsZS4kJGFuY2VzdG9ycztcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW10sIGksIG1vZHMsIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIG1vZHMgPSBvd25fYW5jZXN0b3JzKG1vZHVsZSksIGxlbmd0aCA9IG1vZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKG1vZHNbaV0pO1xuICAgIH1cblxuICAgIGlmIChtb2R1bGUuJCRzdXBlcikge1xuICAgICAgZm9yIChpID0gMCwgbW9kcyA9IE9wYWwuYW5jZXN0b3JzKG1vZHVsZS4kJHN1cGVyKSwgbGVuZ3RoID0gbW9kcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChtb2RzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGUuJCRhbmNlc3RvcnNfY2FjaGVfdmVyc2lvbiA9IE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbjtcbiAgICBtb2R1bGUuJCRhbmNlc3RvcnMgPSByZXN1bHQ7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIE9wYWwuaW5jbHVkZWRfbW9kdWxlcyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuICAgIHZhciByZXN1bHQgPSBbXSwgbW9kID0gbnVsbCwgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobW9kdWxlLiQkcHJvdG90eXBlKTtcblxuICAgIGZvciAoOyBwcm90byAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pOyBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykpIHtcbiAgICAgIG1vZCA9IHByb3RvVG9Nb2R1bGUocHJvdG8pO1xuICAgICAgaWYgKG1vZCAmJiBtb2QuJCRpc19tb2R1bGUgJiYgcHJvdG8uJCRpY2xhc3MgJiYgcHJvdG8uJCRpbmNsdWRlZCkge1xuICAgICAgICByZXN1bHQucHVzaChtb2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblxuICAvLyBNZXRob2QgTWlzc2luZ1xuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIE1ldGhvZHMgc3R1YnMgYXJlIHVzZWQgdG8gZmFjaWxpdGF0ZSBtZXRob2RfbWlzc2luZyBpbiBvcGFsLiBBIHN0dWIgaXMgYVxuICAvLyBwbGFjZWhvbGRlciBmdW5jdGlvbiB3aGljaCBqdXN0IGNhbGxzIGBtZXRob2RfbWlzc2luZ2Agb24gdGhlIHJlY2VpdmVyLlxuICAvLyBJZiBubyBtZXRob2Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBhY3R1YWxseSBkZWZpbmVkIG9uIGFuIG9iamVjdCwgdGhlbiBpdFxuICAvLyBpcyBvYnZpb3VzIHRvIHNheSB0aGF0IHRoZSBzdHViIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQsIGFuZCB0aGVuIGluIHR1cm5cbiAgLy8gbWV0aG9kX21pc3Npbmcgd2lsbCBiZSBjYWxsZWQuXG4gIC8vXG4gIC8vIFdoZW4gYSBmaWxlIGluIHJ1YnkgZ2V0cyBjb21waWxlZCB0byBqYXZhc2NyaXB0LCBpdCBpbmNsdWRlcyBhIGNhbGwgdG9cbiAgLy8gdGhpcyBmdW5jdGlvbiB3aGljaCBhZGRzIHN0dWJzIGZvciBldmVyeSBtZXRob2QgbmFtZSBpbiB0aGUgY29tcGlsZWQgZmlsZS5cbiAgLy8gSXQgc2hvdWxkIHRoZW4gYmUgc2FmZSB0byBhc3N1bWUgdGhhdCBtZXRob2RfbWlzc2luZyB3aWxsIHdvcmsgZm9yIGFueVxuICAvLyBtZXRob2QgY2FsbCBkZXRlY3RlZC5cbiAgLy9cbiAgLy8gTWV0aG9kIHN0dWJzIGFyZSBhZGRlZCB0byB0aGUgQmFzaWNPYmplY3QgcHJvdG90eXBlLCB3aGljaCBldmVyeSBvdGhlclxuICAvLyBydWJ5IG9iamVjdCBpbmhlcml0cywgc28gYWxsIG9iamVjdHMgc2hvdWxkIGhhbmRsZSBtZXRob2QgbWlzc2luZy4gQSBzdHViXG4gIC8vIGlzIG9ubHkgYWRkZWQgaWYgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgKG1ldGhvZCBuYW1lKSBpcyBub3QgYWxyZWFkeVxuICAvLyBkZWZpbmVkLlxuICAvL1xuICAvLyBOb3RlOiBhbGwgcnVieSBtZXRob2RzIGhhdmUgYSBgJGAgcHJlZml4IGluIGphdmFzY3JpcHQsIHNvIGFsbCBzdHVicyB3aWxsXG4gIC8vIGhhdmUgdGhpcyBwcmVmaXggYXMgd2VsbCAodG8gbWFrZSB0aGlzIG1ldGhvZCBtb3JlIHBlcmZvcm1hbnQpLlxuICAvL1xuICAvLyAgICBPcGFsLmFkZF9zdHVicyhbXCIkZm9vXCIsIFwiJGJhclwiLCBcIiRiYXo9XCJdKTtcbiAgLy9cbiAgLy8gQWxsIHN0dWIgZnVuY3Rpb25zIHdpbGwgaGF2ZSBhIHByaXZhdGUgYCQkc3R1YmAgcHJvcGVydHkgc2V0IHRvIHRydWUgc29cbiAgLy8gdGhhdCBvdGhlciBpbnRlcm5hbCBtZXRob2RzIGNhbiBkZXRlY3QgaWYgYSBtZXRob2QgaXMganVzdCBhIHN0dWIgb3Igbm90LlxuICAvLyBgS2VybmVsI3Jlc3BvbmRfdG8/YCB1c2VzIHRoaXMgcHJvcGVydHkgdG8gZGV0ZWN0IGEgbWV0aG9kcyBwcmVzZW5jZS5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0dWJzIFtBcnJheV0gYW4gYXJyYXkgb2YgbWV0aG9kIHN0dWJzIHRvIGFkZFxuICAvLyBAcmV0dXJuIFt1bmRlZmluZWRdXG4gIE9wYWwuYWRkX3N0dWJzID0gZnVuY3Rpb24oc3R1YnMpIHtcbiAgICB2YXIgcHJvdG8gPSBPcGFsLkJhc2ljT2JqZWN0LiQkcHJvdG90eXBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0dWJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3R1YiA9IHN0dWJzW2ldLCBleGlzdGluZ19tZXRob2QgPSBwcm90b1tzdHViXTtcblxuICAgICAgaWYgKGV4aXN0aW5nX21ldGhvZCA9PSBudWxsIHx8IGV4aXN0aW5nX21ldGhvZC4kJHN0dWIpIHtcbiAgICAgICAgT3BhbC5hZGRfc3R1Yl9mb3IocHJvdG8sIHN0dWIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYSBtZXRob2RfbWlzc2luZyBzdHViIGZ1bmN0aW9uIHRvIHRoZSBnaXZlbiBwcm90b3R5cGUgZm9yIHRoZVxuICAvLyBnaXZlbiBuYW1lLlxuICAvL1xuICAvLyBAcGFyYW0gcHJvdG90eXBlIFtQcm90b3R5cGVdIHRoZSB0YXJnZXQgcHJvdG90eXBlXG4gIC8vIEBwYXJhbSBzdHViIFtTdHJpbmddIHN0dWIgbmFtZSB0byBhZGQgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5hZGRfc3R1Yl9mb3IgPSBmdW5jdGlvbihwcm90b3R5cGUsIHN0dWIpIHtcbiAgICB2YXIgbWV0aG9kX21pc3Npbmdfc3R1YiA9IE9wYWwuc3R1Yl9mb3Ioc3R1Yik7XG4gICAgJGRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgc3R1YiwgbWV0aG9kX21pc3Npbmdfc3R1Yik7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgdGhlIG1ldGhvZF9taXNzaW5nIHN0dWIgZm9yIGEgZ2l2ZW4gbWV0aG9kIG5hbWUuXG4gIC8vXG4gIC8vIEBwYXJhbSBtZXRob2RfbmFtZSBbU3RyaW5nXSBUaGUganMtbmFtZSBvZiB0aGUgbWV0aG9kIHRvIHN0dWIgKGUuZy4gXCIkZm9vXCIpXG4gIC8vIEByZXR1cm4gW3VuZGVmaW5lZF1cbiAgT3BhbC5zdHViX2ZvciA9IGZ1bmN0aW9uKG1ldGhvZF9uYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBtZXRob2RfbWlzc2luZ19zdHViKCkge1xuICAgICAgLy8gQ29weSBhbnkgZ2l2ZW4gYmxvY2sgb250byB0aGUgbWV0aG9kX21pc3NpbmcgZGlzcGF0Y2hlclxuICAgICAgdGhpcy4kbWV0aG9kX21pc3NpbmcuJCRwID0gbWV0aG9kX21pc3Npbmdfc3R1Yi4kJHA7XG5cbiAgICAgIC8vIFNldCBibG9jayBwcm9wZXJ0eSB0byBudWxsIHJlYWR5IGZvciB0aGUgbmV4dCBjYWxsIChzdG9wIGZhbHNlLXBvc2l0aXZlcylcbiAgICAgIG1ldGhvZF9taXNzaW5nX3N0dWIuJCRwID0gbnVsbDtcblxuICAgICAgLy8gY2FsbCBtZXRob2QgbWlzc2luZyB3aXRoIGNvcnJlY3QgYXJncyAocmVtb3ZlICckJyBwcmVmaXggb24gbWV0aG9kIG5hbWUpXG4gICAgICB2YXIgYXJnc19hcnkgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJnc19hcnkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGFyZ3NfYXJ5W2ldID0gYXJndW1lbnRzW2ldOyB9XG5cbiAgICAgIHJldHVybiB0aGlzLiRtZXRob2RfbWlzc2luZy5hcHBseSh0aGlzLCBbbWV0aG9kX25hbWUuc2xpY2UoMSldLmNvbmNhdChhcmdzX2FyeSkpO1xuICAgIH1cblxuICAgIG1ldGhvZF9taXNzaW5nX3N0dWIuJCRzdHViID0gdHJ1ZTtcblxuICAgIHJldHVybiBtZXRob2RfbWlzc2luZ19zdHViO1xuICB9O1xuXG5cbiAgLy8gTWV0aG9kc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gQXJpdHkgY291bnQgZXJyb3IgZGlzcGF0Y2hlciBmb3IgbWV0aG9kc1xuICAvL1xuICAvLyBAcGFyYW0gYWN0dWFsIFtGaXhudW1dIG51bWJlciBvZiBhcmd1bWVudHMgZ2l2ZW4gdG8gbWV0aG9kXG4gIC8vIEBwYXJhbSBleHBlY3RlZCBbRml4bnVtXSBleHBlY3RlZCBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEBwYXJhbSBvYmplY3QgW09iamVjdF0gb3duZXIgb2YgdGhlIG1ldGhvZCArbWV0aCtcbiAgLy8gQHBhcmFtIG1ldGggW1N0cmluZ10gbWV0aG9kIG5hbWUgdGhhdCBnb3Qgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICAvLyBAcmFpc2UgW0FyZ3VtZW50RXJyb3JdXG4gIE9wYWwuYWMgPSBmdW5jdGlvbihhY3R1YWwsIGV4cGVjdGVkLCBvYmplY3QsIG1ldGgpIHtcbiAgICB2YXIgaW5zcGVjdCA9ICcnO1xuICAgIGlmIChvYmplY3QuJCRpc19hX21vZHVsZSkge1xuICAgICAgaW5zcGVjdCArPSBvYmplY3QuJCRuYW1lICsgJy4nO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGluc3BlY3QgKz0gb2JqZWN0LiQkY2xhc3MuJCRuYW1lICsgJyMnO1xuICAgIH1cbiAgICBpbnNwZWN0ICs9IG1ldGg7XG5cbiAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldygnWycgKyBpbnNwZWN0ICsgJ10gd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cygnICsgYWN0dWFsICsgJyBmb3IgJyArIGV4cGVjdGVkICsgJyknKTtcbiAgfTtcblxuICAvLyBBcml0eSBjb3VudCBlcnJvciBkaXNwYXRjaGVyIGZvciBibG9ja3NcbiAgLy9cbiAgLy8gQHBhcmFtIGFjdHVhbCBbRml4bnVtXSBudW1iZXIgb2YgYXJndW1lbnRzIGdpdmVuIHRvIGJsb2NrXG4gIC8vIEBwYXJhbSBleHBlY3RlZCBbRml4bnVtXSBleHBlY3RlZCBudW1iZXIgb2YgYXJndW1lbnRzXG4gIC8vIEBwYXJhbSBjb250ZXh0IFtPYmplY3RdIGNvbnRleHQgb2YgdGhlIGJsb2NrIGRlZmluaXRpb25cbiAgLy8gQHJhaXNlIFtBcmd1bWVudEVycm9yXVxuICBPcGFsLmJsb2NrX2FjID0gZnVuY3Rpb24oYWN0dWFsLCBleHBlY3RlZCwgY29udGV4dCkge1xuICAgIHZhciBpbnNwZWN0ID0gXCJgYmxvY2sgaW4gXCIgKyBjb250ZXh0ICsgXCInXCI7XG5cbiAgICB0aHJvdyBPcGFsLkFyZ3VtZW50RXJyb3IuJG5ldyhpbnNwZWN0ICsgJzogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJyArIGFjdHVhbCArICcgZm9yICcgKyBleHBlY3RlZCArICcpJyk7XG4gIH07XG5cbiAgLy8gU3VwZXIgZGlzcGF0Y2hlclxuICBPcGFsLmZpbmRfc3VwZXJfZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKG9iaiwgbWlkLCBjdXJyZW50X2Z1bmMsIGRlZmNoZWNrLCBhbGxvd19zdHVicykge1xuICAgIHZhciBqc2lkID0gJyQnICsgbWlkLCBhbmNlc3RvcnMsIHN1cGVyX21ldGhvZDtcblxuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvYmouJCRtZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5jZXN0b3JzID0gT3BhbC5hbmNlc3RvcnMob2JqLiQkY2xhc3MpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50X2luZGV4ID0gYW5jZXN0b3JzLmluZGV4T2YoY3VycmVudF9mdW5jLiQkb3duZXIpO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRfaW5kZXggKyAxOyBpIDwgYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBhbmNlc3RvcnNbaV0sXG4gICAgICAgICAgcHJvdG8gPSBhbmNlc3Rvci4kJHByb3RvdHlwZTtcblxuICAgICAgaWYgKHByb3RvLmhhc093blByb3BlcnR5KCckJGR1bW15JykpIHtcbiAgICAgICAgcHJvdG8gPSBwcm90by4kJGRlZmluZV9tZXRob2RzX29uO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkoanNpZCkpIHtcbiAgICAgICAgc3VwZXJfbWV0aG9kID0gcHJvdG9banNpZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZGVmY2hlY2sgJiYgc3VwZXJfbWV0aG9kICYmIHN1cGVyX21ldGhvZC4kJHN0dWIgJiYgb2JqLiRtZXRob2RfbWlzc2luZy4kJHByaXN0aW5lKSB7XG4gICAgICAvLyBtZXRob2RfbWlzc2luZyBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgIHRocm93IE9wYWwuTm9NZXRob2RFcnJvci4kbmV3KCdzdXBlcjogbm8gc3VwZXJjbGFzcyBtZXRob2QgYCcrbWlkK1wiJyBmb3IgXCIrb2JqLCBtaWQpO1xuICAgIH1cblxuICAgIHJldHVybiAoc3VwZXJfbWV0aG9kLiQkc3R1YiAmJiAhYWxsb3dfc3R1YnMpID8gbnVsbCA6IHN1cGVyX21ldGhvZDtcbiAgfTtcblxuICAvLyBJdGVyIGRpc3BhdGNoZXIgZm9yIHN1cGVyIGluIGEgYmxvY2tcbiAgT3BhbC5maW5kX2l0ZXJfc3VwZXJfZGlzcGF0Y2hlciA9IGZ1bmN0aW9uKG9iaiwganNpZCwgY3VycmVudF9mdW5jLCBkZWZjaGVjaywgaW1wbGljaXQpIHtcbiAgICB2YXIgY2FsbF9qc2lkID0ganNpZDtcblxuICAgIGlmICghY3VycmVudF9mdW5jKSB7XG4gICAgICB0aHJvdyBPcGFsLlJ1bnRpbWVFcnJvci4kbmV3KFwic3VwZXIgY2FsbGVkIG91dHNpZGUgb2YgbWV0aG9kXCIpO1xuICAgIH1cblxuICAgIGlmIChpbXBsaWNpdCAmJiBjdXJyZW50X2Z1bmMuJCRkZWZpbmVfbWV0aCkge1xuICAgICAgdGhyb3cgT3BhbC5SdW50aW1lRXJyb3IuJG5ldyhcImltcGxpY2l0IGFyZ3VtZW50IHBhc3Npbmcgb2Ygc3VwZXIgZnJvbSBtZXRob2QgZGVmaW5lZCBieSBkZWZpbmVfbWV0aG9kKCkgaXMgbm90IHN1cHBvcnRlZC4gU3BlY2lmeSBhbGwgYXJndW1lbnRzIGV4cGxpY2l0bHlcIik7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRfZnVuYy4kJGRlZikge1xuICAgICAgY2FsbF9qc2lkID0gY3VycmVudF9mdW5jLiQkanNpZDtcbiAgICB9XG5cbiAgICByZXR1cm4gT3BhbC5maW5kX3N1cGVyX2Rpc3BhdGNoZXIob2JqLCBjYWxsX2pzaWQsIGN1cnJlbnRfZnVuYywgZGVmY2hlY2spO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gcmV0dXJuIGFzIGFuIGV4cHJlc3Npb24uIFNvbWV0aW1lcywgd2UgY2FuJ3Qgc2ltcGx5IHJldHVybiBmcm9tXG4gIC8vIGEgamF2YXNjcmlwdCBmdW5jdGlvbiBhcyBpZiB3ZSB3ZXJlIGEgbWV0aG9kLCBhcyB0aGUgcmV0dXJuIGlzIHVzZWQgYXNcbiAgLy8gYW4gZXhwcmVzc2lvbiwgb3IgZXZlbiBpbnNpZGUgYSBibG9jayB3aGljaCBtdXN0IFwicmV0dXJuXCIgdG8gdGhlIG91dGVyXG4gIC8vIG1ldGhvZC4gVGhpcyBoZWxwZXIgc2ltcGx5IHRocm93cyBhbiBlcnJvciB3aGljaCBpcyB0aGVuIGNhdWdodCBieSB0aGVcbiAgLy8gbWV0aG9kLiBUaGlzIGFwcHJvYWNoIGlzIGV4cGVuc2l2ZSwgc28gaXQgaXMgb25seSB1c2VkIHdoZW4gYWJzb2x1dGVseVxuICAvLyBuZWVkZWQuXG4gIC8vXG4gIE9wYWwucmV0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgT3BhbC5yZXR1cm5lci4kdiA9IHZhbDtcbiAgICB0aHJvdyBPcGFsLnJldHVybmVyO1xuICB9O1xuXG4gIC8vIFVzZWQgdG8gYnJlYWsgb3V0IG9mIGEgYmxvY2suXG4gIE9wYWwuYnJrID0gZnVuY3Rpb24odmFsLCBicmVha2VyKSB7XG4gICAgYnJlYWtlci4kdiA9IHZhbDtcbiAgICB0aHJvdyBicmVha2VyO1xuICB9O1xuXG4gIC8vIEJ1aWxkcyBhIG5ldyB1bmlxdWUgYnJlYWtlciwgdGhpcyBpcyB0byBhdm9pZCBtdWx0aXBsZSBuZXN0ZWQgYnJlYWtzIHRvIGdldFxuICAvLyBpbiB0aGUgd2F5IG9mIGVhY2ggb3RoZXIuXG4gIE9wYWwubmV3X2JyayA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgYnJlYWsnKTtcbiAgfTtcblxuICAvLyBoYW5kbGVzIHlpZWxkIGNhbGxzIGZvciAxIHlpZWxkZWQgYXJnXG4gIE9wYWwueWllbGQxID0gZnVuY3Rpb24oYmxvY2ssIGFyZykge1xuICAgIGlmICh0eXBlb2YoYmxvY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldyhcIm5vIGJsb2NrIGdpdmVuXCIpO1xuICAgIH1cblxuICAgIHZhciBoYXNfbWxocyA9IGJsb2NrLiQkaGFzX3RvcF9sZXZlbF9tbGhzX2FyZyxcbiAgICAgICAgaGFzX3RyYWlsaW5nX2NvbW1hID0gYmxvY2suJCRoYXNfdHJhaWxpbmdfY29tbWFfaW5fYXJncztcblxuICAgIGlmIChibG9jay5sZW5ndGggPiAxIHx8ICgoaGFzX21saHMgfHwgaGFzX3RyYWlsaW5nX2NvbW1hKSAmJiBibG9jay5sZW5ndGggPT09IDEpKSB7XG4gICAgICBhcmcgPSBPcGFsLnRvX2FyeShhcmcpO1xuICAgIH1cblxuICAgIGlmICgoYmxvY2subGVuZ3RoID4gMSB8fCAoaGFzX3RyYWlsaW5nX2NvbW1hICYmIGJsb2NrLmxlbmd0aCA9PT0gMSkpICYmIGFyZy4kJGlzX2FycmF5KSB7XG4gICAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gYmxvY2soYXJnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGFuZGxlcyB5aWVsZCBmb3IgPiAxIHlpZWxkZWQgYXJnXG4gIE9wYWwueWllbGRYID0gZnVuY3Rpb24oYmxvY2ssIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mKGJsb2NrKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBPcGFsLkxvY2FsSnVtcEVycm9yLiRuZXcoXCJubyBibG9jayBnaXZlblwiKTtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2subGVuZ3RoID4gMSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19hcnJheSkge1xuICAgICAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJnc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgIHZhciBhcmdzX2FyeSA9IG5ldyBBcnJheShhcmdzLmxlbmd0aCk7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsID0gYXJnc19hcnkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGFyZ3NfYXJ5W2ldID0gYXJnc1tpXTsgfVxuXG4gICAgICByZXR1cm4gYmxvY2suYXBwbHkobnVsbCwgYXJnc19hcnkpO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jay5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICAvLyBGaW5kcyB0aGUgY29ycmVzcG9uZGluZyBleGNlcHRpb24gbWF0Y2ggaW4gY2FuZGlkYXRlcy4gIEVhY2ggY2FuZGlkYXRlIGNhblxuICAvLyBiZSBhIHZhbHVlLCBvciBhbiBhcnJheSBvZiB2YWx1ZXMuICBSZXR1cm5zIG51bGwgaWYgbm90IGZvdW5kLlxuICBPcGFsLnJlc2N1ZSA9IGZ1bmN0aW9uKGV4Y2VwdGlvbiwgY2FuZGlkYXRlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaV07XG5cbiAgICAgIGlmIChjYW5kaWRhdGUuJCRpc19hcnJheSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gT3BhbC5yZXNjdWUoZXhjZXB0aW9uLCBjYW5kaWRhdGUpO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChjYW5kaWRhdGUgPT09IE9wYWwuSlMuRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNhbmRpZGF0ZVsnJD09PSddKGV4Y2VwdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBPcGFsLmlzX2EgPSBmdW5jdGlvbihvYmplY3QsIGtsYXNzKSB7XG4gICAgaWYgKGtsYXNzICE9IG51bGwgJiYgb2JqZWN0LiQkbWV0YSA9PT0ga2xhc3MgfHwgb2JqZWN0LiQkY2xhc3MgPT09IGtsYXNzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0LiQkaXNfbnVtYmVyICYmIGtsYXNzLiQkaXNfbnVtYmVyX2NsYXNzKSB7XG4gICAgICByZXR1cm4gKGtsYXNzLiQkaXNfaW50ZWdlcl9jbGFzcykgPyAob2JqZWN0ICUgMSkgPT09IDAgOiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpLCBsZW5ndGgsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKG9iamVjdC4kJGlzX2NsYXNzID8gT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKG9iamVjdCkgOiAob2JqZWN0LiQkbWV0YSB8fCBvYmplY3QuJCRjbGFzcykpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYW5jZXN0b3JzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBrbGFzcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gSGVscGVycyBmb3IgZXh0cmFjdGluZyBrd3NwbGF0c1xuICAvLyBVc2VkIGZvcjogeyAqKmggfVxuICBPcGFsLnRvX2hhc2ggPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2hhc2gpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBoYXNoID0gdmFsdWUuJHRvX2hhc2goKTtcbiAgICAgIGlmIChoYXNoLiQkaXNfaGFzaCkge1xuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEhhc2ggKFwiICsgdmFsdWUuJCRjbGFzcyArIFwiI3RvX2hhc2ggZ2l2ZXMgXCIgKyBoYXNoLiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgT3BhbC5UeXBlRXJyb3IuJG5ldyhcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgXCIgKyB2YWx1ZS4kJGNsYXNzICsgXCIgaW50byBIYXNoXCIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXJzIGZvciBpbXBsZW1lbnRpbmcgbXVsdGlwbGUgYXNzaWdubWVudFxuICAvLyBPdXIgY29kZSBmb3IgZXh0cmFjdGluZyB0aGUgdmFsdWVzIGFuZCBhc3NpZ25pbmcgdGhlbSBvbmx5IHdvcmtzIGlmIHRoZVxuICAvLyByZXR1cm4gdmFsdWUgaXMgYSBKUyBhcnJheS5cbiAgLy8gU28gaWYgd2UgZ2V0IGFuIEFycmF5IHN1YmNsYXNzLCBleHRyYWN0IHRoZSB3cmFwcGVkIEpTIGFycmF5IGZyb20gaXRcblxuICAvLyBVc2VkIGZvcjogYSwgYiA9IHNvbWV0aGluZyAobm8gc3BsYXQpXG4gIE9wYWwudG9fYXJ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUuJCRpc19hcnJheSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVsnJHJlc3BvbmRfdG8/J10oJ3RvX2FyeScsIHRydWUpKSB7XG4gICAgICB2YXIgYXJ5ID0gdmFsdWUuJHRvX2FyeSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hcnkgZ2l2ZXMgXCIgKyBhcnkuJCRjbGFzcyArIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlZCBmb3I6IGEsIGIgPSAqc29tZXRoaW5nICh3aXRoIHNwbGF0KVxuICBPcGFsLnRvX2EgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS4kJGlzX2FycmF5KSB7XG4gICAgICAvLyBBIHNwbGF0dGVkIGFycmF5IG11c3QgYmUgY29waWVkXG4gICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVbJyRyZXNwb25kX3RvPyddKCd0b19hJywgdHJ1ZSkpIHtcbiAgICAgIHZhciBhcnkgPSB2YWx1ZS4kdG9fYSgpO1xuICAgICAgaWYgKGFyeSA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbdmFsdWVdO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyeTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiQ2FuJ3QgY29udmVydCBcIiArIHZhbHVlLiQkY2xhc3MgK1xuICAgICAgICAgIFwiIHRvIEFycmF5IChcIiArIHZhbHVlLiQkY2xhc3MgKyBcIiN0b19hIGdpdmVzIFwiICsgYXJ5LiQkY2xhc3MgKyBcIilcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFt2YWx1ZV07XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgZm9yIGV4dHJhY3Rpbmcga2V5d29yZCBhcmd1bWVudHMgZnJvbSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gIC8vIEpTIGZ1bmN0aW9uLiBJZiBwcm92aWRlZCArYXJndW1lbnRzKyBsaXN0IGRvZXNuJ3QgaGF2ZSBhIEhhc2hcbiAgLy8gYXMgYSBsYXN0IGl0ZW0sIHJldHVybnMgYSBibGFuayBIYXNoLlxuICAvL1xuICAvLyBAcGFyYW0gcGFyYW1ldGVycyBbQXJyYXldXG4gIC8vIEByZXR1cm4gW0hhc2hdXG4gIC8vXG4gIE9wYWwuZXh0cmFjdF9rd2FyZ3MgPSBmdW5jdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIGt3YXJncyA9IHBhcmFtZXRlcnNbcGFyYW1ldGVycy5sZW5ndGggLSAxXTtcbiAgICBpZiAoa3dhcmdzICE9IG51bGwgJiYgT3BhbC5yZXNwb25kX3RvKGt3YXJncywgJyR0b19oYXNoJywgdHJ1ZSkpIHtcbiAgICAgICRzcGxpY2UuY2FsbChwYXJhbWV0ZXJzLCBwYXJhbWV0ZXJzLmxlbmd0aCAtIDEsIDEpO1xuICAgICAgcmV0dXJuIGt3YXJncy4kdG9faGFzaCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBPcGFsLmhhc2gyKFtdLCB7fSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVzZWQgdG8gZ2V0IGEgbGlzdCBvZiByZXN0IGtleXdvcmQgYXJndW1lbnRzLiBNZXRob2QgdGFrZXMgdGhlIGdpdmVuXG4gIC8vIGtleXdvcmQgYXJncywgaS5lLiB0aGUgaGFzaCBsaXRlcmFsIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNvbnRhaW5pbmcgYWxsXG4gIC8vIGtleXdvcmQgYXJndWVtbnRzIHBhc3NlZCB0byBtZXRob2QsIGFzIHdlbGwgYXMgdGhlIHVzZWQgYXJncyB3aGljaCBhcmVcbiAgLy8gdGhlIG5hbWVzIG9mIHJlcXVpcmVkIGFuZCBvcHRpb25hbCBhcmd1bWVudHMgZGVmaW5lZC4gVGhpcyBtZXRob2QgdGhlblxuICAvLyBqdXN0IHJldHVybnMgYWxsIGtleS92YWx1ZSBwYWlycyB3aGljaCBoYXZlIG5vdCBiZWVuIHVzZWQsIGluIGEgbmV3XG4gIC8vIGhhc2ggbGl0ZXJhbC5cbiAgLy9cbiAgLy8gQHBhcmFtIGdpdmVuX2FyZ3MgW0hhc2hdIGFsbCBrd2FyZ3MgZ2l2ZW4gdG8gbWV0aG9kXG4gIC8vIEBwYXJhbSB1c2VkX2FyZ3MgW09iamVjdDxTdHJpbmc6IHRydWU+XSBhbGwga2V5cyB1c2VkIGFzIG5hbWVkIGt3YXJnc1xuICAvLyBAcmV0dXJuIFtIYXNoXVxuICAvL1xuICBPcGFsLmt3cmVzdGFyZ3MgPSBmdW5jdGlvbihnaXZlbl9hcmdzLCB1c2VkX2FyZ3MpIHtcbiAgICB2YXIga2V5cyAgICAgID0gW10sXG4gICAgICAgIG1hcCAgICAgICA9IHt9LFxuICAgICAgICBrZXkgICAgICAgICAgICxcbiAgICAgICAgZ2l2ZW5fbWFwID0gZ2l2ZW5fYXJncy4kJHNtYXA7XG5cbiAgICBmb3IgKGtleSBpbiBnaXZlbl9tYXApIHtcbiAgICAgIGlmICghdXNlZF9hcmdzW2tleV0pIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIG1hcFtrZXldID0gZ2l2ZW5fbWFwW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE9wYWwuaGFzaDIoa2V5cywgbWFwKTtcbiAgfTtcblxuICAvLyBDYWxscyBwYXNzZWQgbWV0aG9kIG9uIGEgcnVieSBvYmplY3Qgd2l0aCBhcmd1bWVudHMgYW5kIGJsb2NrOlxuICAvL1xuICAvLyBDYW4gdGFrZSBhIG1ldGhvZCBvciBhIG1ldGhvZCBuYW1lLlxuICAvL1xuICAvLyAxLiBXaGVuIG1ldGhvZCBuYW1lIGdldHMgcGFzc2VkIGl0IGludm9rZXMgaXQgYnkgaXRzIG5hbWVcbiAgLy8gICAgYW5kIGNhbGxzICdtZXRob2RfbWlzc2luZycgd2hlbiBvYmplY3QgZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgbWV0aG9kIHRoYXQgdGFrZXMgYSBibG9jayBvciBhIHNwbGF0LlxuICAvLyAyLiBXaGVuIG1ldGhvZCAoaS5lLiBtZXRob2QgYm9keSkgZ2V0cyBwYXNzZWQsIGl0IGRvZXNuJ3QgdHJpZ2dlciAnbWV0aG9kX21pc3NpbmcnXG4gIC8vICAgIGJlY2F1c2UgaXQgZG9lc24ndCBrbm93IHRoZSBuYW1lIG9mIHRoZSBhY3R1YWwgbWV0aG9kLlxuICAvLyAgICBVc2VkIGludGVybmFsbHkgYnkgT3BhbCB0byBpbnZva2UgJ3N1cGVyJy5cbiAgLy9cbiAgLy8gQGV4YW1wbGVcbiAgLy8gICB2YXIgbXlfYXJyYXkgPSBbMSwgMiwgMywgNF1cbiAgLy8gICBPcGFsLnNlbmQobXlfYXJyYXksICdsZW5ndGgnKSAgICAgICAgICAgICAgICAgICAgIyA9PiA0XG4gIC8vICAgT3BhbC5zZW5kKG15X2FycmF5LCBteV9hcnJheS4kbGVuZ3RoKSAgICAgICAgICAgICMgPT4gNFxuICAvL1xuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgJ3JldmVyc2UhJykgICAgICAgICAgICAgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvLyAgIE9wYWwuc2VuZChteV9hcnJheSwgbXlfYXJyYXlbJyRyZXZlcnNlISddJykgICAgICAjID0+IFs0LCAzLCAyLCAxXVxuICAvL1xuICAvLyBAcGFyYW0gcmVjdiBbT2JqZWN0XSBydWJ5IG9iamVjdFxuICAvLyBAcGFyYW0gbWV0aG9kIFtGdW5jdGlvbiwgU3RyaW5nXSBtZXRob2QgYm9keSBvciBuYW1lIG9mIHRoZSBtZXRob2RcbiAgLy8gQHBhcmFtIGFyZ3MgW0FycmF5XSBhcmd1bWVudHMgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgbWV0aG9kIGNhbGxcbiAgLy8gQHBhcmFtIGJsb2NrIFtGdW5jdGlvbl0gcnVieSBibG9ja1xuICAvLyBAcmV0dXJuIFtPYmplY3RdIHJldHVybmluZyB2YWx1ZSBvZiB0aGUgbWV0aG9kIGNhbGxcbiAgT3BhbC5zZW5kID0gZnVuY3Rpb24ocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jaykge1xuICAgIHZhciBib2R5O1xuXG4gICAgaWYgKHR5cGVvZihtZXRob2QpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBib2R5ID0gbWV0aG9kO1xuICAgICAgbWV0aG9kID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihtZXRob2QpID09PSAnc3RyaW5nJykge1xuICAgICAgYm9keSA9IHJlY3ZbJyQnK21ldGhvZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJQYXNzZWQgbWV0aG9kIHNob3VsZCBiZSBhIHN0cmluZyBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spO1xuICB9O1xuXG4gIE9wYWwuc2VuZDIgPSBmdW5jdGlvbihyZWN2LCBib2R5LCBtZXRob2QsIGFyZ3MsIGJsb2NrKSB7XG4gICAgaWYgKGJvZHkgPT0gbnVsbCAmJiBtZXRob2QgIT0gbnVsbCAmJiByZWN2LiRtZXRob2RfbWlzc2luZykge1xuICAgICAgYm9keSA9IHJlY3YuJG1ldGhvZF9taXNzaW5nO1xuICAgICAgYXJncyA9IFttZXRob2RdLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJsb2NrID09PSAnZnVuY3Rpb24nKSBib2R5LiQkcCA9IGJsb2NrO1xuICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3MpO1xuICB9O1xuXG4gIE9wYWwucmVmaW5lZF9zZW5kID0gZnVuY3Rpb24ocmVmaW5lbWVudF9ncm91cHMsIHJlY3YsIG1ldGhvZCwgYXJncywgYmxvY2spIHtcbiAgICB2YXIgaSwgaiwgaywgYW5jZXN0b3JzLCBhbmNlc3RvciwgcmVmaW5lbWVudHMsIHJlZmluZW1lbnQsIHJlZmluZV9tb2R1bGVzLCByZWZpbmVfbW9kdWxlLCBib2R5O1xuXG4gICAgaWYgKHJlY3YuaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhyZWN2LiQkbWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHJlY3YuJCRjbGFzcyk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGFsbCBhbmNlc3RvcnMgdGhhdCB0aGVyZSBhcmUsIHN0YXJ0aW5nIGZyb20gdGhlIGNsb3Nlc3QgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgZm9yIChpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgYW5jZXN0b3IgPSBPcGFsLmlkKGFuY2VzdG9yc1tpXSk7XG4gICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnQgZ3JvdXBzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgY2xvc2VzdCBzY29wZSB0byB0aGUgZnVydGhlc3QuLi5cbiAgICAgIGZvciAoaiA9IDA7IGogPCByZWZpbmVtZW50X2dyb3Vwcy5sZW5ndGg7IGorKykge1xuICAgICAgICByZWZpbmVtZW50cyA9IHJlZmluZW1lbnRfZ3JvdXBzW2pdO1xuICAgICAgICAvLyBGb3IgYWxsIHJlZmluZW1lbnRzIHRoZXJlIGFyZSwgc3RhcnRpbmcgZnJvbSB0aGUgbGFzdCBgdXNpbmdgIGNhbGwgdG8gdGhlIGZ1cnRoZXN0Li4uXG4gICAgICAgIGZvciAoayA9IHJlZmluZW1lbnRzLmxlbmd0aCAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgICAgcmVmaW5lbWVudCA9IHJlZmluZW1lbnRzW2tdO1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lbWVudC4kJHJlZmluZV9tb2R1bGVzID09PSAndW5kZWZpbmVkJykgY29udGludWU7XG4gICAgICAgICAgLy8gQSBzaW5nbGUgbW9kdWxlIGJlaW5nIGdpdmVuIGFzIGFuIGFyZ3VtZW50IG9mIHRoZSBgdXNpbmdgIGNhbGwgY29udGFpbnMgbXVsdGlwbGVcbiAgICAgICAgICAvLyByZWZpbmVtZW50IG1vZHVsZXNcbiAgICAgICAgICByZWZpbmVfbW9kdWxlcyA9IHJlZmluZW1lbnQuJCRyZWZpbmVfbW9kdWxlcztcbiAgICAgICAgICAvLyBEb2VzIHRoaXMgbW9kdWxlIHJlZmluZSBhIGdpdmVuIGNhbGwgZm9yIGEgZ2l2ZW4gYW5jZXN0b3IgbW9kdWxlP1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lX21vZHVsZXNbYW5jZXN0b3JdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVmaW5lX21vZHVsZSA9IHJlZmluZV9tb2R1bGVzW2FuY2VzdG9yXTtcbiAgICAgICAgICAgIC8vIERvZXMgdGhpcyBtb2R1bGUgZGVmaW5lIGEgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbD9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmaW5lX21vZHVsZS4kJHByb3RvdHlwZVsnJCcrbWV0aG9kXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYm9keSA9IHJlZmluZV9tb2R1bGUuJCRwcm90b3R5cGVbJyQnK21ldGhvZF07XG4gICAgICAgICAgICAgIHJldHVybiBPcGFsLnNlbmQyKHJlY3YsIGJvZHksIG1ldGhvZCwgYXJncywgYmxvY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBPcGFsLnNlbmQocmVjdiwgbWV0aG9kLCBhcmdzLCBibG9jayk7XG4gIH07XG5cbiAgT3BhbC5sYW1iZGEgPSBmdW5jdGlvbihibG9jaykge1xuICAgIGJsb2NrLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG5cbiAgLy8gVXNlZCB0byBkZWZpbmUgbWV0aG9kcyBvbiBhbiBvYmplY3QuIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kLCB1c2VkIGJ5IHRoZVxuICAvLyBjb21waWxlZCBzb3VyY2UgdG8gZGVmaW5lIG1ldGhvZHMgb24gc3BlY2lhbCBjYXNlIG9iamVjdHMgd2hlbiB0aGUgY29tcGlsZXJcbiAgLy8gY2FuIG5vdCBkZXRlcm1pbmUgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCwgb3IgdGhlIG9iamVjdCBpcyBhIE1vZHVsZVxuICAvLyBpbnN0YW5jZS4gVGhpcyBjYW4gZ2V0IGNhbGxlZCBieSBgTW9kdWxlI2RlZmluZV9tZXRob2RgIGFzIHdlbGwuXG4gIC8vXG4gIC8vICMjIE1vZHVsZXNcbiAgLy9cbiAgLy8gQW55IG1ldGhvZCBkZWZpbmVkIG9uIGEgbW9kdWxlIHdpbGwgY29tZSB0aHJvdWdoIHRoaXMgcnVudGltZSBoZWxwZXIuXG4gIC8vIFRoZSBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG1vZHVsZSBib2R5LCBhbmQgdGhlIG93bmVyIG9mIHRoZSBtZXRob2QgaXNcbiAgLy8gc2V0IHRvIGJlIHRoZSBtb2R1bGUgaXRzZWxmLiBUaGlzIGlzIHVzZWQgbGF0ZXIgd2hlbiBjaG9vc2luZyB3aGljaFxuICAvLyBtZXRob2Qgc2hvdWxkIHNob3cgb24gYSBjbGFzcyBpZiBtb3JlIHRoYW4gMSBpbmNsdWRlZCBtb2R1bGVzIGRlZmluZVxuICAvLyB0aGUgc2FtZSBtZXRob2QuIEZpbmFsbHksIGlmIHRoZSBtb2R1bGUgaXMgaW4gYG1vZHVsZV9mdW5jdGlvbmAgbW9kZSxcbiAgLy8gdGhlbiB0aGUgbWV0aG9kIGlzIGFsc28gZGVmaW5lZCBvbnRvIHRoZSBtb2R1bGUgaXRzZWxmLlxuICAvL1xuICAvLyAjIyBDbGFzc2VzXG4gIC8vXG4gIC8vIFRoaXMgaGVscGVyIHdpbGwgb25seSBiZSBjYWxsZWQgZm9yIGNsYXNzZXMgd2hlbiBhIG1ldGhvZCBpcyBiZWluZ1xuICAvLyBkZWZpbmVkIGluZGlyZWN0bHk7IGVpdGhlciB0aHJvdWdoIGBNb2R1bGUjZGVmaW5lX21ldGhvZGAsIG9yIGJ5IGFcbiAgLy8gbGl0ZXJhbCBgZGVmYCBtZXRob2QgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBvciBgY2xhc3NfZXZhbGAgYm9keS4gSW5cbiAgLy8gZWl0aGVyIGNhc2UsIHRoZSBtZXRob2QgaXMgc2ltcGx5IGFkZGVkIHRvIHRoZSBjbGFzcycgcHJvdG90eXBlLiBBIHNwZWNpYWxcbiAgLy8gZXhjZXB0aW9uIGV4aXN0cyBmb3IgYEJhc2ljT2JqZWN0YCBhbmQgYE9iamVjdGAuIFRoZXNlIHR3byBjbGFzc2VzIGFyZVxuICAvLyBzcGVjaWFsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0b2xsLWZyZWUgYnJpZGdlZCBjbGFzc2VzLiBJbiBlYWNoIG9mXG4gIC8vIHRoZXNlIHR3byBjYXNlcywgZXh0cmEgd29yayBpcyByZXF1aXJlZCB0byBkZWZpbmUgdGhlIG1ldGhvZHMgb24gdG9sbC1mcmVlXG4gIC8vIGJyaWRnZWQgY2xhc3MnIHByb3RvdHlwZXMgYXMgd2VsbC5cbiAgLy9cbiAgLy8gIyMgT2JqZWN0c1xuICAvL1xuICAvLyBJZiBhIHNpbXBsZSBydWJ5IG9iamVjdCBpcyB0aGUgb2JqZWN0LCB0aGVuIHRoZSBtZXRob2QgaXMgc2ltcGx5IGp1c3RcbiAgLy8gZGVmaW5lZCBvbiB0aGUgb2JqZWN0IGFzIGEgc2luZ2xldG9uIG1ldGhvZC4gVGhpcyB3b3VsZCBiZSB0aGUgY2FzZSB3aGVuXG4gIC8vIGEgbWV0aG9kIGlzIGRlZmluZWQgaW5zaWRlIGFuIGBpbnN0YW5jZV9ldmFsYCBibG9jay5cbiAgLy9cbiAgLy8gQHBhcmFtIG9iaiAgW09iamVjdCwgQ2xhc3NdIHRoZSBhY3R1YWwgb2JqIHRvIGRlZmluZSBtZXRob2QgZm9yXG4gIC8vIEBwYXJhbSBqc2lkIFtTdHJpbmddIHRoZSBKYXZhU2NyaXB0IGZyaWVuZGx5IG1ldGhvZCBuYW1lIChlLmcuICckZm9vJylcbiAgLy8gQHBhcmFtIGJvZHkgW0pTLkZ1bmN0aW9uXSB0aGUgbGl0ZXJhbCBKYXZhU2NyaXB0IGZ1bmN0aW9uIHVzZWQgYXMgbWV0aG9kXG4gIC8vIEByZXR1cm4gW251bGxdXG4gIC8vXG4gIE9wYWwuZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkLCBib2R5KSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIG1ldGhvZCBkZWZpbml0aW9uIGluIHRoZVxuICAgIC8vIHRvcC1sZXZlbCBuYW1lc3BhY2VcbiAgICBpZiAob2JqID09PSBPcGFsLnRvcCkge1xuICAgICAgT3BhbC5kZWZuKE9wYWwuT2JqZWN0LCBqc2lkLCBib2R5KVxuICAgIH1cbiAgICAvLyBpZiBpbnN0YW5jZV9ldmFsIGlzIGludm9rZWQgb24gYSBtb2R1bGUvY2xhc3MsIGl0IHNldHMgaW5zdF9ldmFsX21vZFxuICAgIGVsc2UgaWYgKCFvYmouJCRldmFsICYmIG9iai4kJGlzX2FfbW9kdWxlKSB7XG4gICAgICBPcGFsLmRlZm4ob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBPcGFsLmRlZnMob2JqLCBqc2lkLCBib2R5KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVmaW5lIG1ldGhvZCBvbiBhIG1vZHVsZSBvciBjbGFzcyAoc2VlIE9wYWwuZGVmKS5cbiAgT3BhbC5kZWZuID0gZnVuY3Rpb24obW9kdWxlLCBqc2lkLCBib2R5KSB7XG4gICAgYm9keS5kaXNwbGF5TmFtZSA9IGpzaWQ7XG4gICAgYm9keS4kJG93bmVyID0gbW9kdWxlO1xuXG4gICAgdmFyIHByb3RvID0gbW9kdWxlLiQkcHJvdG90eXBlO1xuICAgIGlmIChwcm90by5oYXNPd25Qcm9wZXJ0eSgnJCRkdW1teScpKSB7XG4gICAgICBwcm90byA9IHByb3RvLiQkZGVmaW5lX21ldGhvZHNfb247XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShwcm90bywganNpZCwgYm9keSk7XG5cbiAgICBpZiAobW9kdWxlLiQkaXNfbW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLiQkbW9kdWxlX2Z1bmN0aW9uKSB7XG4gICAgICAgIE9wYWwuZGVmcyhtb2R1bGUsIGpzaWQsIGJvZHkpXG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpY2xhc3NlcyA9IG1vZHVsZS4kJGljbGFzc2VzLCBsZW5ndGggPSBpY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWNsYXNzID0gaWNsYXNzZXNbaV07XG4gICAgICAgICRkZWZpbmVQcm9wZXJ0eShpY2xhc3MsIGpzaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaW5nbGV0b25fb2YgPSBtb2R1bGUuJCRzaW5nbGV0b25fb2Y7XG4gICAgaWYgKG1vZHVsZS4kbWV0aG9kX2FkZGVkICYmICFtb2R1bGUuJG1ldGhvZF9hZGRlZC4kJHN0dWIgJiYgIXNpbmdsZXRvbl9vZikge1xuICAgICAgbW9kdWxlLiRtZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiRzaW5nbGV0b25fbWV0aG9kX2FkZGVkICYmICFzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQuJCRzdHViKSB7XG4gICAgICBzaW5nbGV0b25fb2YuJHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgYSBzaW5nbGV0b24gbWV0aG9kIG9uIHRoZSBnaXZlbiBvYmplY3QgKHNlZSBPcGFsLmRlZikuXG4gIE9wYWwuZGVmcyA9IGZ1bmN0aW9uKG9iaiwganNpZCwgYm9keSkge1xuICAgIGlmIChvYmouJCRpc19zdHJpbmcgfHwgb2JqLiQkaXNfbnVtYmVyKSB7XG4gICAgICB0aHJvdyBPcGFsLlR5cGVFcnJvci4kbmV3KFwiY2FuJ3QgZGVmaW5lIHNpbmdsZXRvblwiKTtcbiAgICB9XG4gICAgT3BhbC5kZWZuKE9wYWwuZ2V0X3NpbmdsZXRvbl9jbGFzcyhvYmopLCBqc2lkLCBib2R5KVxuICB9O1xuXG4gIC8vIENhbGxlZCBmcm9tICNyZW1vdmVfbWV0aG9kLlxuICBPcGFsLnJkZWYgPSBmdW5jdGlvbihvYmosIGpzaWQpIHtcbiAgICBpZiAoISRoYXNfb3duLmNhbGwob2JqLiQkcHJvdG90eXBlLCBqc2lkKSkge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBkZWxldGUgb2JqLiQkcHJvdG90eXBlW2pzaWRdO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF9yZW1vdmVkICYmICFvYmouJCRwcm90b3R5cGUuJHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiQkcHJvdG90eXBlLiRzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF9yZW1vdmVkICYmICFvYmouJG1ldGhvZF9yZW1vdmVkLiQkc3R1Yikge1xuICAgICAgICBvYmouJG1ldGhvZF9yZW1vdmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FsbGVkIGZyb20gI3VuZGVmX21ldGhvZC5cbiAgT3BhbC51ZGVmID0gZnVuY3Rpb24ob2JqLCBqc2lkKSB7XG4gICAgaWYgKCFvYmouJCRwcm90b3R5cGVbanNpZF0gfHwgb2JqLiQkcHJvdG90eXBlW2pzaWRdLiQkc3R1Yikge1xuICAgICAgdGhyb3cgT3BhbC5OYW1lRXJyb3IuJG5ldyhcIm1ldGhvZCAnXCIgKyBqc2lkLnN1YnN0cigxKSArIFwiJyBub3QgZGVmaW5lZCBpbiBcIiArIG9iai4kbmFtZSgpKTtcbiAgICB9XG5cbiAgICBPcGFsLmFkZF9zdHViX2ZvcihvYmouJCRwcm90b3R5cGUsIGpzaWQpO1xuXG4gICAgaWYgKG9iai4kJGlzX3NpbmdsZXRvbikge1xuICAgICAgaWYgKG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQuJCRzdHViKSB7XG4gICAgICAgIG9iai4kJHByb3RvdHlwZS4kc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoanNpZC5zdWJzdHIoMSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChvYmouJG1ldGhvZF91bmRlZmluZWQgJiYgIW9iai4kbWV0aG9kX3VuZGVmaW5lZC4kJHN0dWIpIHtcbiAgICAgICAgb2JqLiRtZXRob2RfdW5kZWZpbmVkKGpzaWQuc3Vic3RyKDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNfbWV0aG9kX2JvZHkoYm9keSkge1xuICAgIHJldHVybiAodHlwZW9mKGJvZHkpID09PSBcImZ1bmN0aW9uXCIgJiYgIWJvZHkuJCRzdHViKTtcbiAgfVxuXG4gIE9wYWwuYWxpYXMgPSBmdW5jdGlvbihvYmosIG5hbWUsIG9sZCkge1xuICAgIHZhciBpZCAgICAgPSAnJCcgKyBuYW1lLFxuICAgICAgICBvbGRfaWQgPSAnJCcgKyBvbGQsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGFsaWFzO1xuXG4gICAgLy8gQWxpYXNpbmcgb24gbWFpbiBtZWFucyBhbGlhc2luZyBvbiBPYmplY3QuLi5cbiAgICBpZiAodHlwZW9mIG9iai4kJHByb3RvdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9iaiA9IE9wYWwuT2JqZWN0O1xuICAgIH1cblxuICAgIGJvZHkgPSBvYmouJCRwcm90b3R5cGVbJyQnICsgb2xkXTtcblxuICAgIC8vIFdoZW4gcnVubmluZyBpbnNpZGUgI2luc3RhbmNlX2V2YWwgdGhlIGFsaWFzIHJlZmVycyB0byBjbGFzcyBtZXRob2RzLlxuICAgIGlmIChvYmouJCRldmFsKSB7XG4gICAgICByZXR1cm4gT3BhbC5hbGlhcyhPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob2JqKSwgbmFtZSwgb2xkKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBvYmouJCRzdXBlcjtcblxuICAgICAgd2hpbGUgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiICYmIGFuY2VzdG9yKSB7XG4gICAgICAgIGJvZHkgICAgID0gYW5jZXN0b3Jbb2xkX2lkXTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci4kJHN1cGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpICYmIG9iai4kJGlzX21vZHVsZSkge1xuICAgICAgICAvLyB0cnkgdG8gbG9vayBpbnRvIE9iamVjdFxuICAgICAgICBib2R5ID0gT3BhbC5PYmplY3QuJCRwcm90b3R5cGVbb2xkX2lkXVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzX21ldGhvZF9ib2R5KGJvZHkpKSB7XG4gICAgICAgIHRocm93IE9wYWwuTmFtZUVycm9yLiRuZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGBcIiArIG9sZCArIFwiJyBmb3IgY2xhc3MgYFwiICsgb2JqLiRuYW1lKCkgKyBcIidcIilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYm9keSBpcyBpdHNlbGYgYW4gYWxpYXMgdXNlIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgLy8gdG8ga2VlcCB0aGUgbWF4IGRlcHRoIGF0IDEuXG4gICAgaWYgKGJvZHkuJCRhbGlhc19vZikgYm9keSA9IGJvZHkuJCRhbGlhc19vZjtcblxuICAgIC8vIFdlIG5lZWQgYSB3cmFwcGVyIGJlY2F1c2Ugb3RoZXJ3aXNlIHByb3BlcnRpZXNcbiAgICAvLyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBvbiB0aGUgb3JpZ2luYWwgYm9keS5cbiAgICBhbGlhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGJsb2NrID0gYWxpYXMuJCRwLCBhcmdzLCBpLCBpaTtcblxuICAgICAgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgIGZvcihpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmxvY2sgIT0gbnVsbCkgeyBhbGlhcy4kJHAgPSBudWxsIH1cblxuICAgICAgcmV0dXJuIE9wYWwuc2VuZCh0aGlzLCBib2R5LCBhcmdzLCBibG9jayk7XG4gICAgfTtcblxuICAgIC8vIEFzc2lnbiB0aGUgJ2xlbmd0aCcgdmFsdWUgd2l0aCBkZWZpbmVQcm9wZXJ0eSBiZWNhdXNlXG4gICAgLy8gaW4gc3RyaWN0IG1vZGUgdGhlIHByb3BlcnR5IGlzIG5vdCB3cml0YWJsZS5cbiAgICAvLyBJdCBkb2Vzbid0IHdvcmsgaW4gb2xkZXIgYnJvd3NlcnMgKGxpa2UgQ2hyb21lIDM4KSwgd2hlcmVcbiAgICAvLyBhbiBleGNlcHRpb24gaXMgdGhyb3duIGJyZWFraW5nIE9wYWwgYWx0b2dldGhlci5cbiAgICB0cnkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFsaWFzLCAnbGVuZ3RoJywgeyB2YWx1ZTogYm9keS5sZW5ndGggfSk7XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIC8vIFRyeSB0byBtYWtlIHRoZSBicm93c2VyIHBpY2sgdGhlIHJpZ2h0IG5hbWVcbiAgICBhbGlhcy5kaXNwbGF5TmFtZSAgICAgICA9IG5hbWU7XG5cbiAgICBhbGlhcy4kJGFyaXR5ICAgICAgICAgICA9IGJvZHkuJCRhcml0eTtcbiAgICBhbGlhcy4kJHBhcmFtZXRlcnMgICAgICA9IGJvZHkuJCRwYXJhbWV0ZXJzO1xuICAgIGFsaWFzLiQkc291cmNlX2xvY2F0aW9uID0gYm9keS4kJHNvdXJjZV9sb2NhdGlvbjtcbiAgICBhbGlhcy4kJGFsaWFzX29mICAgICAgICA9IGJvZHk7XG4gICAgYWxpYXMuJCRhbGlhc19uYW1lICAgICAgPSBuYW1lO1xuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGFsaWFzKTtcblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgT3BhbC5hbGlhc19ndmFyID0gZnVuY3Rpb24obmV3X25hbWUsIG9sZF9uYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9wYWwuZ3ZhcnMsIG5ld19uYW1lLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuZ3ZhcnNbb2xkX25hbWVdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24obmV3X3ZhbHVlKSB7XG4gICAgICAgIE9wYWwuZ3ZhcnNbb2xkX25hbWVdID0gbmV3X3ZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuaWw7XG4gIH1cblxuICBPcGFsLmFsaWFzX25hdGl2ZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgbmF0aXZlX25hbWUpIHtcbiAgICB2YXIgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgIGJvZHkgPSBvYmouJCRwcm90b3R5cGVbbmF0aXZlX25hbWVdO1xuXG4gICAgaWYgKHR5cGVvZihib2R5KSAhPT0gXCJmdW5jdGlvblwiIHx8IGJvZHkuJCRzdHViKSB7XG4gICAgICB0aHJvdyBPcGFsLk5hbWVFcnJvci4kbmV3KFwidW5kZWZpbmVkIG5hdGl2ZSBtZXRob2QgYFwiICsgbmF0aXZlX25hbWUgKyBcIicgZm9yIGNsYXNzIGBcIiArIG9iai4kbmFtZSgpICsgXCInXCIpXG4gICAgfVxuXG4gICAgT3BhbC5kZWZuKG9iaiwgaWQsIGJvZHkpO1xuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuXG4gIC8vIEhhc2hlc1xuICAvLyAtLS0tLS1cblxuICBPcGFsLmhhc2hfaW5pdCA9IGZ1bmN0aW9uKGhhc2gpIHtcbiAgICBoYXNoLiQkc21hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaGFzaC4kJG1hcCAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRrZXlzID0gW107XG4gIH07XG5cbiAgT3BhbC5oYXNoX2Nsb25lID0gZnVuY3Rpb24oZnJvbV9oYXNoLCB0b19oYXNoKSB7XG4gICAgdG9faGFzaC4kJG5vbmUgPSBmcm9tX2hhc2guJCRub25lO1xuICAgIHRvX2hhc2guJCRwcm9jID0gZnJvbV9oYXNoLiQkcHJvYztcblxuICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gZnJvbV9oYXNoLiQka2V5cywgc21hcCA9IGZyb21faGFzaC4kJHNtYXAsIGxlbiA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgdmFsdWUgPSBzbWFwW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5oYXNoX3B1dCh0b19oYXNoLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoX3B1dCA9IGZ1bmN0aW9uKGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgaGFzaC4kJGtleXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgaGFzaC4kJHNtYXBba2V5XSA9IHZhbHVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBrZXlfaGFzaCwgYnVja2V0LCBsYXN0X2J1Y2tldDtcbiAgICBrZXlfaGFzaCA9IGhhc2guJCRieV9pZGVudGl0eSA/IE9wYWwuaWQoa2V5KSA6IGtleS4kaGFzaCgpO1xuXG4gICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0ge2tleToga2V5LCBrZXlfaGFzaDoga2V5X2hhc2gsIHZhbHVlOiB2YWx1ZX07XG4gICAgICBoYXNoLiQka2V5cy5wdXNoKGJ1Y2tldCk7XG4gICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBidWNrZXQgPSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBidWNrZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsYXN0X2J1Y2tldCA9IGJ1Y2tldDtcbiAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgIH1cblxuICAgIGlmIChsYXN0X2J1Y2tldCkge1xuICAgICAgYnVja2V0ID0ge2tleToga2V5LCBrZXlfaGFzaDoga2V5X2hhc2gsIHZhbHVlOiB2YWx1ZX07XG4gICAgICBoYXNoLiQka2V5cy5wdXNoKGJ1Y2tldCk7XG4gICAgICBsYXN0X2J1Y2tldC5uZXh0ID0gYnVja2V0O1xuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZ2V0ID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKCRoYXNfb3duLmNhbGwoaGFzaC4kJHNtYXAsIGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGhhc2guJCRzbWFwW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoLCBidWNrZXQ7XG4gICAga2V5X2hhc2ggPSBoYXNoLiQkYnlfaWRlbnRpdHkgPyBPcGFsLmlkKGtleSkgOiBrZXkuJGhhc2goKTtcblxuICAgIGlmICgkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gYnVja2V0LmtleSB8fCBrZXlbJyRlcWw/J10oYnVja2V0LmtleSkpIHtcbiAgICAgICAgICByZXR1cm4gYnVja2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1Y2tldCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPcGFsLmhhc2hfZGVsZXRlID0gZnVuY3Rpb24oaGFzaCwga2V5KSB7XG4gICAgdmFyIGksIGtleXMgPSBoYXNoLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIHZhbHVlO1xuXG4gICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIGtleSA9IGtleS52YWx1ZU9mKCk7XG5cbiAgICAgIGlmICghJGhhc19vd24uY2FsbChoYXNoLiQkc21hcCwga2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2V5c1tpXSA9PT0ga2V5KSB7XG4gICAgICAgICAga2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBoYXNoLiQkc21hcFtrZXldO1xuICAgICAgZGVsZXRlIGhhc2guJCRzbWFwW2tleV07XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleV9oYXNoID0ga2V5LiRoYXNoKCk7XG5cbiAgICBpZiAoISRoYXNfb3duLmNhbGwoaGFzaC4kJG1hcCwga2V5X2hhc2gpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1Y2tldCA9IGhhc2guJCRtYXBba2V5X2hhc2hdLCBsYXN0X2J1Y2tldDtcblxuICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgIGlmIChrZXkgPT09IGJ1Y2tldC5rZXkgfHwga2V5WyckZXFsPyddKGJ1Y2tldC5rZXkpKSB7XG4gICAgICAgIHZhbHVlID0gYnVja2V0LnZhbHVlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChrZXlzW2ldID09PSBidWNrZXQpIHtcbiAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RfYnVja2V0ICYmIGJ1Y2tldC5uZXh0KSB7XG4gICAgICAgICAgbGFzdF9idWNrZXQubmV4dCA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgICAgZGVsZXRlIGxhc3RfYnVja2V0Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGJ1Y2tldC5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBoYXNoLiQkbWFwW2tleV9oYXNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgYnVja2V0ID0gYnVja2V0Lm5leHQ7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwuaGFzaF9yZWhhc2ggPSBmdW5jdGlvbihoYXNoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGhhc2guJCRrZXlzLmxlbmd0aCwga2V5X2hhc2gsIGJ1Y2tldCwgbGFzdF9idWNrZXQ7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoaGFzaC4kJGtleXNbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGtleV9oYXNoID0gaGFzaC4kJGtleXNbaV0ua2V5LiRoYXNoKCk7XG5cbiAgICAgIGlmIChrZXlfaGFzaCA9PT0gaGFzaC4kJGtleXNbaV0ua2V5X2hhc2gpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJ1Y2tldCA9IGhhc2guJCRtYXBbaGFzaC4kJGtleXNbaV0ua2V5X2hhc2hdO1xuICAgICAgbGFzdF9idWNrZXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHdoaWxlIChidWNrZXQpIHtcbiAgICAgICAgaWYgKGJ1Y2tldCA9PT0gaGFzaC4kJGtleXNbaV0pIHtcbiAgICAgICAgICBpZiAobGFzdF9idWNrZXQgJiYgYnVja2V0Lm5leHQpIHtcbiAgICAgICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAobGFzdF9idWNrZXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0X2J1Y2tldC5uZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChidWNrZXQubmV4dCkge1xuICAgICAgICAgICAgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF0gPSBidWNrZXQubmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgaGFzaC4kJG1hcFtoYXNoLiQka2V5c1tpXS5rZXlfaGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaGFzaC4kJGtleXNbaV0ua2V5X2hhc2ggPSBrZXlfaGFzaDtcblxuICAgICAgaWYgKCEkaGFzX293bi5jYWxsKGhhc2guJCRtYXAsIGtleV9oYXNoKSkge1xuICAgICAgICBoYXNoLiQkbWFwW2tleV9oYXNoXSA9IGhhc2guJCRrZXlzW2ldO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnVja2V0ID0gaGFzaC4kJG1hcFtrZXlfaGFzaF07XG4gICAgICBsYXN0X2J1Y2tldCA9IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGJ1Y2tldCkge1xuICAgICAgICBpZiAoYnVja2V0ID09PSBoYXNoLiQka2V5c1tpXSkge1xuICAgICAgICAgIGxhc3RfYnVja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RfYnVja2V0ID0gYnVja2V0O1xuICAgICAgICBidWNrZXQgPSBidWNrZXQubmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhc3RfYnVja2V0KSB7XG4gICAgICAgIGxhc3RfYnVja2V0Lm5leHQgPSBoYXNoLiQka2V5c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgT3BhbC5oYXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3VtZW50c19sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBoYXNoLCBpLCBsZW5ndGgsIGtleSwgdmFsdWU7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0uJCRpc19oYXNoKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuICAgIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG4gICAgT3BhbC5oYXNoX2luaXQoaGFzaCk7XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0uJCRpc19hcnJheSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3NbaV0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgT3BhbC5Bcmd1bWVudEVycm9yLiRuZXcoXCJ2YWx1ZSBub3Qgb2YgbGVuZ3RoIDI6IFwiICsgYXJnc1tpXS4kaW5zcGVjdCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleSA9IGFyZ3NbaV1bMF07XG4gICAgICAgIHZhbHVlID0gYXJnc1tpXVsxXTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCA9PT0gMSkge1xuICAgICAgYXJncyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAoa2V5IGluIGFyZ3MpIHtcbiAgICAgICAgaWYgKCRoYXNfb3duLmNhbGwoYXJncywga2V5KSkge1xuICAgICAgICAgIHZhbHVlID0gYXJnc1trZXldO1xuXG4gICAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzX2xlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwib2RkIG51bWJlciBvZiBhcmd1bWVudHMgZm9yIEhhc2hcIik7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50c19sZW5ndGg7IGkgKz0gMikge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbaSArIDFdO1xuXG4gICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8vIEEgZmFzdGVyIEhhc2ggY3JlYXRvciBmb3IgaGFzaGVzIHRoYXQganVzdCB1c2Ugc3ltYm9scyBhbmRcbiAgLy8gc3RyaW5ncyBhcyBrZXlzLiBUaGUgbWFwIGFuZCBrZXlzIGFycmF5IGNhbiBiZSBjb25zdHJ1Y3RlZCBhdFxuICAvLyBjb21waWxlIHRpbWUsIHNvIHRoZXkgYXJlIGp1c3QgYWRkZWQgaGVyZSBieSB0aGUgY29uc3RydWN0b3JcbiAgLy8gZnVuY3Rpb24uXG4gIC8vXG4gIE9wYWwuaGFzaDIgPSBmdW5jdGlvbihrZXlzLCBzbWFwKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgT3BhbC5IYXNoKCk7XG5cbiAgICBoYXNoLiQkc21hcCA9IHNtYXA7XG4gICAgaGFzaC4kJG1hcCAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGhhc2guJCRrZXlzID0ga2V5cztcblxuICAgIHJldHVybiBoYXNoO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIG5ldyByYW5nZSBpbnN0YW5jZSB3aXRoIGZpcnN0IGFuZCBsYXN0IHZhbHVlcywgYW5kIHdoZXRoZXIgdGhlXG4gIC8vIHJhbmdlIGV4Y2x1ZGVzIHRoZSBsYXN0IHZhbHVlLlxuICAvL1xuICBPcGFsLnJhbmdlID0gZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGV4Yykge1xuICAgIHZhciByYW5nZSAgICAgICAgID0gbmV3IE9wYWwuUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2UuYmVnaW4gICA9IGZpcnN0O1xuICAgICAgICByYW5nZS5lbmQgICAgID0gbGFzdDtcbiAgICAgICAgcmFuZ2UuZXhjbCAgICA9IGV4YztcblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGl2YXIgbmFtZSBmb3IgYSBnaXZlbiBuYW1lLlxuICAvLyBNb3N0bHkgYWRkcyBhIHRyYWlsaW5nICQgdG8gcmVzZXJ2ZWQgbmFtZXMuXG4gIC8vXG4gIE9wYWwuaXZhciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoXG4gICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgbmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICAgIG5hbWUgPT09IFwiZGlzcGxheU5hbWVcIiB8fFxuICAgICAgICBuYW1lID09PSBcIl9fY291bnRfX1wiIHx8XG4gICAgICAgIG5hbWUgPT09IFwiX19ub1N1Y2hNZXRob2RfX1wiIHx8XG4gICAgICAgIG5hbWUgPT09IFwiX19wYXJlbnRfX1wiIHx8XG4gICAgICAgIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHxcblxuICAgICAgICAvLyBtZXRob2RzXG4gICAgICAgIG5hbWUgPT09IFwiaGFzT3duUHJvcGVydHlcIiB8fFxuICAgICAgICBuYW1lID09PSBcInZhbHVlT2ZcIlxuICAgICAgIClcbiAgICB7XG4gICAgICByZXR1cm4gbmFtZSArIFwiJFwiO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lO1xuICB9O1xuXG5cbiAgLy8gUmVnZXhwc1xuICAvLyAtLS0tLS0tXG5cbiAgLy8gRXNjYXBlIFJlZ2V4cCBzcGVjaWFsIGNoYXJzIGxldHRpbmcgdGhlIHJlc3VsdGluZyBzdHJpbmcgYmUgdXNlZCB0byBidWlsZFxuICAvLyBhIG5ldyBSZWdleHAuXG4gIC8vXG4gIE9wYWwuZXNjYXBlX3JlZ2V4cCA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFstW1xcXVxcL3t9KCkqKz8uXiRcXFxcfCBdKS9nLCAnXFxcXCQxJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXG5dL2csICdcXFxcbicpXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxyXS9nLCAnXFxcXHInKVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcZl0vZywgJ1xcXFxmJylcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHRdL2csICdcXFxcdCcpO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGdsb2JhbCBSZWdleHAgZnJvbSBhIFJlZ0V4cCBvYmplY3QgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgLy8gb24gdGhlIG9iamVjdCBpdHNlbGYgKCQkZyBhdHRyaWJ1dGUpLlxuICAvL1xuICBPcGFsLmdsb2JhbF9yZWdleHAgPSBmdW5jdGlvbihwYXR0ZXJuKSB7XG4gICAgaWYgKHBhdHRlcm4uZ2xvYmFsKSB7XG4gICAgICByZXR1cm4gcGF0dGVybjsgLy8gUmVnRXhwIGFscmVhZHkgaGFzIHRoZSBnbG9iYWwgZmxhZ1xuICAgIH1cbiAgICBpZiAocGF0dGVybi4kJGcgPT0gbnVsbCkge1xuICAgICAgcGF0dGVybi4kJGcgPSBuZXcgUmVnRXhwKHBhdHRlcm4uc291cmNlLCAocGF0dGVybi5tdWx0aWxpbmUgPyAnZ20nIDogJ2cnKSArIChwYXR0ZXJuLmlnbm9yZUNhc2UgPyAnaScgOiAnJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuLiQkZy5sYXN0SW5kZXggPSBudWxsOyAvLyByZXNldCBsYXN0SW5kZXggcHJvcGVydHlcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm4uJCRnO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGdsb2JhbCBtdWx0aWxpbmUgUmVnZXhwIGZyb20gYSBSZWdFeHAgb2JqZWN0IGFuZCBjYWNoZSB0aGUgcmVzdWx0XG4gIC8vIG9uIHRoZSBvYmplY3QgaXRzZWxmICgkJGdtIG9yICQkZyBhdHRyaWJ1dGUpLlxuICAvL1xuICBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwID0gZnVuY3Rpb24ocGF0dGVybikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKHBhdHRlcm4ubXVsdGlsaW5lKSB7XG4gICAgICBpZiAocGF0dGVybi5nbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm47IC8vIFJlZ0V4cCBhbHJlYWR5IGhhcyB0aGUgZ2xvYmFsIGFuZCBtdWx0aWxpbmUgZmxhZ1xuICAgICAgfVxuICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSAkJGcgYXR0cmlidXRlIGJlY2F1c2UgdGhlIFJlZ2V4cCBpcyBhbHJlYWR5IG11bHRpbGluZVxuICAgICAgaWYgKHBhdHRlcm4uJCRnICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gcGF0dGVybi4kJGc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZyA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsICdnbScgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhdHRlcm4uJCRnbSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBwYXR0ZXJuLiQkZ207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHBhdHRlcm4uJCRnbSA9IG5ldyBSZWdFeHAocGF0dGVybi5zb3VyY2UsICdnbScgKyAocGF0dGVybi5pZ25vcmVDYXNlID8gJ2knIDogJycpKTtcbiAgICB9XG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IG51bGw7IC8vIHJlc2V0IGxhc3RJbmRleCBwcm9wZXJ0eVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29tYmluZSBtdWx0aXBsZSByZWdleHAgcGFydHMgdG9nZXRoZXJcbiAgT3BhbC5yZWdleHAgPSBmdW5jdGlvbihwYXJ0cywgZmxhZ3MpIHtcbiAgICB2YXIgcGFydDtcbiAgICB2YXIgaWdub3JlQ2FzZSA9IHR5cGVvZiBmbGFncyAhPT0gJ3VuZGVmaW5lZCcgJiYgZmxhZ3MgJiYgZmxhZ3MuaW5kZXhPZignaScpID49IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwYXJ0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgICBpZiAocGFydCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBpZiAocGFydC5pZ25vcmVDYXNlICE9PSBpZ25vcmVDYXNlKVxuICAgICAgICAgIE9wYWwuS2VybmVsLiR3YXJuKFxuICAgICAgICAgICAgXCJpZ25vcmUgY2FzZSBkb2Vzbid0IG1hdGNoIGZvciBcIiArIHBhcnQuc291cmNlLiRpbnNwZWN0KCksXG4gICAgICAgICAgICBPcGFsLmhhc2goe3VwbGV2ZWw6IDF9KVxuICAgICAgICAgIClcblxuICAgICAgICBwYXJ0ID0gcGFydC5zb3VyY2U7XG4gICAgICB9XG4gICAgICBpZiAocGFydCA9PT0gJycpIHBhcnQgPSAnKD86JyArIHBhcnQgKyAnKSc7XG4gICAgICBwYXJ0c1tpXSA9IHBhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGZsYWdzKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKCcnKSwgZmxhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXJ0cy5qb2luKCcnKSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlcXVpcmUgc3lzdGVtXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgT3BhbC5tb2R1bGVzICAgICAgICAgPSB7fTtcbiAgT3BhbC5sb2FkZWRfZmVhdHVyZXMgPSBbJ2NvcmVsaWIvcnVudGltZSddO1xuICBPcGFsLmN1cnJlbnRfZGlyICAgICA9ICcuJztcbiAgT3BhbC5yZXF1aXJlX3RhYmxlICAgPSB7J2NvcmVsaWIvcnVudGltZSc6IHRydWV9O1xuXG4gIE9wYWwubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciBwYXJ0cywgcGFydCwgbmV3X3BhcnRzID0gW10sIFNFUEFSQVRPUiA9ICcvJztcblxuICAgIGlmIChPcGFsLmN1cnJlbnRfZGlyICE9PSAnLicpIHtcbiAgICAgIHBhdGggPSBPcGFsLmN1cnJlbnRfZGlyLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhdGg7XG4gICAgfVxuXG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLlxcLy8sICcnKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXC4ocmJ8b3BhbHxqcykkLywgJycpO1xuICAgIHBhcnRzID0gcGF0aC5zcGxpdChTRVBBUkFUT1IpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSBjb250aW51ZTtcbiAgICAgIChwYXJ0ID09PSAnLi4nKSA/IG5ld19wYXJ0cy5wb3AoKSA6IG5ld19wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld19wYXJ0cy5qb2luKFNFUEFSQVRPUik7XG4gIH07XG5cbiAgT3BhbC5sb2FkZWQgPSBmdW5jdGlvbihwYXRocykge1xuICAgIHZhciBpLCBsLCBwYXRoO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGhzW2ldKTtcblxuICAgICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgT3BhbC5sb2FkZWRfZmVhdHVyZXMucHVzaChwYXRoKTtcbiAgICAgIE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIE9wYWwubG9hZCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG5cbiAgICBPcGFsLmxvYWRlZChbcGF0aF0pO1xuXG4gICAgdmFyIG1vZHVsZSA9IE9wYWwubW9kdWxlc1twYXRoXTtcblxuICAgIGlmIChtb2R1bGUpIHtcbiAgICAgIG1vZHVsZShPcGFsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2V2ZXJpdHkgPSBPcGFsLmNvbmZpZy5taXNzaW5nX3JlcXVpcmVfc2V2ZXJpdHk7XG4gICAgICB2YXIgbWVzc2FnZSAgPSAnY2Fubm90IGxvYWQgc3VjaCBmaWxlIC0tICcgKyBwYXRoO1xuXG4gICAgICBpZiAoc2V2ZXJpdHkgPT09IFwiZXJyb3JcIikge1xuICAgICAgICBpZiAoT3BhbC5Mb2FkRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBPcGFsLkxvYWRFcnJvci4kbmV3KG1lc3NhZ2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbWVzc2FnZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZXZlcml0eSA9PT0gXCJ3YXJuaW5nXCIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBMb2FkRXJyb3I6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBPcGFsLnJlcXVpcmUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IE9wYWwubm9ybWFsaXplKHBhdGgpO1xuXG4gICAgaWYgKE9wYWwucmVxdWlyZV90YWJsZVtwYXRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBPcGFsLmxvYWQocGF0aCk7XG4gIH07XG5cblxuICAvLyBTdHJpbmdzXG4gIC8vIC0tLS0tLS1cblxuICBPcGFsLmVuY29kaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gU2V0cyB0aGUgZW5jb2Rpbmcgb24gYSBzdHJpbmcsIHdpbGwgdHJlYXQgc3RyaW5nIGxpdGVyYWxzIGFzIGZyb3plbiBzdHJpbmdzXG4gIC8vIHJhaXNpbmcgYSBGcm96ZW5FcnJvci5cbiAgLy9cbiAgLy8gQHBhcmFtIHN0ciBbU3RyaW5nXSB0aGUgc3RyaW5nIG9uIHdoaWNoIHRoZSBlbmNvZGluZyBzaG91bGQgYmUgc2V0XG4gIC8vIEBwYXJhbSBuYW1lIFtTdHJpbmddIHRoZSBjYW5vbmljYWwgbmFtZSBvZiB0aGUgZW5jb2RpbmdcbiAgLy8gQHBhcmFtIHR5cGUgW1N0cmluZ10gcG9zc2libGUgdmFsdWVzIGFyZSBlaXRoZXIgYFwiZW5jb2RpbmdcImAsIGBcImludGVybmFsX2VuY29kaW5nXCJgLCBvciBgdW5kZWZpbmVkXG4gIE9wYWwuc2V0X2VuY29kaW5nID0gZnVuY3Rpb24oc3RyLCBuYW1lLCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInVuZGVmaW5lZFwiKSB0eXBlID0gXCJlbmNvZGluZ1wiO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIuJCRmcm96ZW4gPT09IHRydWUpXG4gICAgICB0aHJvdyBPcGFsLkZyb3plbkVycm9yLiRuZXcoXCJjYW4ndCBtb2RpZnkgZnJvemVuIFN0cmluZ1wiKTtcblxuICAgIHZhciBlbmNvZGluZyA9IE9wYWwuZmluZF9lbmNvZGluZyhuYW1lKTtcblxuICAgIGlmIChlbmNvZGluZyA9PT0gc3RyW3R5cGVdKSB7IHJldHVybiBzdHI7IH1cblxuICAgIHN0clt0eXBlXSA9IGVuY29kaW5nO1xuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICAvLyBGZXRjaGVzIHRoZSBlbmNvZGluZyBmb3IgdGhlIGdpdmVuIG5hbWUgb3IgcmFpc2VzIEFyZ3VtZW50RXJyb3IuXG4gIE9wYWwuZmluZF9lbmNvZGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgcmVnaXN0ZXIgPSBPcGFsLmVuY29kaW5ncztcbiAgICB2YXIgZW5jb2RpbmcgPSByZWdpc3RlcltuYW1lXSB8fCByZWdpc3RlcltuYW1lLnRvVXBwZXJDYXNlKCldO1xuICAgIGlmICghZW5jb2RpbmcpIHRocm93IE9wYWwuQXJndW1lbnRFcnJvci4kbmV3KFwidW5rbm93biBlbmNvZGluZyBuYW1lIC0gXCIgKyBuYW1lKTtcbiAgICByZXR1cm4gZW5jb2Rpbmc7XG4gIH1cblxuICAvLyBAcmV0dXJucyBhIFN0cmluZyBvYmplY3Qgd2l0aCB0aGUgZW5jb2Rpbmcgc2V0IGZyb20gYSBzdHJpbmcgbGl0ZXJhbFxuICBPcGFsLmVuYyA9IGZ1bmN0aW9uKHN0ciwgbmFtZSkge1xuICAgIHZhciBkdXAgPSBuZXcgU3RyaW5nKHN0cik7XG4gICAgZHVwID0gT3BhbC5zZXRfZW5jb2RpbmcoZHVwLCBuYW1lKTtcbiAgICBkdXAuaW50ZXJuYWxfZW5jb2RpbmcgPSBkdXAuZW5jb2Rpbmc7XG4gICAgcmV0dXJuIGR1cFxuICB9XG5cbiAgLy8gQHJldHVybnMgYSBTdHJpbmcgb2JqZWN0IHdpdGggdGhlIGludGVybmFsIGVuY29kaW5nIHNldCB0byBCaW5hcnlcbiAgT3BhbC5iaW5hcnkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgZHVwID0gbmV3IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiBPcGFsLnNldF9lbmNvZGluZyhkdXAsIFwiYmluYXJ5XCIsIFwiaW50ZXJuYWxfZW5jb2RpbmdcIik7XG4gIH1cblxuXG4gIC8vIEluaXRpYWxpemF0aW9uXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uICRCYXNpY09iamVjdCgpIHt9XG4gIGZ1bmN0aW9uICRPYmplY3QoKSB7fVxuICBmdW5jdGlvbiAkTW9kdWxlKCkge31cbiAgZnVuY3Rpb24gJENsYXNzKCkge31cblxuICBPcGFsLkJhc2ljT2JqZWN0ID0gQmFzaWNPYmplY3QgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdCYXNpY09iamVjdCcsIG51bGwsICRCYXNpY09iamVjdCk7XG4gIE9wYWwuT2JqZWN0ICAgICAgPSBfT2JqZWN0ICAgICA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ09iamVjdCcsIE9wYWwuQmFzaWNPYmplY3QsICRPYmplY3QpO1xuICBPcGFsLk1vZHVsZSAgICAgID0gTW9kdWxlICAgICAgPSBPcGFsLmFsbG9jYXRlX2NsYXNzKCdNb2R1bGUnLCBPcGFsLk9iamVjdCwgJE1vZHVsZSk7XG4gIE9wYWwuQ2xhc3MgICAgICAgPSBDbGFzcyAgICAgICA9IE9wYWwuYWxsb2NhdGVfY2xhc3MoJ0NsYXNzJywgT3BhbC5Nb2R1bGUsICRDbGFzcyk7XG5cbiAgJHNldF9wcm90byhPcGFsLkJhc2ljT2JqZWN0LCBPcGFsLkNsYXNzLiQkcHJvdG90eXBlKTtcbiAgJHNldF9wcm90byhPcGFsLk9iamVjdCwgT3BhbC5DbGFzcy4kJHByb3RvdHlwZSk7XG4gICRzZXRfcHJvdG8oT3BhbC5Nb2R1bGUsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuICAkc2V0X3Byb3RvKE9wYWwuQ2xhc3MsIE9wYWwuQ2xhc3MuJCRwcm90b3R5cGUpO1xuXG4gIC8vIEJhc2ljT2JqZWN0IGNhbiByZWFjaCBpdHNlbGYsIGF2b2lkIGNvbnN0X3NldCB0byBza2lwIHRoZSAkJGJhc2VfbW9kdWxlIGxvZ2ljXG4gIEJhc2ljT2JqZWN0LiQkY29uc3RbXCJCYXNpY09iamVjdFwiXSA9IEJhc2ljT2JqZWN0O1xuXG4gIC8vIEFzc2lnbiBiYXNpYyBjb25zdGFudHNcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJCYXNpY09iamVjdFwiLCAgQmFzaWNPYmplY3QpO1xuICBPcGFsLmNvbnN0X3NldChfT2JqZWN0LCBcIk9iamVjdFwiLCAgICAgICBfT2JqZWN0KTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJNb2R1bGVcIiwgICAgICAgTW9kdWxlKTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgXCJDbGFzc1wiLCAgICAgICAgQ2xhc3MpO1xuXG4gIC8vIEZpeCBib290ZWQgY2xhc3NlcyB0byBoYXZlIGNvcnJlY3QgLmNsYXNzIHZhbHVlXG4gIEJhc2ljT2JqZWN0LiQkY2xhc3MgPSBDbGFzcztcbiAgX09iamVjdC4kJGNsYXNzICAgICA9IENsYXNzO1xuICBNb2R1bGUuJCRjbGFzcyAgICAgID0gQ2xhc3M7XG4gIENsYXNzLiQkY2xhc3MgICAgICAgPSBDbGFzcztcblxuICAvLyBGb3J3YXJkIC50b1N0cmluZygpIHRvICN0b19zXG4gICRkZWZpbmVQcm9wZXJ0eShfT2JqZWN0LiQkcHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdG9fcyA9IHRoaXMuJHRvX3MoKTtcbiAgICBpZiAodG9fcy4kJGlzX3N0cmluZyAmJiB0eXBlb2YodG9fcykgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBhIHN0cmluZyBjcmVhdGVkIHVzaW5nIG5ldyBTdHJpbmcoJ3N0cmluZycpXG4gICAgICByZXR1cm4gdG9fcy52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b19zO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gTWFrZSBLZXJuZWwjcmVxdWlyZSBpbW1lZGlhdGVseSBhdmFpbGFibGUgYXMgaXQncyBuZWVkZWQgdG8gcmVxdWlyZSBhbGwgdGhlXG4gIC8vIG90aGVyIGNvcmVsaWIgZmlsZXMuXG4gICRkZWZpbmVQcm9wZXJ0eShfT2JqZWN0LiQkcHJvdG90eXBlLCAnJHJlcXVpcmUnLCBPcGFsLnJlcXVpcmUpO1xuXG4gIC8vIEluc3RhbnRpYXRlIHRoZSBtYWluIG9iamVjdFxuICBPcGFsLnRvcCA9IG5ldyBfT2JqZWN0KCk7XG4gIE9wYWwudG9wLiR0b19zID0gT3BhbC50b3AuJGluc3BlY3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuICdtYWluJyB9O1xuICBPcGFsLnRvcC4kZGVmaW5lX21ldGhvZCA9IHRvcF9kZWZpbmVfbWV0aG9kO1xuXG4gIC8vIEZvd2FyZCBjYWxscyB0byBkZWZpbmVfbWV0aG9kIG9uIHRoZSB0b3Agb2JqZWN0IHRvIE9iamVjdFxuICBmdW5jdGlvbiB0b3BfZGVmaW5lX21ldGhvZCgpIHtcbiAgICB2YXIgYXJncyA9IE9wYWwuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIHZhciBibG9jayA9IHRvcF9kZWZpbmVfbWV0aG9kLiQkcDtcbiAgICB0b3BfZGVmaW5lX21ldGhvZC4kJHAgPSBudWxsO1xuICAgIHJldHVybiBPcGFsLnNlbmQoX09iamVjdCwgJ2RlZmluZV9tZXRob2QnLCBhcmdzLCBibG9jaylcbiAgfTtcblxuXG4gIC8vIE5pbFxuICBmdW5jdGlvbiAkTmlsQ2xhc3MoKSB7fVxuICBPcGFsLk5pbENsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcygnTmlsQ2xhc3MnLCBPcGFsLk9iamVjdCwgJE5pbENsYXNzKTtcbiAgT3BhbC5jb25zdF9zZXQoX09iamVjdCwgJ05pbENsYXNzJywgT3BhbC5OaWxDbGFzcyk7XG4gIG5pbCA9IE9wYWwubmlsID0gbmV3IE9wYWwuTmlsQ2xhc3MoKTtcbiAgbmlsLiQkaWQgPSBuaWxfaWQ7XG4gIG5pbC5jYWxsID0gbmlsLmFwcGx5ID0gZnVuY3Rpb24oKSB7IHRocm93IE9wYWwuTG9jYWxKdW1wRXJyb3IuJG5ldygnbm8gYmxvY2sgZ2l2ZW4nKTsgfTtcblxuICAvLyBFcnJvcnNcbiAgT3BhbC5icmVha2VyICA9IG5ldyBFcnJvcigndW5leHBlY3RlZCBicmVhayAob2xkKScpO1xuICBPcGFsLnJldHVybmVyID0gbmV3IEVycm9yKCd1bmV4cGVjdGVkIHJldHVybicpO1xuICBUeXBlRXJyb3IuJCRzdXBlciA9IEVycm9yO1xufSkuY2FsbCh0aGlzKTtcbk9wYWwubG9hZGVkKFtcImNvcmVsaWIvcnVudGltZS5qc1wiXSk7Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNJOztBQUVKO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7O0FBRUU7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNJO0FBQ0E7O0FBRUo7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTs7QUFFRjtBQUNFOztBQUVGO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVKO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7O0FBRUo7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDSTs7QUFFSjtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTs7QUFFSjtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7O0FBR0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVFO0FBQ0U7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0k7QUFDQTtBQUNBOztBQUVKO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNJOztBQUVKO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNFOztBQUVBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNBO0FBQ0E7O0FBRUo7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDSDtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1U7QUFDQTtBQUNBO0FBQ0E7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFRjtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFOztBQUVBOztBQUVBOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNjkxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oZWxwZXJzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHlwZV9lcnJvciwgY29lcmNlX3RvXG5cbm1vZHVsZSBPcGFsXG4gIGRlZiBzZWxmLmJyaWRnZShjb25zdHJ1Y3Rvciwga2xhc3MpXG4gICAgYE9wYWwuYnJpZGdlKGNvbnN0cnVjdG9yLCBrbGFzcylgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvZXJjZV90byEob2JqZWN0LCB0eXBlLCBtZXRob2QsICphcmdzKVxuICAgIGNvZXJjZWQgPSBgJGNvZXJjZV90byhvYmplY3QsIHR5cGUsIG1ldGhvZCwgYXJncylgXG5cbiAgICB1bmxlc3MgdHlwZSA9PT0gY29lcmNlZFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKG9iamVjdCwgdHlwZSwgbWV0aG9kLCBjb2VyY2VkKWBcbiAgICBlbmRcblxuICAgIGNvZXJjZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29lcmNlX3RvPyhvYmplY3QsIHR5cGUsIG1ldGhvZCwgKmFyZ3MpXG4gICAgcmV0dXJuIHVubGVzcyBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG5cbiAgICBjb2VyY2VkID0gYCRjb2VyY2VfdG8ob2JqZWN0LCB0eXBlLCBtZXRob2QsIGFyZ3MpYFxuXG4gICAgcmV0dXJuIGlmIGNvZXJjZWQubmlsP1xuXG4gICAgdW5sZXNzIHR5cGUgPT09IGNvZXJjZWRcbiAgICAgIHJhaXNlIGAkdHlwZV9lcnJvcihvYmplY3QsIHR5cGUsIG1ldGhvZCwgY29lcmNlZClgXG4gICAgZW5kXG5cbiAgICBjb2VyY2VkXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iamVjdCwgdHlwZSwgbWV0aG9kKVxuICAgIHJldHVybiBvYmplY3QgaWYgdHlwZSA9PT0gb2JqZWN0XG5cbiAgICBpZiBvYmplY3QucmVzcG9uZF90bz8gbWV0aG9kXG4gICAgICBvYmplY3QuX19zZW5kX18gbWV0aG9kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbXBhcmUoYSwgYilcbiAgICBjb21wYXJlID0gYSA8PT4gYlxuXG4gICAgaWYgYGNvbXBhcmUgPT09IG5pbGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2EuY2xhc3N9IHdpdGggI3tiLmNsYXNzfSBmYWlsZWRcIlxuICAgIGVuZFxuXG4gICAgY29tcGFyZVxuICBlbmRcblxuICBkZWYgc2VsZi5kZXN0cnVjdHVyZShhcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhcmdzLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGFyZ3NfYXJ5ID0gbmV3IEFycmF5KGFyZ3MubGVuZ3RoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgbCA9IGFyZ3NfYXJ5Lmxlbmd0aDsgaSA8IGw7IGkrKykgeyBhcmdzX2FyeVtpXSA9IGFyZ3NbaV07IH1cblxuICAgICAgICByZXR1cm4gYXJnc19hcnk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yZXNwb25kX3RvPyhvYmosIG1ldGhvZCwgaW5jbHVkZV9hbGwgPSBmYWxzZSlcbiAgICAleHtcbiAgICAgIGlmIChvYmogPT0gbnVsbCB8fCAhb2JqLiQkY2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9iai5yZXNwb25kX3RvPyhtZXRob2QsIGluY2x1ZGVfYWxsKVxuICBlbmRcblxuICBkZWYgc2VsZi5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuXG4gICAgdW5sZXNzIGAvXkBbYS16QS1aX11bYS16QS1aMC05X10qPyQvLnRlc3QobmFtZSlgXG4gICAgICByYWlzZSBOYW1lRXJyb3IubmV3KFwiJyN7bmFtZX0nIGlzIG5vdCBhbGxvd2VkIGFzIGFuIGluc3RhbmNlIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGBuYW1lLmxlbmd0aCA8IDMgfHwgbmFtZS5zbGljZSgwLDIpICE9PSAnQEAnYFxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcImAje25hbWV9JyBpcyBub3QgYWxsb3dlZCBhcyBhIGNsYXNzIHZhcmlhYmxlIG5hbWVcIiwgbmFtZSlcbiAgICBlbmRcblxuICAgIG5hbWVcbiAgZW5kXG5cbiAgZGVmIHNlbGYuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICBjb25zdF9uYW1lID0gT3BhbC5jb2VyY2VfdG8hKGNvbnN0X25hbWUsIFN0cmluZywgOnRvX3N0cilcblxuICAgIGlmIGNvbnN0X25hbWVbMF0gIT0gY29uc3RfbmFtZVswXS51cGNhc2VcbiAgICAgIHJhaXNlIE5hbWVFcnJvciwgXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7Y29uc3RfbmFtZX1cIlxuICAgIGVuZFxuXG4gICAgY29uc3RfbmFtZVxuICBlbmRcblxuICAjIEBwcml2YXRlXG4gICMgTWFyayBzb21lIG1ldGhvZHMgYXMgcHJpc3RpbmUgaW4gb3JkZXIgdG8gYXBwbHkgb3B0aW1pemF0aW9ucyB3aGVuIHRoZXlcbiAgIyBhcmUgc3RpbGwgaW4gdGhlaXIgb3JpZ2luYWwgZm9ybS4gVGhpcyBjb3VsZCBwcm9iYWJseSBiZSBtb3ZlZCB0b1xuICAjIHRoZSBgT3BhbC5kZWYoKWAgSlMgQVBJLCBidXQgZm9yIG5vdyBpdCB3aWxsIHN0YXkgbWFudWFsLlxuICAjXG4gICMgQGV4YW1wbGVcbiAgI1xuICAjICAgT3BhbC5wcmlzdGluZSBBcnJheSwgOmFsbG9jYXRlLCA6Y29weV9pbnN0YW5jZV92YXJpYWJsZXMsIDppbml0aWFsaXplX2R1cFxuICAjXG4gICMgICBjbGFzcyBBcnJheVxuICAjICAgICBkZWYgZHVwXG4gICMgICAgICAgJXh7XG4gICMgICAgICAgICBpZiAoXG4gICMgICAgICAgICAgIHNlbGYuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgIyAgICAgICAgICAgc2VsZi4kY29weV9pbnN0YW5jZV92YXJpYWJsZXMuJCRwcmlzdGluZSAmJlxuICAjICAgICAgICAgICBzZWxmLiRpbml0aWFsaXplX2R1cC4kJHByaXN0aW5lXG4gICMgICAgICAgICApIHJldHVybiBzZWxmLnNsaWNlKDApO1xuICAjICAgICAgIH1cbiAgI1xuICAjICAgICAgIHN1cGVyXG4gICMgICAgIGVuZFxuICAjICAgZW5kXG4gICNcbiAgIyBAcGFyYW0gb3duZXJfY2xhc3MgW0NsYXNzXSB0aGUgY2xhc3Mgb3duaW5nIHRoZSBtZXRob2RzXG4gICMgQHBhcmFtIG1ldGhvZF9uYW1lcyBbQXJyYXk8U3ltYm9sPl0gdGhlIGxpc3Qgb2YgbWV0aG9kcyBuYW1lcyB0byBtYXJrXG4gICMgQHJldHVybiBbbmlsXVxuICBkZWYgc2VsZi5wcmlzdGluZShvd25lcl9jbGFzcywgKm1ldGhvZF9uYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBtZXRob2RfbmFtZSwgbWV0aG9kO1xuICAgICAgZm9yICh2YXIgaSA9IG1ldGhvZF9uYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBtZXRob2RfbmFtZSA9IG1ldGhvZF9uYW1lc1tpXTtcbiAgICAgICAgbWV0aG9kID0gb3duZXJfY2xhc3MuJCRwcm90b3R5cGVbJyQnK21ldGhvZF9uYW1lXTtcblxuICAgICAgICBpZiAobWV0aG9kICYmICFtZXRob2QuJCRzdHViKSB7XG4gICAgICAgICAgbWV0aG9kLiQkcHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5pbFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOk9wYWw+IiwiYnJpZGdlIiwic2VsZiIsImNvbnN0cnVjdG9yIiwia2xhc3MiLCJjb2VyY2VfdG8hIiwib2JqZWN0IiwidHlwZSIsIm1ldGhvZCIsImNvZXJjZWQiLCI9PT0iLCJyYWlzZSIsImNvZXJjZV90bz8iLCJyZXNwb25kX3RvPyIsIm5pbD8iLCJ0cnlfY29udmVydCIsIl9fc2VuZF9fIiwiY29tcGFyZSIsImEiLCJiIiwiPD0+IiwiQXJndW1lbnRFcnJvciIsImNsYXNzIiwiZGVzdHJ1Y3R1cmUiLCJhcmdzIiwib2JqIiwiaW5jbHVkZV9hbGwiLCJpbnN0YW5jZV92YXJpYWJsZV9uYW1lISIsIm5hbWUiLCJPcGFsIiwiU3RyaW5nIiwiTmFtZUVycm9yIiwibmV3IiwiY2xhc3NfdmFyaWFibGVfbmFtZSEiLCJjb25zdF9uYW1lISIsImNvbnN0X25hbWUiLCJbXSIsIjAiLCIhPSIsInVwY2FzZSIsInByaXN0aW5lIiwib3duZXJfY2xhc3MiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsVUFBSUMsSUFBSkQsYUFBQUEsaUJBQUFBLGtCQUFnQkUsV0FBRCxFQUFjQyxLQUE3Qkg7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLCtCQUFEQTtJQURGQSxDQUFBQSw0QkFBQUE7SUFJQUksVUFBSUgsSUFBSkcsaUJBQUFBLHlCQUFBQSxTQUFvQkMsTUFBRCxFQUFTQyxJQUFULEVBQWVDLE1BQWYsRUFQckIsRUFPRUg7QUFBQUEsTUFBQUE7Ozs7TUFQRjs7TUFPNEM7TUFDeENJLFVBQVdKO01BRVgsSUFBQSxRQUFPRSxJQUFLRyxRQUFBQSxDQUFJRCxPQUFKQyxDQUFaLENBQUE7TUFBQTtRQUNFUixJQUFBUyxPQUFBQSxDQUFPTiwwQ0FBUE07TUFERjtNQUlBTixPQUFBSTtJQVBGSixDQUFBQSxxQ0FBQUE7SUFVQU8sVUFBSVYsSUFBSlUsaUJBQUFBLHlCQUFBQSxTQUFvQk4sTUFBRCxFQUFTQyxJQUFULEVBQWVDLE1BQWYsRUFqQnJCLEVBaUJFSTtBQUFBQSxNQUFBQTs7OztNQWpCRjs7TUFpQjRDO01BQ3hDLElBQUEsUUFBY04sTUFBTU8sZ0JBQUFBLENBQWFMLE1BQWJLLENBQXBCLENBQUE7TUFBQTtRQUFBLE9BQUE7TUFBQTtNQUVBSixVQUFXRztNQUVYLElBQUEsUUFBVUgsT0FBT0ssU0FBQUEsQ0FBQUEsQ0FBakIsQ0FBQTtRQUFBLE9BQUEsR0FBQTtNQUVB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VUFBaEIsRUFBNEJMLHNCQUE1QixFQUFvQyxRQUFoQ3pCO01BRWpCLElBQUEsUUFBRzhCLFVBQVVDLE9BQUFBLENBQUNDLENBQURELENBQUlFLE9BQUFBLENBQUdILFVBQVVDLE9BQUFBLENBQUNDLENBQURELENBQUdHLFFBQUFBLENBQUFBLENBQWhCRCxDQUFqQixDQUFBO1FBQ0VwQyxJQUFBUyxPQUFBQSxDQUFNb0IseUJBQU4sRUFBaUIsRUFBQSxHQUFBLHNCQUFBLEdBQUEsQ0FBdUJJLFVBQXZCLENBQWpCeEIsQ0FERjtNQUlBdUIsT0FBQUM7SUFQRkQsQ0FBQUEsc0NBQUFBO0lBb0NBbEMsT0FBQXdDLENBQUFBLFVBQUl0QyxJQUFKc0MsZUFBQUEsb0JBQUFBLG9CQUFrQkMsV0FBRCxFQXBJbkIsRUFvSUVEO0FBQUFBLE1BQUFBOzs7O01BcElGOztNQW9JaUM7O0FBRWpDQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFDSUEsT0FBQTtJQVpGQSxDQUFBQSxnQ0FBQUEsQ0FBQUE7RUFsSUZ4QyxHQUFBQSxXQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6Mjg1MCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbW9kdWxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogdHJ1dGh5LCBjb2VyY2VfdG9cblxuY2xhc3MgTW9kdWxlXG4gIGRlZiBzZWxmLmFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgbW9kdWxlID0gT3BhbC5hbGxvY2F0ZV9tb2R1bGUobmlsLCBmdW5jdGlvbigpe30pO1xuICAgICAgLy8gTGluayB0aGUgcHJvdG90eXBlIG9mIE1vZHVsZSBzdWJjbGFzc2VzXG4gICAgICBpZiAoc2VsZiAhPT0gT3BhbC5Nb2R1bGUpIE9iamVjdC5zZXRQcm90b3R5cGVPZihtb2R1bGUsIHNlbGYuJCRwcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKCZibG9jaylcbiAgICBtb2R1bGVfZXZhbCgmYmxvY2spIGlmIGJsb2NrX2dpdmVuP1xuICBlbmRcblxuICBkZWYgPT09KG9iamVjdClcbiAgICByZXR1cm4gZmFsc2UgaWYgYG9iamVjdCA9PSBudWxsYFxuXG4gICAgYE9wYWwuaXNfYShvYmplY3QsIHNlbGYpYFxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmFpc2UgVHlwZUVycm9yLCAnY29tcGFyZWQgd2l0aCBub24gY2xhc3MvbW9kdWxlJ1xuICAgIGVuZFxuXG4gICAgIyBjbGFzcyBjYW5ub3QgYmUgYSBkZXNjZW5kYW50IG9mIGl0c2VsZlxuICAgICV4e1xuICAgICAgdmFyIHdvcmtpbmcgPSBzZWxmLFxuICAgICAgICAgIGFuY2VzdG9ycyxcbiAgICAgICAgICBpLCBsZW5ndGg7XG5cbiAgICAgIGlmICh3b3JraW5nID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDAsIGFuY2VzdG9ycyA9IE9wYWwuYW5jZXN0b3JzKHNlbGYpLCBsZW5ndGggPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yc1tpXSA9PT0gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhvdGhlciksIGxlbmd0aCA9IGFuY2VzdG9ycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYW5jZXN0b3JzW2ldID09PSBzZWxmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmIDwgb3RoZXJcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgdW5sZXNzIE1vZHVsZSA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2NvbXBhcmVkIHdpdGggbm9uIGNsYXNzL21vZHVsZSdcbiAgICBlbmRcblxuICAgIG90aGVyIDwgc2VsZlxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgZXF1YWw/KG90aGVyKSB8fCBzZWxmID4gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgTW9kdWxlID09PSBvdGhlclxuICAgICAgcmV0dXJuIG5pbFxuICAgIGVuZFxuXG4gICAgbHQgPSBzZWxmIDwgb3RoZXJcbiAgICByZXR1cm4gbmlsIGlmIGx0Lm5pbD9cbiAgICBsdCA/IC0xIDogMVxuICBlbmRcblxuICBkZWYgYWxpYXNfbWV0aG9kKG5ld25hbWUsIG9sZG5hbWUpXG4gICAgbmV3bmFtZSA9IGAkY29lcmNlX3RvKG5ld25hbWUsICN7U3RyaW5nfSwgJ3RvX3N0cicpYFxuICAgIG9sZG5hbWUgPSBgJGNvZXJjZV90byhvbGRuYW1lLCAje1N0cmluZ30sICd0b19zdHInKWBcbiAgICBgT3BhbC5hbGlhcyhzZWxmLCBuZXduYW1lLCBvbGRuYW1lKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFsaWFzX25hdGl2ZShtaWQsIGpzaWQgPSBtaWQpXG4gICAgYE9wYWwuYWxpYXNfbmF0aXZlKHNlbGYsIG1pZCwganNpZClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhbmNlc3RvcnNcbiAgICBgT3BhbC5hbmNlc3RvcnMoc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhcHBlbmRfZmVhdHVyZXMoaW5jbHVkZXIpXG4gICAgYE9wYWwuYXBwZW5kX2ZlYXR1cmVzKHNlbGYsIGluY2x1ZGVyKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhdHRyX2FjY2Vzc29yKCpuYW1lcylcbiAgICBhdHRyX3JlYWRlcigqbmFtZXMpXG4gICAgYXR0cl93cml0ZXIoKm5hbWVzKVxuICBlbmRcblxuICBkZWYgYXR0cigqYXJncylcbiAgICAleHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAyICYmIChhcmdzWzFdID09PSB0cnVlIHx8IGFyZ3NbMV0gPT09IGZhbHNlKSkge1xuICAgICAgICAje3dhcm4gJ29wdGlvbmFsIGJvb2xlYW4gYXJndW1lbnQgaXMgb2Jzb2xldGVkJywgdXBsZXZlbDogMX1cblxuICAgICAgICBhcmdzWzFdID8gI3thdHRyX2FjY2Vzc29yKGBhcmdzWzBdYCl9IDogI3thdHRyX3JlYWRlcihgYXJnc1swXWApfTtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyX3JlYWRlcigqYXJncylcbiAgZW5kXG5cbiAgZGVmIGF0dHJfcmVhZGVyKCpuYW1lcylcbiAgICAleHtcbiAgICAgIHZhciBwcm90byA9IHNlbGYuJCRwcm90b3R5cGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSBuYW1lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldLFxuICAgICAgICAgICAgaWQgICA9ICckJyArIG5hbWUsXG4gICAgICAgICAgICBpdmFyID0gT3BhbC5pdmFyKG5hbWUpO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zdXJlIGhlcmUgaXMgbmVlZGVkIGJlY2F1c2UgbmFtZSB3aWxsIGNoYW5nZSBhdCB0aGUgbmV4dFxuICAgICAgICAvLyBjeWNsZSwgSSB3aXNoIHdlIGNvdWxkIHVzZSBsZXQuXG4gICAgICAgIHZhciBib2R5ID0gKGZ1bmN0aW9uKGl2YXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpdmFyXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbaXZhcl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgYm9keS4kJGFyaXR5ID0gMDtcblxuICAgICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgYXR0cl93cml0ZXIoKm5hbWVzKVxuICAgICV4e1xuICAgICAgdmFyIHByb3RvID0gc2VsZi4kJHByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV0sXG4gICAgICAgICAgICBpZCAgID0gJyQnICsgbmFtZSArICc9JyxcbiAgICAgICAgICAgIGl2YXIgPSBPcGFsLml2YXIobmFtZSk7XG5cbiAgICAgICAgLy8gdGhlIGNsb3N1cmUgaGVyZSBpcyBuZWVkZWQgYmVjYXVzZSBuYW1lIHdpbGwgY2hhbmdlIGF0IHRoZSBuZXh0XG4gICAgICAgIC8vIGN5Y2xlLCBJIHdpc2ggd2UgY291bGQgdXNlIGxldC5cbiAgICAgICAgdmFyIGJvZHkgPSAoZnVuY3Rpb24oaXZhcil7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tpdmFyXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoaXZhcik7XG5cbiAgICAgICAgYm9keS4kJHBhcmFtZXRlcnMgPSBbWydyZXEnXV07XG4gICAgICAgIGJvZHkuJCRhcml0eSA9IDE7XG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgaW5zdGFuY2UgdmFyaWFibGUgYXMgbmlsXG4gICAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkocHJvdG8sIGl2YXIsIG5pbCk7XG5cbiAgICAgICAgT3BhbC5kZWZuKHNlbGYsIGlkLCBib2R5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGF1dG9sb2FkKGNvbnN0LCBwYXRoKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCA9PSBudWxsKSBzZWxmLiQkYXV0b2xvYWQgPSB7fTtcbiAgICAgIE9wYWwuY29uc3RfY2FjaGVfdmVyc2lvbisrO1xuICAgICAgc2VsZi4kJGF1dG9sb2FkWyN7Y29uc3R9XSA9ICN7cGF0aH07XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlc1xuICAgIGBPYmplY3Qua2V5cyhPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKSlgXG4gIGVuZFxuXG4gIGRlZiBjbGFzc192YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfZ2V0KHNlbGYsIG5hbWUsIGZhbHNlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBuYW1lID0gT3BhbC5jbGFzc192YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuY2xhc3NfdmFyaWFibGVfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcbiAgZW5kXG5cbiAgZGVmIGNsYXNzX3ZhcmlhYmxlX2RlZmluZWQ/KG5hbWUpXG4gICAgbmFtZSA9IE9wYWwuY2xhc3NfdmFyaWFibGVfbmFtZSEobmFtZSlcblxuICAgIGBPcGFsLmNsYXNzX3ZhcmlhYmxlcyhzZWxmKS5oYXNPd25Qcm9wZXJ0eShuYW1lKWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9jbGFzc192YXJpYWJsZShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmNsYXNzX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChPcGFsLmhhc093blByb3BlcnR5LmNhbGwoc2VsZi4kJGN2YXJzLCBuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIGRlbGV0ZSBzZWxmLiQkY3ZhcnNbbmFtZV07XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICN7cmFpc2UgTmFtZUVycm9yLCBcImNhbm5vdCByZW1vdmUgI3tuYW1lfSBmb3IgI3tzZWxmfVwifVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbnN0YW50cyhpbmhlcml0ID0gdHJ1ZSlcbiAgICBgT3BhbC5jb25zdGFudHMoc2VsZiwgaW5oZXJpdClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnN0YW50cyhpbmhlcml0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgbmVzdGluZyA9IChzZWxmLiQkbmVzdGluZyB8fCBbXSkuY29uY2F0KE9wYWwuT2JqZWN0KSxcbiAgICAgICAgICAgIGNvbnN0YW50LCBjb25zdGFudHMgPSB7fSxcbiAgICAgICAgICAgIGksIGlpO1xuXG4gICAgICAgIGZvcihpID0gMCwgaWkgPSBuZXN0aW5nLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBmb3IgKGNvbnN0YW50IGluIG5lc3RpbmdbaV0uJCRjb25zdCkge1xuICAgICAgICAgICAgY29uc3RhbnRzW2NvbnN0YW50XSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhjb25zdGFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuY29uc3RhbnRzKHNlbGYsIGluaGVyaXQpXG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXN0aW5nXG4gICAgYHNlbGYuJCRuZXN0aW5nIHx8IFtdYFxuICBlbmRcblxuICAjIGNoZWNrIGZvciBjb25zdGFudCB3aXRoaW4gY3VycmVudCBzY29wZVxuICAjIGlmIGluaGVyaXQgaXMgdHJ1ZSBvciBzZWxmIGlzIE9iamVjdCwgd2lsbCBhbHNvIGNoZWNrIGFuY2VzdG9yc1xuICBkZWYgY29uc3RfZGVmaW5lZD8obmFtZSwgaW5oZXJpdCA9IHRydWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgdmFyIG1vZHVsZSwgbW9kdWxlcyA9IFtzZWxmXSwgbW9kdWxlX2NvbnN0YW50cywgaSwgaWk7XG5cbiAgICAgIC8vIEFkZCB1cCBhbmNlc3RvcnMgaWYgaW5oZXJpdCBpcyB0cnVlXG4gICAgICBpZiAoaW5oZXJpdCkge1xuICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoT3BhbC5hbmNlc3RvcnMoc2VsZikpO1xuXG4gICAgICAgIC8vIEFkZCBPYmplY3QncyBhbmNlc3RvcnMgaWYgaXQncyBhIG1vZHVsZSDigJMgbW9kdWxlcyBoYXZlIG5vIGFuY2VzdG9ycyBvdGhlcndpc2VcbiAgICAgICAgaWYgKHNlbGYuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICBtb2R1bGVzID0gbW9kdWxlcy5jb25jYXQoW09wYWwuT2JqZWN0XSkuY29uY2F0KE9wYWwuYW5jZXN0b3JzKE9wYWwuT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBtb2R1bGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbW9kdWxlID0gbW9kdWxlc1tpXTtcbiAgICAgICAgaWYgKG1vZHVsZS4kJGNvbnN0W25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfZ2V0KG5hbWUsIGluaGVyaXQgPSB0cnVlKVxuICAgIG5hbWUgPSBPcGFsLmNvbnN0X25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIGlmIChuYW1lLmluZGV4T2YoJzo6JykgPT09IDAgJiYgbmFtZSAhPT0gJzo6Jyl7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBuYW1lLmluZGV4T2YoJzo6JykgIT0gLTEgJiYgbmFtZSAhPSAnOjonYFxuICAgICAgcmV0dXJuIG5hbWUuc3BsaXQoJzo6JykuaW5qZWN0KHNlbGYpIHsgfG8sIGN8IG8uY29uc3RfZ2V0KGMpIH1cbiAgICBlbmRcblxuICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJ3cm9uZyBjb25zdGFudCBuYW1lICN7bmFtZX1cIiwgbmFtZSkgdW5sZXNzIG5hbWUgPX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFBcblxuICAgICV4e1xuICAgICAgaWYgKGluaGVyaXQpIHtcbiAgICAgICAgcmV0dXJuICQkKFtzZWxmXSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5jb25zdF9nZXRfbG9jYWwoc2VsZiwgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uc3RfbWlzc2luZyhuYW1lKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRhdXRvbG9hZCkge1xuICAgICAgICB2YXIgZmlsZSA9IHNlbGYuJCRhdXRvbG9hZFtuYW1lXTtcblxuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgIHNlbGYuJHJlcXVpcmUoZmlsZSk7XG5cbiAgICAgICAgICByZXR1cm4gI3tjb25zdF9nZXQgbmFtZX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdWxsX2NvbnN0X25hbWUgPSBzZWxmID09IE9iamVjdCA/IG5hbWUgOiBcIiN7c2VsZn06OiN7bmFtZX1cIlxuXG4gICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcInVuaW5pdGlhbGl6ZWQgY29uc3RhbnQgI3tmdWxsX2NvbnN0X25hbWV9XCIsIG5hbWUpXG4gIGVuZFxuXG4gIGRlZiBjb25zdF9zZXQobmFtZSwgdmFsdWUpXG4gICAgbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEobmFtZSlcblxuICAgIGlmIG5hbWUgIX4gT3BhbDo6Q09OU1RfTkFNRV9SRUdFWFAgfHwgbmFtZS5zdGFydF93aXRoPygnOjonKVxuICAgICAgcmFpc2UgTmFtZUVycm9yLm5ldyhcIndyb25nIGNvbnN0YW50IG5hbWUgI3tuYW1lfVwiLCBuYW1lKVxuICAgIGVuZFxuXG4gICAgYE9wYWwuY29uc3Rfc2V0KHNlbGYsIG5hbWUsIHZhbHVlKWBcblxuICAgIHZhbHVlXG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfY29uc3RhbnQoY29uc3RfbmFtZSlcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9tZXRob2QobmFtZSwgbWV0aG9kID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYG1ldGhvZCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2sgfHw9IGNhc2UgbWV0aG9kXG4gICAgICAgICAgICAgIHdoZW4gUHJvY1xuICAgICAgICAgICAgICAgIG1ldGhvZFxuXG4gICAgICAgICAgICAgIHdoZW4gTWV0aG9kXG4gICAgICAgICAgICAgICAgYCN7bWV0aG9kLnRvX3Byb2N9LiQkdW5ib3VuZGBcblxuICAgICAgICAgICAgICB3aGVuIFVuYm91bmRNZXRob2RcbiAgICAgICAgICAgICAgICAtPigqYXJncykge1xuICAgICAgICAgICAgICAgICAgYm91bmQgPSBtZXRob2QuYmluZChzZWxmKVxuICAgICAgICAgICAgICAgICAgYm91bmQuY2FsbCgqYXJncylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YmxvY2suY2xhc3N9IChleHBlY3RlZCBQcm9jL01ldGhvZClcIlxuICAgICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIGlkID0gJyQnICsgbmFtZTtcblxuICAgICAgYmxvY2suJCRqc2lkICAgICAgICA9IG5hbWU7XG4gICAgICBibG9jay4kJHMgICAgICAgICAgID0gbnVsbDtcbiAgICAgIGJsb2NrLiQkZGVmICAgICAgICAgPSBibG9jaztcbiAgICAgIGJsb2NrLiQkZGVmaW5lX21ldGggPSB0cnVlO1xuXG4gICAgICBPcGFsLmRlZm4oc2VsZiwgaWQsIGJsb2NrKTtcblxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVtb3ZlX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC5yZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9jbGFzcz9cbiAgICBgISFzZWxmLiQkaXNfc2luZ2xldG9uYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZSgqbW9kcylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmluY2x1ZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkX21vZHVsZXNcbiAgICBgT3BhbC5pbmNsdWRlZF9tb2R1bGVzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obW9kKVxuICAgICV4e1xuICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgIH1cblxuICAgICAgdmFyIGksIGlpLCBtb2QyLCBhbmNlc3RvcnMgPSBPcGFsLmFuY2VzdG9ycyhzZWxmKTtcblxuICAgICAgZm9yIChpID0gMCwgaWkgPSBhbmNlc3RvcnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBtb2QyID0gYW5jZXN0b3JzW2ldO1xuICAgICAgICBpZiAobW9kMiA9PT0gbW9kICYmIG1vZDIgIT09IHNlbGYpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGYuJCRwcm90b3R5cGVbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5uYW1lfSdcIiwgbmFtZSl9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tVbmJvdW5kTWV0aG9kLm5ldyhzZWxmLCBgbWV0aC4kJG93bmVyIHx8ICN7c2VsZn1gLCBgbWV0aGAsIG5hbWUpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV9tZXRob2RzKGluY2x1ZGVfc3VwZXIgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3tpbmNsdWRlX3N1cGVyfSkpIHtcbiAgICAgICAgcmV0dXJuIE9wYWwuaW5zdGFuY2VfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBPcGFsLm93bl9pbnN0YW5jZV9tZXRob2RzKHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZGVkKG1vZClcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZF9vYmplY3Qob2JqZWN0KVxuICBlbmRcblxuICBkZWYgbWV0aG9kX2FkZGVkKCopXG4gIGVuZFxuXG4gIGRlZiBtZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgbWV0aG9kX3VuZGVmaW5lZCgqKVxuICBlbmRcblxuICBkZWYgbW9kdWxlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIEtlcm5lbC5yYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknIHVubGVzcyAoMS4uMykuY292ZXI/IGFyZ3Muc2l6ZVxuXG4gICAgICBzdHJpbmcsIGZpbGUsIF9saW5lbm8gPSAqYXJnc1xuICAgICAgZGVmYXVsdF9ldmFsX29wdGlvbnMgPSB7IGZpbGU6IChmaWxlIHx8ICcoZXZhbCknKSwgZXZhbDogdHJ1ZSB9XG4gICAgICBjb21waWxpbmdfb3B0aW9ucyA9IF9fT1BBTF9DT01QSUxFUl9DT05GSUdfXy5tZXJnZShkZWZhdWx0X2V2YWxfb3B0aW9ucylcbiAgICAgIGNvbXBpbGVkID0gT3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gS2VybmVsLnByb2MgZG9cbiAgICAgICAgJXh7XG4gICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihzZWxmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbChjb21waWxlZCk7XG4gICAgICAgICAgfSkoc2VsZilcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzaWYgYXJncy5hbnk/XG4gICAgICBLZXJuZWwucmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCIgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcblxcbiAgTk9URTpJZiB5b3Ugd2FudCB0byBlbmFibGUgcGFzc2luZyBhIFN0cmluZyBhcmd1bWVudCBwbGVhc2UgYWRkIFxcXCJyZXF1aXJlICdvcGFsLXBhcnNlcidcXFwiIHRvIHlvdXIgc2NyaXB0XFxuXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG4gICAgICByZXN1bHQgPSBibG9jay5hcHBseShzZWxmLCBbc2VsZl0pO1xuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgY2xhc3NfZXZhbCBtb2R1bGVfZXZhbFxuXG4gIGRlZiBtb2R1bGVfZXhlYygqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJ31cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrX3NlbGYgPSBibG9jay4kJHMsIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgYmxvY2suJCRzID0gYmxvY2tfc2VsZjtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGNsYXNzX2V4ZWMgbW9kdWxlX2V4ZWNcblxuICBkZWYgbWV0aG9kX2RlZmluZWQ/KG1ldGhvZClcbiAgICAleHtcbiAgICAgIHZhciBib2R5ID0gc2VsZi4kJHByb3RvdHlwZVsnJCcgKyBtZXRob2RdO1xuICAgICAgcmV0dXJuICghIWJvZHkpICYmICFib2R5LiQkc3R1YjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtb2R1bGVfZnVuY3Rpb24oKm1ldGhvZHMpXG4gICAgJXh7XG4gICAgICBpZiAobWV0aG9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi4kJG1vZHVsZV9mdW5jdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aCA9IG1ldGhvZHNbaV0sXG4gICAgICAgICAgICAgIGlkICAgPSAnJCcgKyBtZXRoLFxuICAgICAgICAgICAgICBmdW5jID0gc2VsZi4kJHByb3RvdHlwZVtpZF07XG5cbiAgICAgICAgICBPcGFsLmRlZnMoc2VsZiwgaWQsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5hbWVcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkZnVsbF9uYW1lKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkZnVsbF9uYW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGJhc2UgPSBzZWxmO1xuXG4gICAgICB3aGlsZSAoYmFzZSkge1xuICAgICAgICAvLyBHaXZlIHVwIGlmIGFueSBvZiB0aGUgYW5jZXN0b3JzIGlzIHVubmFtZWRcbiAgICAgICAgaWYgKGJhc2UuJCRuYW1lID09PSBuaWwgfHwgYmFzZS4kJG5hbWUgPT0gbnVsbCkgcmV0dXJuIG5pbDtcblxuICAgICAgICByZXN1bHQudW5zaGlmdChiYXNlLiQkbmFtZSk7XG5cbiAgICAgICAgYmFzZSA9IGJhc2UuJCRiYXNlX21vZHVsZTtcblxuICAgICAgICBpZiAoYmFzZSA9PT0gT3BhbC5PYmplY3QpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGZ1bGxfbmFtZSA9IHJlc3VsdC5qb2luKCc6OicpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHByZXBlbmQoKm1vZHMpXG4gICAgJXh7XG4gICAgICBpZiAobW9kcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZ2l2ZW4gMCwgZXhwZWN0ZWQgMSspJ31cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IG1vZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG1vZCA9IG1vZHNbaV07XG5cbiAgICAgICAgaWYgKCFtb2QuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YG1vZGAuY2xhc3N9IChleHBlY3RlZCBNb2R1bGUpXCJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgI3tgbW9kYC5wcmVwZW5kX2ZlYXR1cmVzIHNlbGZ9O1xuICAgICAgICAje2Btb2RgLnByZXBlbmRlZCBzZWxmfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmVwZW5kX2ZlYXR1cmVzKHByZXBlbmRlcilcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7c2VsZi5jbGFzc30gKGV4cGVjdGVkIE1vZHVsZSlcIn07XG4gICAgICB9XG5cbiAgICAgIE9wYWwucHJlcGVuZF9mZWF0dXJlcyhzZWxmLCBwcmVwZW5kZXIpXG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHByZXBlbmRlZChtb2QpXG4gIGVuZFxuXG4gIGRlZiByZW1vdmVfY29uc3QobmFtZSlcbiAgICBgT3BhbC5jb25zdF9yZW1vdmUoc2VsZiwgbmFtZSlgXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYE9wYWwuTW9kdWxlLiRuYW1lLmNhbGwoc2VsZilgIHx8IFwiIzwje2BzZWxmLiQkaXNfbW9kdWxlID8gJ01vZHVsZScgOiAnQ2xhc3MnYH06MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5cbiAgZGVmIHVuZGVmX21ldGhvZCgqbmFtZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgT3BhbC51ZGVmKHNlbGYsIFwiJFwiICsgbmFtZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIGNvbnN0cyA9IGNvbnN0YW50c1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZS5jaGFyQXQoMCkgIT09ICckJyAmJiBuYW1lICE9PSAnY29uc3RydWN0b3InICYmICEje2NvbnN0cy5pbmNsdWRlPyhgbmFtZWApfSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHN1cGVyXG4gICAgY29weS5jb3B5X2NsYXNzX3ZhcmlhYmxlcyhzZWxmKVxuICAgIGNvcHkuY29weV9jb25zdGFudHMoc2VsZilcbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBjb3B5X2NsYXNzX3ZhcmlhYmxlcyhvdGhlcilcbiAgICAleHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXIuJCRjdmFycykge1xuICAgICAgICBzZWxmLiQkY3ZhcnNbbmFtZV0gPSBvdGhlci4kJGN2YXJzW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvcHlfY29uc3RhbnRzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIG5hbWUsIG90aGVyX2NvbnN0YW50cyA9IG90aGVyLiQkY29uc3Q7XG5cbiAgICAgIGZvciAobmFtZSBpbiBvdGhlcl9jb25zdGFudHMpIHtcbiAgICAgICAgT3BhbC5jb25zdF9zZXQoc2VsZiwgbmFtZSwgb3RoZXJfY29uc3RhbnRzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWZpbmUobW9kLCAmYmxvY2spXG4gICAgcywgbSwgbW9kX2lkID0gc2VsZiwgbmlsLCBuaWxcbiAgICAleHtcbiAgICAgIG1vZF9pZCA9IE9wYWwuaWQobW9kKTtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZi4kJHJlZmluZV9tb2R1bGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHNlbGYuJCRyZWZpbmVfbW9kdWxlcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzZWxmLiQkcmVmaW5lX21vZHVsZXNbbW9kX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBtID0gc2VsZi4kJHJlZmluZV9tb2R1bGVzW21vZF9pZF0gPSAjezo6TW9kdWxlLm5ld307XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbSA9IHNlbGYuJCRyZWZpbmVfbW9kdWxlc1ttb2RfaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICBtLmRlZmluZV9zaW5nbGV0b25fbWV0aG9kIDppbnNwZWN0IGRvXG4gICAgICBcIiM8cmVmaW5lbWVudDoje21vZC5pbnNwZWN0fUAje3MuaW5zcGVjdH0+XCJcbiAgICBlbmRcbiAgICBtLmNsYXNzX2V4ZWMoJmJsb2NrKVxuICAgIG1cbiAgZW5kXG5cbiAgIyBDb21waWxlciBvdmVycmlkZXMgdGhpcyBtZXRob2RcbiAgZGVmIHVzaW5nKG1vZClcbiAgICByYWlzZSAnTW9kdWxlI3VzaW5nIGlzIG5vdCBwZXJtaXR0ZWQgaW4gbWV0aG9kcydcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk1vZHVsZT4iLCJhbGxvY2F0ZSIsInNlbGYiLCJpbml0aWFsaXplIiwiYmxvY2tfZ2l2ZW4/IiwibW9kdWxlX2V2YWwiLCJibG9jayIsInRvX3Byb2MiLCI9PT0iLCJvYmplY3QiLCI8Iiwib3RoZXIiLCJNb2R1bGUiLCJyYWlzZSIsIlR5cGVFcnJvciIsIjw9IiwiJHJldF9vcl8xIiwiZXF1YWw/IiwiPiIsIj49IiwiJHJldF9vcl8yIiwiPD0+IiwibHQiLCJuaWw/IiwiLTEiLCIxIiwiYWxpYXNfbWV0aG9kIiwibmV3bmFtZSIsIm9sZG5hbWUiLCJTdHJpbmciLCJhbGlhc19uYXRpdmUiLCJtaWQiLCJqc2lkIiwiYW5jZXN0b3JzIiwiYXBwZW5kX2ZlYXR1cmVzIiwiaW5jbHVkZXIiLCJhdHRyX2FjY2Vzc29yIiwiYXR0cl9yZWFkZXIiLCJuYW1lcyIsImF0dHJfd3JpdGVyIiwiYXR0ciIsIndhcm4iLCJhcmdzIiwiYXV0b2xvYWQiLCJjb25zdCQiLCJwYXRoIiwiY2xhc3NfdmFyaWFibGVzIiwiY2xhc3NfdmFyaWFibGVfZ2V0IiwibmFtZSIsIk9wYWwiLCJjbGFzc192YXJpYWJsZV9uYW1lISIsImNsYXNzX3ZhcmlhYmxlX3NldCIsInZhbHVlIiwiY2xhc3NfdmFyaWFibGVfZGVmaW5lZD8iLCJyZW1vdmVfY2xhc3NfdmFyaWFibGUiLCJOYW1lRXJyb3IiLCJjb25zdGFudHMiLCJpbmhlcml0IiwibmVzdGluZyIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3RfbmFtZSEiLCI9fiIsIk9wYWw6OkNPTlNUX05BTUVfUkVHRVhQIiwibmV3IiwiY29uc3RfZ2V0IiwiaW5qZWN0Iiwic3BsaXQiLCJibG9jayBpbiBjb25zdF9nZXQiLCJvIiwiYyIsImJsb2NrICgyIGxldmVscykgaW4gY29uc3RfZ2V0IiwiY29uc3RfbWlzc2luZyIsImZ1bGxfY29uc3RfbmFtZSIsIj09IiwiT2JqZWN0IiwiY29uc3Rfc2V0IiwiJHJldF9vcl8zIiwiIX4iLCJzdGFydF93aXRoPyIsInB1YmxpY19jb25zdGFudCIsImNvbnN0X25hbWUiLCJkZWZpbmVfbWV0aG9kIiwibWV0aG9kIiwiQXJndW1lbnRFcnJvciIsIiRyZXRfb3JfNCIsIlByb2MiLCJNZXRob2QiLCJVbmJvdW5kTWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX21ldGhvZCIsImJsb2NrICgyIGxldmVscykgaW4gZGVmaW5lX21ldGhvZCIsImJvdW5kIiwiYmluZCIsImNhbGwiLCJjbGFzcyIsInJlbW92ZV9tZXRob2QiLCJzaW5nbGV0b25fY2xhc3M/IiwiaW5jbHVkZSIsImluY2x1ZGVkIiwiaW5jbHVkZWRfbW9kdWxlcyIsImluY2x1ZGU/IiwibW9kIiwiaW5zdGFuY2VfbWV0aG9kIiwiaW5zdGFuY2VfbWV0aG9kcyIsImluY2x1ZGVfc3VwZXIiLCJleHRlbmRlZCIsImV4dGVuZF9vYmplY3QiLCJtZXRob2RfYWRkZWQiLCJtZXRob2RfcmVtb3ZlZCIsIm1ldGhvZF91bmRlZmluZWQiLCIkcmV0X29yXzUiLCIzIiwiY292ZXI/Iiwic2l6ZSIsIktlcm5lbCIsInN0cmluZyIsImZpbGUiLCJfbGluZW5vIiwiZGVmYXVsdF9ldmFsX29wdGlvbnMiLCIkcmV0X29yXzYiLCJjb21waWxpbmdfb3B0aW9ucyIsIl9fT1BBTF9DT01QSUxFUl9DT05GSUdfXyIsIm1lcmdlIiwiY29tcGlsZWQiLCJjb21waWxlIiwicHJvYyIsImJsb2NrIGluIG1vZHVsZV9ldmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtb2R1bGVfZXZhbCIsImFueT8iLCJtb2R1bGVfZXhlYyIsIkxvY2FsSnVtcEVycm9yIiwibWV0aG9kX2RlZmluZWQ/IiwibW9kdWxlX2Z1bmN0aW9uIiwicHJlcGVuZCIsInByZXBlbmRfZmVhdHVyZXMiLCJwcmVwZW5kZWQiLCJwcmVwZW5kZXIiLCJyZW1vdmVfY29uc3QiLCJ0b19zIiwiJHJldF9vcl83IiwiX19pZF9fIiwiMTYiLCJ1bmRlZl9tZXRob2QiLCJpbnN0YW5jZV92YXJpYWJsZXMiLCJjb25zdHMiLCJkdXAiLCJjb3B5IiwiY29weV9jbGFzc192YXJpYWJsZXMiLCJjb3B5X2NvbnN0YW50cyIsInJlZmluZSIsInMiLCJtIiwibW9kX2lkIiwiZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QiLCJibG9jayBpbiByZWZpbmUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlZmluZSIsImluc3BlY3QiLCJjbGFzc19leGVjIiwidXNpbmciXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsVUFBSUMsSUFBSkQsZUFBQUEscUJBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZB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QUFDQUE7QUFDQUE7TUFDS0ksTUFBREYsQ0FBQ0UsMkJBQUFBLEVBQUFBLENBQXlCLFNBQXpCQSxDQUFBQSxFQUFrQ0MsaUJBQUFBLEVBQUFDOztRQUNqQ0EsT0FBQSxFQUFBLEdBQUEsZUFBQSxHQUFBLENBQWdCdEQsR0FBR3VELFNBQUFBLENBQUFBLENBQW5CLENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBK0JOLENBQUNNLFNBQUFBLENBQUFBLENBQWhDLENBQUEsR0FBQSxHQURpQ0YsbUJBQUFBLGtCQUFBQSxNQUFsQ0Q7TUFHQUksTUFBRE4sQ0FBQ00sY0FBQUEsRUFBQUEsRUFBQUEsRUFBYXRKLEtBQURDLFNBQUFBLENBQUFBLENBQVpxSjtNQUNEUixPQUFBRTtJQWxCRkYsQ0FBQUEsK0JBQUFBO0lBc0JBcEosT0FBQTZKLENBQUFBLHlCQUFBQSxtQkFBQUEsaUJBQVV6RCxHQUFWeUQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEzSixJQUFBVyxPQUFBQSxDQUFNZ0osMENBQU5oSjtJQURGZ0osQ0FBQUEsOEJBQUFBLENBQUFBO0VBL3JCRjdKLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozODUzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jbGFzcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL21vZHVsZSdcblxuY2xhc3MgQ2xhc3NcbiAgZGVmIHNlbGYubmV3KHN1cGVyY2xhc3MgPSBPYmplY3QsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghc3VwZXJjbGFzcy4kJGlzX2NsYXNzKSB7XG4gICAgICAgIHRocm93IE9wYWwuVHlwZUVycm9yLiRuZXcoXCJzdXBlcmNsYXNzIG11c3QgYmUgYSBDbGFzc1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtsYXNzID0gT3BhbC5hbGxvY2F0ZV9jbGFzcyhuaWwsIHN1cGVyY2xhc3MpO1xuICAgICAgc3VwZXJjbGFzcy4kaW5oZXJpdGVkKGtsYXNzKTtcbiAgICAgICN7YGtsYXNzYC5jbGFzc19ldmFsKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/fVxuICAgICAgcmV0dXJuIGtsYXNzO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFsbG9jYXRlXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuICAgICAgb2JqLiQkaWQgPSBPcGFsLnVpZCgpO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbmhlcml0ZWQoY2xzKVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZV9kdXAob3JpZ2luYWwpXG4gICAgaW5pdGlhbGl6ZV9jb3B5KG9yaWdpbmFsKVxuICAgICV4e1xuICAgICAgc2VsZi4kJG5hbWUgPSBudWxsO1xuICAgICAgc2VsZi4kJGZ1bGxfbmFtZSA9IG51bGw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmV3KCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqZWN0ID0gI3thbGxvY2F0ZX07XG4gICAgICBPcGFsLnNlbmQob2JqZWN0LCBvYmplY3QuJGluaXRpYWxpemUsIGFyZ3MsIGJsb2NrKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3VwZXJjbGFzc1xuICAgIGBzZWxmLiQkc3VwZXIgfHwgbmlsYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICV4e1xuICAgICAgdmFyIHNpbmdsZXRvbl9vZiA9IHNlbGYuJCRzaW5nbGV0b25fb2Y7XG5cbiAgICAgIGlmIChzaW5nbGV0b25fb2YgJiYgc2luZ2xldG9uX29mLiQkaXNfYV9tb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiN7YHNpbmdsZXRvbl9vZmAubmFtZX0+XCJ9O1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2luZ2xldG9uX29mKSB7XG4gICAgICAgIC8vIGEgc2luZ2xldG9uIGNsYXNzIGNyZWF0ZWQgZnJvbSBhbiBvYmplY3RcbiAgICAgICAgcmV0dXJuICN7XCIjPENsYXNzOiM8I3tgc2luZ2xldG9uX29mLiQkY2xhc3NgLm5hbWV9OjB4I3tgT3BhbC5pZChzaW5nbGV0b25fb2YpYC50b19zKDE2KX0+PlwifTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c3VwZXIoKX07XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbnNwZWN0IHRvX3NcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpDbGFzcz4iLCJuZXciLCJzdXBlcmNsYXNzIiwiT2JqZWN0IiwiYmxvY2tfZ2l2ZW4/IiwiY2xhc3NfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImFsbG9jYXRlIiwiaW5oZXJpdGVkIiwiY2xzIiwiaW5pdGlhbGl6ZV9kdXAiLCJvcmlnaW5hbCIsImluaXRpYWxpemVfY29weSIsInRvX3MiLCJuYW1lIiwiMTYiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFQyxVQUFJSCxJQUFKRyxVQUFBQSxlQUFBQSxTQUFhQyxVQUFiRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFrQzs7TUFBckI7TUFBQSxlQUFhRSxzQkFBYjtNQUFBOztBQUVmRjtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsTUFBUSxhQUFBLElBQThCRyxlQUE5QjtRQUFBSCxPQUFPSSxNQUFQSixDQUFDQSxLQUFEQSxDQUFPSSxjQUFBQSxFQUFBQSxFQUFBQSxFQUFhQyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFaRjtNQUFQO1FBQUFKLE9BQUE7TUFBQSxDQUFBO0FBQ1JBO0FBQ0FBO0lBVkVBLENBQUFBLDJCQUFBQTs7QUFhQU8sSUFBQUEsNEJBQUFBLG9CQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSwrQkFBQUE7O0FBUUFDLElBQUFBLDZCQUFBQSxxQkFBQUEscUJBQWNDLEdBQWREO0FBQUFBLE1BQUFBOztNQXhCRkEsT0FBQTtJQXdCRUEsQ0FBQUEsZ0NBQUFBOztBQUdBRSxJQUFBQSxrQ0FBQUEsMEJBQUFBLDBCQUFtQkMsUUFBbkJEO0FBQUFBLE1BQUFBOzs7TUFDRWIsSUFBQWUsaUJBQUFBLENBQWdCRCxRQUFoQkM7O0FBRUpGO0FBQ0FBO0FBQ0FBO0lBTEVBLENBQUFBLHFDQUFBQTs7QUFRQVYsSUFBQUEsdUJBQUFBLGVBQUFBLFNBbkNGLEVBbUNFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFlOztNQW5DakI7O01BbUNVOztBQUVWQSxtQkFBcUJILElBQUFVLFVBQUFBLENBQUFBLENBQVNQO0FBQzlCQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSwyQkFBQUE7O0FBUUFDLElBQUFBLDhCQUFBQSxzQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxtQkFBREE7SUFERkEsQ0FBQUEsaUNBQUFBOztBQUlBWSxJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7O0FBRUZBOztBQUVBQTtBQUNBQSxlQUFpQixFQUFBLEdBQUEsVUFBQSxHQUFBLENBQVdBLENBQUNBLFlBQURBLENBQWNDLE1BQUFBLENBQUFBLENBQXpCLENBQUEsR0FBQSxHQUFrQ0Q7QUFDbkRBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWlCLEVBQUEsR0FBQSxZQUFBLEdBQUEsQ0FBYUEsQ0FBQ0Esb0JBQURBLENBQXNCQyxNQUFBQSxDQUFBQSxDQUFuQyxDQUFBLEdBQUEsS0FBQSxHQUFBLENBQThDRCxDQUFDQSxxQkFBREEsQ0FBdUJBLE1BQUFBLENBQU1FLEVBQU5GLENBQXJFLENBQUEsR0FBQSxJQUFtRkE7QUFDcEdBOztBQUVBQSxhQUFlLE9BQUFoQixJQUFBLEVBQUEsb0VBQUEsUUFBQSxFQUFBLEVBQUEsRUFBQSxJQUFBLENBQVFnQjtBQUN2QkE7SUFiRUEsQ0FBQUEsMkJBQUFBO0lBZ0JBZCxPQUFBLGFBQU0sU0FBTixFQUFjLE1BQWQ7RUE3REZBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjozOTY2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9iYXNpY19vYmplY3QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQmFzaWNPYmplY3RcbiAgZGVmIGluaXRpYWxpemUoKilcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGBzZWxmID09PSBvdGhlcmBcbiAgZW5kXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBhbGlhcyBlcXVhbD8gPT1cblxuICBkZWYgX19pZF9fXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGlkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRpZDtcbiAgICAgIH1cbiAgICAgIE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZiwgJyQkaWQnLCBPcGFsLnVpZCgpKTtcbiAgICAgIHJldHVybiBzZWxmLiQkaWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19zZW5kX18oc3ltYm9sLCAqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGZ1bmMgPSBzZWxmWyckJyArIHN5bWJvbF1cblxuICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgICBmdW5jLiQkcCA9IGJsb2NrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJG1ldGhvZF9taXNzaW5nLiQkcCA9IGJsb2NrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kbWV0aG9kX21pc3NpbmcuYXBwbHkoc2VsZiwgW3N5bWJvbF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAhXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmICE9KG90aGVyKVxuICAgICEoc2VsZiA9PSBvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX2V2YWwoKmFyZ3MsICZibG9jaylcbiAgICBpZiBibG9jay5uaWw/ICYmIGAhIU9wYWwuY29tcGlsZWBcbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEuLjMpJyB1bmxlc3MgKDEuLjMpLmNvdmVyPyBhcmdzLnNpemVcblxuICAgICAgc3RyaW5nLCBmaWxlLCBfbGluZW5vID0gKmFyZ3NcbiAgICAgIGRlZmF1bHRfZXZhbF9vcHRpb25zID0geyBmaWxlOiAoZmlsZSB8fCAnKGV2YWwpJyksIGV2YWw6IHRydWUgfVxuICAgICAgY29tcGlsaW5nX29wdGlvbnMgPSBfX09QQUxfQ09NUElMRVJfQ09ORklHX18ubWVyZ2UoZGVmYXVsdF9ldmFsX29wdGlvbnMpXG4gICAgICBjb21waWxlZCA9IDo6T3BhbC5jb21waWxlIHN0cmluZywgY29tcGlsaW5nX29wdGlvbnNcbiAgICAgIGJsb2NrID0gOjpLZXJuZWwucHJvYyBkb1xuICAgICAgICAleHtcbiAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsKGNvbXBpbGVkKTtcbiAgICAgICAgICB9KShzZWxmKVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbHNpZiBhcmdzLmFueT9cbiAgICAgIDo6S2VybmVsLnJhaXNlIDo6QXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3Muc2l6ZX0gZm9yIDApXCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG9sZCA9IGJsb2NrLiQkcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGJsb2NrLiQkcyA9IG51bGw7XG5cbiAgICAgIC8vIE5lZWQgdG8gcGFzcyAkJGV2YWwgc28gdGhhdCBtZXRob2QgZGVmaW5pdGlvbnMga25vdyBpZiB0aGlzIGlzXG4gICAgICAvLyBiZWluZyBkb25lIG9uIGEgY2xhc3MvbW9kdWxlLiBDYW5ub3QgYmUgY29tcGlsZXIgZHJpdmVuIHNpbmNlXG4gICAgICAvLyBzZW5kKDppbnN0YW5jZV9ldmFsKSBuZWVkcyB0byB3b3JrLlxuICAgICAgaWYgKHNlbGYuJCRpc19hX21vZHVsZSkge1xuICAgICAgICBzZWxmLiQkZXZhbCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICBzZWxmLiQkZXZhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gYmxvY2suY2FsbChzZWxmLCBzZWxmKTtcbiAgICAgIH1cblxuICAgICAgYmxvY2suJCRzID0gb2xkO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX2V4ZWMoKmFyZ3MsICZibG9jaylcbiAgICA6Oktlcm5lbC5yYWlzZSA6OkFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciBibG9ja19zZWxmID0gYmxvY2suJCRzLFxuICAgICAgICAgIHJlc3VsdDtcblxuICAgICAgYmxvY2suJCRzID0gbnVsbDtcblxuICAgICAgaWYgKHNlbGYuJCRpc19hX21vZHVsZSkge1xuICAgICAgICBzZWxmLiQkZXZhbCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gYmxvY2suYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgc2VsZi4kJGV2YWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGJsb2NrLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgfVxuXG4gICAgICBibG9jay4kJHMgPSBibG9ja19zZWxmO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfYWRkZWQoKilcbiAgZW5kXG5cbiAgZGVmIHNpbmdsZXRvbl9tZXRob2RfcmVtb3ZlZCgqKVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX21ldGhvZF91bmRlZmluZWQoKilcbiAgZW5kXG5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKHN5bWJvbCwgKmFyZ3MsICZibG9jaylcbiAgICBtZXNzYWdlID0gaWYgYHNlbGYuJGluc3BlY3QgJiYgIXNlbGYuJGluc3BlY3QuJCRzdHViYFxuICAgICAgICAgICAgICAgIFwidW5kZWZpbmVkIG1ldGhvZCBgI3tzeW1ib2x9JyBmb3IgI3tpbnNwZWN0fToje2BzZWxmLiQkY2xhc3NgfVwiXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBcInVuZGVmaW5lZCBtZXRob2QgYCN7c3ltYm9sfScgZm9yICN7YHNlbGYuJCRjbGFzc2B9XCJcbiAgICAgICAgICAgICAgZW5kXG5cbiAgICA6Oktlcm5lbC5yYWlzZSA6Ok5vTWV0aG9kRXJyb3IubmV3KG1lc3NhZ2UsIHN5bWJvbClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJhc2ljT2JqZWN0PiIsImluaXRpYWxpemUiLCI9PSIsIm90aGVyIiwiZXFsPyIsInNlbGYiLCJfX2lkX18iLCJfX3NlbmRfXyIsInN5bWJvbCIsIiEiLCIhPSIsImluc3RhbmNlX2V2YWwiLCIkcmV0X29yXzEiLCJibG9jayIsIm5pbD8iLCIxIiwiMyIsImNvdmVyPyIsImFyZ3MiLCJzaXplIiwiS2VybmVsIiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwic3RyaW5nIiwiZmlsZSIsIl9saW5lbm8iLCJkZWZhdWx0X2V2YWxfb3B0aW9ucyIsIiRyZXRfb3JfMiIsImNvbXBpbGluZ19vcHRpb25zIiwiX19PUEFMX0NPTVBJTEVSX0NPTkZJR19fIiwibWVyZ2UiLCJjb21waWxlZCIsIk9wYWwiLCJjb21waWxlIiwicHJvYyIsImJsb2NrIGluIGluc3RhbmNlX2V2YWwiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3RhbmNlX2V2YWwiLCJhbnk/IiwiaW5zdGFuY2VfZXhlYyIsInNpbmdsZXRvbl9tZXRob2RfYWRkZWQiLCJzaW5nbGV0b25fbWV0aG9kX3JlbW92ZWQiLCJzaW5nbGV0b25fbWV0aG9kX3VuZGVmaW5lZCIsIm1ldGhvZF9taXNzaW5nIiwibWVzc2FnZSIsImluc3BlY3QiLCJOb01ldGhvZEVycm9yIiwibmV3IiwicmVzcG9uZF90b19taXNzaW5nPyIsIm1ldGhvZF9uYW1lIiwiaW5jbHVkZV9hbGwiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBQ0VDLElBQUFBLDhCQUFBQSw0QkFBQUEsc0JBREYsRUFDRUE7QUFBQUEsTUFBQUE7Ozs7TUFERjs7TUFBQUEsT0FBQTtJQUNFQSxDQUFBQSx3Q0FBQUE7O0FBR0FDLElBQUFBLHNCQUFBQSx3QkFBQUEsU0FBT0MsS0FBUEQ7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGNBQURBO0lBREZBLENBQUFBLG1DQUFBQTs7QUFJQUUsSUFBQUEsd0JBQUFBLDBCQUFBQSxTQUFTRCxLQUFUQztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUMsSUFBS0gsT0FBQUEsQ0FBR0MsS0FBSEQ7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QXJCLENBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBcUNrQyxZQUFyQztNQUhGLENBQUE7TUFNVkEsT0FBQXRCLElBQUEsSUFBQUEsV0FBUUMsT0FBQUEsQ0FBT3dCLElBQUEsSUFBQUEsa0JBQWVDLEtBQUFBLENBQUtILE9BQXBCLEVBQTZCbkMsTUFBZHNDLENBQXRCekI7SUFQVnFCLENBQUFBLDZDQUFBQTtJQVVBMUMsT0FBQStDLENBQUFBLHVDQUFBQSwwQ0FBQUEsU0FBd0JDLFdBQUQsRUFBY0MsV0FBckNGO0FBQUFBLE1BQUFBOzs7O01BQXFDO01BQUEsZ0JBQWMsS0FBZDtNQUFBO01BQ25DQSxPQUFBO0lBREZBLENBQUFBLHNEQUFBQSxDQUFBQTtFQWxKRi9DLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBQUFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo0MjIyLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9rZXJuZWwucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGNvZXJjZV90bywgcmVzcG9uZF90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBtZXRob2RfbWlzc2luZyhzeW1ib2wsICphcmdzLCAmYmxvY2spXG4gICAgcmFpc2UgTm9NZXRob2RFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje3N5bWJvbH0nIGZvciAje2luc3BlY3R9XCIsIHN5bWJvbCwgYXJncyksIG5pbCwgY2FsbGVyKDEpXG4gIGVuZFxuXG4gIGRlZiA9fihvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmICF+KG9iailcbiAgICAhKHNlbGYgPX4gb2JqKVxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgIG9iamVjdF9pZCA9PSBvdGhlci5vYmplY3RfaWQgfHwgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgICV4e1xuICAgICAgLy8gc2V0IGd1YXJkIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIHNlbGYuJCRjb21wYXJhYmxlID0gdHJ1ZTtcblxuICAgICAgdmFyIHggPSAje3NlbGYgPT0gb3RoZXJ9O1xuXG4gICAgICBpZiAoeCAmJiB4ICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWV0aG9kKG5hbWUpXG4gICAgJXh7XG4gICAgICB2YXIgbWV0aCA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICghbWV0aCB8fCBtZXRoLiQkc3R1Yikge1xuICAgICAgICAje3JhaXNlIE5hbWVFcnJvci5uZXcoXCJ1bmRlZmluZWQgbWV0aG9kIGAje25hbWV9JyBmb3IgY2xhc3MgYCN7c2VsZi5jbGFzc30nXCIsIG5hbWUpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7TWV0aG9kLm5ldyhzZWxmLCBgbWV0aC4kJG93bmVyIHx8ICN7c2VsZi5jbGFzc31gLCBgbWV0aGAsIG5hbWUpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBtZXRob2RzKGFsbCA9IHRydWUpXG4gICAgJXh7XG4gICAgICBpZiAoJHRydXRoeSgje2FsbH0pKSB7XG4gICAgICAgIHJldHVybiBPcGFsLm1ldGhvZHMoc2VsZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5vd25fbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwdWJsaWNfbWV0aG9kcyhhbGwgPSB0cnVlKVxuICAgICV4e1xuICAgICAgaWYgKCR0cnV0aHkoI3thbGx9KSkge1xuICAgICAgICByZXR1cm4gT3BhbC5tZXRob2RzKHNlbGYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE9wYWwucmVjZWl2ZXJfbWV0aG9kcyhzZWxmKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBBcnJheShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgY29lcmNlZDtcblxuICAgICAgaWYgKG9iamVjdCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdC4kJGlzX2FycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICAgIGNvZXJjZWQgPSAje09wYWwuY29lcmNlX3RvPyhvYmplY3QsIEFycmF5LCA6dG9fYXJ5KX07XG4gICAgICBpZiAoY29lcmNlZCAhPT0gbmlsKSB7IHJldHVybiBjb2VyY2VkOyB9XG5cbiAgICAgIGNvZXJjZWQgPSAje09wYWwuY29lcmNlX3RvPyhvYmplY3QsIEFycmF5LCA6dG9fYSl9O1xuICAgICAgaWYgKGNvZXJjZWQgIT09IG5pbCkgeyByZXR1cm4gY29lcmNlZDsgfVxuXG4gICAgICByZXR1cm4gW29iamVjdF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXRfZXhpdCgmYmxvY2spXG4gICAgJF9fYXRfZXhpdF9fIHx8PSBbXVxuICAgICRfX2F0X2V4aXRfXyA8PCBibG9ja1xuICAgIGJsb2NrXG4gIGVuZFxuXG4gIGRlZiBjYWxsZXIoc3RhcnQgPSAxLCBsZW5ndGggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgc3RhY2ssIHJlc3VsdDtcblxuICAgICAgc3RhY2sgPSBuZXcgRXJyb3IoKS4kYmFja3RyYWNlKCk7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9ICN7c3RhcnR9ICsgMSwgaWkgPSBzdGFjay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICghc3RhY2tbaV0ubWF0Y2goL3J1bnRpbWVcXC5qcy8pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RhY2tbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVuZ3RoICE9IG5pbCkgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNsYXNzXG4gICAgYHNlbGYuJCRjbGFzc2BcbiAgZW5kXG5cbiAgZGVmIGNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvdGhlciksIGksIGlpLCBuYW1lO1xuICAgICAgZm9yIChpID0gMCwgaWkgPSBrZXlzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IGtleXNbaV07XG4gICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29weV9zaW5nbGV0b25fbWV0aG9kcyhvdGhlcilcbiAgICAleHtcbiAgICAgIHZhciBpLCBuYW1lLCBuYW1lcywgbGVuZ3RoO1xuXG4gICAgICBpZiAob3RoZXIuaGFzT3duUHJvcGVydHkoJyQkbWV0YScpKSB7XG4gICAgICAgIHZhciBvdGhlcl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Mob3RoZXIpO1xuICAgICAgICB2YXIgc2VsZl9zaW5nbGV0b25fY2xhc3MgPSBPcGFsLmdldF9zaW5nbGV0b25fY2xhc3Moc2VsZik7XG4gICAgICAgIG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBuYW1lcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgICBpZiAoT3BhbC5pc19tZXRob2QobmFtZSkpIHtcbiAgICAgICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdID0gb3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlW25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGZfc2luZ2xldG9uX2NsYXNzLiQkY29uc3QgPSBPYmplY3QuYXNzaWduKHt9LCBvdGhlcl9zaW5nbGV0b25fY2xhc3MuJCRjb25zdCk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihcbiAgICAgICAgICBzZWxmX3NpbmdsZXRvbl9jbGFzcy4kJHByb3RvdHlwZSxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3RoZXJfc2luZ2xldG9uX2NsYXNzLiQkcHJvdG90eXBlKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG90aGVyKSwgbGVuZ3RoID0gbmFtZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09ICckJyAmJiBuYW1lLmNoYXJBdCgxKSAhPT0gJyQnICYmIG90aGVyLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgc2VsZltuYW1lXSA9IG90aGVyW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIGNvcHkgPSBzZWxmLmNsYXNzLmFsbG9jYXRlXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5jb3B5X3NpbmdsZXRvbl9tZXRob2RzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2Nsb25lKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2Nsb25lKG90aGVyKVxuICAgIGluaXRpYWxpemVfY29weShvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGRlZmluZV9zaW5nbGV0b25fbWV0aG9kKG5hbWUsIG1ldGhvZCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHNpbmdsZXRvbl9jbGFzcy5kZWZpbmVfbWV0aG9kKG5hbWUsIG1ldGhvZCwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgY29weSA9IHNlbGYuY2xhc3MuYWxsb2NhdGVcblxuICAgIGNvcHkuY29weV9pbnN0YW5jZV92YXJpYWJsZXMoc2VsZilcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG5cbiAgICBjb3B5XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2R1cChvdGhlcilcbiAgICBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBlbnVtX2ZvcihtZXRob2QgPSA6ZWFjaCwgKmFyZ3MsICZibG9jaylcbiAgICBFbnVtZXJhdG9yLmZvcihzZWxmLCBtZXRob2QsICphcmdzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2VudW0gZW51bV9mb3JcblxuICBkZWYgZXF1YWw/KG90aGVyKVxuICAgIGBzZWxmID09PSBvdGhlcmBcbiAgZW5kXG5cbiAgZGVmIGV4aXQoc3RhdHVzID0gdHJ1ZSlcbiAgICAkX19hdF9leGl0X18gfHw9IFtdXG5cbiAgICB1bnRpbCAkX19hdF9leGl0X18uZW1wdHk/XG4gICAgICBibG9jayA9ICRfX2F0X2V4aXRfXy5wb3BcbiAgICAgIGJsb2NrLmNhbGxcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHN0YXR1cy4kJGlzX2Jvb2xlYW4pIHtcbiAgICAgICAgc3RhdHVzID0gc3RhdHVzID8gMCA6IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0dXMgPSAkY29lcmNlX3RvKHN0YXR1cywgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpXG4gICAgICB9XG5cbiAgICAgIE9wYWwuZXhpdChzdGF0dXMpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGV4dGVuZCgqbW9kcylcbiAgICAleHtcbiAgICAgIHZhciBzaW5nbGV0b24gPSAje3NpbmdsZXRvbl9jbGFzc307XG5cbiAgICAgIGZvciAodmFyIGkgPSBtb2RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBtb2QgPSBtb2RzW2ldO1xuXG4gICAgICAgIGlmICghbW9kLiQkaXNfbW9kdWxlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgYXJndW1lbnQgdHlwZSAje2Btb2RgLmNsYXNzfSAoZXhwZWN0ZWQgTW9kdWxlKVwifTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7YG1vZGAuYXBwZW5kX2ZlYXR1cmVzIGBzaW5nbGV0b25gfTtcbiAgICAgICAgI3tgbW9kYC5leHRlbmRfb2JqZWN0IHNlbGZ9O1xuICAgICAgICAje2Btb2RgLmV4dGVuZGVkIHNlbGZ9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGdldHMoKmFyZ3MpXG4gICAgJHN0ZGluLmdldHMoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgX19pZF9fXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgaXZzID0gJydcbiAgICBpbnN0YW5jZV92YXJpYWJsZXMuZWFjaCBkbyB8aXxcbiAgICAgIGl2cyArPSBcIiAje2l9PSN7aW5zdGFuY2VfdmFyaWFibGVfZ2V0KGkpfVwiXG4gICAgZW5kXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje19faWRfXy50b19zKDE2KX0je2l2c30+XCJcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX29mPyhrbGFzcylcbiAgICAleHtcbiAgICAgIGlmICgha2xhc3MuJCRpc19jbGFzcyAmJiAha2xhc3MuJCRpc19tb2R1bGUpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdjbGFzcyBvciBtb2R1bGUgcmVxdWlyZWQnfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjbGFzcyA9PT0ga2xhc3M7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zdGFuY2VfdmFyaWFibGVfZGVmaW5lZD8obmFtZSlcbiAgICBuYW1lID0gT3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYE9wYWwuaGFzT3duUHJvcGVydHkuY2FsbChzZWxmLCBuYW1lLnN1YnN0cigxKSlgXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZV9nZXQobmFtZSlcbiAgICBuYW1lID0gT3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgJXh7XG4gICAgICB2YXIgaXZhciA9IHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV07XG5cbiAgICAgIHJldHVybiBpdmFyID09IG51bGwgPyBuaWwgOiBpdmFyO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlX3NldChuYW1lLCB2YWx1ZSlcbiAgICBuYW1lID0gT3BhbC5pbnN0YW5jZV92YXJpYWJsZV9uYW1lIShuYW1lKVxuXG4gICAgYHNlbGZbT3BhbC5pdmFyKG5hbWUuc3Vic3RyKDEpKV0gPSB2YWx1ZWBcbiAgZW5kXG5cbiAgZGVmIHJlbW92ZV9pbnN0YW5jZV92YXJpYWJsZShuYW1lKVxuICAgIG5hbWUgPSBPcGFsLmluc3RhbmNlX3ZhcmlhYmxlX25hbWUhKG5hbWUpXG5cbiAgICAleHtcbiAgICAgIHZhciBrZXkgPSBPcGFsLml2YXIobmFtZS5zdWJzdHIoMSkpLFxuICAgICAgICAgIHZhbDtcbiAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFsID0gc2VsZltrZXldO1xuICAgICAgICBkZWxldGUgc2VsZltrZXldO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJhaXNlIE5hbWVFcnJvciwgXCJpbnN0YW5jZSB2YXJpYWJsZSAje25hbWV9IG5vdCBkZWZpbmVkXCJcbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpdmFyO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgbmFtZS5jaGFyQXQoMCkgIT09ICckJykge1xuICAgICAgICAgIGlmIChuYW1lLnN1YnN0cigtMSkgPT09ICckJykge1xuICAgICAgICAgICAgaXZhciA9IG5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXZhciA9IG5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKCdAJyArIGl2YXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgSW50ZWdlcih2YWx1ZSwgYmFzZSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBzdHIsIGJhc2VfZGlnaXRzO1xuXG4gICAgICBpZiAoIXZhbHVlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdiYXNlIHNwZWNpZmllZCBmb3Igbm9uIHN0cmluZyB2YWx1ZSd9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEludGVnZXJcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuJCRpc19udW1iZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5IHx8IHZhbHVlID09PSAtSW5maW5pdHkgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAje3JhaXNlIEZsb2F0RG9tYWluRXJyb3IsIHZhbHVlfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCN7dmFsdWUucmVzcG9uZF90bz8oOnRvX2ludCl9KSB7XG4gICAgICAgICAgaSA9ICN7dmFsdWUudG9faW50fTtcbiAgICAgICAgICBpZiAoaSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCBJbnRlZ2VyLCA6dG9faSl9O1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09IFwiMFwiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmFzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJhc2UgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZSA9ICRjb2VyY2VfdG8oYmFzZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpZiAoYmFzZSA9PT0gMSB8fCBiYXNlIDwgMCB8fCBiYXNlID4gMzYpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJ9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RyID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XG5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pLywgZnVuY3Rpb24gKF8sIGhlYWQsIGZsYWcpIHtcbiAgICAgICAgc3dpdGNoIChmbGFnKSB7XG4gICAgICAgIGNhc2UgJzBiJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAyKSB7XG4gICAgICAgICAgICBiYXNlID0gMjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBuby1icmVha1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChiYXNlID09PSAwIHx8IGJhc2UgPT09IDgpIHtcbiAgICAgICAgICAgIGJhc2UgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJzBkJzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxMCkge1xuICAgICAgICAgICAgYmFzZSA9IDEwO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICBpZiAoYmFzZSA9PT0gMCB8fCBiYXNlID09PSAxNikge1xuICAgICAgICAgICAgYmFzZSA9IDE2O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfSk7XG5cbiAgICAgIGJhc2UgPSAoYmFzZSA9PT0gMCA/IDEwIDogYmFzZSk7XG5cbiAgICAgIGJhc2VfZGlnaXRzID0gJzAtJyArIChiYXNlIDw9IDEwID8gYmFzZSAtIDEgOiAnOWEtJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAoYmFzZSAtIDExKSkpO1xuXG4gICAgICBpZiAoIShuZXcgUmVnRXhwKCdeXFxcXHMqWystXT9bJyArIGJhc2VfZGlnaXRzICsgJ10rXFxcXHMqJCcpKS50ZXN0KHN0cikpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgdmFsdWUgZm9yIEludGVnZXIoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgfVxuXG4gICAgICBpID0gcGFyc2VJbnQoc3RyLCBiYXNlKTtcblxuICAgICAgaWYgKGlzTmFOKGkpKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIHZhbHVlIGZvciBJbnRlZ2VyKCk6IFxcXCIje3ZhbHVlfVxcXCJcIn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgRmxvYXQodmFsdWUpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0IG5pbCBpbnRvIEZsb2F0XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzdHIgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xuXG4gICAgICAgIC8vU3BlY2lhbCBjYXNlIGZvciBoZXggc3RyaW5ncyBvbmx5OlxuICAgICAgICBpZiAoL15cXHMqWy0rXT8wW3hYXVswLTlhLWZBLUZdK1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICByZXR1cm4gI3tJbnRlZ2VyKGBzdHJgKX07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIS9eXFxzKlstK10/WzAtOV0qXFwuP1swLTldKyhbZUVdWy0rXT9bMC05XSspP1xccyokLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCB2YWx1ZSBmb3IgRmxvYXQoKTogXFxcIiN7dmFsdWV9XFxcIlwifVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7T3BhbC5jb2VyY2VfdG8hKHZhbHVlLCBGbG9hdCwgOnRvX2YpfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBIYXNoKGFyZylcbiAgICByZXR1cm4ge30gaWYgYXJnLm5pbD8gfHwgYXJnID09IFtdXG4gICAgcmV0dXJuIGFyZyBpZiBIYXNoID09PSBhcmdcbiAgICBPcGFsLmNvZXJjZV90byEoYXJnLCBIYXNoLCA6dG9faGFzaClcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgICV4e1xuICAgICAgaWYgKCFrbGFzcy4kJGlzX2NsYXNzICYmICFrbGFzcy4kJGlzX21vZHVsZSkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ2NsYXNzIG9yIG1vZHVsZSByZXF1aXJlZCd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT3BhbC5pc19hKHNlbGYsIGtsYXNzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpdHNlbGZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGtpbmRfb2Y/IGlzX2E/XG5cbiAgZGVmIGxhbWJkYSgmYmxvY2spXG4gICAgYE9wYWwubGFtYmRhKGJsb2NrKWBcbiAgZW5kXG5cbiAgZGVmIGxvYWQoZmlsZSlcbiAgICBmaWxlID0gT3BhbC5jb2VyY2VfdG8hKGZpbGUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgT3BhbC5sb2FkKCN7ZmlsZX0pYFxuICBlbmRcblxuICBkZWYgbG9vcFxuICAgIHJldHVybiBlbnVtX2Zvcig6bG9vcCkgeyBGbG9hdDo6SU5GSU5JVFkgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSB0cnVlXG4gICAgICBiZWdpblxuICAgICAgICB5aWVsZFxuICAgICAgcmVzY3VlIFN0b3BJdGVyYXRpb24gPT4gZVxuICAgICAgICByZXR1cm4gZS5yZXN1bHRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbmlsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIG9iamVjdF9pZCBfX2lkX19cblxuICBkZWYgcHJpbnRmKCphcmdzKVxuICAgIGlmIGFyZ3MuYW55P1xuICAgICAgcHJpbnQgZm9ybWF0KCphcmdzKVxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBwcm9jKCZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjcmVhdGUgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYGJsb2NrLiQkaXNfbGFtYmRhID0gZmFsc2VgXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKnN0cnMpXG4gICAgJHN0ZG91dC5wdXRzKCpzdHJzKVxuICBlbmRcblxuICBkZWYgcCgqYXJncylcbiAgICBhcmdzLmVhY2ggeyB8b2JqfCAkc3Rkb3V0LnB1dHMgb2JqLmluc3BlY3QgfVxuXG4gICAgYXJncy5sZW5ndGggPD0gMSA/IGFyZ3NbMF0gOiBhcmdzXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqc3RycylcbiAgICAkc3Rkb3V0LnByaW50KCpzdHJzKVxuICBlbmRcblxuICBkZWYgcmVhZGxpbmUoKmFyZ3MpXG4gICAgJHN0ZGluLnJlYWRsaW5lKCphcmdzKVxuICBlbmRcblxuICBkZWYgd2Fybigqc3RycywgdXBsZXZlbDogbmlsKVxuICAgIGlmIHVwbGV2ZWxcbiAgICAgIHVwbGV2ZWwgPSBPcGFsLmNvZXJjZV90byEodXBsZXZlbCwgSW50ZWdlciwgOnRvX3N0cilcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwibmVnYXRpdmUgbGV2ZWwgKCN7dXBsZXZlbH0pXCIgaWYgdXBsZXZlbCA8IDBcbiAgICAgIGxvY2F0aW9uID0gY2FsbGVyKHVwbGV2ZWwgKyAxLCAxKS5maXJzdCYuc3BsaXQoJzppbiBgJykmLmZpcnN0XG4gICAgICBsb2NhdGlvbiA9IFwiI3tsb2NhdGlvbn06IFwiIGlmIGxvY2F0aW9uXG4gICAgICBzdHJzID0gc3Rycy5tYXAgeyB8c3wgXCIje2xvY2F0aW9ufXdhcm5pbmc6ICN7c31cIiB9XG4gICAgZW5kXG5cbiAgICAkc3RkZXJyLnB1dHMoKnN0cnMpIHVubGVzcyAkVkVSQk9TRS5uaWw/IHx8IHN0cnMuZW1wdHk/XG4gIGVuZFxuXG4gIGRlZiByYWlzZShleGNlcHRpb24gPSB1bmRlZmluZWQsIHN0cmluZyA9IG5pbCwgYmFja3RyYWNlID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKGV4Y2VwdGlvbiA9PSBudWxsICYmICN7JCF9ICE9PSBuaWwpIHtcbiAgICAgICAgdGhyb3cgI3skIX07XG4gICAgICB9XG4gICAgICBpZiAoZXhjZXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3tSdW50aW1lRXJyb3IubmV3ICcnfTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCRyZXNwb25kX3RvKGV4Y2VwdGlvbiwgJyR0b19zdHInKSkge1xuICAgICAgICBleGNlcHRpb24gPSAje1J1bnRpbWVFcnJvci5uZXcgZXhjZXB0aW9uLnRvX3N0cn07XG4gICAgICB9XG4gICAgICAvLyB1c2luZyByZXNwb25kX3RvPyBhbmQgbm90IGFuIHVuZGVmaW5lZCBjaGVjayB0byBhdm9pZCBtZXRob2RfbWlzc2luZyBtYXRjaGluZyBhcyB0cnVlXG4gICAgICBlbHNlIGlmIChleGNlcHRpb24uJCRpc19jbGFzcyAmJiAkcmVzcG9uZF90byhleGNlcHRpb24sICckZXhjZXB0aW9uJykpIHtcbiAgICAgICAgZXhjZXB0aW9uID0gI3tleGNlcHRpb24uZXhjZXB0aW9uIHN0cmluZ307XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChleGNlcHRpb24uJCRpc19leGNlcHRpb24pIHtcbiAgICAgICAgLy8gZXhjZXB0aW9uIGlzIGZpbmVcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBleGNlcHRpb24gPSAje1R5cGVFcnJvci5uZXcgJ2V4Y2VwdGlvbiBjbGFzcy9vYmplY3QgZXhwZWN0ZWQnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJhY2t0cmFjZSAhPT0gbmlsKSB7XG4gICAgICAgIGV4Y2VwdGlvbi4kc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoI3skIX0gIT09IG5pbCkge1xuICAgICAgICBPcGFsLmV4Y2VwdGlvbnMucHVzaCgjeyQhfSk7XG4gICAgICB9XG5cbiAgICAgICN7JCF9ID0gZXhjZXB0aW9uO1xuICAgICAgI3skQH0gPSAje2BleGNlcHRpb25gLmJhY2t0cmFjZX07XG5cbiAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGZhaWwgcmFpc2VcblxuICBkZWYgcmFuZChtYXggPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICN7UmFuZG9tOjpERUZBVUxULnJhbmR9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChtYXggPCAwKSB7XG4gICAgICAgICAgbWF4ID0gTWF0aC5hYnMobWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXggJSAxICE9PSAwKSB7XG4gICAgICAgICAgbWF4ID0gbWF4LiR0b19pKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWF4ID09PSAwKSB7XG4gICAgICAgICAgbWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFJhbmRvbTo6REVGQVVMVC5yYW5kKG1heClcbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG8/KG5hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgJXh7XG4gICAgICB2YXIgYm9keSA9IHNlbGZbJyQnICsgbmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YoYm9keSkgPT09IFwiZnVuY3Rpb25cIiAmJiAhYm9keS4kJHN0dWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmWyckcmVzcG9uZF90b19taXNzaW5nPyddLiQkcHJpc3RpbmUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7cmVzcG9uZF90b19taXNzaW5nPyhuYW1lLCBpbmNsdWRlX2FsbCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlc3BvbmRfdG9fbWlzc2luZz8obWV0aG9kX25hbWUsIGluY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgT3BhbC5wcmlzdGluZShzZWxmLCA6cmVzcG9uZF90bz8sIDpyZXNwb25kX3RvX21pc3Npbmc/KVxuXG4gIGRlZiByZXF1aXJlKGZpbGUpXG4gICAgZmlsZSA9IE9wYWwuY29lcmNlX3RvIShmaWxlLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgYE9wYWwucmVxdWlyZSgje2ZpbGV9KWBcbiAgZW5kXG5cbiAgZGVmIHJlcXVpcmVfcmVsYXRpdmUoZmlsZSlcbiAgICBPcGFsLnRyeV9jb252ZXJ0IShmaWxlLCBTdHJpbmcsIDp0b19zdHIpXG4gICAgZmlsZSA9IEZpbGUuZXhwYW5kX3BhdGggRmlsZS5qb2luKGBPcGFsLmN1cnJlbnRfZmlsZWAsICcuLicsIGZpbGUpXG5cbiAgICBgT3BhbC5yZXF1aXJlKCN7ZmlsZX0pYFxuICBlbmRcblxuICAjIGBwYXRoYCBzaG91bGQgYmUgdGhlIGZ1bGwgcGF0aCB0byBiZSBmb3VuZCBpbiByZWdpc3RlcmVkIG1vZHVsZXMgKGBPcGFsLm1vZHVsZXNgKVxuICBkZWYgcmVxdWlyZV90cmVlKHBhdGgpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHBhdGggPSAje0ZpbGUuZXhwYW5kX3BhdGgocGF0aCl9XG4gICAgICBwYXRoID0gT3BhbC5ub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAocGF0aCA9PT0gJy4nKSBwYXRoID0gJyc7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIE9wYWwubW9kdWxlcykge1xuICAgICAgICBpZiAoI3tgbmFtZWAuc3RhcnRfd2l0aD8ocGF0aCl9KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goW25hbWUsIE9wYWwucmVxdWlyZShuYW1lKV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzZW5kICAgICAgICBfX3NlbmRfX1xuICBhbGlhcyBwdWJsaWNfc2VuZCBfX3NlbmRfX1xuXG4gIGRlZiBzaW5nbGV0b25fY2xhc3NcbiAgICBgT3BhbC5nZXRfc2luZ2xldG9uX2NsYXNzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgc2xlZXAoc2Vjb25kcyA9IG5pbClcbiAgICAleHtcbiAgICAgIGlmIChzZWNvbmRzID09PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwiY2FuJ3QgY29udmVydCBOaWxDbGFzcyBpbnRvIHRpbWUgaW50ZXJ2YWxcIn1cbiAgICAgIH1cbiAgICAgIGlmICghc2Vjb25kcy4kJGlzX251bWJlcikge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2Vjb25kcy5jbGFzc30gaW50byB0aW1lIGludGVydmFsXCJ9XG4gICAgICB9XG4gICAgICBpZiAoc2Vjb25kcyA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAndGltZSBpbnRlcnZhbCBtdXN0IGJlIHBvc2l0aXZlJ31cbiAgICAgIH1cbiAgICAgIHZhciBnZXRfdGltZSA9IE9wYWwuZ2xvYmFsLnBlcmZvcm1hbmNlID9cbiAgICAgICAgZnVuY3Rpb24oKSB7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfSA6XG4gICAgICAgIGZ1bmN0aW9uKCkge3JldHVybiBuZXcgRGF0ZSgpfVxuXG4gICAgICB2YXIgdCA9IGdldF90aW1lKCk7XG4gICAgICB3aGlsZSAoZ2V0X3RpbWUoKSAtIHQgPD0gc2Vjb25kcyAqIDEwMDApO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3JhbmQoc2VlZCA9IFJhbmRvbS5uZXdfc2VlZClcbiAgICBSYW5kb20uc3JhbmQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIFN0cmluZyhzdHIpXG4gICAgT3BhbC5jb2VyY2VfdG8/KHN0ciwgU3RyaW5nLCA6dG9fc3RyKSB8fFxuICAgICAgT3BhbC5jb2VyY2VfdG8hKHN0ciwgU3RyaW5nLCA6dG9fcylcbiAgZW5kXG5cbiAgZGVmIHRhcCgmYmxvY2spXG4gICAgeWllbGQgc2VsZlxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgXCIjPCN7c2VsZi5jbGFzc306MHgje19faWRfXy50b19zKDE2KX0+XCJcbiAgZW5kXG5cbiAgZGVmIGNhdGNoKHRhZyA9IG5pbClcbiAgICB0YWcgfHw9IE9iamVjdC5uZXdcbiAgICB5aWVsZCh0YWcpXG4gIHJlc2N1ZSBVbmNhdWdodFRocm93RXJyb3IgPT4gZVxuICAgIHJldHVybiBlLnZhbHVlIGlmIGUudGFnID09IHRhZ1xuICAgIHJhaXNlXG4gIGVuZFxuXG4gIGRlZiB0aHJvdyh0YWcsIG9iaiA9IG5pbClcbiAgICByYWlzZSBVbmNhdWdodFRocm93RXJyb3IubmV3KHRhZywgb2JqKVxuICBlbmRcblxuICAjIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIG9wZW4sIGRlbGVnYXRlIHRvIEZpbGUub3BlblxuICBkZWYgb3BlbigqYXJncywgJmJsb2NrKVxuICAgIEZpbGUub3BlbigqYXJncywgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgeWllbGRfc2VsZlxuICAgIHJldHVybiBlbnVtX2Zvcig6eWllbGRfc2VsZikgeyAxIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgIHlpZWxkIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgdGhlbiB5aWVsZF9zZWxmXG5cbiAgT3BhbC5wcmlzdGluZShzZWxmLCA6bWV0aG9kX21pc3NpbmcpXG5lbmRcblxuY2xhc3MgT2JqZWN0XG4gIGluY2x1ZGUgS2VybmVsXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwibWV0aG9kX21pc3NpbmciLCJzeW1ib2wiLCJzZWxmIiwicmFpc2UiLCJOb01ldGhvZEVycm9yIiwibmV3IiwiaW5zcGVjdCIsImFyZ3MiLCJjYWxsZXIiLCIxIiwiPX4iLCJvYmoiLCIhfiIsIiEiLCI9PT0iLCJvdGhlciIsIiRyZXRfb3JfMSIsIm9iamVjdF9pZCIsIj09IiwiPD0+IiwibWV0aG9kIiwibmFtZSIsIk5hbWVFcnJvciIsImNsYXNzIiwiTWV0aG9kIiwibWV0aG9kcyIsImFsbCIsInB1YmxpY19tZXRob2RzIiwiQXJyYXkiLCJvYmplY3QiLCJPcGFsIiwiY29lcmNlX3RvPyIsImF0X2V4aXQiLCIkX19hdF9leGl0X18iLCIkcmV0X29yXzIiLCI8PCIsImJsb2NrIiwic3RhcnQiLCJsZW5ndGgiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImNvcHlfc2luZ2xldG9uX21ldGhvZHMiLCJjbG9uZSIsIiRrd2FyZ3MiLCJjb3B5IiwiYWxsb2NhdGUiLCJpbml0aWFsaXplX2Nsb25lIiwiaW5pdGlhbGl6ZV9jb3B5IiwiZGVmaW5lX3NpbmdsZXRvbl9tZXRob2QiLCJkZWZpbmVfbWV0aG9kIiwic2luZ2xldG9uX2NsYXNzIiwidG9fcHJvYyIsImR1cCIsImluaXRpYWxpemVfZHVwIiwiZW51bV9mb3IiLCJmb3IiLCJFbnVtZXJhdG9yIiwiZXF1YWw/IiwiZXhpdCIsInN0YXR1cyIsIiRyZXRfb3JfMyIsImVtcHR5PyIsInBvcCIsImNhbGwiLCJJbnRlZ2VyIiwiZXh0ZW5kIiwiVHlwZUVycm9yIiwiYXBwZW5kX2ZlYXR1cmVzIiwiZXh0ZW5kX29iamVjdCIsImV4dGVuZGVkIiwiZ2V0cyIsIiRzdGRpbiIsImhhc2giLCJfX2lkX18iLCJpdnMiLCJlYWNoIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiYmxvY2sgaW4gaW5zcGVjdCIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCIrIiwiaW5zdGFuY2VfdmFyaWFibGVfZ2V0IiwidG9fcyIsIjE2IiwiaW5zdGFuY2Vfb2Y/Iiwia2xhc3MiLCJpbnN0YW5jZV92YXJpYWJsZV9kZWZpbmVkPyIsImluc3RhbmNlX3ZhcmlhYmxlX25hbWUhIiwiaW5zdGFuY2VfdmFyaWFibGVfc2V0IiwidmFsdWUiLCJyZW1vdmVfaW5zdGFuY2VfdmFyaWFibGUiLCJiYXNlIiwiQXJndW1lbnRFcnJvciIsIkZsb2F0RG9tYWluRXJyb3IiLCJyZXNwb25kX3RvPyIsInRvX2ludCIsImNvZXJjZV90byEiLCJGbG9hdCIsIkhhc2giLCJhcmciLCIkcmV0X29yXzQiLCJuaWw/IiwiaXNfYT8iLCJpdHNlbGYiLCJsYW1iZGEiLCJsb2FkIiwiZmlsZSIsIlN0cmluZyIsImxvb3AiLCJibG9ja19naXZlbj8iLCJibG9jayBpbiBsb29wIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBsb29wIiwiRmxvYXQ6OklORklOSVRZIiwiU3RvcEl0ZXJhdGlvbiIsImUiLCJyZXN1bHQiLCJwcmludGYiLCJhbnk/IiwicHJpbnQiLCJmb3JtYXQiLCJwcm9jIiwicHV0cyIsIiRzdGRvdXQiLCJzdHJzIiwicCIsImJsb2NrIGluIHAiLCJibG9jayAoMiBsZXZlbHMpIGluIHAiLCI8PSIsIltdIiwiMCIsInJlYWRsaW5lIiwid2FybiIsInVwbGV2ZWwiLCI8IiwibG9jYXRpb24iLCJmaXJzdCIsIm1hcCIsImJsb2NrIGluIHdhcm4iLCJzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB3YXJuIiwiJHJldF9vcl81IiwiJFZFUkJPU0UiLCIkc3RkZXJyIiwiZXhjZXB0aW9uIiwic3RyaW5nIiwiYmFja3RyYWNlIiwiJCEiLCJSdW50aW1lRXJyb3IiLCJ0b19zdHIiLCIkQCIsInJhbmQiLCJtYXgiLCJSYW5kb206OkRFRkFVTFQiLCJSYW5kb20iLCJpbmNsdWRlX2FsbCIsInJlc3BvbmRfdG9fbWlzc2luZz8iLCJtZXRob2RfbmFtZSIsInByaXN0aW5lIiwicmVxdWlyZSIsInJlcXVpcmVfcmVsYXRpdmUiLCJ0cnlfY29udmVydCEiLCJGaWxlIiwiZXhwYW5kX3BhdGgiLCJqb2luIiwicmVxdWlyZV90cmVlIiwicGF0aCIsInN0YXJ0X3dpdGg/Iiwic2xlZXAiLCJzZWNvbmRzIiwic3JhbmQiLCJzZWVkIiwibmV3X3NlZWQiLCJzdHIiLCIkcmV0X29yXzYiLCJ0YXAiLCJjYXRjaCIsInRhZyIsIiRyZXRfb3JfNyIsIk9iamVjdCIsIlVuY2F1Z2h0VGhyb3dFcnJvciIsInRocm93Iiwib3BlbiIsInlpZWxkX3NlbGYiLCJibG9jayBpbiB5aWVsZF9zZWxmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB5aWVsZF9zZWxmIiwiPGNsYXNzOk9iamVjdD4iLCJpbmNsdWRlIiwiS2VybmVsIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQztFQUFBQTs7SUFBQUE7Ozs7QUFDRUMsSUFBQUEsa0NBQUFBLDJCQUFBQSwwQkFBbUJDLE1BQUQsRUFIcEIsRUFHRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBa0M7O01BSHBDOztNQUc2QjtNQUN6QkEsT0FBQUUsSUFBQUMsT0FBQUEsQ0FBTUMsNkJBQWFDLEtBQUFBLENBQUssRUFBQSxHQUFBLG9CQUFBLEdBQUEsQ0FBcUJKLE1BQXJCLENBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBb0NDLElBQUFJLFNBQUFBLENBQUFBLENBQXBDLENBQWxCLEVBQWlFTCxNQUFqRSxFQUF5RU0sSUFBNURGLENBQW5CLEVBQXNGLEdBQXRGLEVBQTJGSCxJQUFBTSxRQUFBQSxDQUFPQyxDQUFQRCxDQUEzRkw7SUFERkgsQ0FBQUEsdUNBQUFBOztBQUlBVSxJQUFBQSxzQkFBQUEsc0JBQUFBLFNBQU9DLEdBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBO0lBREZBLENBQUFB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QXhCRjtJQURGZ0wsQ0FBQUEsK0JBQUFBOztBQUtBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQWx0QkYsRUFrdEJFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFnQjs7TUFsdEJsQjs7TUFrdEJXO01BQ1BBLE9BQUlBLE1BQUpwQixvQkFBSW9CLFFBQUFBLEVBQU0sVUFBQzdLLElBQUQsQ0FBTjZLLEVBQWNoSixLQUFEYyxTQUFBQSxDQUFBQSxDQUFia0k7SUFETkEsQ0FBQUEsOEJBQUFBOztBQUlBQyxJQUFBQSw4QkFBQUEsd0JBQUFBLHNCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7O01BQ0UsSUFBMEN6RSxnQkFBMUM7TUFBQTtRQUFBLE9BQU92RCxNQUFBbkQsSUFBQW1ELFlBQUFBLEVBQUFBLENBQVMsWUFBVEEsQ0FBQUEsRUFBc0JpSSxpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUE5SyxDQUFGNkssbUJBQUFBLGtCQUFBQSxNQUF0QmpJO01BQVA7TUFDQSxPQUFBLG9CQUFNbkQsSUFBTixDQUFBO0lBRkZtTCxDQUFBQSxtQ0FBQUE7SUFLQSxhQUFNLE1BQU4sRUFBVyxZQUFYO0lBRUF0TCxPQUFBK0Isb0JBQUk4SCxVQUFBQSxDQUFVMUosSUFBZCxFQUFvQixnQkFBaEIwSjtFQTN0Qk43SixHQUFBQSxXQUFBQTtFQTh0QkFELE9BQUEwTDtFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUF0TCxJQUFBdUwsU0FBQUEsQ0FBUUMsc0JBQVJEO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBaHVCQTFMOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo1Mzg2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9lcnJvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBFeGNlcHRpb24gPCBgRXJyb3JgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX2V4Y2VwdGlvbicsIHRydWUpYFxuICBgdmFyIHN0YWNrX3RyYWNlX2xpbWl0YFxuXG4gIGRlZiBzZWxmLm5ldygqYXJncylcbiAgICAleHtcbiAgICAgIHZhciBtZXNzYWdlICAgPSAoYXJncy5sZW5ndGggPiAwKSA/IGFyZ3NbMF0gOiBuaWw7XG4gICAgICB2YXIgZXJyb3IgICAgID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICAgIGVycm9yLm5hbWUgICAgPSBzZWxmLiQkbmFtZTtcbiAgICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgZXJyb3IuY2F1c2UgICA9ICN7JCF9O1xuICAgICAgT3BhbC5zZW5kKGVycm9yLCBlcnJvci4kaW5pdGlhbGl6ZSwgYXJncyk7XG5cbiAgICAgIC8vIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKCkgd2lsbCB1c2UgLm5hbWUgYW5kIC50b1N0cmluZyB0byBidWlsZCB0aGVcbiAgICAgIC8vIGZpcnN0IGxpbmUgb2YgdGhlIHN0YWNrIHRyYWNlIHNvIGl0IG11c3QgYmUgY2FsbGVkIGFmdGVyIHRoZSBlcnJvclxuICAgICAgLy8gaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICAvLyBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QtdjYueC9kb2NzL2FwaS9lcnJvcnMuaHRtbFxuICAgICAgaWYgKE9wYWwuY29uZmlnLmVuYWJsZV9zdGFja190cmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAvLyBQYXNzaW5nIEtlcm5lbC5yYWlzZSB3aWxsIGN1dCB0aGUgc3RhY2sgdHJhY2UgZnJvbSB0aGF0IHBvaW50IGFib3ZlXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVycm9yLCBzdGFja190cmFjZV9saW1pdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIGVuZFxuICBgc3RhY2tfdHJhY2VfbGltaXQgPSBzZWxmLiRuZXdgXG5cbiAgZGVmIHNlbGYuZXhjZXB0aW9uKCphcmdzKVxuICAgIG5ldygqYXJncylcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgIyB1c2luZyBzZWxmLm1lc3NhZ2UgYWthIEBtZXNzYWdlIHRvIHJldGFpbiBjb21wYXRpYmlsaXR5IHdpdGggbmF0aXZlIGV4Y2VwdGlvbidzIG1lc3NhZ2UgcHJvcGVydHlcbiAgICBgc2VsZi5tZXNzYWdlID0gKGFyZ3MubGVuZ3RoID4gMCkgPyBhcmdzWzBdIDogbmlsYFxuICBlbmRcblxuICAleHtcbiAgICAvLyBDb252ZXJ0IGJhY2t0cmFjZSBmcm9tIGFueSBmb3JtYXQgdG8gUnVieSBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb3JyZWN0X2JhY2t0cmFjZShiYWNrdHJhY2UpIHtcbiAgICAgIHZhciBuZXdfYnQgPSBbXSwgbTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYWNrdHJhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IGJhY2t0cmFjZVtpXTtcbiAgICAgICAgaWYgKCFsb2MgfHwgIWxvYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIC8qIERvIG5vdGhpbmcgKi9cbiAgICAgICAgfVxuICAgICAgICAvKiBDaHJvbWl1bSBmb3JtYXQgKi9cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBsb2MubWF0Y2goL14gICAgYXQgKC4qPykgXFwoKC4qPylcXCkkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsyXSArIFwiOmluIGBcIiArIG1bMV0gKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG0gPSBsb2MubWF0Y2goL14gICAgYXQgKC4qPykkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsxXSArIFwiOmluIGB1bmRlZmluZWQnXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE5vZGUgZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eICBmcm9tICguKj8pJC8pKSkge1xuICAgICAgICAgIG5ld19idC5wdXNoKG1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIE1vemlsbGEvQXBwbGUgZm9ybWF0ICovXG4gICAgICAgIGVsc2UgaWYgKChtID0gbG9jLm1hdGNoKC9eKC4qPylAKC4qPykkLykpKSB7XG4gICAgICAgICAgbmV3X2J0LnB1c2gobVsyXSArICc6aW4gYCcgKyBtWzFdICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdfYnQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIGJhY2t0cmFjZVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuYmFja3RyYWNlKSB7XG4gICAgICAgIC8vIG5pbCBpcyBhIHZhbGlkIGJhY2t0cmFjZVxuICAgICAgICByZXR1cm4gc2VsZi5iYWNrdHJhY2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYWNrdHJhY2UgPSBzZWxmLnN0YWNrO1xuXG4gICAgICBpZiAoYmFja3RyYWNlLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZSA9IGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZS5zcGxpdChcIlxcblwiKS5zbGljZSgwLCAxNSkpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYmFja3RyYWNlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZSA9IGNvcnJlY3RfYmFja3RyYWNlKGJhY2t0cmFjZS5zbGljZSgwLCAxNSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICBlbmRcblxuICBkZWYgYmFja3RyYWNlX2xvY2F0aW9uc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucykgcmV0dXJuIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucztcbiAgICAgIHNlbGYuYmFja3RyYWNlX2xvY2F0aW9ucyA9ICN7YmFja3RyYWNlJi5tYXAgZG8gfGxvY3xcbiAgICAgICAgOjpUaHJlYWQ6OkJhY2t0cmFjZTo6TG9jYXRpb24ubmV3KGxvYylcbiAgICAgIGVuZH1cbiAgICAgIHJldHVybiBzZWxmLmJhY2t0cmFjZV9sb2NhdGlvbnM7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2F1c2VcbiAgICBgc2VsZi5jYXVzZSB8fCBuaWxgXG4gIGVuZFxuXG4gIGRlZiBleGNlcHRpb24oc3RyID0gbmlsKVxuICAgICV4e1xuICAgICAgaWYgKHN0ciA9PT0gbmlsIHx8IHNlbGYgPT09IHN0cikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsb25lZCA9ICN7Y2xvbmV9O1xuICAgICAgY2xvbmVkLm1lc3NhZ2UgPSBzdHI7XG4gICAgICBpZiAoc2VsZi5iYWNrdHJhY2UpIGNsb25lZC5iYWNrdHJhY2UgPSBzZWxmLmJhY2t0cmFjZS4kZHVwKCk7XG4gICAgICBjbG9uZWQuc3RhY2sgPSBzZWxmLnN0YWNrO1xuICAgICAgY2xvbmVkLmNhdXNlID0gc2VsZi5jYXVzZTtcbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICBlbmRcblxuICAjIG5vdCB1c2luZyBhbGlhcyBtZXNzYWdlIHRvX3MgYmVjYXVzZSB5b3UgbmVlZCB0byBiZSBhYmxlIHRvIG92ZXJyaWRlIHRvX3MgYW5kIGhhdmUgbWVzc2FnZSB1c2Ugb3ZlcnJpZGRlbiBtZXRob2QsIHdvbid0IHdvcmsgd2l0aCBhbGlhc1xuICBkZWYgbWVzc2FnZVxuICAgIHRvX3NcbiAgZW5kXG5cbiAgZGVmIGZ1bGxfbWVzc2FnZShoaWdobGlnaHQ6ICRzdGRlcnIudHR5Pywgb3JkZXI6IDp0b3ApXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCB0cnVlIG9yIGZhbHNlIGFzIGhpZ2hsaWdodDogI3toaWdobGlnaHR9XCIgdW5sZXNzIFt0cnVlLCBmYWxzZV0uaW5jbHVkZT8gaGlnaGxpZ2h0XG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJleHBlY3RlZCA6dG9wIG9yIDpib3R0b20gYXMgb3JkZXI6ICN7b3JkZXJ9XCIgdW5sZXNzICVpW3RvcCBib3R0b21dLmluY2x1ZGU/IG9yZGVyXG5cbiAgICBpZiBoaWdobGlnaHRcbiAgICAgIGJvbGRfdW5kZXJsaW5lID0gXCJcXGVbMTs0bVwiXG4gICAgICBib2xkID0gXCJcXGVbMW1cIlxuICAgICAgcmVzZXQgPSBcIlxcZVttXCJcbiAgICBlbHNlXG4gICAgICBib2xkX3VuZGVybGluZSA9IGJvbGQgPSByZXNldCA9ICcnXG4gICAgZW5kXG5cbiAgICBidCA9IGJhY2t0cmFjZS5kdXBcbiAgICBidCA9IGNhbGxlciBpZiAhYnQgfHwgYnQuZW1wdHk/XG4gICAgZmlyc3QgPSBidC5zaGlmdFxuXG4gICAgbXNnID0gXCIje2ZpcnN0fTogXCJcbiAgICBtc2cgKz0gXCIje2JvbGR9I3t0b19zfSAoI3tib2xkX3VuZGVybGluZX0je3NlbGYuY2xhc3N9I3tyZXNldH0je2JvbGR9KSN7cmVzZXR9XFxuXCJcblxuICAgIG1zZyArPSBidC5tYXAgeyB8bG9jfCBcIlxcdGZyb20gI3tsb2N9XFxuXCIgfS5qb2luXG5cbiAgICBtc2cgKz0gY2F1c2UuZnVsbF9tZXNzYWdlKGhpZ2hsaWdodDogaGlnaGxpZ2h0KSBpZiBjYXVzZVxuXG4gICAgaWYgb3JkZXIgPT0gOmJvdHRvbVxuICAgICAgbXNnID0gbXNnLnNwbGl0KFwiXFxuXCIpLnJldmVyc2Uuam9pbihcIlxcblwiKVxuICAgICAgbXNnID0gXCIje2JvbGR9VHJhY2ViYWNrI3tyZXNldH0gKG1vc3QgcmVjZW50IGNhbGwgbGFzdCk6XFxuXCIgKyBtc2dcbiAgICBlbmRcblxuICAgIG1zZ1xuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgIGFzX3N0ciA9IHRvX3NcbiAgICBhc19zdHIuZW1wdHk/ID8gc2VsZi5jbGFzcy50b19zIDogXCIjPCN7c2VsZi5jbGFzcy50b19zfTogI3t0b19zfT5cIlxuICBlbmRcblxuICBkZWYgc2V0X2JhY2t0cmFjZShiYWNrdHJhY2UpXG4gICAgJXh7XG4gICAgICB2YXIgdmFsaWQgPSB0cnVlLCBpLCBpaTtcblxuICAgICAgaWYgKGJhY2t0cmFjZSA9PT0gbmlsKSB7XG4gICAgICAgIHNlbGYuYmFja3RyYWNlID0gbmlsO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKGJhY2t0cmFjZS4kJGlzX3N0cmluZykge1xuICAgICAgICBzZWxmLmJhY2t0cmFjZSA9IFtiYWNrdHJhY2VdO1xuICAgICAgICBzZWxmLnN0YWNrID0gJyAgZnJvbSAnICsgYmFja3RyYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJhY2t0cmFjZS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgaWkgPSBiYWNrdHJhY2UubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFiYWNrdHJhY2VbaV0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdiYWNrdHJhY2UgbXVzdCBiZSBBcnJheSBvZiBTdHJpbmcnfVxuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5iYWNrdHJhY2UgPSBiYWNrdHJhY2U7XG4gICAgICAgIHNlbGYuc3RhY2sgPSAje2BiYWNrdHJhY2VgLm1hcCB7IHxpfCAnICBmcm9tICcgKyBpIH19LmpvaW4oXCJcXG5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYWNrdHJhY2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgICMgdXNpbmcgc2VsZi5tZXNzYWdlIGFrYSBAbWVzc2FnZSB0byByZXRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG5hdGl2ZSBleGNlcHRpb24ncyBtZXNzYWdlIHByb3BlcnR5XG4gICAgKEBtZXNzYWdlICYmIEBtZXNzYWdlLnRvX3MpIHx8IHNlbGYuY2xhc3MudG9fc1xuICBlbmRcbmVuZFxuXG4jIGtlZXAgdGhlIGluZGVudGF0aW9uLCBpdCBtYWtlcyB0aGUgZXhjZXB0aW9uIGhpZXJhcmNoeSBjbGVhclxuY2xhc3MgU2NyaXB0RXJyb3IgICAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgU3ludGF4RXJyb3IgICAgICAgICA8IFNjcmlwdEVycm9yOyBlbmRcbmNsYXNzIExvYWRFcnJvciAgICAgICAgICAgPCBTY3JpcHRFcnJvcjsgZW5kXG5jbGFzcyBOb3RJbXBsZW1lbnRlZEVycm9yIDwgU2NyaXB0RXJyb3I7IGVuZFxuXG5jbGFzcyBTeXN0ZW1FeGl0ICAgICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBOb01lbW9yeUVycm9yICAgICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBTaWduYWxFeGNlcHRpb24gICA8IEV4Y2VwdGlvbjsgZW5kXG5jbGFzcyBJbnRlcnJ1cHQgICAgICAgICAgIDwgU2lnbmFsRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFNlY3VyaXR5RXJyb3IgICAgIDwgRXhjZXB0aW9uOyBlbmRcbmNsYXNzIFN5c3RlbVN0YWNrRXJyb3IgIDwgRXhjZXB0aW9uOyBlbmRcblxuY2xhc3MgU3RhbmRhcmRFcnJvciAgICAgPCBFeGNlcHRpb247IGVuZFxuY2xhc3MgRW5jb2RpbmdFcnJvciAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgWmVyb0RpdmlzaW9uRXJyb3IgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTmFtZUVycm9yICAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgTm9NZXRob2RFcnJvciAgICAgICAgIDwgTmFtZUVycm9yOyBlbmRcbmNsYXNzIFJ1bnRpbWVFcnJvciAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZyb3plbkVycm9yICAgICAgICAgICA8IFJ1bnRpbWVFcnJvcjsgZW5kXG5jbGFzcyBMb2NhbEp1bXBFcnJvciAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBUeXBlRXJyb3IgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBBcmd1bWVudEVycm9yICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBVbmNhdWdodFRocm93RXJyb3IgICAgPCBBcmd1bWVudEVycm9yOyBlbmRcbmNsYXNzIEluZGV4RXJyb3IgICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIFN0b3BJdGVyYXRpb24gICAgICAgICA8IEluZGV4RXJyb3I7IGVuZFxuY2xhc3MgQ2xvc2VkUXVldWVFcnJvciAgICAgICAgPCBTdG9wSXRlcmF0aW9uOyBlbmRcbmNsYXNzIEtleUVycm9yICAgICAgICAgICAgICA8IEluZGV4RXJyb3I7IGVuZFxuY2xhc3MgUmFuZ2VFcnJvciAgICAgICAgICA8IFN0YW5kYXJkRXJyb3I7IGVuZFxuY2xhc3MgRmxvYXREb21haW5FcnJvciAgICAgIDwgUmFuZ2VFcnJvcjsgZW5kXG5jbGFzcyBJT0Vycm9yICAgICAgICAgICAgIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5jbGFzcyBFT0ZFcnJvciAgICAgICAgICAgICAgPCBJT0Vycm9yOyBlbmRcbmNsYXNzIFN5c3RlbUNhbGxFcnJvciAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIFJlZ2V4cEVycm9yICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIFRocmVhZEVycm9yICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcbmNsYXNzIEZpYmVyRXJyb3IgICAgICAgICAgPCBTdGFuZGFyZEVycm9yOyBlbmRcblxubW9kdWxlIEVycm5vXG4gIGNsYXNzIEVJTlZBTCAgICAgICAgICAgICAgPCBTeXN0ZW1DYWxsRXJyb3JcbiAgICBkZWYgc2VsZi5uZXcobmFtZSA9IG5pbClcbiAgICAgIG1lc3NhZ2UgPSAnSW52YWxpZCBhcmd1bWVudCdcbiAgICAgIG1lc3NhZ2UgKz0gXCIgLSAje25hbWV9XCIgaWYgbmFtZVxuICAgICAgc3VwZXIobWVzc2FnZSlcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxuY2xhc3MgVW5jYXVnaHRUaHJvd0Vycm9yIDwgQXJndW1lbnRFcnJvclxuICBhdHRyX3JlYWRlciA6dGFnLCA6dmFsdWVcblxuICBkZWYgaW5pdGlhbGl6ZSh0YWcsIHZhbHVlID0gbmlsKVxuICAgIEB0YWcgPSB0YWdcbiAgICBAdmFsdWUgPSB2YWx1ZVxuXG4gICAgc3VwZXIoXCJ1bmNhdWdodCB0aHJvdyAje0B0YWcuaW5zcGVjdH1cIilcbiAgZW5kXG5lbmRcblxuY2xhc3MgTmFtZUVycm9yXG4gIGF0dHJfcmVhZGVyIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUobWVzc2FnZSwgbmFtZSA9IG5pbClcbiAgICBzdXBlciBtZXNzYWdlXG4gICAgQG5hbWUgPSBuYW1lXG4gIGVuZFxuZW5kXG5cbmNsYXNzIE5vTWV0aG9kRXJyb3JcbiAgYXR0cl9yZWFkZXIgOmFyZ3NcblxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCBuYW1lID0gbmlsLCBhcmdzID0gW10pXG4gICAgc3VwZXIgbWVzc2FnZSwgbmFtZVxuICAgIEBhcmdzID0gYXJnc1xuICBlbmRcbmVuZFxuXG5jbGFzcyBTdG9wSXRlcmF0aW9uXG4gIGF0dHJfcmVhZGVyIDpyZXN1bHRcbmVuZFxuXG5jbGFzcyBLZXlFcnJvclxuICBkZWYgaW5pdGlhbGl6ZShtZXNzYWdlLCByZWNlaXZlcjogbmlsLCBrZXk6IG5pbClcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQGtleSA9IGtleVxuICBlbmRcblxuICBkZWYgcmVjZWl2ZXJcbiAgICBAcmVjZWl2ZXIgfHwgcmFpc2UoQXJndW1lbnRFcnJvciwgJ25vIHJlY2VpdmVyIGlzIGF2YWlsYWJsZScpXG4gIGVuZFxuXG4gIGRlZiBrZXlcbiAgICBAa2V5IHx8IHJhaXNlKEFyZ3VtZW50RXJyb3IsICdubyBrZXkgaXMgYXZhaWxhYmxlJylcbiAgZW5kXG5lbmRcblxubW9kdWxlIEpTXG4gIGNsYXNzIEVycm9yXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpFeGNlcHRpb24+IiwibmV3Iiwic2VsZiIsIiQhIiwiZXhjZXB0aW9uIiwiYXJncyIsImluaXRpYWxpemUiLCJiYWNrdHJhY2UiLCJiYWNrdHJhY2VfbG9jYXRpb25zIiwiYmxvY2sgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsImxvYyIsImJsb2NrICgyIGxldmVscykgaW4gYmFja3RyYWNlX2xvY2F0aW9ucyIsIlRocmVhZDo6QmFja3RyYWNlOjpMb2NhdGlvbiIsIlRocmVhZDo6QmFja3RyYWNlIiwiVGhyZWFkIiwiY2F1c2UiLCJzdHIiLCJjbG9uZSIsIm1lc3NhZ2UiLCJ0b19zIiwiZnVsbF9tZXNzYWdlIiwiJGt3YXJncyIsIiRzdGRlcnIiLCJ0dHk/IiwiaW5jbHVkZT8iLCJoaWdobGlnaHQiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJvcmRlciIsImJvbGRfdW5kZXJsaW5lIiwiYm9sZCIsInJlc2V0IiwiYnQiLCJkdXAiLCIkcmV0X29yXzEiLCIhIiwiZW1wdHk/IiwiY2FsbGVyIiwiZmlyc3QiLCJzaGlmdCIsIm1zZyIsIisiLCJjbGFzcyIsIm1hcCIsImJsb2NrIGluIGZ1bGxfbWVzc2FnZSIsImJsb2NrICgyIGxldmVscykgaW4gZnVsbF9tZXNzYWdlIiwiam9pbiIsIj09Iiwic3BsaXQiLCJyZXZlcnNlIiwiaW5zcGVjdCIsImFzX3N0ciIsInNldF9iYWNrdHJhY2UiLCJUeXBlRXJyb3IiLCJibG9jayBpbiBzZXRfYmFja3RyYWNlIiwiaSIsImJsb2NrICgyIGxldmVscykgaW4gc2V0X2JhY2t0cmFjZSIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIkBtZXNzYWdlIiwiPGNsYXNzOlNjcmlwdEVycm9yPiIsIkV4Y2VwdGlvbiIsIjxjbGFzczpTeW50YXhFcnJvcj4iLCJTY3JpcHRFcnJvciIsIjxjbGFzczpMb2FkRXJyb3I+IiwiPGNsYXNzOk5vdEltcGxlbWVudGVkRXJyb3I+IiwiPGNsYXNzOlN5c3RlbUV4aXQ+IiwiPGNsYXNzOk5vTWVtb3J5RXJyb3I+IiwiPGNsYXNzOlNpZ25hbEV4Y2VwdGlvbj4iLCI8Y2xhc3M6SW50ZXJydXB0PiIsIlNpZ25hbEV4Y2VwdGlvbiIsIjxjbGFzczpTZWN1cml0eUVycm9yPiIsIjxjbGFzczpTeXN0ZW1TdGFja0Vycm9yPiIsIjxjbGFzczpTdGFuZGFyZEVycm9yPiIsIjxjbGFzczpFbmNvZGluZ0Vycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6WmVyb0RpdmlzaW9uRXJyb3I+IiwiPGNsYXNzOk5hbWVFcnJvcj4iLCI8Y2xhc3M6Tm9NZXRob2RFcnJvcj4iLCJOYW1lRXJyb3IiLCI8Y2xhc3M6UnVudGltZUVycm9yPiIsIjxjbGFzczpGcm96ZW5FcnJvcj4iLCJSdW50aW1lRXJyb3IiLCI8Y2xhc3M6TG9jYWxKdW1wRXJyb3I+IiwiPGNsYXNzOlR5cGVFcnJvcj4iLCI8Y2xhc3M6QXJndW1lbnRFcnJvcj4iLCI8Y2xhc3M6VW5jYXVnaHRUaHJvd0Vycm9yPiIsIjxjbGFzczpJbmRleEVycm9yPiIsIjxjbGFzczpTdG9wSXRlcmF0aW9uPiIsIkluZGV4RXJyb3IiLCI8Y2xhc3M6Q2xvc2VkUXVldWVFcnJvcj4iLCJTdG9wSXRlcmF0aW9uIiwiPGNsYXNzOktleUVycm9yPiIsIjxjbGFzczpSYW5nZUVycm9yPiIsIjxjbGFzczpGbG9hdERvbWFpbkVycm9yPiIsIlJhbmdlRXJyb3IiLCI8Y2xhc3M6SU9FcnJvcj4iLCI8Y2xhc3M6RU9GRXJyb3I+IiwiSU9FcnJvciIsIjxjbGFzczpTeXN0ZW1DYWxsRXJyb3I+IiwiPGNsYXNzOlJlZ2V4cEVycm9yPiIsIjxjbGFzczpUaHJlYWRFcnJvcj4iLCI8Y2xhc3M6RmliZXJFcnJvcj4iLCI8bW9kdWxlOkVycm5vPiIsIjxjbGFzczpFSU5WQUw+IiwibmFtZSIsIlN5c3RlbUNhbGxFcnJvciIsImF0dHJfcmVhZGVyIiwidGFnIiwidmFsdWUiLCJAdGFnIiwiQHZhbHVlIiwiQG5hbWUiLCJAYXJncyIsIkByZWNlaXZlciIsInJlY2VpdmVyIiwiQGtleSIsImtleSIsIiRyZXRfb3JfNCIsIiRyZXRfb3JfNSIsIjxtb2R1bGU6SlM+IiwiPGNsYXNzOkVycm9yPiJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDR0E7SUFDQUE7SUFFREMsVUFBSUMsSUFBSkQsVUFBQUEsbUJBQUFBLFNBSkYsRUFJRUE7QUFBQUEsTUFBQUE7QUFBQUE7Ozs7TUFKRjs7TUFJZTs7QUFFZkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsc0JBQXdCRSxXQUFHRjtBQUMzQkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQW5CRUEsQ0FBQUEsK0JBQUFBO0lBcUJDRDtJQUVESSxVQUFJRixJQUFKRSxnQkFBQUEseUJBQUFBLHFCQTNCRixFQTJCRUE7QUFBQUEsTUFBQUE7Ozs7TUEzQkY7O01BMkJxQjtNQUNqQkEsT0FBQUgsTUFBQUMsSUFBQUQsT0FBQUEsRUFBSSxVQUFDSSxJQUFELENBQUpKO0lBREZHLENBQUFBLHFDQUFBQTs7QUFJQUUsSUFBQUEsOEJBQUFBLDBCQUFBQSxzQkEvQkYsRUErQkVBO0FBQUFBLE1BQUFBOzs7O01BL0JGOztNQStCaUI7TUFFYkEsT0FBQ0EsZ0RBQURBO0lBRkZBLENBQUFBLHNDQUFBQTs7QUFNRk47QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFRU8sSUFB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LFFBalNKRyxDQWlTSSxDQUFBO1FBalNKRixPQUFBO01BaVNJO1FBQVFBLE9BQUFuSCxJQUFBd0IsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUIwRixxQkFBckIzRjtNQUFSO0lBREYyRixDQUFBQSw4QkFBQUEsQ0FBQUE7RUFYRnpCLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBZ0JBN0YsT0FBQXlIO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUM7SUFBQUE7O01BQUFBOztNQUFBQSxPQUFBO0lBQUFBLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBREZELEdBQUFBLFdBQUFBO0FBclNBekg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYwODksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbnN0YW50cy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJSVUJZX1BMQVRGT1JNICAgICAgID0gJ29wYWwnXG5SVUJZX0VOR0lORSAgICAgICAgID0gJ29wYWwnXG5SVUJZX1ZFUlNJT04gICAgICAgID0gJzMuMC4yJ1xuUlVCWV9FTkdJTkVfVkVSU0lPTiA9ICcxLjMuMC5kZXYnXG5SVUJZX1JFTEVBU0VfREFURSAgID0gJzIwMjEtMDgtMTEnXG5SVUJZX1BBVENITEVWRUwgICAgID0gMFxuUlVCWV9SRVZJU0lPTiAgICAgICA9ICcwJ1xuUlVCWV9DT1BZUklHSFQgICAgICA9ICdvcGFsIC0gQ29weXJpZ2h0IChDKSAyMDEzLTIwMjEgQWRhbSBCZXlub24gYW5kIHRoZSBPcGFsIGNvbnRyaWJ1dG9ycydcblJVQllfREVTQ1JJUFRJT04gICAgPSBcIm9wYWwgI3tSVUJZX0VOR0lORV9WRVJTSU9OfSAoI3tSVUJZX1JFTEVBU0VfREFURX0gcmV2aXNpb24gI3tSVUJZX1JFVklTSU9OfSlcIlxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIwIiwiUlVCWV9FTkdJTkVfVkVSU0lPTiIsIlJVQllfUkVMRUFTRV9EQVRFIiwiUlVCWV9SRVZJU0lPTiJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOzs7RUFBQSw2Q0FBc0JBLE1BQXRCO0VBQ0EsMkNBQXNCQSxNQUF0QjtFQUNBLDRDQUFzQkEsT0FBdEI7RUFDQSxtREFBc0JBLFdBQXRCO0VBQ0EsaURBQXNCQSxZQUF0QjtFQUNBLCtDQUFzQkMsQ0FBdEI7RUFDQSw2Q0FBc0JELEdBQXRCO0VBQ0EsOENBQXNCQSxzRUFBdEI7RUFDQUEsT0FBQSxnREFBc0IsRUFBQSxHQUFBLE9BQUEsR0FBQSxDQUFRRSxtQ0FBUixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQWdDQyxpQ0FBaEMsQ0FBQSxHQUFBLFlBQUEsR0FBQSxDQUE4REMsNkJBQTlELENBQUEsR0FBQSxHQUF0QjtBQVJBSjsifX0seyJvZmZzZXQiOnsibGluZSI6NjEwNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvYmFzZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL3J1bnRpbWUnXG5yZXF1aXJlICdjb3JlbGliL2hlbHBlcnMnXG5yZXF1aXJlICdjb3JlbGliL21vZHVsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvY2xhc3MnXG5yZXF1aXJlICdjb3JlbGliL2Jhc2ljX29iamVjdCdcbnJlcXVpcmUgJ2NvcmVsaWIva2VybmVsJ1xucmVxdWlyZSAnY29yZWxpYi9lcnJvcidcblxucmVxdWlyZSAnY29yZWxpYi9jb25zdGFudHMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixzQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBRUFGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtBQVJBRjsifX0seyJvZmZzZXQiOnsibGluZSI6NjEyMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbmlsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5pbENsYXNzXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkbWV0YSA9ICN7c2VsZn1gXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuICBlbmRcblxuICBkZWYgIVxuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHwob3RoZXIpXG4gICAgYG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsYFxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICBgb3RoZXIgIT09IGZhbHNlICYmIG90aGVyICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgb3RoZXIgPT09IG5pbGBcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICduaWwnXG4gIGVuZFxuXG4gIGRlZiBuaWw/XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgTmlsQ2xhc3NcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbXVxuICBlbmRcblxuICBkZWYgdG9faFxuICAgIGBPcGFsLmhhc2goKWBcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICAwXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2YgdG9faVxuXG4gIGRlZiB0b19zXG4gICAgJydcbiAgZW5kXG5cbiAgZGVmIHRvX2NcbiAgICBDb21wbGV4Lm5ldygwLCAwKVxuICBlbmRcblxuICBkZWYgcmF0aW9uYWxpemUoKmFyZ3MpXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciBpZiBhcmdzLmxlbmd0aCA+IDFcbiAgICBSYXRpb25hbCgwLCAxKVxuICBlbmRcblxuICBkZWYgdG9fclxuICAgIFJhdGlvbmFsKDAsIDEpXG4gIGVuZFxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcbmVuZFxuXG5OSUwgPSBuaWxcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOk5pbENsYXNzPiIsInNlbGYiLCJhbGxvY2F0ZSIsInJhaXNlIiwiVHlwZUVycm9yIiwibmFtZSIsIiEiLCImIiwib3RoZXIiLCJ8IiwiXiIsIj09IiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwiaW5zcGVjdCIsIm5pbD8iLCJzaW5nbGV0b25fY2xhc3MiLCJOaWxDbGFzcyIsInRvX2EiLCJ0b19oIiwidG9faSIsIjAiLCJ0b19zIiwidG9fYyIsIkNvbXBsZXgiLCJuZXciLCJyYXRpb25hbGl6ZSIsIj4iLCJhcmdzIiwibGVuZ3RoIiwiMSIsIkFyZ3VtZW50RXJyb3IiLCJSYXRpb25hbCIsInRvX3IiLCJpbnN0YW5jZV92YXJpYWJsZXMiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0dBLDBCQUE0QkM7SUFFN0I7TUFBQTs7OztBQUNFQyxNQUFBQSw0QkFBQUEsY0FBQUEsb0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBRCxJQUFBRSxPQUFBQSxDQUFNQyx5QkFBTixFQUFpQixFQUFBLEdBQUEsMEJBQUEsR0FB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SUFsQyxPQUFBbUMsQ0FBQUEsc0NBQUFBLGtDQUFBQSw4QkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUE7SUFERkEsQ0FBQUEsNkNBQUFBLENBQUFBO0VBbEZGbkMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUF1RkFELE9BQUEsbUNBQU0sR0FBTjtBQXZGQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjYyODMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2Jvb2xlYW4ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQm9vbGVhbiA8IGBCb29sZWFuYFxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19ib29sZWFuJywgdHJ1ZSlgXG5cbiAgJXh7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBbJyQkY2xhc3MnLCAnJCRtZXRhJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCBwcm9wZXJ0aWVzW2ldLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMgPT0gdHJ1ZSAgPyBPcGFsLlRydWVDbGFzcyA6XG4gICAgICAgICAgICAgICAgIHRoaXMgPT0gZmFsc2UgPyBPcGFsLkZhbHNlQ2xhc3MgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BhbC5Cb29sZWFuO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgXCIkJGlkXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gdHJ1ZSAgPyAyIDpcbiAgICAgICAgICAgICAgIHRoaXMgPT0gZmFsc2UgPyAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuaWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG4gIGVuZFxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi52YWx1ZU9mKCkgPyAyIDogMGBcbiAgZW5kXG5cbiAgYWxpYXMgb2JqZWN0X2lkIF9faWRfX1xuXG4gIGRlZiAhXG4gICAgYHNlbGYgIT0gdHJ1ZWBcbiAgZW5kXG5cbiAgZGVmICYob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKSA6IGZhbHNlYFxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPyB0cnVlIDogKG90aGVyICE9PSBmYWxzZSAmJiBvdGhlciAhPT0gbmlsKWBcbiAgZW5kXG5cbiAgZGVmIF4ob3RoZXIpXG4gICAgYChzZWxmID09IHRydWUpID8gKG90aGVyID09PSBmYWxzZSB8fCBvdGhlciA9PT0gbmlsKSA6IChvdGhlciAhPT0gZmFsc2UgJiYgb3RoZXIgIT09IG5pbClgXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICBgKHNlbGYgPT0gdHJ1ZSkgPT09IG90aGVyLnZhbHVlT2YoKWBcbiAgZW5kXG5cbiAgYWxpYXMgZXF1YWw/ID09XG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgc2luZ2xldG9uX2NsYXNzXG4gICAgYHNlbGYuJCRtZXRhYFxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIGAoc2VsZiA9PSB0cnVlKSA/ICd0cnVlJyA6ICdmYWxzZSdgXG4gIGVuZFxuXG4gIGFsaWFzIGluc3BlY3QgdG9fc1xuXG4gIGRlZiBkdXBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjbG9uZShmcmVlemU6IHRydWUpXG4gICAgc2VsZlxuICBlbmRcblxuICAjIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9pc3N1ZXMvMjIzMFxuICAjXG4gICMgVGhpcyBpcyBhIGhhY2sgdGhhdCBhbGxvd3MgeW91IHRvIGFkZCBtZXRob2RzIHRvIFRydWVDbGFzcyBhbmQgRmFsc2VDbGFzcy5cbiAgIyBEbyBub3RlLCB0aGF0IHdoaWxlIHRydWUgYW5kIGZhbHNlIGhhdmUgYSBjb3JyZWN0ICQkY2xhc3MgKGl0J3MgZWl0aGVyXG4gICMgVHJ1ZUNsYXNzIG9yIEZhbHNlQ2xhc3MpLCB0aGVpciBwcm90b3R5cGUgaXMgYEJvb2xlYW4uJCRwcm90b3R5cGVgLCB3aGljaFxuICAjIGJhc2ljYWxseSBtZWFucyB0aGF0IHdoZW4gY2FsbGluZyBgdHJ1ZS5zb21ldGhpbmdgIHdlIGFjdHVhbGx5IGNhbGxcbiAgIyBgQm9vbGVhbiNzb21ldGhpbmdgIGluc3RlYWQgb2YgYFRydWVDbGFzcyNzb21ldGhpbmdgLiBTbyB1c2luZ1xuICAjIG1ldGhvZF9taXNzaW5nIHdlIGRpc3BhdGNoIGl0IHRvIGBUcnVlQ2xhc3MvRmFsc2VDbGFzcyNzb21ldGhpbmdgIGNvcnJlY3RseS5cbiAgI1xuICAjIFRoZSBkb3duc2lkZSBpcyB0aGF0IGEgY29ycmVjdCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBhbHNvIGFsbG93IHVzIHRvIG92ZXJyaWRlXG4gICMgdGhlIG1ldGhvZHMgZGVmaW5lZCBvbiBCb29sZWFuLCBidXQgb3VyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgYWxsb3cgdGhhdCxcbiAgIyB1bmxlc3MgeW91IGRlZmluZSB0aGVtIG9uIEJvb2xlYW4gYW5kIG5vdCBvbiBUcnVlQ2xhc3MvRmFsc2VDbGFzcy5cbiAgZGVmIG1ldGhvZF9taXNzaW5nKG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgICBgdmFyIGJvZHkgPSBzZWxmLiQkY2xhc3MuJCRwcm90b3R5cGVbJyQnICsgI3ttZXRob2R9XWBcbiAgICBzdXBlciB1bmxlc3MgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gICAgYE9wYWwuc2VuZChzZWxmLCBib2R5LCAje2FyZ3N9LCAje2Jsb2NrfSlgXG4gIGVuZFxuXG4gIGRlZiByZXNwb25kX3RvX21pc3Npbmc/KG1ldGhvZCwgX2luY2x1ZGVfYWxsID0gZmFsc2UpXG4gICAgYHZhciBib2R5ID0gc2VsZi4kJGNsYXNzLiQkcHJvdG90eXBlWyckJyArICN7bWV0aG9kfV1gXG4gICAgYHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyAmJiAhYm9keS4kJHN0dWJgXG4gIGVuZFxuZW5kXG5cbmNsYXNzIFRydWVDbGFzcyA8IEJvb2xlYW47IGVuZFxuY2xhc3MgRmFsc2VDbGFzcyA8IEJvb2xlYW47IGVuZFxuXG5UUlVFICA9IHRydWVcbkZBTFNFID0gZmFsc2VcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOkJvb2xlYW4+IiwiYWxsb2NhdGUiLCJzZWxmIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuYW1lIiwiX19pZF9fIiwiISIsIiYiLCJvdGhlciIsInwiLCJeIiwiPT0iLCJzaW5nbGV0b25fY2xhc3MiLCJ0b19zIiwiZHVwIiwiY2xvbmUiLCIka3dhcmdzIiwibWV0aG9kX21pc3NpbmciLCJtZXRob2QiLCJhcmdzIiwiYmxvY2siLCJyZXNwb25kX3RvX21pc3Npbmc/IiwiX2luY2x1ZGVfYWxsIiwiPGNsYXNzOlRydWVDbGFzcz4iLCJCb29sZWFuIiwiPGNsYXNzOkZhbHNlQ2xhc3M+Il0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQztFQUFBQTs7SUFBQUE7OztJQUNHQTs7QUFHSEE7O0FBRUFBO0FBQ0FB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QUEsa0RBQUFBLENBQUFBO0VBdEdGdEIsR0FBQUEsV0FBQUEsRUFBaUJELE9BQWpCQztFQTRHQXdCO0VBQUFBOztJQUFBQTs7SUFBQUEsT0FBQTtFQUFBQSxHQUFBQSxXQUFBQSxFQUFrQkMsdUJBQWxCRDtFQUNBRTtFQUFBQTs7SUFBQUE7O0lBQUFBLE9BQUE7RUFBQUEsR0FBQUEsV0FBQUEsRUFBbUJELHVCQUFuQkM7RUFFQSxvQ0FBUSxJQUFSO0VBQ0EzQixPQUFBLHFDQUFRLEtBQVI7QUFoSEFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjo2NDY1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9jb21wYXJhYmxlLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogZmFsc3lcblxubW9kdWxlIENvbXBhcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHdoYXQpIHtcbiAgICAgIGlmIChPcGFsLmlzX2Eod2hhdCwgT3BhbC5JbnRlZ2VyKSkgeyByZXR1cm4gd2hhdDsgfVxuXG4gICAgICBpZiAoI3tgd2hhdGAgPiAwfSkgeyByZXR1cm4gMTsgfVxuICAgICAgaWYgKCN7YHdoYXRgIDwgMH0pIHsgcmV0dXJuIC0xOyB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmYWlsX2NvbXBhcmlzb24obGhzLCByaHMpIHtcbiAgICAgIHZhciBjbGFzc19uYW1lO1xuICAgICAgI3tcbiAgICAgICAgY2FzZSBgcmhzYFxuICAgICAgICB3aGVuIG5pbCwgdHJ1ZSwgZmFsc2UsIEludGVnZXIsIEZsb2F0XG4gICAgICAgICAgYGNsYXNzX25hbWUgPSByaHMuJGluc3BlY3QoKWBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGBjbGFzc19uYW1lID0gcmhzLiQkY2xhc3NgXG4gICAgICAgIGVuZFxuICAgICAgfVxuICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImNvbXBhcmlzb24gb2YgI3tgbGhzYC5jbGFzc30gd2l0aCAje2BjbGFzc19uYW1lYH0gZmFpbGVkXCJ9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY21wX29yX2ZhaWwobGhzLCByaHMpIHtcbiAgICAgIHZhciBjbXAgPSAje2BsaHNgIDw9PiBgcmhzYH07XG4gICAgICBpZiAoJGZhbHN5KGNtcCkpIGZhaWxfY29tcGFyaXNvbihsaHMsIHJocyk7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKGNtcCk7XG4gICAgfVxuICB9XG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiB0cnVlIGlmIGVxdWFsPyhvdGhlcilcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGZbXCIkPD0+XCJdID09IE9wYWwuS2VybmVsW1wiJDw9PlwiXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgIGlmIChzZWxmLiQkY29tcGFyYWJsZSkge1xuICAgICAgICBkZWxldGUgc2VsZi4kJGNvbXBhcmFibGU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIGNtcCA9IChzZWxmIDw9PiBvdGhlcilcblxuICAgIGBub3JtYWxpemUoY21wKSA9PSAwYFxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpID4gMGBcbiAgZW5kXG5cbiAgZGVmID49KG90aGVyKVxuICAgIGBjbXBfb3JfZmFpbChzZWxmLCBvdGhlcikgPj0gMGBcbiAgZW5kXG5cbiAgZGVmIDwob3RoZXIpXG4gICAgYGNtcF9vcl9mYWlsKHNlbGYsIG90aGVyKSA8IDBgXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBgY21wX29yX2ZhaWwoc2VsZiwgb3RoZXIpIDw9IDBgXG4gIGVuZFxuXG4gIGRlZiBiZXR3ZWVuPyhtaW4sIG1heClcbiAgICByZXR1cm4gZmFsc2UgaWYgc2VsZiA8IG1pblxuICAgIHJldHVybiBmYWxzZSBpZiBzZWxmID4gbWF4XG4gICAgdHJ1ZVxuICBlbmRcblxuICBkZWYgY2xhbXAobWluLCBtYXggPSBuaWwpXG4gICAgJXh7XG4gICAgICB2YXIgYywgZXhjbDtcblxuICAgICAgaWYgKG1heCA9PT0gbmlsKSB7XG4gICAgICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYSBuZXcgUnVieSAyLjcgYmVoYXZpb3VyIHRoYXQgd2UgYXJlIGFibGUgdG9cbiAgICAgICAgLy8gcHJvdmlkZSBhIHNpbmdsZSBSYW5nZSBhcmd1bWVudCBpbnN0ZWFkIG9mIDIgQ29tcGFyYWJsZXMuXG5cbiAgICAgICAgaWYgKCFPcGFsLmlzX2EobWluLCBPcGFsLlJhbmdlKSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3ttaW4uY2xhc3N9IChleHBlY3RlZCBSYW5nZSlcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4Y2wgPSBtaW4uZXhjbDtcbiAgICAgICAgbWF4ID0gbWluLmVuZDtcbiAgICAgICAgbWluID0gbWluLmJlZ2luO1xuXG4gICAgICAgIGlmIChtYXggIT09IG5pbCAmJiBleGNsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY2Fubm90IGNsYW1wIHdpdGggYW4gZXhjbHVzaXZlIHJhbmdlJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWluICE9PSBuaWwgJiYgbWF4ICE9PSBuaWwgJiYgY21wX29yX2ZhaWwobWluLCBtYXgpID4gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtaW4gYXJndW1lbnQgbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiAhPT0gbmlsKSB7XG4gICAgICAgIGMgPSBjbXBfb3JfZmFpbChzZWxmLCBtaW4pO1xuXG4gICAgICAgIGlmIChjID09IDApIHJldHVybiBzZWxmO1xuICAgICAgICBpZiAoYyA8IDApIHJldHVybiBtaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggIT09IG5pbCkge1xuICAgICAgICBjID0gY21wX29yX2ZhaWwoc2VsZiwgbWF4KTtcblxuICAgICAgICBpZiAoYyA+IDApIHJldHVybiBtYXg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpDb21wYXJhYmxlPiIsIj4iLCIwIiwiPCIsIj09PSIsIkludGVnZXIiLCJGbG9hdCIsInNlbGYiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjbGFzcyIsIjw9PiIsIj09Iiwib3RoZXIiLCJlcXVhbD8iLCJjbXAiLCI+PSIsIjw9IiwiYmV0d2Vlbj8iLCJtaW4iLCJtYXgiLCJjbGFtcCIsIlR5cGVFcnJvciJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7Ozs7QUFFQUE7QUFDQUE7O0FBRUFBLFVBQW1CQyxPQUFORCxJQUFNQyxFQUFFQyxDQUFGRCxDQUFJRDtBQUN2QkEsVUFBbUJHLE9BQU5ILElBQU1HLEVBQUVELENBQUZDLENBQUlIO0FBQ3ZCQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsTUFDUSxhQUFBLFFBQU1BLEdBQU47SUFDQSxJQUFLLEdBQUxJLFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxJQUFVLElBQVZBLFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxJQUFnQixLQUFoQkEsUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLElBQXVCQyx1QkFBdkJELFFBQUFBLENBQUEsS0FBQUEsQ0FBQSxJQUFnQ0UscUJBQWhDRixRQUFBQSxDQUFBLEtBQUFBLENBQUEsR0FDRUosT0FBQ0EsMkJBQURBLENBREY7SUFEQSxNQUlFQSxPQUFDQSx3QkFBREEsQ0FKRixDQUFBO0FBT1JBLE1BQVFPLElBQUFDLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCVCxDQUFDQSxHQUFEQSxDQUFLVSxPQUFBQSxDQUFBQSxDQUF0QixDQUFBLEdBQUEsUUFBQSxHQUFBLENBQXNDVixVQUF0QyxDQUFBLEdBQUEsU0FBckJRO0FBQ1JSOztBQUVBQTtBQUNBQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQU1XLFFBQUFBLENBQUtYLEdBQUxXLENBQVVYO0FBQ2xDQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFRVksSUFBQUEsc0JBQUFBLHVCQUFBQSxTQUFPQyxLQUFQRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFlTCxJQUFBTyxXQUFBQSxDQUFPRCxLQUFQQyxDQUFmLENBQUE7UUFBQSxPQUFPLElBQVA7O0FBR0pGO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJLElBQUEsUUFBb0JHLENBQUFBLE1BQU9SLElBQUtJLFFBQUFBLENBQUlFLEtBQUpGLENBQVpJLENBQXBCLENBQUE7TUFBQTtRQUFBLE9BQU87TUFBUDtNQUVBSCxPQUFDQSxtQkFBREE7SUFqQkZBLENBQUFBLGtDQUFBQTs7QUFvQkFYLElBQUFBLHFCQUFBQSxvQkFBQUEsU0FBTVksS0FBTlo7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDRCQUFEQTtJQURGQSxDQUFBQSwrQkFBQUE7O0FBSUFlLElBQUFBLHNCQUFBQSx1QkFBQUEsU0FBT0gsS0FBUEc7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDZCQUFEQTtJQURGQSxDQUFBQSxrQ0FBQUE7O0FBSUFiLElBQUFBLHFCQUFBQSxvQkFBQUEsU0FBTVUsS0FBTlY7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDRCQUFEQTtJQURGQSxDQUFBQSwrQkFBQUE7O0FBSUFjLElBQUFBLHNCQUFBQSx1QkFBQUEsU0FBT0osS0FBUEk7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLDZCQUFEQTtJQURGQSxDQUFBQSxrQ0FBQUE7O0FBSUFDLElBQUFBLDRCQUFBQSw2QkFBQUEsU0FBYUMsR0FBRCxFQUFNQyxHQUFsQkY7QUFBQUEsTUFBQUE7OztNQUNFLElBQXFCZixPQUFMSSxJQUFLSixFQUFFZ0IsR0FBRmhCLENBQXJCO1FBQUEsT0FBTyxLQUFQO01BQ0EsSUFBcUJGLE9BQUxNLElBQUtOLEVBQUVtQixHQUFGbkIsQ0FBckI7UUFBQSxPQUFPLEtBQVA7TUFDQWlCLE9BQUE7SUFIRkEsQ0FBQUEsd0NBQUFBO0lBTUFsQixPQUFBcUIsQ0FBQUEseUJBQUFBLHNCQUFBQSxpQkFBVUYsR0FBRCxFQUFNQyxHQUFmQztBQUFBQSxNQUFBQTs7OztNQUFlO01BQUEsUUFBTSxHQUFOO01BQUE7O0FBRWpCQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlkLElBQUFDLE9BQUFBLENBQU1jLHlCQUFOLEVBQWlCLEVBQUEsR0FBQSxzQkFBQSxHQUFBLENBQXVCSCxHQUFHVCxPQUFBQSxDQUFBQSxDQUExQixDQUFBLEdBQUEsbUJBQWpCRjtBQUNaYTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVlkLElBQUFDLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCWSxzQ0FBckJiO0FBQ1phO0FBQ0FBOztBQUVBQTtBQUNBQSxRQUFVZCxJQUFBQyxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQlksZ0RBQXJCYjtBQUNWYTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBdkNFQSxDQUFBQSxrQ0FBQUEsQ0FBQUE7RUF4RUZyQixHQUFBQSxXQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6NjYxNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmVnZXhwLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvXG5cbmNsYXNzIFJlZ2V4cEVycm9yIDwgU3RhbmRhcmRFcnJvcjsgZW5kXG5cbmNsYXNzIFJlZ2V4cCA8IGBSZWdFeHBgXG4gIElHTk9SRUNBU0UgPSAxXG4gIEVYVEVOREVEID0gMlxuICBNVUxUSUxJTkUgPSA0XG5cbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfcmVnZXhwJywgdHJ1ZSlgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgYWxsb2NhdGVkID0gc3VwZXJcbiAgICAgIGAje2FsbG9jYXRlZH0udW5pbml0aWFsaXplZCA9IHRydWVgXG4gICAgICBhbGxvY2F0ZWRcbiAgICBlbmRcblxuICAgIGRlZiBlc2NhcGUoc3RyaW5nKVxuICAgICAgYE9wYWwuZXNjYXBlX3JlZ2V4cChzdHJpbmcpYFxuICAgIGVuZFxuXG4gICAgZGVmIGxhc3RfbWF0Y2gobiA9IG5pbClcbiAgICAgIGlmIG4ubmlsP1xuICAgICAgICAkflxuICAgICAgZWxzZVxuICAgICAgICAkfltuXVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBxdW90ZSBlc2NhcGVcblxuICAgIGRlZiB1bmlvbigqcGFydHMpXG4gICAgICAleHtcbiAgICAgICAgdmFyIGlzX2ZpcnN0X3BhcnRfYXJyYXksIHF1b3RlZF92YWxpZGF0ZWQsIHBhcnQsIG9wdGlvbnMsIGVhY2hfcGFydF9vcHRpb25zO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICByZXR1cm4gLyg/ISkvO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJldHVybiBmYXN0IGlmIHRoZXJlJ3Mgb25seSBvbmUgZWxlbWVudFxuICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDEgJiYgcGFydHNbMF0uJCRpc19yZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY292ZXIgdGhlIDIgYXJyYXlzIHBhc3NlZCBhcyBhcmd1bWVudHMgY2FzZVxuICAgICAgICBpc19maXJzdF9wYXJ0X2FycmF5ID0gcGFydHNbMF0uJCRpc19hcnJheTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEgJiYgaXNfZmlyc3RfcGFydF9hcnJheSkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnbm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiBBcnJheSBpbnRvIFN0cmluZyd9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVhbCB3aXRoIHNwbGF0IGlzc3VlcyAocmVsYXRlZCB0byBodHRwczovL2dpdGh1Yi5jb20vb3BhbC9vcGFsL2lzc3Vlcy84NTgpXG4gICAgICAgIGlmIChpc19maXJzdF9wYXJ0X2FycmF5KSB7XG4gICAgICAgICAgcGFydHMgPSBwYXJ0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICBxdW90ZWRfdmFsaWRhdGVkID0gW107XG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgIGlmIChwYXJ0LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goI3tlc2NhcGUoYHBhcnRgKX0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChwYXJ0LiQkaXNfcmVnZXhwKSB7XG4gICAgICAgICAgICBlYWNoX3BhcnRfb3B0aW9ucyA9ICN7YHBhcnRgLm9wdGlvbnN9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT0gdW5kZWZpbmVkICYmIG9wdGlvbnMgIT0gZWFjaF9wYXJ0X29wdGlvbnMpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdBbGwgZXhwcmVzc2lvbnMgbXVzdCB1c2UgdGhlIHNhbWUgb3B0aW9ucyd9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gZWFjaF9wYXJ0X29wdGlvbnM7XG4gICAgICAgICAgICBxdW90ZWRfdmFsaWRhdGVkLnB1c2goJygnK3BhcnQuc291cmNlKycpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVvdGVkX3ZhbGlkYXRlZC5wdXNoKCN7ZXNjYXBlKGBwYXJ0YC50b19zdHIpfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAjIFRha2UgYWR2YW50YWdlIG9mIGxvZ2ljIHRoYXQgY2FuIHBhcnNlIG9wdGlvbnMgZnJvbSBKUyBSZWdleFxuICAgICAgbmV3KGBxdW90ZWRfdmFsaWRhdGVkYC5qb2luKCd8JyksIGBvcHRpb25zYClcbiAgICBlbmRcblxuICAgIGRlZiBuZXcocmVnZXhwLCBvcHRpb25zID0gdW5kZWZpbmVkKVxuICAgICAgJXh7XG4gICAgICAgIGlmIChyZWdleHAuJCRpc19yZWdleHApIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnZXhwID0gI3tPcGFsLmNvZXJjZV90byEocmVnZXhwLCBTdHJpbmcsIDp0b19zdHIpfTtcblxuICAgICAgICBpZiAocmVnZXhwLmNoYXJBdChyZWdleHAubGVuZ3RoIC0gMSkgPT09ICdcXFxcJyAmJiByZWdleHAuY2hhckF0KHJlZ2V4cC5sZW5ndGggLSAyKSAhPT0gJ1xcXFwnKSB7XG4gICAgICAgICAgI3tyYWlzZSBSZWdleHBFcnJvciwgXCJ0b28gc2hvcnQgZXNjYXBlIHNlcXVlbmNlOiAvI3tyZWdleHB9L1wifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCAjeyFvcHRpb25zfSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy4kJGlzX251bWJlcikge1xuICAgICAgICAgIHZhciB0ZW1wID0gJyc7XG4gICAgICAgICAgaWYgKCN7SUdOT1JFQ0FTRX0gJiBvcHRpb25zKSB7IHRlbXAgKz0gJ2knOyB9XG4gICAgICAgICAgaWYgKCN7TVVMVElMSU5FfSAgJiBvcHRpb25zKSB7IHRlbXAgKz0gJ20nOyB9XG4gICAgICAgICAgb3B0aW9ucyA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucyA9ICdpJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4cCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBhbGlhcyBjb21waWxlIG5ld1xuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgYG90aGVyIGluc3RhbmNlb2YgUmVnRXhwICYmIHNlbGYudG9TdHJpbmcoKSA9PT0gb3RoZXIudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgZGVmID09PShzdHJpbmcpXG4gICAgYCN7bWF0Y2goT3BhbC5jb2VyY2VfdG8/KHN0cmluZywgU3RyaW5nLCA6dG9fc3RyKSl9ICE9PSBuaWxgXG4gIGVuZFxuXG4gIGRlZiA9fihzdHJpbmcpXG4gICAgbWF0Y2goc3RyaW5nKSAmJiAkfi5iZWdpbigwKVxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGluc3BlY3RcbiAgICAjIFVzZSBhIHJlZ2V4cCB0byBleHRyYWN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24gYW5kIHRoZSBvcHRpb25hbCBtb2RlIG1vZGlmaWVycyBmcm9tIHRoZSBzdHJpbmcuXG4gICAgIyBJbiB0aGUgcmVndWxhciBleHByZXNzaW9uLCBlc2NhcGUgYW55IGZyb250IHNsYXNoIChub3QgYWxyZWFkeSBlc2NhcGVkKSB3aXRoIGEgYmFja3NsYXNoLlxuICAgICV4e1xuICAgICAgdmFyIHJlZ2V4cF9mb3JtYXQgPSAvXlxcLyguKilcXC8oW15cXC9dKikkLztcbiAgICAgIHZhciB2YWx1ZSA9IHNlbGYudG9TdHJpbmcoKTtcbiAgICAgIHZhciBtYXRjaGVzID0gcmVnZXhwX2Zvcm1hdC5leGVjKHZhbHVlKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHZhciByZWdleHBfcGF0dGVybiA9IG1hdGNoZXNbMV07XG4gICAgICAgIHZhciByZWdleHBfZmxhZ3MgPSBtYXRjaGVzWzJdO1xuICAgICAgICB2YXIgY2hhcnMgPSByZWdleHBfcGF0dGVybi5zcGxpdCgnJyk7XG4gICAgICAgIHZhciBjaGFyc19sZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gICAgICAgIHZhciBjaGFyX2VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyc19sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjdXJyZW50X2NoYXIgPSBjaGFyc1tpXTtcbiAgICAgICAgICBpZiAoIWNoYXJfZXNjYXBlZCAmJiBjdXJyZW50X2NoYXIgPT0gJy8nKSB7XG4gICAgICAgICAgICByZWdleHBfcGF0dGVybl9lc2NhcGVkID0gcmVnZXhwX3BhdHRlcm5fZXNjYXBlZC5jb25jYXQoJ1xcXFwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnZXhwX3BhdHRlcm5fZXNjYXBlZCA9IHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQuY29uY2F0KGN1cnJlbnRfY2hhcik7XG4gICAgICAgICAgaWYgKGN1cnJlbnRfY2hhciA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGlmIChjaGFyX2VzY2FwZWQpIHtcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3Qgb3ZlciBlc2NhcGVcbiAgICAgICAgICAgICAgY2hhcl9lc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGFyX2VzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFyX2VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcvJyArIHJlZ2V4cF9wYXR0ZXJuX2VzY2FwZWQgKyAnLycgKyByZWdleHBfZmxhZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWF0Y2goc3RyaW5nLCBwb3MgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoc3RyaW5nID09PSBuaWwpIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgICAgdmFyIG0gPSBzZWxmLmV4ZWMoJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpKTtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgc2VsZmAsIGBtYCl9O1xuICAgICAgICAgIHJldHVybiBibG9jayA9PT0gbmlsID8gI3skfn0gOiAje3lpZWxkICR+fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcG9zID0gJGNvZXJjZV90byhwb3MsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKHN0cmluZyA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiAjeyR+ID0gbmlsfTtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gJGNvZXJjZV90byhzdHJpbmcsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2xvYmFsIFJlZ0V4cCBtYWludGFpbnMgc3RhdGUsIHNvIG5vdCB1c2luZyBzZWxmL3RoaXNcbiAgICAgIHZhciBtZCwgcmUgPSBPcGFsLmdsb2JhbF9yZWdleHAoc2VsZik7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIG1kID0gcmUuZXhlYyhzdHJpbmcpO1xuICAgICAgICBpZiAobWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gI3skfiA9IG5pbH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1kLmluZGV4ID49IHBvcykge1xuICAgICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGByZWAsIGBtZGApfTtcbiAgICAgICAgICByZXR1cm4gYmxvY2sgPT09IG5pbCA/ICN7JH59IDogI3t5aWVsZCAkfn07XG4gICAgICAgIH1cbiAgICAgICAgcmUubGFzdEluZGV4ID0gbWQuaW5kZXggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoPyhzdHJpbmcsIHBvcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLnVuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICd1bmluaXRpYWxpemVkIFJlZ2V4cCd9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nID09PSBuaWwgPyBmYWxzZSA6IHNlbGYudGVzdCgkY29lcmNlX3RvKHN0cmluZywgI3tTdHJpbmd9LCAndG9fc3RyJykpO1xuICAgICAgfVxuXG4gICAgICBwb3MgPSAkY29lcmNlX3RvKHBvcywgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoc3RyaW5nID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBzdHJpbmcgPSAkY29lcmNlX3RvKHN0cmluZywgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG5cbiAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyArPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbG9iYWwgUmVnRXhwIG1haW50YWlucyBzdGF0ZSwgc28gbm90IHVzaW5nIHNlbGYvdGhpc1xuICAgICAgdmFyIG1kLCByZSA9IE9wYWwuZ2xvYmFsX3JlZ2V4cChzZWxmKTtcblxuICAgICAgbWQgPSByZS5leGVjKHN0cmluZyk7XG4gICAgICBpZiAobWQgPT09IG51bGwgfHwgbWQuaW5kZXggPCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgbmFtZXNcbiAgICBzb3VyY2Uuc2NhbigvXFwoPzwoXFx3Kyk+LykubWFwKCY6Zmlyc3QpLnVuaXFcbiAgZW5kXG5cbiAgZGVmIG5hbWVkX2NhcHR1cmVzXG4gICAgc291cmNlLnNjYW4oL1xcKD88KFxcdyspPi8pICAgICAgICAjIFNjYW4gZm9yIGNhcHR1cmUgZ3JvdXBzXG4gICAgICAgICAgLm1hcCgmOmZpcnN0KSAgICAgICAgICAgICAgIyBHZXQgdGhlIGZpcnN0IHJlZ2V4cCBtYXRjaCAoXFx3KylcbiAgICAgICAgICAuZWFjaF93aXRoX2luZGV4ICAgICAgICAgICAjIEFkZCBpbmRleCB0byBhbiBpdGVyYXRvclxuICAgICAgICAgIC5ncm91cF9ieSgmOmZpcnN0KSAgICAgICAgICMgR3JvdXAgYnkgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXNcbiAgICAgICAgICAudHJhbnNmb3JtX3ZhbHVlcyBkbyB8aXwgICAjIENvbnZlcnQgaGFzaCB2YWx1ZXNcbiAgICAgICAgICAgIGkubWFwIHsgfGp8IGoubGFzdCArIDEgfSAjIERyb3AgdGhlIGNhcHR1cmUgZ3JvdXAgbmFtZXM7IGluY3JlYXNlIGluZGV4ZXMgYnkgMVxuICAgICAgICAgIGVuZFxuICBlbmRcblxuICBkZWYgflxuICAgIHNlbGYgPX4gJF9cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZVxuICAgIGBzZWxmLnNvdXJjZWBcbiAgZW5kXG5cbiAgZGVmIG9wdGlvbnNcbiAgICAjIEZsYWdzIHdvdWxkIGJlIG5pY2UgdG8gdXNlIHdpdGggdGhpcywgYnV0IHN0aWxsIGV4cGVyaW1lbnRhbCAtIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cC9mbGFnc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYudW5pbml0aWFsaXplZCkge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3VuaW5pdGlhbGl6ZWQgUmVnZXhwJ31cbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAwO1xuICAgICAgLy8gc2hvdWxkIGJlIHN1cHBvcnRlZCBpbiBJRTYgYWNjb3JkaW5nIHRvIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvN2Y1ejI2dzQodj12cy45NCkuYXNweFxuICAgICAgaWYgKHNlbGYubXVsdGlsaW5lKSB7XG4gICAgICAgIHJlc3VsdCB8PSAje01VTFRJTElORX07XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5pZ25vcmVDYXNlKSB7XG4gICAgICAgIHJlc3VsdCB8PSAje0lHTk9SRUNBU0V9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYXNlZm9sZD9cbiAgICBgc2VsZi5pZ25vcmVDYXNlYFxuICBlbmRcblxuICBhbGlhcyB0b19zIHNvdXJjZVxuZW5kXG5cbmNsYXNzIE1hdGNoRGF0YVxuICBhdHRyX3JlYWRlciA6cG9zdF9tYXRjaCwgOnByZV9tYXRjaCwgOnJlZ2V4cCwgOnN0cmluZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlZ2V4cCwgbWF0Y2hfZ3JvdXBzKVxuICAgICR+ICAgICAgICAgID0gc2VsZlxuICAgIEByZWdleHAgICAgID0gcmVnZXhwXG4gICAgQGJlZ2luICAgICAgPSBgbWF0Y2hfZ3JvdXBzLmluZGV4YFxuICAgIEBzdHJpbmcgICAgID0gYG1hdGNoX2dyb3Vwcy5pbnB1dGBcbiAgICBAcHJlX21hdGNoICA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UoMCwgbWF0Y2hfZ3JvdXBzLmluZGV4KWBcbiAgICBAcG9zdF9tYXRjaCA9IGBtYXRjaF9ncm91cHMuaW5wdXQuc2xpY2UobWF0Y2hfZ3JvdXBzLmluZGV4ICsgbWF0Y2hfZ3JvdXBzWzBdLmxlbmd0aClgXG4gICAgQG1hdGNoZXMgICAgPSBbXVxuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbWF0Y2hfZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBncm91cCA9IG1hdGNoX2dyb3Vwc1tpXTtcblxuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgICAgICN7QG1hdGNoZXN9LnB1c2gobmlsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAje0BtYXRjaGVzfS5wdXNoKGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIFtdKCphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGFyZ3NbMF0uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKCN7IXJlZ2V4cC5uYW1lcy5pbmNsdWRlPyhhcmdzWzBdKX0pIHtcbiAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwidW5kZWZpbmVkIGdyb3VwIG5hbWUgcmVmZXJlbmNlOiAje2FyZ3NbMF19XCJ9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICN7bmFtZWRfY2FwdHVyZXNbYXJnc1swXV19XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7QG1hdGNoZXNbKmFyZ3NdfVxuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9mZnNldChuKVxuICAgICV4e1xuICAgICAgaWYgKG4gIT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnTWF0Y2hEYXRhI29mZnNldCBvbmx5IHN1cHBvcnRzIDB0aCBlbGVtZW50J31cbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2VsZi5iZWdpbiwgc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGhdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3MgTWF0Y2hEYXRhID09PSBvdGhlclxuXG4gICAgYHNlbGYuc3RyaW5nID09IG90aGVyLnN0cmluZ2AgJiZcbiAgICAgIGBzZWxmLnJlZ2V4cC50b1N0cmluZygpID09IG90aGVyLnJlZ2V4cC50b1N0cmluZygpYCAmJlxuICAgICAgYHNlbGYucHJlX21hdGNoID09IG90aGVyLnByZV9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLnBvc3RfbWF0Y2ggPT0gb3RoZXIucG9zdF9tYXRjaGAgJiZcbiAgICAgIGBzZWxmLmJlZ2luID09IG90aGVyLmJlZ2luYFxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG5cbiAgZGVmIGJlZ2luKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdNYXRjaERhdGEjYmVnaW4gb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlbmQobilcbiAgICAleHtcbiAgICAgIGlmIChuICE9PSAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ01hdGNoRGF0YSNlbmQgb25seSBzdXBwb3J0cyAwdGggZWxlbWVudCd9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5iZWdpbiArIHNlbGYubWF0Y2hlc1tuXS5sZW5ndGg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2FwdHVyZXNcbiAgICBgI3tAbWF0Y2hlc30uc2xpY2UoMSlgXG4gIGVuZFxuXG4gIGRlZiBuYW1lZF9jYXB0dXJlc1xuICAgIG1hdGNoZXMgPSBjYXB0dXJlc1xuICAgIHJlZ2V4cC5uYW1lZF9jYXB0dXJlcy50cmFuc2Zvcm1fdmFsdWVzIGRvIHxpfFxuICAgICAgbWF0Y2hlc1tpLmxhc3QgLSAxXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgbmFtZXNcbiAgICByZWdleHAubmFtZXNcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBcIiM8TWF0Y2hEYXRhIFwiICsgI3tgI3tAbWF0Y2hlc31bMF1gLmluc3BlY3R9O1xuXG4gICAgICBpZiAoI3tyZWdleHAubmFtZXMuZW1wdHk/fSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gI3tAbWF0Y2hlc30ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgXCIgKyBpICsgXCI6XCIgKyAje2Aje0BtYXRjaGVzfVtpXWAuaW5zcGVjdH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAjeyBuYW1lZF9jYXB0dXJlcy5lYWNoIGRvIHxrLCB2fFxuICAgICAgICAgICAgICV4e1xuICAgICAgICAgICAgICAgc3RyICs9IFwiIFwiICsgI3trfSArIFwiOlwiICsgI3t2Lmluc3BlY3R9XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICBlbmQgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyICsgXCI+XCI7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYCN7QG1hdGNoZXN9Lmxlbmd0aGBcbiAgZW5kXG5cbiAgYWxpYXMgc2l6ZSBsZW5ndGhcblxuICBkZWYgdG9fYVxuICAgIEBtYXRjaGVzXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYCN7QG1hdGNoZXN9WzBdYFxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgICV4e1xuICAgICAgdmFyIGksIGEsIGluZGV4LCB2YWx1ZXMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICBpZiAoYXJnc1tpXS4kJGlzX3JhbmdlKSB7XG4gICAgICAgICAgYSA9ICN7YGFyZ3NbaV1gLnRvX2F9O1xuICAgICAgICAgIGEudW5zaGlmdChpLCAxKTtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGFyZ3MsIGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSAje09wYWwuY29lcmNlX3RvIShgYXJnc1tpXWAsIEludGVnZXIsIDp0b19pbnQpfTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gI3tAbWF0Y2hlc30ubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5pbCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXMucHVzaCgje0BtYXRjaGVzfVtpbmRleF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlJlZ2V4cEVycm9yPiIsIlN0YW5kYXJkRXJyb3IiLCI8Y2xhc3M6UmVnZXhwPiIsIjEiLCIyIiwiNCIsImFsbG9jYXRlIiwiYWxsb2NhdGVkIiwic2VsZiIsImVzY2FwZSIsInN0cmluZyIsImxhc3RfbWF0Y2giLCJuIiwibmlsPyIsIiR+IiwiW10iLCJ1bmlvbiIsInJhaXNlIiwiVHlwZUVycm9yIiwib3B0aW9ucyIsInRvX3N0ciIsIm5ldyIsImpvaW4iLCJyZWdleHAiLCJPcGFsIiwiY29lcmNlX3RvISIsIlN0cmluZyIsIlJlZ2V4cEVycm9yIiwiISIsIklHTk9SRUNBU0UiLCJNVUxUSUxJTkUiLCI9PSIsIm90aGVyIiwiPT09IiwibWF0Y2giLCJjb2VyY2VfdG8/IiwiPX4iLCIkcmV0X29yXzEiLCJiZWdpbiIsIjAiLCJpbnNwZWN0IiwicG9zIiwiTWF0Y2hEYXRhIiwiSW50ZWdlciIsIm1hdGNoPyIsIm5hbWVzIiwibWFwIiwic291cmNlIiwic2NhbiIsInRvX3Byb2MiLCJ1bmlxIiwibmFtZWRfY2FwdHVyZXMiLCJ0cmFuc2Zvcm1fdmFsdWVzIiwiZ3JvdXBfYnkiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9jayBpbiBuYW1lZF9jYXB0dXJlcyIsImkiLCJibG9jayAoMiBsZXZlbHMpIGluIG5hbWVkX2NhcHR1cmVzIiwiaiIsImJsb2NrICgzIGxldmVscykgaW4gbmFtZWRfY2FwdHVyZXMiLCIrIiwibGFzdCIsIn4iLCIkXyIsImNhc2Vmb2xkPyIsIjxjbGFzczpNYXRjaERhdGE+IiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwibWF0Y2hfZ3JvdXBzIiwiQHJlZ2V4cCIsIkBiZWdpbiIsIkBzdHJpbmciLCJAcHJlX21hdGNoIiwiQHBvc3RfbWF0Y2giLCJAbWF0Y2hlcyIsImluY2x1ZGU/IiwiYXJncyIsIkluZGV4RXJyb3IiLCJvZmZzZXQiLCJBcmd1bWVudEVycm9yIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiJHJldF9vcl81IiwiZW5kIiwiY2FwdHVyZXMiLCJtYXRjaGVzIiwiLSIsImVtcHR5PyIsImVhY2giLCJibG9jayBpbiBpbnNwZWN0IiwiayIsInYiLCJibG9jayAoMiBsZXZlbHMpIGluIGluc3BlY3QiLCJsZW5ndGgiLCJ0b19hIiwidG9fcyIsInZhbHVlc19hdCJdLCJtYXBwaW5n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QUE7O0FBcUJBc0QsSUFBQUEsMEJBQUFBLHVCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUdwQixZQUFTb0I7SUFEZEEsQ0FBQUEsa0NBQUFBO0lBSUEsYUFBTSxNQUFOLEVBQVcsUUFBWDs7QUFFQUMsSUFBQUEsd0JBQUFBLHFCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFyQjtJQURGcUIsQ0FBQUEsZ0NBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEscUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBR3RCLFlBQVNzQjtJQURkQSxDQUFBQSxnQ0FBQUE7SUFJQS9CLE9BQUFnQyxDQUFBQSw2QkFBQUEsMEJBQUFBLHFCQXRhRixFQXNhRUE7QUFBQUEsTUFBQUE7Ozs7TUF0YUY7O01Bc2FnQjs7QUFFaEJBOztBQUVBQTs7QUFFQUE7QUFDQUEsY0FBZ0JBLENBQUNBLE9BQURBLENBQVNGLE1BQUFBLENBQUFBLENBQU1FO0FBQy9CQTtBQUNBQTtBQUNBQTs7QUFFQUEsZ0JBQWtCekUsb0JBQUlDLGVBQUFBLENBQWF3RSxPQUFqQixFQUEyQnRELHVCQUEzQixFQUFvQyxRQUFoQ2xCLENBQXlDd0U7O0FBRS9EQTtBQUNBQSxtQkFBcUJ2QixZQUFTdUI7QUFDOUJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxvQkFBc0J2QixZQUFTdUI7QUFDL0JBOztBQUVBQTtBQUNBQTtJQTFCRUEsQ0FBQUEsc0NBQUFBLENBQUFBO0VBaklGaEMsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFyU0FsRTsifX0seyJvZmZzZXQiOnsibGluZSI6NzIyNSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RyaW5nLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgaGVscGVyczogY29lcmNlX3RvLCByZXNwb25kX3RvXG5cbnJlcXVpcmUgJ2NvcmVsaWIvY29tcGFyYWJsZSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmVnZXhwJ1xuXG5jbGFzcyBTdHJpbmcgPCBgU3RyaW5nYFxuICBpbmNsdWRlIENvbXBhcmFibGVcblxuICAleHtcbiAgICBPcGFsLmRlZmluZVByb3BlcnR5KCN7c2VsZn0uJCRwcm90b3R5cGUsICckJGlzX3N0cmluZycsIHRydWUpO1xuXG4gICAgT3BhbC5kZWZpbmVQcm9wZXJ0eSgje3NlbGZ9LiQkcHJvdG90eXBlLCAnJCRjYXN0JywgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIga2xhc3MgPSB0aGlzLiQkY2xhc3M7XG4gICAgICBpZiAoa2xhc3MuJCRjb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IGtsYXNzLiQkY29uc3RydWN0b3Ioc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlZiBfX2lkX19cbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmIHNlbGYudHJ5X2NvbnZlcnQod2hhdClcbiAgICBPcGFsLmNvZXJjZV90bz8od2hhdCwgU3RyaW5nLCA6dG9fc3RyKVxuICBlbmRcblxuICBkZWYgc2VsZi5uZXcoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgc3RyID0gYXJnc1swXSB8fCBcIlwiO1xuICAgICAgdmFyIG9wdHMgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdO1xuICAgICAgc3RyID0gJGNvZXJjZV90byhzdHIsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy4kJGlzX2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdHMuJCRzbWFwLmVuY29kaW5nKSBzdHIgPSBzdHIuJGZvcmNlX2VuY29kaW5nKG9wdHMuJCRzbWFwLmVuY29kaW5nKTtcbiAgICAgIH1cbiAgICAgIHN0ciA9IG5ldyBzZWxmLiQkY29uc3RydWN0b3Ioc3RyKTtcbiAgICAgIGlmICghc3RyLiRpbml0aWFsaXplLiQkcHJpc3RpbmUpICN7YHN0cmAuaW5pdGlhbGl6ZSgqYXJncyl9O1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gICMgT3VyIGluaXRpYWxpemUgbWV0aG9kIGRvZXMgbm90aGluZywgdGhlIHN0cmluZyB2YWx1ZSBzZXR1cCBpcyBiZWluZ1xuICAjIGRvbmUgYnkgU3RyaW5nLm5ldy4gVGhlcmVmb3JlIG5vdCBhbGwga2luZHMgb2Ygc3ViY2xhc3Npbmcgd2lsbCB3b3JrLlxuICAjIEFzIGEgcnVsZSBvZiB0aHVtYiwgd2hlbiBzdWJjbGFzc2luZyBTdHJpbmcsIGVpdGhlciBtYWtlIHN1cmUgdG8gb3ZlcnJpZGVcbiAgIyAubmV3IG9yIG1ha2Ugc3VyZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBnaXZlbiB0byBhIGNvbnN0cnVjdG9yIGlzXG4gICMgYSBzdHJpbmcgd2Ugd2FudCBvdXIgc3ViY2xhc3Mtc3RyaW5nIHRvIGhvbGQuXG4gIGRlZiBpbml0aWFsaXplKHN0ciA9IHVuZGVmaW5lZCwgZW5jb2Rpbmc6IG5pbCwgY2FwYWNpdHk6IG5pbClcbiAgZW5kXG5cbiAgZGVmICUoZGF0YSlcbiAgICBpZiBBcnJheSA9PT0gZGF0YVxuICAgICAgZm9ybWF0KHNlbGYsICpkYXRhKVxuICAgIGVsc2VcbiAgICAgIGZvcm1hdChzZWxmLCBkYXRhKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihjb3VudClcbiAgICAleHtcbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J31cbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdCgnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCk7XG5cbiAgICAgIC8vIEFsbCBjcmVkaXQgZm9yIHRoZSBiaXQtdHdpZGRsaW5nIG1hZ2ljIGNvZGUgYmVsb3cgZ29lcyB0byBNb3ppbGxhXG4gICAgICAvLyBwb2x5ZmlsbCBpbXBsZW1lbnRhdGlvbiBvZiBTdHJpbmcucHJvdG90eXBlLnJlcGVhdCgpIHBvc3RlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3JlcGVhdFxuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCAqIGNvdW50ID49IDEgPDwgMjgpIHtcbiAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCAnbXVsdGlwbHkgY291bnQgbXVzdCBub3Qgb3ZlcmZsb3cgbWF4aW11bSBzdHJpbmcgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKChjb3VudCAmIDEpID09PSAxKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBjb3VudCA+Pj49IDE7XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmluZyArPSBzdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgb3RoZXIgPSBgJGNvZXJjZV90bygje290aGVyfSwgI3tTdHJpbmd9LCAndG9fc3RyJylgXG5cbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PSBcIlwiICYmIHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5TdHJpbmcpIHJldHVybiAje3NlbGZ9O1xuICAgICAgaWYgKHNlbGYgPT0gXCJcIiAmJiBvdGhlci4kJGNsYXNzID09PSBPcGFsLlN0cmluZykgcmV0dXJuICN7b3RoZXJ9O1xuICAgICAgdmFyIG91dCA9IHNlbGYgKyBvdGhlcjtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nID09PSBvdXQuZW5jb2RpbmcgJiYgb3RoZXIuZW5jb2RpbmcgPT09IG91dC5lbmNvZGluZykgcmV0dXJuIG91dDtcbiAgICAgIGlmIChzZWxmLmVuY29kaW5nLm5hbWUgPT09IFwiVVRGLThcIiB8fCBvdGhlci5lbmNvZGluZy5uYW1lID09PSBcIlVURi04XCIpIHJldHVybiBvdXQ7XG4gICAgICByZXR1cm4gT3BhbC5lbmMob3V0LCBzZWxmLmVuY29kaW5nKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgb3RoZXIucmVzcG9uZF90bz8gOnRvX3N0clxuICAgICAgb3RoZXIgPSBvdGhlci50b19zdHIudG9fc1xuXG4gICAgICBgc2VsZiA+IG90aGVyID8gMSA6IChzZWxmIDwgb3RoZXIgPyAtMSA6IDApYFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICB2YXIgY21wID0gI3tvdGhlciA8PT4gc2VsZn07XG5cbiAgICAgICAgaWYgKGNtcCA9PT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY21wID4gMCA/IC0xIDogKGNtcCA8IDAgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCkgPT09IG90aGVyLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJHJlc3BvbmRfdG8ob3RoZXIsICckdG9fc3RyJykpIHtcbiAgICAgICAgcmV0dXJuICN7b3RoZXIgPT0gc2VsZn07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBlcWw/ID09XG4gIGFsaWFzID09PSA9PVxuXG4gIGRlZiA9fihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX3N0cmluZykge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3R5cGUgbWlzbWF0Y2g6IFN0cmluZyBnaXZlbid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tvdGhlciA9fiBzZWxmfTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHNpemUgPSBzZWxmLmxlbmd0aCwgZXhjbHVkZTtcblxuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICAgIGxlbmd0aCAgPSAkY29lcmNlX3RvKGluZGV4LmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBpbmRleCAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChNYXRoLmFicyhpbmRleCkgPiBzaXplKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggKz0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gaW5kZXg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc3Vic3RyKGluZGV4LCBsZW5ndGgpKTtcbiAgICAgIH1cblxuXG4gICAgICBpZiAoaW5kZXguJCRpc19zdHJpbmcpIHtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3J9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZihpbmRleCkgIT09IC0xID8gc2VsZi4kJGNhc3QoaW5kZXgpIDogbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGlmIChpbmRleC4kJGlzX3JlZ2V4cCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBzZWxmLm1hdGNoKGluZGV4KTtcblxuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgaW5kZXhgLCBgbWF0Y2hgKX1cblxuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuZ3RoID0gJGNvZXJjZV90byhsZW5ndGgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgICBpZiAobGVuZ3RoIDwgMCAmJiAtbGVuZ3RoIDwgbWF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KG1hdGNoW2xlbmd0aCArPSBtYXRjaC5sZW5ndGhdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiBsZW5ndGggPCBtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QobWF0Y2hbbGVuZ3RoXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IHNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gc2l6ZSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnN1YnN0cihpbmRleCwgMSkpO1xuICAgICAgfVxuXG4gICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zdWJzdHIoaW5kZXgsIGxlbmd0aCkpO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgYnl0ZXNsaWNlIFtdXG5cbiAgZGVmIGJcbiAgICBgbmV3IFN0cmluZygje3NlbGZ9KWAuZm9yY2VfZW5jb2RpbmcoJ2JpbmFyeScpXG4gIGVuZFxuXG4gIGRlZiBjYXBpdGFsaXplXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzZWxmLnN1YnN0cigxKS50b0xvd2VyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIGNhc2VjbXAob3RoZXIpXG4gICAgcmV0dXJuIG5pbCB1bmxlc3Mgb3RoZXIucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAje1N0cmluZ30sICd0b19zdHInKWAudG9fc1xuICAgICV4e1xuICAgICAgdmFyIGFzY2lpX29ubHkgPSAvXltcXHgwMC1cXHg3Rl0qJC87XG4gICAgICBpZiAoYXNjaWlfb25seS50ZXN0KHNlbGYpICYmIGFzY2lpX29ubHkudGVzdChvdGhlcikpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgb3RoZXIgPSBvdGhlci50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmIDw9PiBvdGhlclxuICBlbmRcblxuICBkZWYgY2FzZWNtcD8ob3RoZXIpXG4gICAgJXh7XG4gICAgICB2YXIgY21wID0gI3tjYXNlY21wKG90aGVyKX07XG4gICAgICBpZiAoY21wID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjbXAgPT09IDA7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VudGVyKHdpZHRoLCBwYWRzdHIgPSAnICcpXG4gICAgd2lkdGggID0gYCRjb2VyY2VfdG8oI3t3aWR0aH0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICBwYWRzdHIgPSBgJGNvZXJjZV90bygje3BhZHN0cn0sICN7U3RyaW5nfSwgJ3RvX3N0cicpYC50b19zXG5cbiAgICBpZiBwYWRzdHIuZW1wdHk/XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnemVybyB3aWR0aCBwYWRkaW5nJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIHNlbGYgaWYgYHdpZHRoIDw9IHNlbGYubGVuZ3RoYFxuXG4gICAgJXh7XG4gICAgICB2YXIgbGp1c3RpZmllZCA9ICN7bGp1c3QgKCh3aWR0aCArIGBzZWxmLmxlbmd0aGApIC8gMikuY2VpbCwgcGFkc3RyfSxcbiAgICAgICAgICByanVzdGlmaWVkID0gI3tyanVzdCAoKHdpZHRoICsgYHNlbGYubGVuZ3RoYCkgLyAyKS5mbG9vciwgcGFkc3RyfTtcblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJqdXN0aWZpZWQgKyBsanVzdGlmaWVkLnNsaWNlKHNlbGYubGVuZ3RoKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hvbXAoc2VwYXJhdG9yID0gJC8pXG4gICAgcmV0dXJuIHNlbGYgaWYgYHNlcGFyYXRvciA9PT0gbmlsIHx8IHNlbGYubGVuZ3RoID09PSAwYFxuXG4gICAgc2VwYXJhdG9yID0gT3BhbC5jb2VyY2VfdG8hKHNlcGFyYXRvciwgU3RyaW5nLCA6dG9fc3RyKS50b19zXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5yZXBsYWNlKC9cXHI/XFxuPyQvLCAnJyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZXBhcmF0b3IgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5yZXBsYWNlKC8oXFxyP1xcbikrJC8sICcnKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYubGVuZ3RoID49IHNlcGFyYXRvci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRhaWwgPSBzZWxmLnN1YnN0cihzZWxmLmxlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGgsIHNlcGFyYXRvci5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0YWlsID09PSBzZXBhcmF0b3IpIHtcbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnN1YnN0cigwLCBzZWxmLmxlbmd0aCAtIHNlcGFyYXRvci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3QocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjaG9wXG4gICAgJXh7XG4gICAgICB2YXIgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIHJlc3VsdDtcblxuICAgICAgaWYgKGxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuY2hhckF0KGxlbmd0aCAtIDEpID09PSBcIlxcblwiICYmIHNlbGYuY2hhckF0KGxlbmd0aCAtIDIpID09PSBcIlxcclwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHNlbGYuc3Vic3RyKDAsIGxlbmd0aCAtIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gc2VsZi5zdWJzdHIoMCwgbGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNoclxuICAgIGBzZWxmLmNoYXJBdCgwKWBcbiAgZW5kXG5cbiAgZGVmIGNsb25lXG4gICAgY29weSA9IGBuZXcgU3RyaW5nKHNlbGYpYFxuICAgIGNvcHkuY29weV9zaW5nbGV0b25fbWV0aG9kcyhzZWxmKVxuICAgIGNvcHkuaW5pdGlhbGl6ZV9jbG9uZShzZWxmKVxuICAgIGNvcHlcbiAgZW5kXG5cbiAgZGVmIGR1cFxuICAgIGNvcHkgPSBgbmV3IFN0cmluZyhzZWxmKWBcbiAgICBjb3B5LmluaXRpYWxpemVfZHVwKHNlbGYpXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgY291bnQoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnQXJndW1lbnRFcnJvcjogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSspJ31cbiAgICAgIH1cbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcbiAgICAgIGlmIChjaGFyX2NsYXNzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoIC0gc2VsZi5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcl9jbGFzcywgJ2cnKSwgJycpLmxlbmd0aDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnQXJndW1lbnRFcnJvcjogd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMSspJ31cbiAgICAgIH1cbiAgICAgIHZhciBjaGFyX2NsYXNzID0gY2hhcl9jbGFzc19mcm9tX2NoYXJfc2V0cyhzZXRzKTtcbiAgICAgIGlmIChjaGFyX2NsYXNzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZShuZXcgUmVnRXhwKGNoYXJfY2xhc3MsICdnJyksICcnKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX3ByZWZpeChwcmVmaXgpXG4gICAgJXh7XG4gICAgICBpZiAoIXByZWZpeC4kJGlzX3N0cmluZykge1xuICAgICAgICBwcmVmaXggPSAkY29lcmNlX3RvKHByZWZpeCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYuc2xpY2UocHJlZml4Lmxlbmd0aCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX3N1ZmZpeChzdWZmaXgpXG4gICAgJXh7XG4gICAgICBpZiAoIXN1ZmZpeC4kJGlzX3N0cmluZykge1xuICAgICAgICBzdWZmaXggPSAkY29lcmNlX3RvKHN1ZmZpeCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnNsaWNlKHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCkgPT09IHN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGNhc3Qoc2VsZi5zbGljZSgwLCBzZWxmLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRvd25jYXNlXG4gICAgYHNlbGYuJCRjYXN0KHNlbGYudG9Mb3dlckNhc2UoKSlgXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2xpbmUoc2VwYXJhdG9yID0gJC8sICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOmVhY2hfbGluZSwgc2VwYXJhdG9yIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gbmlsKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzZWxmKTtcblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgc2VwYXJhdG9yID0gJGNvZXJjZV90byhzZXBhcmF0b3IsICN7U3RyaW5nfSwgJ3RvX3N0cicpXG5cbiAgICAgIHZhciBhLCBpLCBuLCBsZW5ndGgsIGNob21wZWQsIHRyYWlsaW5nLCBzcGxpdHRlZDtcblxuICAgICAgaWYgKHNlcGFyYXRvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChhID0gc2VsZi5zcGxpdCgvKFxcbnsyLH0pLyksIGkgPSAwLCBuID0gYS5sZW5ndGg7IGkgPCBuOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoYVtpXSB8fCBhW2kgKyAxXSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gKGFbaV0gfHwgXCJcIikgKyAoYVtpICsgMV0gfHwgXCJcIik7XG4gICAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3QodmFsdWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgY2hvbXBlZCAgPSAje2Nob21wKHNlcGFyYXRvcil9O1xuICAgICAgdHJhaWxpbmcgPSBzZWxmLmxlbmd0aCAhPSBjaG9tcGVkLmxlbmd0aDtcbiAgICAgIHNwbGl0dGVkID0gY2hvbXBlZC5zcGxpdChzZXBhcmF0b3IpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzcGxpdHRlZC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8IGxlbmd0aCAtIDEgfHwgdHJhaWxpbmcpIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3Qoc3BsaXR0ZWRbaV0gKyBzZXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgc2VsZi4kJGNhc3Qoc3BsaXR0ZWRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGVuZF93aXRoPygqc3VmZml4ZXMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3VmZml4ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHN1ZmZpeCA9ICRjb2VyY2VfdG8oc3VmZml4ZXNbaV0sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgICAgaWYgKHNlbGYubGVuZ3RoID49IHN1ZmZpeC5sZW5ndGggJiZcbiAgICAgICAgICAgIHNlbGYuc3Vic3RyKHNlbGYubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCwgc3VmZml4Lmxlbmd0aCkgPT0gc3VmZml4KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmYWxzZVxuICBlbmRcblxuICBhbGlhcyBlcXVhbD8gPT09XG5cbiAgZGVmIGdzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7ZW51bV9mb3IgOmdzdWIsIHBhdHRlcm59O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gJycsIG1hdGNoX2RhdGEgPSBuaWwsIGluZGV4ID0gMCwgbWF0Y2gsIF9yZXBsYWNlbWVudDtcblxuICAgICAgaWYgKHBhdHRlcm4uJCRpc19yZWdleHApIHtcbiAgICAgICAgcGF0dGVybiA9IE9wYWwuZ2xvYmFsX211bHRpbGluZV9yZWdleHAocGF0dGVybik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpLCAnZ20nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3RJbmRleDtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHNlbGYpO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgcmVzdWx0ICs9IHNlbGYuc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hfZGF0YSA9ICN7TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9O1xuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbGFzdEluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgICAgICAgX3JlcGxhY2VtZW50ID0gYmxvY2sobWF0Y2hbMF0pO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gbGFzdEluZGV4OyAvLyBzYXZlIGFuZCByZXN0b3JlIGxhc3RJbmRleFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50LiQkaXNfaGFzaCkge1xuICAgICAgICAgIF9yZXBsYWNlbWVudCA9ICN7YHJlcGxhY2VtZW50YFtgbWF0Y2hbMF1gXS50b19zfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoIXJlcGxhY2VtZW50LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9ICRjb2VyY2VfdG8ocmVwbGFjZW1lbnQsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQgKyAoc2VsZlttYXRjaC5pbmRleF0gfHwgXCJcIikpO1xuICAgICAgICAgIHBhdHRlcm4ubGFzdEluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ICs9IChzZWxmLnNsaWNlKGluZGV4LCBtYXRjaC5pbmRleCkgKyBfcmVwbGFjZW1lbnQpXG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICAgIH1cblxuICAgICAgI3skfiA9IGBtYXRjaF9kYXRhYH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgc2VsZi50b1N0cmluZygpYFxuICBlbmRcblxuICBkZWYgaGV4XG4gICAgdG9faSAxNlxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIG90aGVyID0gJGNvZXJjZV90byhvdGhlciwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5pbmRleE9mKG90aGVyKSAhPT0gLTE7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgoc2VhcmNoLCBvZmZzZXQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgcmVnZXg7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGNvZXJjZV90byhvZmZzZXQsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgcmVnZXggPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlYXJjaCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgbWF0Y2ggPSByZWdleC5leGVjKHNlbGYpO1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgI3skfiA9IG5pbH07XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXRjaC5pbmRleCA+PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICN7JH4gPSBNYXRjaERhdGEubmV3KGByZWdleGAsIGBtYXRjaGApfVxuICAgICAgICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWdleC5sYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaCA9ICRjb2VyY2VfdG8oc2VhcmNoLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDAgJiYgb2Zmc2V0ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4ID0gc2VsZi5pbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbmlsIDogaW5kZXg7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zcGVjdFxuICAgICV4e1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3MgKi9cbiAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHUwMDdGLVxcdTAwOUZcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgICAgICAgIG1ldGEgPSB7XG4gICAgICAgICAgICAnXFx1MDAwNyc6ICdcXFxcYScsXG4gICAgICAgICAgICAnXFx1MDAxYic6ICdcXFxcZScsXG4gICAgICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgJ1xcdic6ICdcXFxcdicsXG4gICAgICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVzY2FwZWQgPSBzZWxmLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoY2hyKSB7XG4gICAgICAgICAgICBpZiAobWV0YVtjaHJdKSByZXR1cm4gbWV0YVtjaHJdO1xuICAgICAgICAgICAgY2hyID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY2hyIDw9IDB4ZmYgJiYgKHNlbGYuZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpIHx8IHNlbGYuaW50ZXJuYWxfZW5jb2RpbmdbXCIkYmluYXJ5P1wiXSgpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgY2hyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJ1xcXFx1JyArICgnMDAwMCcgKyBjaHIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC00KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIHJldHVybiAnXCInICsgZXNjYXBlZC5yZXBsYWNlKC9cXCNbXFwkXFxAXFx7XS9nLCAnXFxcXCQmJykgKyAnXCInO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1taXNsZWFkaW5nLWNoYXJhY3Rlci1jbGFzcyAqL1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyblxuICAgIGBzZWxmLnRvU3RyaW5nKClgXG4gIGVuZFxuXG4gIGRlZiBsaW5lcyhzZXBhcmF0b3IgPSAkLywgJmJsb2NrKVxuICAgIGUgPSBlYWNoX2xpbmUoc2VwYXJhdG9yLCAmYmxvY2spXG4gICAgYmxvY2sgPyBzZWxmIDogZS50b19hXG4gIGVuZFxuXG4gIGRlZiBsanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAje1N0cmluZ30sICd0b19zdHInKWAudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGluZGV4ICA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IFwiXCI7XG5cbiAgICAgIHdpZHRoIC09IHNlbGYubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IHdpZHRoKSB7XG4gICAgICAgIHJlc3VsdCArPSBwYWRzdHI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmICsgcmVzdWx0LnNsaWNlKDAsIHdpZHRoKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXlxccyovLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBhc2NpaV9vbmx5P1xuICAgICMgbm9uLUFTQ0lJLWNvbXBhdGlibGUgZW5jb2RpbmcgbXVzdCByZXR1cm4gZmFsc2VcbiAgICAleHtcbiAgICAgIGlmICghc2VsZi5lbmNvZGluZy5hc2NpaSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHNlbGYpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1hdGNoKHBhdHRlcm4sIHBvcyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIFN0cmluZyA9PT0gcGF0dGVybiB8fCBwYXR0ZXJuLnJlc3BvbmRfdG8/KDp0b19zdHIpXG4gICAgICBwYXR0ZXJuID0gUmVnZXhwLm5ldyhwYXR0ZXJuLnRvX3N0cilcbiAgICBlbmRcblxuICAgIHVubGVzcyBSZWdleHAgPT09IHBhdHRlcm5cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7cGF0dGVybi5jbGFzc30gKGV4cGVjdGVkIFJlZ2V4cClcIlxuICAgIGVuZFxuXG4gICAgcGF0dGVybi5tYXRjaChzZWxmLCBwb3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIG1hdGNoPyhwYXR0ZXJuLCBwb3MgPSB1bmRlZmluZWQpXG4gICAgaWYgU3RyaW5nID09PSBwYXR0ZXJuIHx8IHBhdHRlcm4ucmVzcG9uZF90bz8oOnRvX3N0cilcbiAgICAgIHBhdHRlcm4gPSBSZWdleHAubmV3KHBhdHRlcm4udG9fc3RyKVxuICAgIGVuZFxuXG4gICAgdW5sZXNzIFJlZ2V4cCA9PT0gcGF0dGVyblxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIndyb25nIGFyZ3VtZW50IHR5cGUgI3twYXR0ZXJuLmNsYXNzfSAoZXhwZWN0ZWQgUmVnZXhwKVwiXG4gICAgZW5kXG5cbiAgICBwYXR0ZXJuLm1hdGNoPyhzZWxmLCBwb3MpXG4gIGVuZFxuXG4gIGRlZiBuZXh0XG4gICAgJXh7XG4gICAgICB2YXIgaSA9IHNlbGYubGVuZ3RoO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KCcnKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzZWxmO1xuICAgICAgdmFyIGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXggPSBzZWxmLnNlYXJjaCgvW2EtekEtWjAtOV0vKTtcbiAgICAgIHZhciBjYXJyeSA9IGZhbHNlO1xuICAgICAgdmFyIGNvZGU7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGNvZGUgPSBzZWxmLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fFxuICAgICAgICAgIChjb2RlID49IDY1ICYmIGNvZGUgPD0gOTApIHx8XG4gICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpKSB7XG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA0ODtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBjYXJyeSA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gNjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEyMjpcbiAgICAgICAgICAgIGNhcnJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvZGUgPSA5NztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYXJyeSA9IGZhbHNlO1xuICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmlyc3RfYWxwaGFudW1fY2hhcl9pbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgICAgICBjb2RlID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNhcnJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FycnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgcmVzdWx0LnNsaWNlKGkgKyAxKTtcbiAgICAgICAgaWYgKGNhcnJ5ICYmIChpID09PSAwIHx8IGkgPT09IGZpcnN0X2FscGhhbnVtX2NoYXJfaW5kZXgpKSB7XG4gICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgY2FzZSA2NTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGkpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIHJlc3VsdC5zbGljZShpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FycnkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhcnJ5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChyZXN1bHQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9jdFxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLFxuICAgICAgICAgIHJhZGl4ID0gODtcblxuICAgICAgaWYgKC9eXFxzKl8vLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL14oXFxzKlsrLV0/KSgwW2JvZHhdPykoLispJC9pLCBmdW5jdGlvbiAob3JpZ2luYWwsIGhlYWQsIGZsYWcsIHRhaWwpIHtcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBpZiAodGFpbC5jaGFyQXQoMSkgPT09ICd4JyAmJiBmbGFnID09PSAnMHgnKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgcmFkaXggPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIHJhZGl4ID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzB4JzpcbiAgICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgIH0pO1xuXG4gICAgICByZXN1bHQgPSBwYXJzZUludChzdHJpbmcucmVwbGFjZSgvXyg/IV8pL2csICcnKSwgcmFkaXgpO1xuICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG9yZFxuICAgICV4e1xuICAgICAgaWYgKHR5cGVvZiBzZWxmLmNvZGVQb2ludEF0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY29kZVBvaW50QXQoMCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oc2VwKVxuICAgICV4e1xuICAgICAgdmFyIGksIG07XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IHNlcC5leGVjKHNlbGYpO1xuICAgICAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje01hdGNoRGF0YS5uZXcgYHNlcGAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VwID0gJGNvZXJjZV90byhzZXAsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuICAgICAgICBpID0gc2VsZi5pbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gW3NlbGYsICcnLCAnJ107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlXG4gICAgYHNlbGYuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKWBcbiAgZW5kXG5cbiAgZGVmIHJpbmRleChzZWFyY2gsIG9mZnNldCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciBpLCBtLCByLCBfbTtcblxuICAgICAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHNlbGYubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gJGNvZXJjZV90byhvZmZzZXQsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2guJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlYXJjaCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgX20gPSByLmV4ZWMoc2VsZik7XG4gICAgICAgICAgaWYgKF9tID09PSBudWxsIHx8IF9tLmluZGV4ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbSA9IF9tO1xuICAgICAgICAgIHIubGFzdEluZGV4ID0gbS5pbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG0gPT09IG51bGwpIHtcbiAgICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAje01hdGNoRGF0YS5uZXcgYHJgLCBgbWB9O1xuICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWFyY2ggPSAkY29lcmNlX3RvKHNlYXJjaCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmxhc3RJbmRleE9mKHNlYXJjaCwgb2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGkgPT09IC0xID8gbmlsIDogaTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByanVzdCh3aWR0aCwgcGFkc3RyID0gJyAnKVxuICAgIHdpZHRoICA9IGAkY29lcmNlX3RvKCN7d2lkdGh9LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgcGFkc3RyID0gYCRjb2VyY2VfdG8oI3twYWRzdHJ9LCAje1N0cmluZ30sICd0b19zdHInKWAudG9fc1xuXG4gICAgaWYgcGFkc3RyLmVtcHR5P1xuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3plcm8gd2lkdGggcGFkZGluZydcbiAgICBlbmRcblxuICAgIHJldHVybiBzZWxmIGlmIGB3aWR0aCA8PSBzZWxmLmxlbmd0aGBcblxuICAgICV4e1xuICAgICAgdmFyIGNoYXJzICAgICA9IE1hdGguZmxvb3Iod2lkdGggLSBzZWxmLmxlbmd0aCksXG4gICAgICAgICAgcGF0dGVybnMgID0gTWF0aC5mbG9vcihjaGFycyAvIHBhZHN0ci5sZW5ndGgpLFxuICAgICAgICAgIHJlc3VsdCAgICA9IEFycmF5KHBhdHRlcm5zICsgMSkuam9pbihwYWRzdHIpLFxuICAgICAgICAgIHJlbWFpbmluZyA9IGNoYXJzIC0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCArIHBhZHN0ci5zbGljZSgwLCByZW1haW5pbmcpICsgc2VsZik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcnBhcnRpdGlvbihzZXApXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbSwgciwgX207XG5cbiAgICAgIGlmIChzZXAuJCRpc19yZWdleHApIHtcbiAgICAgICAgbSA9IG51bGw7XG4gICAgICAgIHIgPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHNlcCk7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBfbSA9IHIuZXhlYyhzZWxmKTtcbiAgICAgICAgICBpZiAoX20gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtID0gX207XG4gICAgICAgICAgci5sYXN0SW5kZXggPSBtLmluZGV4ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtID09PSBudWxsKSB7XG4gICAgICAgICAgaSA9IC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICN7TWF0Y2hEYXRhLm5ldyBgcmAsIGBtYH07XG4gICAgICAgICAgc2VwID0gbVswXTtcbiAgICAgICAgICBpID0gbS5pbmRleDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXAgPSAkY29lcmNlX3RvKHNlcCwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIGkgPSBzZWxmLmxhc3RJbmRleE9mKHNlcCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gWycnLCAnJywgc2VsZl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNlbGYuc2xpY2UoMCwgaSksXG4gICAgICAgIHNlbGYuc2xpY2UoaSwgaSArIHNlcC5sZW5ndGgpLFxuICAgICAgICBzZWxmLnNsaWNlKGkgKyBzZXAubGVuZ3RoKVxuICAgICAgXTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByc3RyaXBcbiAgICBgc2VsZi5yZXBsYWNlKC9bXFxzXFx1MDAwMF0qJC8sICcnKWBcbiAgZW5kXG5cbiAgZGVmIHNjYW4ocGF0dGVybiwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIG1hdGNoX2RhdGEgPSBuaWwsXG4gICAgICAgICAgbWF0Y2g7XG5cbiAgICAgIGlmIChwYXR0ZXJuLiQkaXNfcmVnZXhwKSB7XG4gICAgICAgIHBhdHRlcm4gPSBPcGFsLmdsb2JhbF9tdWx0aWxpbmVfcmVnZXhwKHBhdHRlcm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICRjb2VyY2VfdG8ocGF0dGVybiwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZikpICE9IG51bGwpIHtcbiAgICAgICAgbWF0Y2hfZGF0YSA9ICN7TWF0Y2hEYXRhLm5ldyBgcGF0dGVybmAsIGBtYXRjaGB9O1xuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIG1hdGNoLmxlbmd0aCA9PSAxID8gcmVzdWx0LnB1c2gobWF0Y2hbMF0pIDogcmVzdWx0LnB1c2goI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaC5sZW5ndGggPT0gMSA/IGJsb2NrKG1hdGNoWzBdKSA6IGJsb2NrLmNhbGwoc2VsZiwgI3tgbWF0Y2hfZGF0YWAuY2FwdHVyZXN9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAjeyR+ID0gYG1hdGNoX2RhdGFgfVxuXG4gICAgICByZXR1cm4gKGJsb2NrICE9PSBuaWwgPyBzZWxmIDogcmVzdWx0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNsaWNlIFtdXG5cbiAgZGVmIHNwbGl0KHBhdHRlcm4gPSB1bmRlZmluZWQsIGxpbWl0ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGltaXQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobGltaXQgPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQgfHwgcGF0dGVybiA9PT0gbmlsKSB7XG4gICAgICAgIHBhdHRlcm4gPSAjeyQ7IHx8ICcgJ307XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgIGksIGlpO1xuXG4gICAgICBpZiAocGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gT3BhbC5nbG9iYWxfbXVsdGlsaW5lX3JlZ2V4cChwYXR0ZXJuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdHRlcm4gPSAkY29lcmNlX3RvKHBhdHRlcm4sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnICcpIHtcbiAgICAgICAgICBwYXR0ZXJuID0gL1xccysvZ207XG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoL15cXHMrLywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4ucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKSwgJ2dtJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gc3RyaW5nLnNwbGl0KHBhdHRlcm4pO1xuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiByZXN1bHRbMF0gPT09IHN0cmluZykge1xuICAgICAgICByZXR1cm4gW3NlbGYuJCRjYXN0KHJlc3VsdFswXSldO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKGkgPSByZXN1bHQuaW5kZXhPZih1bmRlZmluZWQpKSAhPT0gLTEpIHtcbiAgICAgICAgcmVzdWx0LnNwbGljZShpLCAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2FzdFJlc3VsdCgpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuJCRjYXN0KHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxpbWl0ID09PSAwKSB7XG4gICAgICAgIHdoaWxlIChyZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICAgIHJlc3VsdC5sZW5ndGggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gcGF0dGVybi5leGVjKHN0cmluZyk7XG5cbiAgICAgIGlmIChsaW1pdCA8IDApIHtcbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoWzBdID09PSAnJyAmJiBwYXR0ZXJuLnNvdXJjZS5pbmRleE9mKCcoPz0nKSA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IG1hdGNoLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FzdFJlc3VsdCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwgJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgcmVzdWx0LnNsaWNlKGxpbWl0IC0gMSkuam9pbignJykpO1xuICAgICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA+PSByZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIGNhc3RSZXN1bHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBpbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgICAgICBpZiAoaSArIDEgPT09IGxpbWl0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5zcGxpY2UobGltaXQgLSAxLCByZXN1bHQubGVuZ3RoIC0gMSwgc3RyaW5nLnNsaWNlKGluZGV4KSk7XG4gICAgICBjYXN0UmVzdWx0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUoKnNldHMpXG4gICAgJXh7XG4gICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHNlbGYucmVwbGFjZSgvKC4pXFwxKy9nLCAnJDEnKSk7XG4gICAgICB9XG4gICAgICB2YXIgY2hhcl9jbGFzcyA9IGNoYXJfY2xhc3NfZnJvbV9jaGFyX3NldHMoc2V0cyk7XG4gICAgICBpZiAoY2hhcl9jbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChzZWxmLnJlcGxhY2UobmV3IFJlZ0V4cCgnKCcgKyBjaGFyX2NsYXNzICsgJylcXFxcMSsnLCAnZycpLCAnJDEnKSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3RhcnRfd2l0aD8oKnByZWZpeGVzKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHByZWZpeGVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmVmaXhlc1tpXS4kJGlzX3JlZ2V4cCkge1xuICAgICAgICAgIHZhciByZWdleHAgPSBwcmVmaXhlc1tpXTtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSByZWdleHAuZXhlYyhzZWxmKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAjeyR+ID0gTWF0Y2hEYXRhLm5ldyhgcmVnZXhwYCwgYG1hdGNoYCl9O1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICN7JH4gPSBuaWx9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmVmaXggPSAkY29lcmNlX3RvKHByZWZpeGVzW2ldLCAje1N0cmluZ30sICd0b19zdHInKS4kdG9fcygpO1xuXG4gICAgICAgICAgaWYgKHNlbGYuaW5kZXhPZihwcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN0cmlwXG4gICAgYHNlbGYucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvW1xcc1xcdTAwMDBdKiQvLCAnJylgXG4gIGVuZFxuXG4gIGRlZiBzdWIocGF0dGVybiwgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmICghcGF0dGVybi4kJGlzX3JlZ2V4cCkge1xuICAgICAgICBwYXR0ZXJuID0gJGNvZXJjZV90byhwYXR0ZXJuLCAje1N0cmluZ30sICd0b19zdHInKTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybi5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCwgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc2VsZik7XG5cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAjeyR+ID0gbmlsfVxuICAgICAgICByZXN1bHQgPSBzZWxmLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAje01hdGNoRGF0YS5uZXcgYHBhdHRlcm5gLCBgbWF0Y2hgfVxuXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMSBmb3IgMiknfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIGJsb2NrKG1hdGNoWzBdKSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZW1lbnQuJCRpc19oYXNoKSB7XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICN7YHJlcGxhY2VtZW50YFtgbWF0Y2hbMF1gXS50b19zfSArIHNlbGYuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICByZXBsYWNlbWVudCA9ICRjb2VyY2VfdG8ocmVwbGFjZW1lbnQsICN7U3RyaW5nfSwgJ3RvX3N0cicpO1xuXG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudC5yZXBsYWNlKC8oW1xcXFxdKykoWzAtOSsmYCddKS9nLCBmdW5jdGlvbiAob3JpZ2luYWwsIHNsYXNoZXMsIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGlmIChzbGFzaGVzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbWF0Y2gubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFtpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICBjYXNlIFwiJlwiOiByZXR1cm4gc2xhc2hlcy5zbGljZSgxKSArIG1hdGNoWzBdO1xuICAgICAgICAgICAgY2FzZSBcImBcIjogcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzbGFzaGVzLnNsaWNlKDEpICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBkZWZhdWx0OiAgcmV0dXJuIHNsYXNoZXMuc2xpY2UoMSkgKyAobWF0Y2hbY29tbWFuZF0gfHwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIHJlcGxhY2VtZW50ICsgc2VsZi5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJCRjYXN0KHJlc3VsdCk7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzdWNjIG5leHRcblxuICBkZWYgc3VtKG4gPSAxNilcbiAgICAleHtcbiAgICAgIG4gPSAkY29lcmNlX3RvKG4sICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IHNlbGYuY2hhckNvZGVBdChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPD0gMCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0ICYgKE1hdGgucG93KDIsIG4pIC0gMSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc3dhcGNhc2VcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLnJlcGxhY2UoLyhbYS16XSspfChbQS1aXSspL2csIGZ1bmN0aW9uKCQwLCQxLCQyKSB7XG4gICAgICAgIHJldHVybiAkMSA/ICQwLnRvVXBwZXJDYXNlKCkgOiAkMC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZWxmLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7c2VsZi5jbGFzcy5uZXcgYHN0cmB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gcGFyc2VGbG9hdChzZWxmLnJlcGxhY2UoL18vZywgJycpKTtcblxuICAgICAgaWYgKGlzTmFOKHJlc3VsdCkgfHwgcmVzdWx0ID09IEluZmluaXR5IHx8IHJlc3VsdCA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19pKGJhc2UgPSAxMClcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgc3RyaW5nID0gc2VsZi50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgIHJhZGl4ID0gJGNvZXJjZV90byhiYXNlLCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChyYWRpeCA9PT0gMSB8fCByYWRpeCA8IDAgfHwgcmFkaXggPiAzNikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2ByYWRpeGB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmICgvXlxccypfLy50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC9eKFxccypbKy1dPykoMFtib2R4XT8pKC4rKSQvLCBmdW5jdGlvbiAob3JpZ2luYWwsIGhlYWQsIGZsYWcsIHRhaWwpIHtcbiAgICAgICAgc3dpdGNoICh0YWlsLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgICBpZiAodGFpbC5jaGFyQXQoMSkgPT09ICd4JyAmJiBmbGFnID09PSAnMHgnICYmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTYpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZmxhZykge1xuICAgICAgICBjYXNlICcwYic6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAyKSB7XG4gICAgICAgICAgICByYWRpeCA9IDI7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcwJzpcbiAgICAgICAgY2FzZSAnMG8nOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gOCkge1xuICAgICAgICAgICAgcmFkaXggPSA4O1xuICAgICAgICAgICAgcmV0dXJuIGhlYWQgKyB0YWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMGQnOlxuICAgICAgICAgIGlmIChyYWRpeCA9PT0gMCB8fCByYWRpeCA9PT0gMTApIHtcbiAgICAgICAgICAgIHJhZGl4ID0gMTA7XG4gICAgICAgICAgICByZXR1cm4gaGVhZCArIHRhaWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcweCc6XG4gICAgICAgICAgaWYgKHJhZGl4ID09PSAwIHx8IHJhZGl4ID09PSAxNikge1xuICAgICAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgICAgIHJldHVybiBoZWFkICsgdGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsXG4gICAgICB9KTtcblxuICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLnJlcGxhY2UoL18oPyFfKS9nLCAnJyksIHJhZGl4KTtcbiAgICAgIHJldHVybiBpc05hTihyZXN1bHQpID8gMCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgbWV0aG9kX25hbWUgPSAnJCcgKyBgc2VsZi52YWx1ZU9mKClgXG5cbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgJXh7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25vIHJlY2VpdmVyIGdpdmVuJ31cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN2ID0gYXJnc1swXTtcblxuICAgICAgICBpZiAocmVjdiA9PSBudWxsKSByZWN2ID0gbmlsO1xuXG4gICAgICAgIHZhciBib2R5ID0gcmVjdlsje21ldGhvZF9uYW1lfV07XG5cbiAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3YuJG1ldGhvZF9taXNzaW5nLmFwcGx5KHJlY3YsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBibG9jayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGJvZHkuJCRwID0gYmxvY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gYm9keS5jYWxsKHJlY3YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHJlY3YsIGFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgYHNlbGYudG9TdHJpbmcoKWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9fc3RyIHRvX3NcblxuICBhbGlhcyB0b19zeW0gaW50ZXJuXG5cbiAgZGVmIHRyKGZyb20sIHRvKVxuICAgICV4e1xuICAgICAgZnJvbSA9ICRjb2VyY2VfdG8oZnJvbSwgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcbiAgICAgIHRvID0gJGNvZXJjZV90byh0bywgI3tTdHJpbmd9LCAndG9fc3RyJykuJHRvX3MoKTtcblxuICAgICAgaWYgKGZyb20ubGVuZ3RoID09IDAgfHwgZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBpbl9yYW5nZSwgYywgY2gsIHN0YXJ0LCBlbmQsIGxlbmd0aDtcbiAgICAgIHZhciBzdWJzID0ge307XG4gICAgICB2YXIgZnJvbV9jaGFycyA9IGZyb20uc3BsaXQoJycpO1xuICAgICAgdmFyIGZyb21fbGVuZ3RoID0gZnJvbV9jaGFycy5sZW5ndGg7XG4gICAgICB2YXIgdG9fY2hhcnMgPSB0by5zcGxpdCgnJyk7XG4gICAgICB2YXIgdG9fbGVuZ3RoID0gdG9fY2hhcnMubGVuZ3RoO1xuXG4gICAgICB2YXIgaW52ZXJzZSA9IGZhbHNlO1xuICAgICAgdmFyIGdsb2JhbF9zdWIgPSBudWxsO1xuICAgICAgaWYgKGZyb21fY2hhcnNbMF0gPT09ICdeJyAmJiBmcm9tX2NoYXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaW52ZXJzZSA9IHRydWU7XG4gICAgICAgIGZyb21fY2hhcnMuc2hpZnQoKTtcbiAgICAgICAgZ2xvYmFsX3N1YiA9IHRvX2NoYXJzW3RvX2xlbmd0aCAtIDFdXG4gICAgICAgIGZyb21fbGVuZ3RoIC09IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBmcm9tX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICB2YXIgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IGZyb21fY2hhcnNbaV07XG4gICAgICAgIGlmIChsYXN0X2Zyb20gPT0gbnVsbCkge1xuICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgIGlmIChsYXN0X2Zyb20gPT09ICctJykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaSA9PSBmcm9tX2xlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICBzdGFydCA9IGxhc3RfZnJvbS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGVuZCA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnJvbV9jaGFycyA9IGZyb21fY2hhcnNfZXhwYW5kZWQ7XG4gICAgICBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuXG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZnJvbV9sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHN1YnNbZnJvbV9jaGFyc1tpXV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRvX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdG9fY2hhcnNfZXhwYW5kZWQgPSBbXTtcbiAgICAgICAgICB2YXIgbGFzdF90byA9IG51bGw7XG4gICAgICAgICAgaW5fcmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNoID0gdG9fY2hhcnNbaV07XG4gICAgICAgICAgICBpZiAobGFzdF90byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfdG8gPSBjaDtcbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0X3RvID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKGkgPT0gdG9fbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdF90by5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYW5nZSBcXFwiI3tgU3RyaW5nLmZyb21DaGFyQ29kZShzdGFydClgfS0je2BTdHJpbmcuZnJvbUNoYXJDb2RlKGVuZClgfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZvciAoYyA9IHN0YXJ0ICsgMTsgYyA8IGVuZDsgYysrKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgICAgaW5fcmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICBsYXN0X3RvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5ld19zdHIgPSAnJ1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBjaCA9IHNlbGYuY2hhckF0KGkpO1xuICAgICAgICB2YXIgc3ViID0gc3Vic1tjaF07XG4gICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgbmV3X3N0ciArPSAoc3ViID09IG51bGwgPyBnbG9iYWxfc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG5ld19zdHIgKz0gKHN1YiAhPSBudWxsID8gc3ViIDogY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi4kJGNhc3QobmV3X3N0cik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdHJfcyhmcm9tLCB0bylcbiAgICAleHtcbiAgICAgIGZyb20gPSAkY29lcmNlX3RvKGZyb20sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG4gICAgICB0byA9ICRjb2VyY2VfdG8odG8sICN7U3RyaW5nfSwgJ3RvX3N0cicpLiR0b19zKCk7XG5cbiAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgaSwgaW5fcmFuZ2UsIGMsIGNoLCBzdGFydCwgZW5kLCBsZW5ndGg7XG4gICAgICB2YXIgc3VicyA9IHt9O1xuICAgICAgdmFyIGZyb21fY2hhcnMgPSBmcm9tLnNwbGl0KCcnKTtcbiAgICAgIHZhciBmcm9tX2xlbmd0aCA9IGZyb21fY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIHRvX2NoYXJzID0gdG8uc3BsaXQoJycpO1xuICAgICAgdmFyIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcblxuICAgICAgdmFyIGludmVyc2UgPSBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxfc3ViID0gbnVsbDtcbiAgICAgIGlmIChmcm9tX2NoYXJzWzBdID09PSAnXicgJiYgZnJvbV9jaGFycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGludmVyc2UgPSB0cnVlO1xuICAgICAgICBmcm9tX2NoYXJzLnNoaWZ0KCk7XG4gICAgICAgIGdsb2JhbF9zdWIgPSB0b19jaGFyc1t0b19sZW5ndGggLSAxXVxuICAgICAgICBmcm9tX2xlbmd0aCAtPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgZnJvbV9jaGFyc19leHBhbmRlZCA9IFtdO1xuICAgICAgdmFyIGxhc3RfZnJvbSA9IG51bGw7XG4gICAgICBpbl9yYW5nZSA9IGZhbHNlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2ggPSBmcm9tX2NoYXJzW2ldO1xuICAgICAgICBpZiAobGFzdF9mcm9tID09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2Zyb20gPSBjaDtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICBpZiAobGFzdF9mcm9tID09PSAnLScpIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGkgPT0gZnJvbV9sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbl9yYW5nZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluX3JhbmdlKSB7XG4gICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBlbmQgPSBjaC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjID0gc3RhcnQgKyAxOyBjIDwgZW5kOyBjKyspIHtcbiAgICAgICAgICAgIGZyb21fY2hhcnNfZXhwYW5kZWQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnJvbV9jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICBpbl9yYW5nZSA9IG51bGw7XG4gICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tX2NoYXJzX2V4cGFuZGVkLnB1c2goY2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyb21fY2hhcnMgPSBmcm9tX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgZnJvbV9sZW5ndGggPSBmcm9tX2NoYXJzLmxlbmd0aDtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0b19sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvX2NoYXJzX2V4cGFuZGVkID0gW107XG4gICAgICAgICAgdmFyIGxhc3RfdG8gPSBudWxsO1xuICAgICAgICAgIGluX3JhbmdlID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHRvX2NoYXJzW2ldO1xuICAgICAgICAgICAgaWYgKGxhc3RfZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RfZnJvbSA9IGNoO1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RfdG8gPT09ICctJykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKCctJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSB0b19sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaCgnLScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluX3JhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5fcmFuZ2UpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBsYXN0X2Zyb20uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgZW5kID0gY2guY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnQpYH0tI3tgU3RyaW5nLmZyb21DaGFyQ29kZShlbmQpYH1cXFwiIGluIHN0cmluZyB0cmFuc2xpdGVyYXRpb25cIn1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGMgPSBzdGFydCArIDE7IGMgPCBlbmQ7IGMrKykge1xuICAgICAgICAgICAgICAgIHRvX2NoYXJzX2V4cGFuZGVkLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdG9fY2hhcnNfZXhwYW5kZWQucHVzaChjaCk7XG4gICAgICAgICAgICAgIGluX3JhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgbGFzdF9mcm9tID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB0b19jaGFyc19leHBhbmRlZC5wdXNoKGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b19jaGFycyA9IHRvX2NoYXJzX2V4cGFuZGVkO1xuICAgICAgICAgIHRvX2xlbmd0aCA9IHRvX2NoYXJzLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IGZyb21fbGVuZ3RoIC0gdG9fbGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoX2RpZmYgPiAwKSB7XG4gICAgICAgICAgdmFyIHBhZF9jaGFyID0gKHRvX2xlbmd0aCA+IDAgPyB0b19jaGFyc1t0b19sZW5ndGggLSAxXSA6ICcnKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoX2RpZmY7IGkrKykge1xuICAgICAgICAgICAgdG9fY2hhcnMucHVzaChwYWRfY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZyb21fbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdWJzW2Zyb21fY2hhcnNbaV1dID0gdG9fY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBuZXdfc3RyID0gJydcbiAgICAgIHZhciBsYXN0X3N1YnN0aXR1dGUgPSBudWxsXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoID0gc2VsZi5jaGFyQXQoaSk7XG4gICAgICAgIHZhciBzdWIgPSBzdWJzW2NoXVxuICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgIGlmIChzdWIgPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxhc3Rfc3Vic3RpdHV0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5ld19zdHIgKz0gZ2xvYmFsX3N1YjtcbiAgICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xuICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHN1YiAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobGFzdF9zdWJzdGl0dXRlID09IG51bGwgfHwgbGFzdF9zdWJzdGl0dXRlICE9PSBzdWIpIHtcbiAgICAgICAgICAgICAgbmV3X3N0ciArPSBzdWI7XG4gICAgICAgICAgICAgIGxhc3Rfc3Vic3RpdHV0ZSA9IHN1YjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdfc3RyICs9IGNoO1xuICAgICAgICAgICAgbGFzdF9zdWJzdGl0dXRlID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLiQkY2FzdChuZXdfc3RyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1cGNhc2VcbiAgICBgc2VsZi4kJGNhc3Qoc2VsZi50b1VwcGVyQ2FzZSgpKWBcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgZXhjbCA9IGZhbHNlLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDp1cHRvLCBzdG9wLCBleGNsIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAleHtcbiAgICAgIHZhciBhLCBiLCBzID0gc2VsZi50b1N0cmluZygpO1xuXG4gICAgICBzdG9wID0gJGNvZXJjZV90byhzdG9wLCAje1N0cmluZ30sICd0b19zdHInKTtcblxuICAgICAgaWYgKHMubGVuZ3RoID09PSAxICYmIHN0b3AubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgYSA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgYiA9IHN0b3AuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICB3aGlsZSAoYSA8PSBiKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgYSA9PT0gYikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2soU3RyaW5nLmZyb21DaGFyQ29kZShhKSk7XG5cbiAgICAgICAgICBhICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChwYXJzZUludChzLCAxMCkudG9TdHJpbmcoKSA9PT0gcyAmJiBwYXJzZUludChzdG9wLCAxMCkudG9TdHJpbmcoKSA9PT0gc3RvcCkge1xuXG4gICAgICAgIGEgPSBwYXJzZUludChzLCAxMCk7XG4gICAgICAgIGIgPSBwYXJzZUludChzdG9wLCAxMCk7XG5cbiAgICAgICAgd2hpbGUgKGEgPD0gYikge1xuICAgICAgICAgIGlmIChleGNsICYmIGEgPT09IGIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJsb2NrKGEudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICBhICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB3aGlsZSAocy5sZW5ndGggPD0gc3RvcC5sZW5ndGggJiYgcyA8PSBzdG9wKSB7XG4gICAgICAgICAgaWYgKGV4Y2wgJiYgcyA9PT0gc3RvcCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmxvY2socyk7XG5cbiAgICAgICAgICBzID0gI3tgc2Auc3VjY307XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiBjaGFyX2NsYXNzX2Zyb21fY2hhcl9zZXRzKHNldHMpIHtcbiAgICAgIGZ1bmN0aW9uIGV4cGxvZGVfc2VxdWVuY2VzX2luX2NoYXJhY3Rlcl9zZXQoc2V0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAgIGksIGxlbiA9IHNldC5sZW5ndGgsXG4gICAgICAgICAgICBjdXJyX2NoYXIsXG4gICAgICAgICAgICBza2lwX25leHRfZGFzaCxcbiAgICAgICAgICAgIGNoYXJfY29kZV9mcm9tLFxuICAgICAgICAgICAgY2hhcl9jb2RlX3VwdG8sXG4gICAgICAgICAgICBjaGFyX2NvZGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGN1cnJfY2hhciA9IHNldC5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKGN1cnJfY2hhciA9PT0gJy0nICYmIGkgPiAwICYmIGkgPCAobGVuIC0gMSkgJiYgIXNraXBfbmV4dF9kYXNoKSB7XG4gICAgICAgICAgICBjaGFyX2NvZGVfZnJvbSA9IHNldC5jaGFyQ29kZUF0KGkgLSAxKTtcbiAgICAgICAgICAgIGNoYXJfY29kZV91cHRvID0gc2V0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICAgICAgaWYgKGNoYXJfY29kZV9mcm9tID4gY2hhcl9jb2RlX3VwdG8pIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgcmFuZ2UgXFxcIiN7YGNoYXJfY29kZV9mcm9tYH0tI3tgY2hhcl9jb2RlX3VwdG9gfVxcXCIgaW4gc3RyaW5nIHRyYW5zbGl0ZXJhdGlvblwifVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjaGFyX2NvZGUgPSBjaGFyX2NvZGVfZnJvbSArIDE7IGNoYXJfY29kZSA8IGNoYXJfY29kZV91cHRvICsgMTsgY2hhcl9jb2RlKyspIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcl9jb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNraXBfbmV4dF9kYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2tpcF9uZXh0X2Rhc2ggPSAoY3Vycl9jaGFyID09PSAnXFxcXCcpO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGN1cnJfY2hhcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKHNldEEsIHNldEIpIHtcbiAgICAgICAgaWYgKHNldEEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHNldEI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnLFxuICAgICAgICAgICAgaSwgbGVuID0gc2V0QS5sZW5ndGgsXG4gICAgICAgICAgICBjaHI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNociA9IHNldEEuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChzZXRCLmluZGV4T2YoY2hyKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBpLCBsZW4sIHNldCwgbmVnLCBjaHIsIHRtcCxcbiAgICAgICAgICBwb3NfaW50ZXJzZWN0aW9uID0gJycsXG4gICAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9ICcnO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHNldCA9ICRjb2VyY2VfdG8oc2V0c1tpXSwgI3tTdHJpbmd9LCAndG9fc3RyJyk7XG4gICAgICAgIG5lZyA9IChzZXQuY2hhckF0KDApID09PSAnXicgJiYgc2V0Lmxlbmd0aCA+IDEpO1xuICAgICAgICBzZXQgPSBleHBsb2RlX3NlcXVlbmNlc19pbl9jaGFyYWN0ZXJfc2V0KG5lZyA/IHNldC5zbGljZSgxKSA6IHNldCk7XG4gICAgICAgIGlmIChuZWcpIHtcbiAgICAgICAgICBuZWdfaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uKG5lZ19pbnRlcnNlY3Rpb24sIHNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbihwb3NfaW50ZXJzZWN0aW9uLCBzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgJiYgbmVnX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRtcCA9ICcnO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwb3NfaW50ZXJzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY2hyID0gcG9zX2ludGVyc2VjdGlvbi5jaGFyQXQoaSk7XG4gICAgICAgICAgaWYgKG5lZ19pbnRlcnNlY3Rpb24uaW5kZXhPZihjaHIpID09PSAtMSkge1xuICAgICAgICAgICAgdG1wICs9IGNocjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zX2ludGVyc2VjdGlvbiA9IHRtcDtcbiAgICAgICAgbmVnX2ludGVyc2VjdGlvbiA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zX2ludGVyc2VjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiAnWycgKyAje1JlZ2V4cC5lc2NhcGUoYHBvc19pbnRlcnNlY3Rpb25gKX0gKyAnXSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWdfaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuICdbXicgKyAje1JlZ2V4cC5lc2NhcGUoYG5lZ19pbnRlcnNlY3Rpb25gKX0gKyAnXSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBpbnN0YW5jZV92YXJpYWJsZXNcbiAgICBbXVxuICBlbmRcblxuICBkZWYgc2VsZi5fbG9hZCgqYXJncylcbiAgICBuZXcoKmFyZ3MpXG4gIGVuZFxuXG4gIGRlZiB1bmljb2RlX25vcm1hbGl6ZShmb3JtID0gOm5mYylcbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIkludmFsaWQgbm9ybWFsaXphdGlvbiBmb3JtICN7Zm9ybX1cIiB1bmxlc3MgJWlbbmZjIG5mZCBuZmtjIG5ma2RdLmluY2x1ZGU/KGZvcm0pXG4gICAgYHNlbGYubm9ybWFsaXplKCN7Zm9ybS51cGNhc2V9KWBcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplZD8oZm9ybSA9IDpuZmMpXG4gICAgdW5pY29kZV9ub3JtYWxpemUoZm9ybSkgPT0gc2VsZlxuICBlbmRcblxuICBkZWYgdW5wYWNrKGZvcm1hdClcbiAgICByYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrLCB5b3UgbXVzdCBmaXJzdCByZXF1aXJlICdjb3JlbGliL3N0cmluZy91bnBhY2snLlwiXG4gIGVuZFxuXG4gIGRlZiB1bnBhY2sxKGZvcm1hdClcbiAgICByYWlzZSBcIlRvIHVzZSBTdHJpbmcjdW5wYWNrMSwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvdW5wYWNrJy5cIlxuICBlbmRcblxuICBkZWYgZnJlZXplXG4gICAgJXh7XG4gICAgICBpZiAodHlwZW9mIHNlbGYgPT09ICdzdHJpbmcnKSByZXR1cm4gc2VsZjtcbiAgICAgIHNlbGYuJCRmcm96ZW4gPSB0cnVlO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyArQCBkdXBcblxuICBkZWYgLUBcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRmcm96ZW4gPT09IHRydWUpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnICYmIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcubmFtZSA9PSAnVVRGLTgnKSByZXR1cm4gc2VsZi50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHNlbGYuJGR1cCgpLiRmcmVlemUoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYHR5cGVvZiBzZWxmID09PSAnc3RyaW5nJyB8fCBzZWxmLiQkZnJvemVuID09PSB0cnVlYFxuICBlbmRcblxuICBPcGFsLnByaXN0aW5lIHNlbGYsIDppbml0aWFsaXplXG5lbmRcblxuU3ltYm9sID0gU3RyaW5nXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlN0cmluZz4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsIl9faWRfXyIsInRyeV9jb252ZXJ0Iiwid2hhdCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiU3RyaW5nIiwibmV3IiwiaW5pdGlhbGl6ZSIsImFyZ3MiLCIlIiwiZGF0YSIsIkFycmF5IiwiPT09IiwiZm9ybWF0IiwiKiIsImNvdW50IiwiSW50ZWdlciIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIlJhbmdlRXJyb3IiLCIrIiwib3RoZXIiLCI8PT4iLCJyZXNwb25kX3RvPyIsInRvX3N0ciIsInRvX3MiLCI9PSIsIj1+IiwiVHlwZUVycm9yIiwiW10iLCJpbmRleCIsImxlbmd0aCIsIiR+IiwiTWF0Y2hEYXRhIiwiYiIsImZvcmNlX2VuY29kaW5nIiwiY2FwaXRhbGl6ZSIsImNhc2VjbXAiLCJjYXNlY21wPyIsImNlbnRlciIsIndpZHRoIiwicGFkc3RyIiwiZW1wdHk/IiwibGp1c3QiLCIvIiwiMiIsImNlaWwiLCJyanVzdCIsImZsb29yIiwiY2hvbXAiLCJzZXBhcmF0b3IiLCIkLyIsImNvZXJjZV90byEiLCJjaG9wIiwiY2hyIiwiY2xvbmUiLCJjb3B5IiwiY29weV9zaW5nbGV0b25fbWV0aG9kcyIsImluaXRpYWxpemVfY2xvbmUiLCJkdXAiLCJpbml0aWFsaXplX2R1cCIsImRlbGV0ZSIsImRlbGV0ZV9wcmVmaXgiLCJwcmVmaXgiLCJkZWxldGVfc3VmZml4Iiwic3VmZml4IiwiZG93bmNhc2UiLCJlYWNoX2xpbmUiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImVuZF93aXRoPyIsImdzdWIiLCJwYXR0ZXJuIiwicmVwbGFjZW1lbnQiLCJoYXNoIiwiaGV4IiwidG9faSIsIjE2IiwiaW5jbHVkZT8iLCJzZWFyY2giLCJvZmZzZXQiLCJpbnNwZWN0IiwiaW50ZXJuIiwibGluZXMiLCJlIiwiYmxvY2siLCJ0b19wcm9jIiwidG9fYSIsImxzdHJpcCIsImFzY2lpX29ubHk/IiwibWF0Y2giLCJwb3MiLCIkcmV0X29yXzEiLCJSZWdleHAiLCJjbGFzcyIsIm1hdGNoPyIsIiRyZXRfb3JfMiIsIm5leHQiLCJvY3QiLCJvcmQiLCJwYXJ0aXRpb24iLCJzZXAiLCJyZXZlcnNlIiwicmluZGV4IiwicnBhcnRpdGlvbiIsInJzdHJpcCIsInNjYW4iLCJjYXB0dXJlcyIsInNwbGl0IiwibGltaXQiLCIkcmV0X29yXzMiLCIkOyIsInNxdWVlemUiLCJzdGFydF93aXRoPyIsInN0cmlwIiwic3ViIiwic3VtIiwibiIsInN3YXBjYXNlIiwidG9fZiIsImJhc2UiLCIxMCIsIm1ldGhvZF9uYW1lIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ0ciIsImZyb20iLCJ0byIsInRyX3MiLCJ1cGNhc2UiLCJ1cHRvIiwic3RvcCIsImV4Y2wiLCJzdWNjIiwiZXNjYXBlIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiX2xvYWQiLCJ1bmljb2RlX25vcm1hbGl6ZSIsImZvcm0iLCJ1bmljb2RlX25vcm1hbGl6ZWQ/IiwidW5wYWNrIiwidW5wYWNrMSIsImZyZWV6ZSIsIi1AIiwiZnJvemVuPyIsInByaXN0aW5lIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VB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SUFBeEJDO0FBQUFBLE1BQUFBOzs7O01BQXdCO01BQUEsU0FBTyxLQUFQO01BQUE7TUFDdEJBLE9BQUFqSixJQUFBK0ksbUJBQUFBLENBQWtCQyxJQUFsQkQsQ0FBd0JoSCxPQUFBQSxDQUFHL0IsSUFBSCtCO0lBRDFCa0gsQ0FBQUEsaURBQUFBOztBQUlBQyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFXaEksTUFBWGdJO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBbEosSUFBQXNCLE9BQUFBLENBQU00SCx1RUFBTjVIO0lBREY0SCxDQUFBQSwrQkFBQUE7O0FBSUFDLElBQUFBLDJCQUFBQSxxQkFBQUEsbUJBQVlqSSxNQUFaaUk7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFuSixJQUFBc0IsT0FBQUEsQ0FBTTZILHdFQUFON0g7SUFERjZILENBQUFBLGdDQUFBQTs7QUFJQUMsSUFBQUEsMEJBQUFBLG9CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFQSxDQUFBQSwrQkFBQUE7SUFRQSxhQUFNLElBQU4sRUFBUyxLQUFUOztBQUVBQyxJQUFBQSxzQkFBQUEscUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFORUEsQ0FBQUEsZ0NBQUFBOztBQVNBQyxJQUFBQSwyQkFBQUEseUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxrREFBREE7SUFERkEsQ0FBQUEsb0NBQUFBO0lBSUFwSixPQUFBTSxvQkFBSStJLFVBQUFBLENBQVV2SixJQUFkLEVBQW9CLFlBQWhCdUo7RUFqMUROckosR0FBQUEsV0FBQUEsRUFBZ0JILE1BQWhCRztFQW8xREFILE9BQUEsc0NBQVNXLHNCQUFUO0FBejFEQVg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjk0MzQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2VudW1lcmFibGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeSwgdHJ1dGh5LCBjb2VyY2VfdG9cblxubW9kdWxlIEVudW1lcmFibGVcbiAgJXh7XG4gICAgZnVuY3Rpb24gY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBbbmlsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZGVmIGFsbD8ocGF0dGVybiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIHJldHVybiBmYWxzZSB1bmxlc3MgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgdW5sZXNzIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBhbnk/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gdHJ1ZSBpZiBwYXR0ZXJuLnB1YmxpY19zZW5kKDo9PT0sICpjb21wYXJhYmxlKVxuICAgICAgZW5kXG4gICAgZWxzaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIHlpZWxkKCp2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIGNodW5rKCZibG9jaylcbiAgICByZXR1cm4gdG9fZW51bSg6Y2h1bmspIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgOjpFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgcHJldmlvdXMgPSBuaWwsIGFjY3VtdWxhdGUgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiByZWxlYXNlQWNjdW11bGF0ZSgpIHtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAje3lpZWxkZXIueWllbGQoYHByZXZpb3VzYCwgYGFjY3VtdWxhdGVgKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGtleSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoa2V5ID09PSBuaWwpIHtcbiAgICAgICAgICAgIHJlbGVhc2VBY2N1bXVsYXRlKCk7XG4gICAgICAgICAgICBhY2N1bXVsYXRlID0gW107XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5pbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSBuaWwgfHwgcHJldmlvdXMgPT09IGtleSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVsZWFzZUFjY3VtdWxhdGUoKTtcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFt2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByZXZpb3VzID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICByZWxlYXNlQWNjdW11bGF0ZSgpO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2h1bmtfd2hpbGUoJmJsb2NrKVxuICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdubyBibG9jayBnaXZlbicgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2xpY2Vfd2hlbiB7IHxiZWZvcmUsIGFmdGVyfCAhKHlpZWxkIGJlZm9yZSwgYWZ0ZXIpIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29sbGVjdCkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbGxlY3RfY29uY2F0KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmNvbGxlY3RfY29uY2F0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBtYXAgeyB8aXRlbXwgeWllbGQgaXRlbSB9LmZsYXR0ZW4oMSlcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHJlc3VsdCA9IDBcblxuICAgICV4e1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIGBvYmplY3QgIT0gbnVsbGBcbiAgICAgIGJsb2NrID0gcHJvYyBkbyB8KmFyZ3N8XG4gICAgICAgIE9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqZWN0XG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9jay5uaWw/XG4gICAgICBibG9jayA9IHByb2MgeyB0cnVlIH1cbiAgICBlbmRcblxuICAgIGVhY2ggZG8gfCphcmdzfFxuICAgICAgYHJlc3VsdCsrYCBpZiBgT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpYFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBjeWNsZShuID0gbmlsLCAmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpjeWNsZSwgbikgZG9cbiAgICAgICAgaWYgbi5uaWw/XG4gICAgICAgICAgcmVzcG9uZF90bz8oOnNpemUpID8gRmxvYXQ6OklORklOSVRZIDogbmlsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBuID0gT3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpXG4gICAgICAgICAgbiA+IDAgPyBlbnVtZXJhdG9yX3NpemUgKiBuIDogMFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgbiA9IE9wYWwuY29lcmNlX3RvISBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAgIHJldHVybiBpZiBgbiA8PSAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgYWxsID0gW10sIGksIGxlbmd0aCwgdmFsdWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGFsbC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICBpZiAoYWxsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYWxsLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBhbGxbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHdoaWxlIChuID4gMSkge1xuICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFsbC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgYWxsW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZXRlY3QoaWZub25lID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkZXRlY3QsIGlmbm9uZSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIHZhbHVlID0gT3BhbC5kZXN0cnVjdHVyZShhcmdzKVxuICAgICAgaWYgeWllbGQodmFsdWUpXG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmIChpZm5vbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mKGlmbm9uZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaWZub25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGlmbm9uZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgZHJvcChudW1iZXIpXG4gICAgbnVtYmVyID0gYCRjb2VyY2VfdG8obnVtYmVyLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIGRyb3AgbmVnYXRpdmUgc2l6ZSdcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCAgPSBbXSxcbiAgICAgICAgICBjdXJyZW50ID0gMDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG51bWJlciA8PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCsrO1xuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpXG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHJvcF93aGlsZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpkcm9wX3doaWxlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCAgID0gW10sXG4gICAgICAgICAgZHJvcHBpbmcgPSB0cnVlO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBpZiAoZHJvcHBpbmcpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgaWYgKCRmYWxzeSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRyb3BwaW5nID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY29ucyhuLCAmYmxvY2spXG4gICAgaWYgYGFyZ3VtZW50cy5sZW5ndGggIT0gMWBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAxKVwiXG4gICAgZW5kXG5cbiAgICBuID0gT3BhbC50cnlfY29udmVydCBuLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBgbiA8PSAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2ludmFsaWQgc2l6ZSdcbiAgICBlbmRcblxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9jb25zLCBuKSBkb1xuICAgICAgICBlbnVtX3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgICAgaWYgZW51bV9zaXplLm5pbD9cbiAgICAgICAgICBuaWxcbiAgICAgICAgZWxzaWYgZW51bV9zaXplID09IDAgfHwgZW51bV9zaXplIDwgblxuICAgICAgICAgIDBcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGVudW1fc2l6ZSAtIG4gKyAxXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciBidWZmZXIgPSBbXTtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgYnVmZmVyLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gbikge1xuICAgICAgICAgIGJ1ZmZlci5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG4pIHtcbiAgICAgICAgICBPcGFsLnlpZWxkMShibG9jaywgYnVmZmVyLnNsaWNlKDAsIG4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9lbnRyeSgqZGF0YSwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiB0b19lbnVtKDplYWNoX2VudHJ5LCAqZGF0YSkgeyBlbnVtZXJhdG9yX3NpemUgfVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXRlbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaC5hcHBseShzZWxmLCBkYXRhKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9zbGljZShuLCAmYmxvY2spXG4gICAgbiA9IGAkY29lcmNlX3RvKCN7bn0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBuIDw9IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnaW52YWxpZCBzbGljZSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3NsaWNlLCBuKSB7IHJlc3BvbmRfdG8/KDpzaXplKSA/IChzaXplIC8gbikuY2VpbCA6IG5pbCB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHNsaWNlID0gW11cblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgc2xpY2UucHVzaChwYXJhbSk7XG5cbiAgICAgICAgaWYgKHNsaWNlLmxlbmd0aCA9PT0gbikge1xuICAgICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAvLyBvdXIgXCJsYXN0XCIgZ3JvdXAsIGlmIHNtYWxsZXIgdGhhbiBuIHRoZW4gd29uJ3QgaGF2ZSBiZWVuIHlpZWxkZWRcbiAgICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIE9wYWwueWllbGQxKGJsb2NrLCBzbGljZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBlYWNoX3dpdGhfaW5kZXgoKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfd2l0aF9pbmRleCwgKmFyZ3MpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfd2l0aF9vYmplY3Qob2JqZWN0LCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3dpdGhfb2JqZWN0LCBvYmplY3QpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcblxuICAgICAgICBibG9jayhwYXJhbSwgb2JqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcbiAgICB9XG5cbiAgICBvYmplY3RcbiAgZW5kXG5cbiAgZGVmIGVudHJpZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2guYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmlsdGVyX21hcCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpmaWx0ZXJfbWFwKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIG1hcCgmYmxvY2spLnNlbGVjdCgmOml0c2VsZilcbiAgZW5kXG5cbiAgYWxpYXMgZmluZCBkZXRlY3RcblxuICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZmluZF9hbGwpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG5cbiAgZGVmIGZpbmRfaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpmaW5kX2luZGV4IGlmIGBvYmplY3QgPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuXG4gICAgJXh7XG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5kZXggPSAwXG5cbiAgICBpZiBgb2JqZWN0ICE9IG51bGxgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUodmFsdWUpID09IG9iamVjdFxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgaWYgeWllbGQoKnZhbHVlKVxuICAgICAgICAgIHJldHVybiBpbmRleFxuICAgICAgICBlbmRcblxuICAgICAgICBgaW5kZXggKz0gMWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChudW1iZXIgPSB1bmRlZmluZWQpXG4gICAgaWYgYG51bWJlciA9PT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8dmFsdWV8XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgcmVzdWx0ID0gW11cbiAgICAgIG51bWJlciA9IGAkY29lcmNlX3RvKG51bWJlciwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBgbnVtYmVyIDwgMGBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2F0dGVtcHQgdG8gdGFrZSBuZWdhdGl2ZSBzaXplJ1xuICAgICAgZW5kXG5cbiAgICAgIGlmIGBudW1iZXIgPT0gMGBcbiAgICAgICAgcmV0dXJuIFtdXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudCA9IDBcblxuICAgICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICAgIGByZXN1bHQucHVzaCgje09wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9KWBcblxuICAgICAgICBpZiBgbnVtYmVyIDw9ICsrY3VycmVudGBcbiAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBmbGF0X21hcCBjb2xsZWN0X2NvbmNhdFxuXG4gIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcbiAgICAgIG5leHQgdW5sZXNzIHBhdHRlcm4uX19zZW5kX18oOj09PSwgKmNtcClcbiAgICAgIGlmIGJsb2NrX2dpdmVuP1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV0gaWYgdmFsdWUubGVuZ3RoID4gMVxuICAgICAgICB2YWx1ZSA9IHlpZWxkKCp2YWx1ZSlcbiAgICAgIGVsc2lmIHZhbHVlLmxlbmd0aCA8PSAxXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF1cbiAgICAgIGVuZFxuXG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSlcbiAgICBlbmRcblxuICAgIHJlc3VsdFxuICBlbmRcblxuICBkZWYgZ3JlcF92KHBhdHRlcm4sICZibG9jaylcbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgY21wID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcbiAgICAgIG5leHQgaWYgcGF0dGVybi5fX3NlbmRfXyg6PT09LCAqY21wKVxuICAgICAgaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHZhbHVlID0gW3ZhbHVlXSBpZiB2YWx1ZS5sZW5ndGggPiAxXG4gICAgICAgIHZhbHVlID0geWllbGQoKnZhbHVlKVxuICAgICAgZWxzaWYgdmFsdWUubGVuZ3RoIDw9IDFcbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXVxuICAgICAgZW5kXG5cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiBncm91cF9ieSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpncm91cF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBoYXNoID0ge31cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgI3soaGFzaFtgdmFsdWVgXSB8fD0gW10pIDw8IGBwYXJhbWB9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhc2hcbiAgZW5kXG5cbiAgZGVmIGluY2x1ZGU/KG9iailcbiAgICBlYWNoIGRvIHwqYXJnc3xcbiAgICAgIGlmIE9wYWwuZGVzdHJ1Y3R1cmUoYXJncykgPT0gb2JqXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiBpbmplY3Qob2JqZWN0ID0gdW5kZWZpbmVkLCBzeW0gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3Q7XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIHN5bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIFtyZXN1bHQsIHZhbHVlXSk7XG5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc3ltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoISN7U3ltYm9sID09PSBvYmplY3R9KSB7XG4gICAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCIje29iamVjdC5pbnNwZWN0fSBpcyBub3QgYSBTeW1ib2xcIn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3ltICAgID0gb2JqZWN0O1xuICAgICAgICAgIHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG5cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9ICN7YHJlc3VsdGAuX19zZW5kX18gc3ltLCBgdmFsdWVgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsYXp5XG4gICAgRW51bWVyYXRvcjo6TGF6eS5uZXcoc2VsZiwgZW51bWVyYXRvcl9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZW51bWVyYXRvcl9zaXplXG4gICAgcmVzcG9uZF90bz8oOnNpemUpID8gc2l6ZSA6IG5pbFxuICBlbmRcblxuICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gIGRlZiBtYXgobiA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZCB8fCBuID09PSBuaWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG5cbiAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBbaXRlbSwgcmVzdWx0XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gI3tgaXRlbWAgPD0+IGByZXN1bHRgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgIH1cblxuICAgIHNvcnQoJmJsb2NrKS5yZXZlcnNlLmZpcnN0KG4pXG4gIGVuZFxuXG4gIGRlZiBtYXhfYnkobiA9IG5pbCwgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6bWF4X2J5LCBuKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgdW5sZXNzIG4ubmlsP1xuICAgICAgcmV0dXJuIHNvcnRfYnkoJmJsb2NrKS5yZXZlcnNlLnRha2UgblxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIGJ5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICBieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoI3tgdmFsdWVgIDw9PiBgYnlgfSA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBwYXJhbVxuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IG5pbCA6IHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIG1lbWJlcj8gaW5jbHVkZT9cblxuICBkZWYgbWluKG4gPSBuaWwsICZibG9jaylcbiAgICB1bmxlc3Mgbi5uaWw/XG4gICAgICBpZiBibG9ja19naXZlbj9cbiAgICAgICAgcmV0dXJuIHNvcnQgeyB8YSwgYnwgeWllbGQgYSwgYiB9LnRha2UgblxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gc29ydC50YWtlIG5cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBibG9jayhwYXJhbSwgcmVzdWx0KTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdjb21wYXJpc29uIGZhaWxlZCd9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9O1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBwYXJhbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoI3tPcGFsLmNvbXBhcmUoYHBhcmFtYCwgYHJlc3VsdGApfSA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBuaWwgOiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWluX2J5KG4gPSBuaWwsICZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbl9ieSwgbikgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgIHVubGVzcyBuLm5pbD9cbiAgICAgIHJldHVybiBzb3J0X2J5KCZibG9jaykudGFrZSBuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsXG4gICAgICAgICAgYnk7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIGJ5ICAgICA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2B2YWx1ZWAgPD0+IGBieWB9IDwgMCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcmFtXG4gICAgICAgICAgYnkgICAgID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gbmlsIDogcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1pbm1heCgmYmxvY2spXG4gICAgYmxvY2sgfHw9IHByb2MgeyB8YSwgYnwgYSA8PT4gYiB9XG5cbiAgICAleHtcbiAgICAgIHZhciBtaW4gPSBuaWwsIG1heCA9IG5pbCwgZmlyc3RfdGltZSA9IHRydWU7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX07XG4gICAgICAgIGlmIChmaXJzdF90aW1lKSB7XG4gICAgICAgICAgbWluID0gbWF4ID0gZWxlbWVudDtcbiAgICAgICAgICBmaXJzdF90aW1lID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1pbl9jbXAgPSAje2Jsb2NrLmNhbGwoYG1pbmAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1pbl9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWluX2NtcCA+IDApIHtcbiAgICAgICAgICAgIG1pbiA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG1heF9jbXAgPSAje2Jsb2NrLmNhbGwoYG1heGAsIGBlbGVtZW50YCl9O1xuXG4gICAgICAgICAgaWYgKG1heF9jbXAgPT09IG5pbCkge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnY29tcGFyaXNvbiBmYWlsZWQnfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWF4X2NtcCA8IDApIHtcbiAgICAgICAgICAgIG1heCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJGVhY2goKTtcblxuICAgICAgcmV0dXJuIFttaW4sIG1heF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgbWlubWF4X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOm1pbm1heF9ieSkgeyBlbnVtZXJhdG9yX3NpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIG1pbl9yZXN1bHQgPSBuaWwsXG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IG5pbCxcbiAgICAgICAgICBtaW5fYnksXG4gICAgICAgICAgbWF4X2J5O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoKG1pbl9ieSA9PT0gdW5kZWZpbmVkKSB8fCAje2B2YWx1ZWAgPD0+IGBtaW5fYnlgfSA8IDApIHtcbiAgICAgICAgICBtaW5fcmVzdWx0ID0gcGFyYW07XG4gICAgICAgICAgbWluX2J5ICAgICA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXhfYnkgPT09IHVuZGVmaW5lZCkgfHwgI3tgdmFsdWVgIDw9PiBgbWF4X2J5YH0gPiAwKSB7XG4gICAgICAgICAgbWF4X3Jlc3VsdCA9IHBhcmFtO1xuICAgICAgICAgIG1heF9ieSAgICAgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW21pbl9yZXN1bHQsIG1heF9yZXN1bHRdO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG5vbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkYFxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBjb21wYXJhYmxlID0gYGNvbXBhcmFibGVGb3JQYXR0ZXJuKHZhbHVlKWBcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgcGF0dGVybi5wdWJsaWNfc2VuZCg6PT09LCAqY29tcGFyYWJsZSlcbiAgICAgIGVuZFxuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpZiB5aWVsZCgqdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBpdGVtID0gT3BhbC5kZXN0cnVjdHVyZSh2YWx1ZSlcblxuICAgICAgICByZXR1cm4gZmFsc2UgaWYgaXRlbVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBvbmU/KHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBjb3VudCA9IDBcblxuICAgIGlmIGBwYXR0ZXJuICE9PSB1bmRlZmluZWRgXG4gICAgICBlYWNoIGRvIHwqdmFsdWV8XG4gICAgICAgIGNvbXBhcmFibGUgPSBgY29tcGFyYWJsZUZvclBhdHRlcm4odmFsdWUpYFxuXG4gICAgICAgIGlmIHBhdHRlcm4ucHVibGljX3NlbmQoOj09PSwgKmNvbXBhcmFibGUpXG4gICAgICAgICAgY291bnQgKz0gMVxuICAgICAgICAgIHJldHVybiBmYWxzZSBpZiBjb3VudCA+IDFcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbHNpZiBibG9ja19naXZlbj9cbiAgICAgIGVhY2ggZG8gfCp2YWx1ZXxcbiAgICAgICAgbmV4dCB1bmxlc3MgeWllbGQoKnZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgZWFjaCBkbyB8KnZhbHVlfFxuICAgICAgICBuZXh0IHVubGVzcyBPcGFsLmRlc3RydWN0dXJlKHZhbHVlKVxuICAgICAgICBjb3VudCArPSAxXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlIGlmIGNvdW50ID4gMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBjb3VudCA9PSAxXG4gIGVuZFxuXG4gIGRlZiBwYXJ0aXRpb24oJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cGFydGl0aW9uKSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHRydXRoeSA9IFtdLCBmYWxzeSA9IFtdLCByZXN1bHQ7XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgIHRydXRoeS5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmYWxzeS5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gW3RydXRoeSwgZmFsc3ldO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgcmVkdWNlIGluamVjdFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IGVudW1lcmF0b3Jfc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHBhcmFtKTtcblxuICAgICAgICBpZiAoJGZhbHN5KHZhbHVlKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSByZXN1bHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgT3BhbC55aWVsZFgoYmxvY2ssIHJlc3VsdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzZWxlY3QgZmluZF9hbGxcblxuICBkZWYgc2xpY2VfYmVmb3JlKHBhdHRlcm4gPSB1bmRlZmluZWQsICZibG9jaylcbiAgICBpZiBgcGF0dGVybiA9PT0gdW5kZWZpbmVkICYmIGJsb2NrID09PSBuaWxgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYm90aCBwYXR0ZXJuIGFuZCBibG9jayBhcmUgZ2l2ZW4nXG4gICAgZW5kXG5cbiAgICBpZiBgcGF0dGVybiAhPT0gdW5kZWZpbmVkICYmIGJsb2NrICE9PSBuaWwgfHwgYXJndW1lbnRzLmxlbmd0aCA+IDFgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBleHBlY3RlZCAxKVwiXG4gICAgZW5kXG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8ZXxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBbXTtcblxuICAgICAgICBpZiAoYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pO1xuXG4gICAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSAmJiBzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKX0sXG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHBhcmFtLCAje3BhdHRlcm4uZHVwfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAje2UgPDwgYHNsaWNlYH07XG4gICAgICAgICAgICAgICAgc2xpY2UgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHNsaWNlLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc2VsZi4kZWFjaC4kJHAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9ICN7T3BhbC5kZXN0cnVjdHVyZShgYXJndW1lbnRzYCl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpICYmIHNsaWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzbGljZS5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi4kZWFjaCgpO1xuXG4gICAgICAgIGlmIChzbGljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgI3tlIDw8IGBzbGljZWB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzbGljZV9hZnRlcihwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgaWYgYHBhdHRlcm4gPT09IHVuZGVmaW5lZCAmJiBibG9jayA9PT0gbmlsYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ2JvdGggcGF0dGVybiBhbmQgYmxvY2sgYXJlIGdpdmVuJ1xuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsIHx8IGFyZ3VtZW50cy5sZW5ndGggPiAxYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2Bhcmd1bWVudHMubGVuZ3RoYH0gZXhwZWN0ZWQgMSlcIlxuICAgIGVuZFxuXG4gICAgaWYgYHBhdHRlcm4gIT09IHVuZGVmaW5lZGBcbiAgICAgIGJsb2NrID0gcHJvYyB7IHxlfCBwYXR0ZXJuID09PSBlIH1cbiAgICBlbmRcblxuICAgIEVudW1lcmF0b3IubmV3IGRvIHx5aWVsZGVyfFxuICAgICAgJXh7XG4gICAgICAgIHZhciBhY2N1bXVsYXRlO1xuXG4gICAgICAgIHNlbGYuJGVhY2guJCRwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgZW5kX2NodW5rID0gT3BhbC55aWVsZDEoYmxvY2ssIGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgYWNjdW11bGF0ZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkdHJ1dGh5KGVuZF9jaHVuaykpIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlLnB1c2goZWxlbWVudClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoKCk7XG5cbiAgICAgICAgaWYgKGFjY3VtdWxhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgYWNjdW11bGF0ZWApfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgc2xpY2Vfd2hlbigmYmxvY2spXG4gICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDAgZm9yIDEpJyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBFbnVtZXJhdG9yLm5ldyBkbyB8eWllbGRlcnxcbiAgICAgICV4e1xuICAgICAgICB2YXIgc2xpY2UgPSBuaWwsIGxhc3RfYWZ0ZXIgPSBuaWw7XG5cbiAgICAgICAgc2VsZi4kZWFjaF9jb25zLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwYXJhbXMgPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgICAgYmVmb3JlID0gcGFyYW1zWzBdLFxuICAgICAgICAgICAgICBhZnRlciA9IHBhcmFtc1sxXSxcbiAgICAgICAgICAgICAgbWF0Y2ggPSBPcGFsLnlpZWxkWChibG9jaywgW2JlZm9yZSwgYWZ0ZXJdKTtcblxuICAgICAgICAgIGxhc3RfYWZ0ZXIgPSBhZnRlcjtcblxuICAgICAgICAgIGlmIChzbGljZSA9PT0gbmlsKSB7XG4gICAgICAgICAgICBzbGljZSA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkdHJ1dGh5KG1hdGNoKSkge1xuICAgICAgICAgICAgc2xpY2UucHVzaChiZWZvcmUpO1xuICAgICAgICAgICAgI3t5aWVsZGVyLnlpZWxkKGBzbGljZWApfTtcbiAgICAgICAgICAgIHNsaWNlID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNsaWNlLnB1c2goYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLiRlYWNoX2NvbnMoMik7XG5cbiAgICAgICAgaWYgKHNsaWNlICE9PSBuaWwpIHtcbiAgICAgICAgICBzbGljZS5wdXNoKGxhc3RfYWZ0ZXIpO1xuICAgICAgICAgICN7eWllbGRlci55aWVsZChgc2xpY2VgKX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNvcnQoJmJsb2NrKVxuICAgIGFyeSA9IHRvX2FcbiAgICBibG9jayA9IC0+KGEsIGIpIHsgYSA8PT4gYiB9IHVubGVzcyBibG9ja19naXZlbj9cbiAgICBhcnkuc29ydCgmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBzb3J0X2J5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkpIHsgZW51bWVyYXRvcl9zaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgZHVwID0gbWFwIGRvXG4gICAgICBhcmcgPSBPcGFsLmRlc3RydWN0dXJlKGBhcmd1bWVudHNgKVxuICAgICAgW3lpZWxkKGFyZyksIGFyZ11cbiAgICBlbmRcbiAgICBkdXAuc29ydCEgeyB8YSwgYnwgYGFbMF1gIDw9PiBgYlswXWAgfVxuICAgIGR1cC5tYXAhIHsgfGl8IGBpWzFdYCB9XG4gIGVuZFxuXG4gIGRlZiBzdW0oaW5pdGlhbCA9IDApXG4gICAgcmVzdWx0ID0gaW5pdGlhbFxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICBpdGVtID0gaWYgYmxvY2tfZ2l2ZW4/XG4gICAgICAgICAgICAgICB5aWVsZCgqYXJncylcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICBPcGFsLmRlc3RydWN0dXJlKGFyZ3MpXG4gICAgICAgICAgICAgZW5kXG4gICAgICByZXN1bHQgKz0gaXRlbVxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB0YWtlKG51bSlcbiAgICBmaXJzdChudW0pXG4gIGVuZFxuXG4gIGRlZiB0YWtlX3doaWxlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IgOnRha2Vfd2hpbGUgdW5sZXNzIGJsb2NrXG5cbiAgICByZXN1bHQgPSBbXVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgdW5sZXNzIHlpZWxkKHZhbHVlKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICBlbmRcblxuICAgICAgYHJlc3VsdC5wdXNoKHZhbHVlKWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVuaXEoJmJsb2NrKVxuICAgIGhhc2ggPSB7fVxuXG4gICAgZWFjaCBkbyB8KmFyZ3N8XG4gICAgICB2YWx1ZSA9IE9wYWwuZGVzdHJ1Y3R1cmUoYXJncylcblxuICAgICAgcHJvZHVjZWQgPSBpZiBibG9ja19naXZlbj9cbiAgICAgICAgICAgICAgICAgICB5aWVsZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB1bmxlc3MgaGFzaC5rZXk/KHByb2R1Y2VkKVxuICAgICAgICBoYXNoW3Byb2R1Y2VkXSA9IHZhbHVlXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGhhc2gudmFsdWVzXG4gIGVuZFxuXG4gIGRlZiB0YWxseVxuICAgIGdyb3VwX2J5KCY6aXRzZWxmKS50cmFuc2Zvcm1fdmFsdWVzKCY6Y291bnQpXG4gIGVuZFxuXG4gIGFsaWFzIHRvX2EgZW50cmllc1xuXG4gIGRlZiB0b19oKCphcmdzLCAmYmxvY2spXG4gICAgcmV0dXJuIG1hcCgmYmxvY2spLnRvX2goKmFyZ3MpIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfTtcbiAgICAgICAgdmFyIGFyeSA9ICN7T3BhbC5jb2VyY2VfdG8/KGBwYXJhbWAsIEFycmF5LCA6dG9fYXJ5KX0sIGtleSwgdmFsO1xuICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsIFwid3JvbmcgZWxlbWVudCB0eXBlICN7YGFyeWAuY2xhc3N9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBhcnJheSBsZW5ndGggKGV4cGVjdGVkIDIsIHdhcyAje2BhcnlgLmxlbmd0aH0pXCJ9XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gYXJ5WzBdO1xuICAgICAgICB2YWwgPSBhcnlbMV07XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChoYXNoLCBrZXksIHZhbCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLiRlYWNoLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgIHRvX2EuemlwKCpvdGhlcnMpXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6RW51bWVyYWJsZT4iLCJhbGw/IiwicGF0dGVybiIsImVhY2giLCJzZWxmIiwiYmxvY2sgaW4gYWxsPyIsImJsb2NrICgyIGxldmVscykgaW4gYWxsPyIsImNvbXBhcmFibGUiLCJwdWJsaWNfc2VuZCIsImJsb2NrX2dpdmVuPyIsInZhbHVlIiwiT3BhbCIsImRlc3RydWN0dXJlIiwiYW55PyIsImJsb2NrIGluIGFueT8iLCJibG9jayAoMiBsZXZlbHMpIGluIGFueT8iLCJjaHVuayIsInRvX2VudW0iLCJibG9jayBpbiBjaHVuayIsImJsb2NrICgyIGxldmVscykgaW4gY2h1bmsiLCJlbnVtZXJhdG9yX3NpemUiLCJuZXciLCJFbnVtZXJhdG9yIiwieWllbGRlciIsInlpZWxkIiwiY2h1bmtfd2hpbGUiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJzbGljZV93aGVuIiwiYmxvY2sgaW4gY2h1bmtfd2hpbGUiLCJiZWZvcmUiLCJhZnRlciIsImJsb2NrICgyIGxldmVscykgaW4gY2h1bmtfd2hpbGUiLCIhIiwiY29sbGVjdCIsImVudW1fZm9yIiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwibWFwIiwiaXRlbSIsImZsYXR0ZW4iLCIxIiwiY291bnQiLCJvYmplY3QiLCJyZXN1bHQiLCIwIiwid2FybiIsImJsb2NrIiwicHJvYyIsImJsb2NrIGluIGNvdW50IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjb3VudCIsImFyZ3MiLCI9PSIsIm5pbD8iLCJjeWNsZSIsIm4iLCJibG9jayBpbiBjeWNsZSIsImJsb2NrICgyIGxldmVscykgaW4gY3ljbGUiLCJyZXNwb25kX3RvPyIsIkZsb2F0OjpJTkZJTklUWSIsIkZsb2F0IiwiY29lcmNlX3RvISIsIkludGVnZXIiLCI+IiwiKiIsImRldGVjdCIsImlmbm9uZSIsImJsb2NrIGluIGRldGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gZGV0ZWN0IiwiZHJvcCIsIm51bWJlciIsImRyb3Bfd2hpbGUiLCJlYWNoX2NvbnMiLCJ0cnlfY29udmVydCIsImJsb2NrIGluIGVhY2hfY29ucyIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9jb25zIiwiZW51bV9zaXplIiwiJHJldF9vcl8xIiwiPCIsIisiLCItIiwiZWFjaF9lbnRyeSIsImRhdGEiLCJibG9jayBpbiBlYWNoX2VudHJ5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2VudHJ5IiwiZWFjaF9zbGljZSIsImJsb2NrIGluIGVhY2hfc2xpY2UiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfc2xpY2UiLCIvIiwic2l6ZSIsImNlaWwiLCJlYWNoX3dpdGhfaW5kZXgiLCJibG9jayBpbiBlYWNoX3dpdGhfaW5kZXgiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfd2l0aF9pbmRleCIsImVhY2hfd2l0aF9vYmplY3QiLCJibG9jayBpbiBlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3dpdGhfb2JqZWN0IiwiZW50cmllcyIsImZpbHRlcl9tYXAiLCJibG9jayBpbiBmaWx0ZXJfbWFwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBmaWx0ZXJfbWFwIiwic2VsZWN0IiwidG9fcHJvYyIsImZpbmRfYWxsIiwiYmxvY2sgaW4gZmluZF9hbGwiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfYWxsIiwiZmluZF9pbmRleCIsImluZGV4IiwiYmxvY2sgaW4gZmluZF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZmluZF9pbmRleCIsImZpcnN0IiwiYmxvY2sgaW4gZmlyc3QiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpcnN0IiwiY3VycmVudCIsImdyZXAiLCJibG9jayBpbiBncmVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncmVwIiwiY21wIiwiX19zZW5kX18iLCJsZW5ndGgiLCI8PSIsIltdIiwicHVzaCIsImdyZXBfdiIsImJsb2NrIGluIGdyZXBfdiIsImJsb2NrICgyIGxldmVscykgaW4gZ3JlcF92IiwiZ3JvdXBfYnkiLCJibG9jayBpbiBncm91cF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gZ3JvdXBfYnkiLCJoYXNoIiwiJHJldF9vcl8yIiwiJHdyaXRlciIsIltdPSIsIjw8IiwiaW5jbHVkZT8iLCJvYmoiLCJibG9jayBpbiBpbmNsdWRlPyIsImJsb2NrICgyIGxldmVscykgaW4gaW5jbHVkZT8iLCJpbmplY3QiLCJzeW0iLCJTeW1ib2wiLCI9PT0iLCJUeXBlRXJyb3IiLCJpbnNwZWN0IiwibGF6eSIsIkVudW1lcmF0b3I6OkxhenkiLCJibG9jayBpbiBsYXp5IiwiZW51bSQiLCJibG9jayAoMiBsZXZlbHMpIGluIGxhenkiLCJtYXgiLCI8PT4iLCJzb3J0IiwicmV2ZXJzZSIsIm1heF9ieSIsImJsb2NrIGluIG1heF9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWF4X2J5Iiwic29ydF9ieSIsInRha2UiLCJtaW4iLCJibG9jayBpbiBtaW4iLCJhIiwiYiIsImJsb2NrICgyIGxldmVscykgaW4gbWluIiwiY29tcGFyZSIsIm1pbl9ieSIsImJsb2NrIGluIG1pbl9ieSIsImJsb2NrICgyIGxldmVscykgaW4gbWluX2J5IiwibWlubWF4IiwiJHJldF9vcl8zIiwiYmxvY2sgaW4gbWlubWF4IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5tYXgiLCJjYWxsIiwibWlubWF4X2J5IiwiYmxvY2sgaW4gbWlubWF4X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBtaW5tYXhfYnkiLCJub25lPyIsImJsb2NrIGluIG5vbmU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBub25lPyIsIm9uZT8iLCJibG9jayBpbiBvbmU/IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBvbmU/IiwicGFydGl0aW9uIiwiYmxvY2sgaW4gcGFydGl0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwYXJ0aXRpb24iLCJyZWplY3QiLCJibG9jayBpbiByZWplY3QiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlamVjdCIsInJldmVyc2VfZWFjaCIsImJsb2NrIGluIHJldmVyc2VfZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gcmV2ZXJzZV9lYWNoIiwic2xpY2VfYmVmb3JlIiwiYmxvY2sgaW4gc2xpY2VfYmVmb3JlIiwiZSIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2VfYmVmb3JlIiwiZHVwIiwic2xpY2VfYWZ0ZXIiLCJibG9jayBpbiBzbGljZV9hZnRlciIsImJsb2NrICgyIGxldmVscykgaW4gc2xpY2VfYWZ0ZXIiLCJibG9jayBpbiBzbGljZV93aGVuIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzbGljZV93aGVuIiwiYXJ5IiwidG9fYSIsImJsb2NrIGluIHNvcnQiLCJibG9jayAoMiBsZXZlbHMpIGluIHNvcnQiLCJibG9jayBpbiBzb3J0X2J5IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0X2J5IiwiYXJnIiwic29ydCEiLCJtYXAhIiwiaSIsInN1bSIsImluaXRpYWwiLCJibG9jayBpbiBzdW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHN1bSIsIm51bSIsInRha2Vfd2hpbGUiLCJibG9jayBpbiB0YWtlX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlX3doaWxlIiwidW5pcSIsImJsb2NrIGluIHVuaXEiLCJibG9jayAoMiBsZXZlbHMpIGluIHVuaXEiLCJwcm9kdWNlZCIsImtleT8iLCJ2YWx1ZXMiLCJ0YWxseSIsInRyYW5zZm9ybV92YWx1ZXMiLCJ0b19oIiwiY29lcmNlX3RvPyIsIkFycmF5IiwiY2xhc3MiLCJ6aXAiLCJvdGhlcnMiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7RUFFQUEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7O0FBRUFBO0FBQ0FB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QUFXNEwsUUFBQUEsRUFBTSxVQUFDL0ssSUFBRCxDQUFOK0ssQ0FBbEI7O0FBR0pBLGlCQUFtQixZQUFBLEVBQUdBOztBQUV0QkE7QUFDQUEsb0JBQXNCMU4sb0JBQUlDLGFBQUFBLENBQWN5TixTQUFkek4sQ0FBMEJ5TjtBQUNwREEsa0JBQW9CMU4sb0JBQUkyTixlQUFBQSxDQUFhRCxLQUFqQixFQUF5QkUscUJBQXpCLEVBQWdDLFFBQTVCRCxDQUFxQ0Q7QUFDN0RBO0FBQ0FBLFVBQVlqTyxJQUFBc0IsT0FBQUEsQ0FBTXVILHlCQUFOLEVBQWlCLEVBQUEsR0FBQSxxQkFBQSxHQUFBLENBQXNCb0YsQ0FBQ0EsR0FBREEsQ0FBS0csT0FBQUEsQ0FBQUEsQ0FBM0IsQ0FBQSxHQUFBLG1CQUFqQjlNO0FBQ1oyTTtBQUNBQTtBQUNBQSxVQUFZak8sSUFBQXNCLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSxzQ0FBQSxHQUFBLENBQXVDME0sQ0FBQ0EsR0FBREEsQ0FBSzNHLFFBQUFBLENBQUFBLENBQTVDLENBQUEsR0FBQSxHQUFyQmhHO0FBQ1oyTTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtJQXhCRUEsQ0FBQUEsbUNBQUFBO0lBMkJBck8sT0FBQXlPLENBQUFBLHVCQUFBQSxzQkFBQUEsZUFodkNGLEVBZ3ZDRUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBaUI7O01BaHZDbkI7O01BZ3ZDVTtNQUNOQSxPQUFJQSxNQUFKck8sSUFBQXdNLE1BQUFBLENBQUFBLENBQUk2QixPQUFBQSxFQUFLLFVBQUNDLE1BQUQsQ0FBTEQ7SUFETkEsQ0FBQUEsa0NBQUFBLENBQUFBO0VBOXVDRnpPLEdBQUFBLFdBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMTQwOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvZW51bWVyYXRvci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGJyZWFrZXIsIHNsaWNlLCBmYWxzeSwgdHJ1dGh5LCBjb2VyY2VfdG9cblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xuXG5jbGFzcyBFbnVtZXJhdG9yXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfZW51bWVyYXRvciA9IHRydWVgXG5cbiAgZGVmIHNlbGYuZm9yKG9iamVjdCwgbWV0aG9kID0gOmVhY2gsICphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgb2JqID0gI3thbGxvY2F0ZX07XG5cbiAgICAgIG9iai5vYmplY3QgPSBvYmplY3Q7XG4gICAgICBvYmouc2l6ZSAgID0gYmxvY2s7XG4gICAgICBvYmoubWV0aG9kID0gbWV0aG9kO1xuICAgICAgb2JqLmFyZ3MgICA9IGFyZ3M7XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5pdGlhbGl6ZSgqLCAmYmxvY2spXG4gICAgaWYgYmxvY2tcbiAgICAgIEBvYmplY3QgPSBHZW5lcmF0b3IubmV3KCZibG9jaylcbiAgICAgIEBtZXRob2QgPSA6ZWFjaFxuICAgICAgQGFyZ3MgICA9IFtdXG4gICAgICBAc2l6ZSAgID0gYGFyZ3VtZW50c1swXSB8fCBuaWxgXG5cbiAgICAgIGlmIEBzaXplICYmICFAc2l6ZS5yZXNwb25kX3RvPyg6Y2FsbClcbiAgICAgICAgQHNpemUgPSBgJGNvZXJjZV90bygje0BzaXplfSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgQG9iamVjdCA9IGBhcmd1bWVudHNbMF1gXG4gICAgICBAbWV0aG9kID0gYGFyZ3VtZW50c1sxXSB8fCBcImVhY2hcImBcbiAgICAgIEBhcmdzICAgPSBgJHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKWBcbiAgICAgIEBzaXplICAgPSBuaWxcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGVhY2goKmFyZ3MsICZibG9jaylcbiAgICByZXR1cm4gc2VsZiBpZiBibG9jay5uaWw/ICYmIGFyZ3MuZW1wdHk/XG5cbiAgICBhcmdzID0gQGFyZ3MgKyBhcmdzXG5cbiAgICByZXR1cm4gc2VsZi5jbGFzcy5uZXcoQG9iamVjdCwgQG1ldGhvZCwgKmFyZ3MpIGlmIGJsb2NrLm5pbD9cblxuICAgIEBvYmplY3QuX19zZW5kX18oQG1ldGhvZCwgKmFyZ3MsICZibG9jaylcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICBAc2l6ZS5yZXNwb25kX3RvPyg6Y2FsbCkgPyBAc2l6ZS5jYWxsKCpAYXJncykgOiBAc2l6ZVxuICBlbmRcblxuICBkZWYgd2l0aF9pbmRleChvZmZzZXQgPSAwLCAmYmxvY2spXG4gICAgb2Zmc2V0ID0gaWYgb2Zmc2V0XG4gICAgICAgICAgICAgICBgJGNvZXJjZV90byhvZmZzZXQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gZW51bV9mb3IoOndpdGhfaW5kZXgsIG9mZnNldCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQsIGluZGV4ID0gb2Zmc2V0O1xuXG4gICAgICBzZWxmLiRlYWNoLiQkcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYGFyZ3VtZW50c2ApfSxcbiAgICAgICAgICAgIHZhbHVlID0gYmxvY2socGFyYW0sIGluZGV4KTtcblxuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGVhY2goKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHdpdGhfb2JqZWN0IGVhY2hfd2l0aF9vYmplY3RcblxuICBkZWYgZWFjaF93aXRoX2luZGV4KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfd2l0aF9pbmRleCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc3VwZXJcbiAgICBAb2JqZWN0XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgcmVzdWx0ID0gXCIjPCN7c2VsZi5jbGFzc306ICN7QG9iamVjdC5pbnNwZWN0fToje0BtZXRob2R9XCJcblxuICAgIGlmIEBhcmdzLmFueT9cbiAgICAgIHJlc3VsdCArPSBcIigje0BhcmdzLmluc3BlY3RbUmFuZ2UubmV3KDEsIC0yKV19KVwiXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKyAnPidcbiAgZW5kXG5cbiAgY2xhc3MgR2VuZXJhdG9yXG4gICAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgICBkZWYgaW5pdGlhbGl6ZSgmYmxvY2spXG4gICAgICByYWlzZSBMb2NhbEp1bXBFcnJvciwgJ25vIGJsb2NrIGdpdmVuJyB1bmxlc3MgYmxvY2tcblxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICBlbmRcblxuICAgIGRlZiBlYWNoKCphcmdzLCAmYmxvY2spXG4gICAgICB5aWVsZGVyID0gWWllbGRlci5uZXcoJmJsb2NrKVxuXG4gICAgICAleHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICBPcGFsLnlpZWxkWCgje0BibG9ja30sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgPT09ICRicmVha2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gJGJyZWFrZXIuJHY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBZaWVsZGVyXG4gICAgZGVmIGluaXRpYWxpemUoJmJsb2NrKVxuICAgICAgQGJsb2NrID0gYmxvY2tcbiAgICBlbmRcblxuICAgIGRlZiB5aWVsZCgqdmFsdWVzKVxuICAgICAgJXh7XG4gICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKCN7QGJsb2NrfSwgdmFsdWVzKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICRicmVha2VyKSB7XG4gICAgICAgICAgdGhyb3cgJGJyZWFrZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgPDwoKnZhbHVlcylcbiAgICAgIHNlbGYueWllbGQoKnZhbHVlcylcblxuICAgICAgc2VsZlxuICAgIGVuZFxuICBlbmRcblxuICBjbGFzcyBMYXp5IDwgc2VsZlxuICAgIGNsYXNzIFN0b3BMYXp5RXJyb3IgPCBFeGNlcHRpb247IGVuZFxuXG4gICAgZGVmIGluaXRpYWxpemUob2JqZWN0LCBzaXplID0gbmlsLCAmYmxvY2spXG4gICAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbmV3IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBAZW51bWVyYXRvciA9IG9iamVjdFxuXG4gICAgICBzdXBlciBzaXplIGRvIHx5aWVsZGVyLCAqZWFjaF9hcmdzfFxuICAgICAgICBvYmplY3QuZWFjaCgqZWFjaF9hcmdzKSBkbyB8KmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoI3t5aWVsZGVyfSk7XG5cbiAgICAgICAgICAgIE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgcmVzY3VlIEV4Y2VwdGlvblxuICAgICAgICBuaWxcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgZm9yY2UgdG9fYVxuXG4gICAgZGVmIGxhenlcbiAgICAgIHNlbGZcbiAgICBlbmRcblxuICAgIGRlZiBjb2xsZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IG1hcCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgZW51bWVyYXRvcl9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBkZWYgY29sbGVjdF9jb25jYXQoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgbWFwIHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCN7YHZhbHVlYC5yZXNwb25kX3RvPyA6Zm9yY2V9ICYmICN7YHZhbHVlYC5yZXNwb25kX3RvPyA6ZWFjaH0pIHtcbiAgICAgICAgICAgICN7YHZhbHVlYC5lYWNoIHsgfHZ8IGVudW0ueWllbGQgdiB9fVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9ICN7T3BhbC50cnlfY29udmVydCBgdmFsdWVgLCBBcnJheSwgOnRvX2FyeX07XG5cbiAgICAgICAgICAgIGlmIChhcnJheSA9PT0gbmlsKSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgdmFsdWVgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAje2B2YWx1ZWAuZWFjaCB7IHx2fCBlbnVtLnlpZWxkIHYgfX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGRlZiBkcm9wKG4pXG4gICAgICBuID0gYCRjb2VyY2VfdG8oI3tufSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgICBpZiBuIDwgMFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYXR0ZW1wdCB0byBkcm9wIG5lZ2F0aXZlIHNpemUnXG4gICAgICBlbmRcblxuICAgICAgY3VycmVudF9zaXplID0gZW51bWVyYXRvcl9zaXplXG4gICAgICBzZXRfc2l6ZSAgICAgPSBpZiBJbnRlZ2VyID09PSBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgICAgbiA8IGN1cnJlbnRfc2l6ZSA/IG4gOiBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaXplXG4gICAgICAgICAgICAgICAgICAgICBlbmRcblxuICAgICAgZHJvcHBlZCA9IDBcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIGRyb3BwZWQgPCBuXG4gICAgICAgICAgZHJvcHBlZCArPSAxXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGRyb3Bfd2hpbGUoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgZHJvcF93aGlsZSB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgc3VjY2VlZGluZyA9IHRydWVcbiAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICBpZiBzdWNjZWVkaW5nXG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBPcGFsLnlpZWxkWChibG9jaywgYXJncyk7XG5cbiAgICAgICAgICAgIGlmICgkZmFsc3kodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHN1Y2NlZWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBlbnVtLnlpZWxkKCphcmdzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIGVudW1fZm9yKG1ldGhvZCA9IDplYWNoLCAqYXJncywgJmJsb2NrKVxuICAgICAgc2VsZi5jbGFzcy5mb3Ioc2VsZiwgbWV0aG9kLCAqYXJncywgJmJsb2NrKVxuICAgIGVuZFxuXG4gICAgYWxpYXMgZmlsdGVyIGZpbmRfYWxsXG5cbiAgICBkZWYgZmluZF9hbGwoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgc2VsZWN0IHdpdGhvdXQgYSBibG9jaydcbiAgICAgIGVuZFxuXG4gICAgICBMYXp5Lm5ldyhzZWxmLCBuaWwpIGRvIHxlbnVtLCAqYXJnc3xcbiAgICAgICAgJXh7XG4gICAgICAgICAgdmFyIHZhbHVlID0gT3BhbC55aWVsZFgoYmxvY2ssIGFyZ3MpO1xuXG4gICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgZmxhdF9tYXAgY29sbGVjdF9jb25jYXRcblxuICAgIGRlZiBncmVwKHBhdHRlcm4sICZibG9jaylcbiAgICAgIGlmIGJsb2NrXG4gICAgICAgIExhenkubmV3KHNlbGYsIG5pbCkgZG8gfGVudW0sICphcmdzfFxuICAgICAgICAgICV4e1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gI3tPcGFsLmRlc3RydWN0dXJlKGFyZ3MpfSxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICN7cGF0dGVybiA9PT0gYHBhcmFtYH07XG5cbiAgICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCBwYXJhbSk7XG5cbiAgICAgICAgICAgICAgI3tlbnVtLnlpZWxkIGBPcGFsLnlpZWxkMShibG9jaywgcGFyYW0pYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICAgJXh7XG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAje09wYWwuZGVzdHJ1Y3R1cmUoYXJncyl9LFxuICAgICAgICAgICAgICAgIHZhbHVlID0gI3twYXR0ZXJuID09PSBgcGFyYW1gfTtcblxuICAgICAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICN7ZW51bS55aWVsZCBgcGFyYW1gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICBhbGlhcyBtYXAgY29sbGVjdFxuXG4gICAgYWxpYXMgc2VsZWN0IGZpbmRfYWxsXG5cbiAgICBkZWYgcmVqZWN0KCZibG9jaylcbiAgICAgIHVubGVzcyBibG9ja1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY2FsbCBsYXp5IHJlamVjdCB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkZmFsc3kodmFsdWUpKSB7XG4gICAgICAgICAgICAje2VudW0ueWllbGQoKmFyZ3MpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRha2UobilcbiAgICAgIG4gPSBgJGNvZXJjZV90bygje259LCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgIGlmIG4gPCAwXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdhdHRlbXB0IHRvIHRha2UgbmVnYXRpdmUgc2l6ZSdcbiAgICAgIGVuZFxuXG4gICAgICBjdXJyZW50X3NpemUgPSBlbnVtZXJhdG9yX3NpemVcbiAgICAgIHNldF9zaXplICAgICA9IGlmIEludGVnZXIgPT09IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICBuIDwgY3VycmVudF9zaXplID8gbiA6IGN1cnJlbnRfc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50X3NpemVcbiAgICAgICAgICAgICAgICAgICAgIGVuZFxuXG4gICAgICB0YWtlbiA9IDBcbiAgICAgIExhenkubmV3KHNlbGYsIHNldF9zaXplKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgIGlmIHRha2VuIDwgblxuICAgICAgICAgIGVudW0ueWllbGQoKmFyZ3MpXG4gICAgICAgICAgdGFrZW4gKz0gMVxuICAgICAgICBlbHNlXG4gICAgICAgICAgcmFpc2UgU3RvcExhenlFcnJvclxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgICAgdW5sZXNzIGJsb2NrXG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICd0cmllZCB0byBjYWxsIGxhenkgdGFrZV93aGlsZSB3aXRob3V0IGEgYmxvY2snXG4gICAgICBlbmRcblxuICAgICAgTGF6eS5uZXcoc2VsZiwgbmlsKSBkbyB8ZW51bSwgKmFyZ3N8XG4gICAgICAgICV4e1xuICAgICAgICAgIHZhciB2YWx1ZSA9IE9wYWwueWllbGRYKGJsb2NrLCBhcmdzKTtcblxuICAgICAgICAgIGlmICgkdHJ1dGh5KHZhbHVlKSkge1xuICAgICAgICAgICAgI3tlbnVtLnlpZWxkKCphcmdzKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgI3tyYWlzZSBTdG9wTGF6eUVycm9yfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYWxpYXMgdG9fZW51bSBlbnVtX2ZvclxuXG4gICAgZGVmIGluc3BlY3RcbiAgICAgIFwiIzwje3NlbGYuY2xhc3N9OiAje0BlbnVtZXJhdG9yLmluc3BlY3R9PlwiXG4gICAgZW5kXG4gIGVuZFxuXG4gIGNsYXNzIEFyaXRobWV0aWNTZXF1ZW5jZSA8IHNlbGZcbiAgICAjIFdlIG5lZWQgdG8gc3R1YiB0aGlzIGZvciB0aGUgdGltZSBiZWluZ1xuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpFbnVtZXJhdG9yPiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwiZm9yIiwib2JqZWN0IiwiYWxsb2NhdGUiLCJpbml0aWFsaXplIiwiYmxvY2siLCJAb2JqZWN0IiwibmV3IiwiR2VuZXJhdG9yIiwidG9fcHJvYyIsIkBtZXRob2QiLCJAYXJncyIsIkBzaXplIiwiJHJldF9vcl8xIiwicmVzcG9uZF90bz8iLCIhIiwiSW50ZWdlciIsImVhY2giLCIkcmV0X29yXzIiLCJuaWw/IiwiYXJncyIsImVtcHR5PyIsIisiLCJjbGFzcyIsIl9fc2VuZF9fIiwic2l6ZSIsImNhbGwiLCJ3aXRoX2luZGV4Iiwib2Zmc2V0IiwiMCIsImVudW1fZm9yIiwiYmxvY2sgaW4gd2l0aF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gd2l0aF9pbmRleCIsIk9wYWwiLCJkZXN0cnVjdHVyZSIsImVhY2hfd2l0aF9pbmRleCIsImJsb2NrX2dpdmVuPyIsImJsb2NrIGluIGVhY2hfd2l0aF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF93aXRoX2luZGV4IiwiaW5zcGVjdCIsInJlc3VsdCIsImFueT8iLCJbXSIsIlJhbmdlIiwiMSIsIi0yIiwiPGNsYXNzOkdlbmVyYXRvcj4iLCJyYWlzZSIsIkxvY2FsSnVtcEVycm9yIiwiQGJsb2NrIiwieWllbGRlciIsIllpZWxkZXIiLCI8Y2xhc3M6WWllbGRlcj4iLCJ5aWVsZCIsIjw8IiwidmFsdWVzIiwiPGNsYXNzOkxhenk+IiwiPGNsYXNzOlN0b3BMYXp5RXJyb3I+IiwiRXhjZXB0aW9uIiwiQXJndW1lbnRFcnJvciIsIkBlbnVtZXJhdG9yIiwiYmxvY2sgaW4gaW5pdGlhbGl6ZSIsImJsb2NrICgyIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsImVhY2hfYXJncyIsImJsb2NrICgzIGxldmVscykgaW4gaW5pdGlhbGl6ZSIsImxhenkiLCJjb2xsZWN0IiwiTGF6eSIsImVudW1lcmF0b3Jfc2l6ZSIsImJsb2NrIGluIGNvbGxlY3QiLCJlbnVtJCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsImNvbGxlY3RfY29uY2F0IiwiYmxvY2sgaW4gY29sbGVjdF9jb25jYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3RfY29uY2F0IiwidiIsImJsb2NrICgzIGxldmVscykgaW4gY29sbGVjdF9jb25jYXQiLCJ0cnlfY29udmVydCIsIkFycmF5IiwiZHJvcCIsIm4iLCI8IiwiY3VycmVudF9zaXplIiwic2V0X3NpemUiLCI9PT0iLCJkcm9wcGVkIiwiYmxvY2sgaW4gZHJvcCIsImJsb2NrICgyIGxldmVscykgaW4gZHJvcCIsImRyb3Bfd2hpbGUiLCJzdWNjZWVkaW5nIiwiYmxvY2sgaW4gZHJvcF93aGlsZSIsImJsb2NrICgyIGxldmVscykgaW4gZHJvcF93aGlsZSIsIm1ldGhvZCIsImZpbmRfYWxsIiwiYmxvY2sgaW4gZmluZF9hbGwiLCJibG9jayAoMiBsZXZlbHMpIGluIGZpbmRfYWxsIiwiZ3JlcCIsInBhdHRlcm4iLCJibG9jayBpbiBncmVwIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBncmVwIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJ0YWtlIiwidGFrZW4iLCJibG9jayBpbiB0YWtlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlIiwiU3RvcExhenlFcnJvciIsInRha2Vfd2hpbGUiLCJibG9jayBpbiB0YWtlX3doaWxlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0YWtlX3doaWxlIiwiPGNsYXNzOkFyaXRobWV0aWNTZXF1ZW5jZT4iXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBRUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQywwQkFBUkQ7SUFFQ0Q7SUFFREcsVUFBSUwsSUFBSkssVUFBQUEsb0JBQUFBLFNBQWFDLE1BQUQsRUFUZCxFQVNjLEVBVGQsRUFTRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBNEM7O01BVDlDOztNQVN1QjtNQUFBO01BQUE7TUFBQTtNQUFBO01BQUEsV0FBUyxNQUFUO01BQUE7O01BQWdCOztBQUV2Q0EsZ0JBQWtCTCxJQUFBTyxVQUFBQSxDQUFBQSxDQUFTRjs7QUFFM0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVZFQSxDQUFBQSxnQ0FBQUE7O0FBYUFHLElBQUFBLDhCQUFBQSwyQkFBQUEsc0JBdEJGLEVBc0JFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFrQjs7TUF0QnBCOztNQXVCSSxJQUFBLFFBQUdDLEtBQUgsQ0FBQTs7UUFDRUMs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QSxDQUFBQSxDQUFULENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBb0JxQyxlQUFXckIsU0FBQUEsQ0FBQUEsQ0FBL0IsQ0FBQSxHQUFBO01BREZBLENBQUFBLDhCQUFBQSxDQUFBQTtJQTFPRmlCLEdBQUFBLFdBQUFBLEVBQWE1RCxJQUFiNEQ7SUErT0ExRCxPQUFBaUg7SUFBQUE7O01BQUFBOztNQUFBQSxPQUFBO0lBQUFBLEdBQUFBLFdBQUFBLEVBQTJCbkgsSUFBM0JtSDtFQXJZRmpILEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjE1NCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbnVtZXJpYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIE51bWVyaWNcbiAgaW5jbHVkZSBDb21wYXJhYmxlXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICBpZiBvdGhlci5pbnN0YW5jZV9vZj8gc2VsZi5jbGFzc1xuICAgICAgcmV0dXJuIFtvdGhlciwgc2VsZl1cbiAgICBlbmRcblxuICAgIFtGbG9hdChvdGhlciksIEZsb2F0KHNlbGYpXVxuICBlbmRcblxuICBkZWYgX19jb2VyY2VkX18obWV0aG9kLCBvdGhlcilcbiAgICBpZiBvdGhlci5yZXNwb25kX3RvPyg6Y29lcmNlKVxuICAgICAgYSwgYiA9IG90aGVyLmNvZXJjZShzZWxmKVxuICAgICAgYS5fX3NlbmRfXyBtZXRob2QsIGJcbiAgICBlbHNlXG4gICAgICBjYXNlIG1ldGhvZFxuICAgICAgd2hlbiA6KywgOi0sIDoqLCA6LywgOiUsIDomLCA6fCwgOl4sIDoqKlxuICAgICAgICByYWlzZSBUeXBlRXJyb3IsIFwiI3tvdGhlci5jbGFzc30gY2FuJ3QgYmUgY29lcmNlZCBpbnRvIE51bWVyaWNcIlxuICAgICAgd2hlbiA6PiwgOj49LCA6PCwgOjw9LCA6PD0+XG4gICAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tvdGhlci5jbGFzc30gZmFpbGVkXCJcbiAgICAgIGVuZFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIGVxdWFsPyBvdGhlclxuICAgICAgcmV0dXJuIDBcbiAgICBlbmRcblxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgK0BcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiAtQFxuICAgIDAgLSBzZWxmXG4gIGVuZFxuXG4gIGRlZiAlKG90aGVyKVxuICAgIHNlbGYgLSBvdGhlciAqIGRpdihvdGhlcilcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIHNlbGYgPCAwID8gLXNlbGYgOiBzZWxmXG4gIGVuZFxuXG4gIGRlZiBhYnMyXG4gICAgc2VsZiAqIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGFuZ2xlXG4gICAgc2VsZiA8IDAgPyBNYXRoOjpQSSA6IDBcbiAgZW5kXG5cbiAgYWxpYXMgYXJnIGFuZ2xlXG5cbiAgZGVmIGNlaWwobmRpZ2l0cyA9IDApXG4gICAgdG9fZi5jZWlsKG5kaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBjb25qXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBjb25qdWdhdGUgY29ualxuXG4gIGRlZiBkZW5vbWluYXRvclxuICAgIHRvX3IuZGVub21pbmF0b3JcbiAgZW5kXG5cbiAgZGVmIGRpdihvdGhlcilcbiAgICByYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgbycgaWYgb3RoZXIgPT0gMFxuXG4gICAgKHNlbGYgLyBvdGhlcikuZmxvb3JcbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBbZGl2KG90aGVyKSwgc2VsZiAlIG90aGVyXVxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB0b19mIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZsb29yKG5kaWdpdHMgPSAwKVxuICAgIHRvX2YuZmxvb3IobmRpZ2l0cylcbiAgZW5kXG5cbiAgZGVmIGlcbiAgICBDb21wbGV4KDAsIHNlbGYpXG4gIGVuZFxuXG4gIGRlZiBpbWFnXG4gICAgMFxuICBlbmRcblxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuXG4gIGRlZiBpbnRlZ2VyP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcblxuICBhbGlhcyBtb2R1bG8gJVxuXG4gIGRlZiBub256ZXJvP1xuICAgIHplcm8/ID8gbmlsIDogc2VsZlxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgdG9fci5udW1lcmF0b3JcbiAgZW5kXG5cbiAgYWxpYXMgcGhhc2UgYXJnXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIE9wYWwuY29lcmNlX3RvIShzZWxmLCBSYXRpb25hbCwgOnRvX3IpIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIHJlYWxcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIHRydWVcbiAgZW5kXG5cbiAgZGVmIHJlY3RcbiAgICBbc2VsZiwgMF1cbiAgZW5kXG5cbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuXG4gIGRlZiByb3VuZChkaWdpdHMgPSB1bmRlZmluZWQpXG4gICAgdG9fZi5yb3VuZChkaWdpdHMpXG4gIGVuZFxuXG4gIGRlZiBzdGVwKGxpbWl0ID0gdW5kZWZpbmVkLCBzdGVwID0gdW5kZWZpbmVkLCB0bzogdW5kZWZpbmVkLCBieTogdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCAmJiB0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvIGlzIGdpdmVuIHR3aWNlJ31cbiAgICAgIH1cblxuICAgICAgaWYgKHN0ZXAgIT09IHVuZGVmaW5lZCAmJiBieSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0ZXAgaXMgZ2l2ZW4gdHdpY2UnfVxuICAgICAgfVxuXG4gICAgICBpZiAodG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsaW1pdCA9IHRvO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdGVwID0gYnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpbWl0ID0gbmlsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmIChzdGVwID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ3N0ZXAgbXVzdCBiZSBudW1lcmljJ31cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwICE9IG51bGwgJiYgI3tzdGVwID09IDB9KSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgPT09IG5pbCB8fCBzdGVwID09IG51bGwpIHtcbiAgICAgICAgICBzdGVwID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWduID0gI3tzdGVwIDw9PiAwfTtcblxuICAgICAgICBpZiAoc2lnbiA9PT0gbmlsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIjAgY2FuJ3QgYmUgY29lcmNlZCBpbnRvICN7c3RlcC5jbGFzc31cIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PT0gbmlsIHx8IGxpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICBsaW1pdCA9IHNpZ24gPiAwID8gI3tGbG9hdDo6SU5GSU5JVFl9IDogI3stRmxvYXQ6OklORklOSVRZfTtcbiAgICAgICAgfVxuXG4gICAgICAgICN7T3BhbC5jb21wYXJlKHNlbGYsIGxpbWl0KX1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcEZsb2F0U2l6ZSgpIHtcbiAgICAgICAgaWYgKChzdGVwID4gMCAmJiBzZWxmID4gbGltaXQpIHx8IChzdGVwIDwgMCAmJiBzZWxmIDwgbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RlcCA9PT0gSW5maW5pdHkgfHwgc3RlcCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoc2VsZikgKyBhYnMobGltaXQpICsgYWJzKGxpbWl0IC0gc2VsZikpIC8gYWJzKHN0ZXApICogI3tGbG9hdDo6RVBTSUxPTn07XG5cbiAgICAgICAgICBpZiAoZXJyID09PSBJbmZpbml0eSB8fCBlcnIgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChlcnIgPiAwLjUpIHtcbiAgICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmxvb3IoKGxpbWl0IC0gc2VsZikgLyBzdGVwICsgZXJyKSArIDFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RlcFNpemUoKSB7XG4gICAgICAgIHZhbGlkYXRlUGFyYW1ldGVycygpO1xuXG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0ZXAgJSAxICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ZXBGbG9hdFNpemUoKTtcbiAgICAgICAgfSBlbHNlIGlmICgoc3RlcCA+IDAgJiYgc2VsZiA+IGxpbWl0KSB8fCAoc3RlcCA8IDAgJiYgc2VsZiA8IGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsLCBhYnMgPSBNYXRoLmFicyxcbiAgICAgICAgICAgICAgbGhzID0gYWJzKHNlbGYgLSBsaW1pdCkgKyAxLFxuICAgICAgICAgICAgICByaHMgPSBhYnMoc3RlcCk7XG5cbiAgICAgICAgICByZXR1cm4gY2VpbChsaHMgLyByaHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZW51bV9mb3IoOnN0ZXAsIGxpbWl0LCBzdGVwLCAmYHN0ZXBTaXplYCkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YWxpZGF0ZVBhcmFtZXRlcnMoKTtcblxuICAgICAgdmFyIGlzRGVzYyA9ICN7c3RlcC5uZWdhdGl2ZT99LFxuICAgICAgICAgIGlzSW5mID0gI3tzdGVwID09IDB9IHx8XG4gICAgICAgICAgICAgICAgICAobGltaXQgPT09IEluZmluaXR5ICYmICFpc0Rlc2MpIHx8XG4gICAgICAgICAgICAgICAgICAobGltaXQgPT09IC1JbmZpbml0eSAmJiBpc0Rlc2MpO1xuXG4gICAgICBpZiAoc2VsZi4kJGlzX251bWJlciAmJiBzdGVwLiQkaXNfbnVtYmVyICYmIGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIGlmIChzZWxmICUgMSA9PT0gMCAmJiAoaXNJbmYgfHwgbGltaXQgJSAxID09PSAwKSAmJiBzdGVwICUgMSA9PT0gMCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNlbGY7XG5cbiAgICAgICAgICBpZiAoaXNJbmYpIHtcbiAgICAgICAgICAgIGZvciAoOzsgdmFsdWUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Rlc2MpIHtcbiAgICAgICAgICAgIGZvciAoOyB2YWx1ZSA+PSBsaW1pdDsgdmFsdWUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoOyB2YWx1ZSA8PSBsaW1pdDsgdmFsdWUgKz0gc3RlcCkge1xuICAgICAgICAgICAgICBibG9jayh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGJlZ2luID0gI3t0b19mfS52YWx1ZU9mKCk7XG4gICAgICAgICAgc3RlcCA9ICN7c3RlcC50b19mfS52YWx1ZU9mKCk7XG4gICAgICAgICAgbGltaXQgPSAje2xpbWl0LnRvX2Z9LnZhbHVlT2YoKTtcblxuICAgICAgICAgIHZhciBuID0gc3RlcEZsb2F0U2l6ZSgpO1xuXG4gICAgICAgICAgaWYgKCFpc0Zpbml0ZShzdGVwKSkge1xuICAgICAgICAgICAgaWYgKG4gIT09IDApIGJsb2NrKGJlZ2luKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZXAgPT09IDApIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgIGJsb2NrKGJlZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGQgPSBpICogc3RlcCArIHNlbGY7XG4gICAgICAgICAgICAgIGlmIChzdGVwID49IDAgPyBsaW1pdCA8IGQgOiBsaW1pdCA+IGQpIHtcbiAgICAgICAgICAgICAgICBkID0gbGltaXQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYmxvY2soZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb3VudGVyID0gc2VsZlxuXG4gICAgd2hpbGUgYGlzRGVzYyA/ICN7Y291bnRlciA+PSBsaW1pdH0gOiAje2NvdW50ZXIgPD0gbGltaXR9YFxuICAgICAgeWllbGQgY291bnRlclxuICAgICAgY291bnRlciArPSBzdGVwXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19jXG4gICAgQ29tcGxleChzZWxmLCAwKVxuICBlbmRcblxuICBkZWYgdG9faW50XG4gICAgdG9faVxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgdG9fZi50cnVuY2F0ZShuZGlnaXRzKVxuICBlbmRcblxuICBkZWYgemVybz9cbiAgICBzZWxmID09IDBcbiAgZW5kXG5cbiAgZGVmIHBvc2l0aXZlP1xuICAgIHNlbGYgPiAwXG4gIGVuZFxuXG4gIGRlZiBuZWdhdGl2ZT9cbiAgICBzZWxmIDwgMFxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgY2xvbmUoZnJlZXplOiB0cnVlKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICB0cnVlXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBuaWxcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6TnVtZXJpYz4iLCJpbmNsdWRlIiwiQ29tcGFyYWJsZSIsImNvZXJjZSIsIm90aGVyIiwiaW5zdGFuY2Vfb2Y/IiwiY2xhc3MiLCJGbG9hdCIsIl9fY29lcmNlZF9fIiwibWV0aG9kIiwicmVzcG9uZF90bz8iLCJhIiwiYiIsIl9fc2VuZF9fIiwiPT09IiwicmFpc2UiLCJUeXBlRXJyb3IiLCJBcmd1bWVudEVycm9yIiwiPD0+IiwiZXF1YWw/IiwiMCIsIitAIiwiLUAiLCItIiwiJSIsIioiLCJkaXYiLCJhYnMiLCI8IiwiYWJzMiIsImFuZ2xlIiwiTWF0aDo6UEkiLCJNYXRoIiwiY2VpbCIsIm5kaWdpdHMiLCJ0b19mIiwiY29uaiIsImRlbm9taW5hdG9yIiwidG9fciIsIj09IiwiWmVyb0RpdmlzaW9uRXJyb3IiLCIvIiwiZmxvb3IiLCJkaXZtb2QiLCJmZGl2IiwiaSIsIkNvbXBsZXgiLCJpbWFnIiwiaW50ZWdlcj8iLCJub256ZXJvPyIsInplcm8/IiwibnVtZXJhdG9yIiwicG9sYXIiLCJhcmciLCJxdW8iLCJPcGFsIiwiY29lcmNlX3RvISIsIlJhdGlvbmFsIiwicmVhbCIsInJlYWw/IiwicmVjdCIsInJvdW5kIiwiZGlnaXRzIiwic3RlcCIsIkZsb2F0OjpJTkZJTklUWSIsImNvbXBhcmUiLCJsaW1pdCIsIkZsb2F0OjpFUFNJTE9OIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJ0b19wcm9jIiwibmVnYXRpdmU/IiwiY291bnRlciIsIj49IiwiPD0iLCIrIiwidG9fYyIsInRvX2ludCIsInRvX2kiLCJ0cnVuY2F0ZSIsInBvc2l0aXZlPyIsIj4iLCJkdXAiLCJjbG9uZSIsIiRrd2FyZ3MiLCJmaW5pdGU/IiwiaW5maW5pdGU/Il0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOzs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsMEJBQVJEOztBQUVBRSxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFHQyxLQUFLQyxpQkFBQUEsQ0FBY1AsSUFBSVEsT0FBQUEsQ0FBQUEsQ0FBbEJELENBQVIsQ0FBQTtRQUNFLE9BQU8sQ0FB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QTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBSzNDLE9BQUw5QixJQUFLOEIsRUFBRVIsQ0FBRlE7SUFEUDJDLENBQUFBLHVDQUFBQTs7QUFJQVcsSUFBQUEsdUJBQUFBLGtCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXBGO0lBREZvRixDQUFBQSw2QkFBQUE7O0FBSUFDLElBQUFBLHlCQUFBQSxvQkFBQUEsaUJBM1VGQyxPQTJVRUQ7QUFBQUEsTUFBQUE7Ozs7TUEzVUY7TUFBQTtNQUFBO01BQUE7TUFBQTs7TUEyVVk7TUFBQTtNQUFBLFdBQVE7TUFBUjtNQUNSQSxPQUFBckY7SUFERnFGLENBQUFBLGdDQUFBQTs7QUFJQUUsSUFBQUEsMkJBQUFBLDBCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxxQ0FBQUE7SUFJQXJGLE9BQUFzRixDQUFBQSw2QkFBQUEsNEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBO0lBREZBLENBQUFBLHVDQUFBQSxDQUFBQTtFQWpWRnRGLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxMjY2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvYXJyYXkucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHksIGZhbHN5LCBoYXNoX2lkcywgeWllbGQxLCBoYXNoX2dldCwgaGFzaF9wdXQsIGhhc2hfZGVsZXRlLCBjb2VyY2VfdG8sIHJlc3BvbmRfdG9cblxucmVxdWlyZSAnY29yZWxpYi9lbnVtZXJhYmxlJ1xucmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBBcnJheSA8IGBBcnJheWBcbiAgaW5jbHVkZSBFbnVtZXJhYmxlXG5cbiAgIyBNYXJrIGFsbCBqYXZhc2NyaXB0IGFycmF5cyBhcyBiZWluZyB2YWxpZCBydWJ5IGFycmF5c1xuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19hcnJheScsIHRydWUpYFxuXG4gICV4e1xuICAgIC8vIFJlY2VudCB2ZXJzaW9ucyBvZiBWOCAoPiA3LjEpIG9ubHkgdXNlIGFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiB3aGVuIEFycmF5LnByb3RvdHlwZSBpcyB1bm1vZGlmaWVkLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgXCJhcnJheS1zcGxpY2UudHFcIiBoYXMgYSBcImZhc3QgcGF0aFwiIChFeHRyYWN0RmFzdEpTQXJyYXksIGRlZmluZWQgaW4gXCJzcmMvY29kZWdlbi9jb2RlLXN0dWItYXNzZW1ibGVyLmNjXCIpXG4gICAgLy8gYnV0IGl0J3Mgb25seSBlbmFibGVkIHdoZW4gXCJJc1Byb3RvdHlwZUluaXRpYWxBcnJheVByb3RvdHlwZSgpXCIgaXMgdHJ1ZS5cbiAgICAvL1xuICAgIC8vIE9sZGVyIHZlcnNpb25zIG9mIFY4IHdlcmUgdXNpbmcgcmVsYXRpdmVseSBmYXN0IEpTLXdpdGgtZXh0ZW5zaW9ucyBjb2RlIGV2ZW4gd2hlbiBBcnJheS5wcm90b3R5cGUgaXMgbW9kaWZpZWQ6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Y4L3Y4L2Jsb2IvNy4wLjEvc3JjL2pzL2FycmF5LmpzI0w1OTktTDY0MlxuICAgIC8vXG4gICAgLy8gSW4gc2hvcnQsIEFycmF5IG9wZXJhdGlvbnMgYXJlIHNsb3cgaW4gcmVjZW50IHZlcnNpb25zIG9mIFY4IHdoZW4gdGhlIEFycmF5LnByb3RvdHlwZSBoYXMgYmVlbiB0YW1wZXJlZC5cbiAgICAvLyBTbywgd2hlbiBwb3NzaWJsZSwgd2UgYXJlIHVzaW5nIGZhc3RlciBvcGVuLWNvZGVkIHZlcnNpb24gdG8gYm9vc3QgdGhlIHBlcmZvcm1hbmNlLlxuXG4gICAgLy8gQXMgb2YgVjggOC40LCBkZXBlbmRpbmcgb24gdGhlIHNpemUgb2YgdGhlIGFycmF5LCB0aGlzIGlzIHVwIHRvIH4yNXggdGltZXMgZmFzdGVyIHRoYW4gQXJyYXkjc2hpZnQoKVxuICAgIC8vIEltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgaW5zcGlyZWQgYnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2JhNjg0ODA1YjZjMGVkZWQ3NmU1Y2Q4OWVlMDAzMjhhYzdhNTkzNjUvbGliL2ludGVybmFsL3V0aWwuanMjTDM0MS1MMzQ3XG4gICAgZnVuY3Rpb24gc2hpZnROb0FyZyhsaXN0KSB7XG4gICAgICB2YXIgciA9IGxpc3RbMF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGxpc3RbaW5kZXggLSAxXSA9IGxpc3RbaW5kZXhdO1xuICAgICAgfVxuICAgICAgbGlzdC5wb3AoKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXlTdWJjbGFzcyhvYmosIGtsYXNzKSB7XG4gICAgICBpZiAoa2xhc3MuJCRuYW1lID09PSBPcGFsLkFycmF5KSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2xhc3MuJGFsbG9jYXRlKCkuJHJlcGxhY2UoI3tgb2JqYC50b19hfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQSBoZWxwZXIgZm9yIGtlZXBfaWYgYW5kIGRlbGV0ZV9pZiwgZmlsdGVyIGlzIGVpdGhlciBPcGFsLnRydXRoeVxuICAgIC8vIG9yIE9wYWwuZmFsc3kuXG4gICAgZnVuY3Rpb24gZmlsdGVySWYoc2VsZiwgZmlsdGVyLCBibG9jaykge1xuICAgICAgdmFyIHZhbHVlLCByYWlzZWQgPSBudWxsLCB1cGRhdGVkID0gbmV3IEFycmF5KHNlbGYubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGkyID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhaXNlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pXG4gICAgICAgICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgICAgICAgcmFpc2VkID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJhaXNlZCB8fCBmaWx0ZXIodmFsdWUpKSB7XG4gICAgICAgICAgdXBkYXRlZFtpMl0gPSBzZWxmW2ldXG4gICAgICAgICAgaTIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaTIgIT09IGkpIHtcbiAgICAgICAgc2VsZi5zcGxpY2UuYXBwbHkoc2VsZiwgWzAsIHVwZGF0ZWQubGVuZ3RoXS5jb25jYXQodXBkYXRlZCkpO1xuICAgICAgICBzZWxmLnNwbGljZShpMiwgdXBkYXRlZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmFpc2VkKSB0aHJvdyByYWlzZWQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHNlbGYuW10oKm9iamVjdHMpXG4gICAgYHRvQXJyYXlTdWJjbGFzcyhvYmplY3RzLCBzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoc2l6ZSA9IG5pbCwgb2JqID0gbmlsLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAob2JqICE9PSBuaWwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGJsb2NrIHN1cGVyc2VkZXMgZGVmYXVsdCB2YWx1ZSBhcmd1bWVudCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2l6ZSA+ICN7SW50ZWdlcjo6TUFYfSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdhcnJheSBzaXplIHRvbyBiaWcnfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMilcIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi5zcGxpY2UoMCwgc2VsZi5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKHNpemUuJCRpc19hcnJheSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2EpfVxuICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9IGVsc2UgaWYgKCN7c2l6ZS5yZXNwb25kX3RvPyA6dG9fYXJ5fSkge1xuICAgICAgICAgICN7cmVwbGFjZShzaXplLnRvX2FyeSl9XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2l6ZSA9ICRjb2VyY2VfdG8oc2l6ZSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKTtcbiAgICAgIHZhciBpLCB2YWx1ZTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMCwgdmFsdWU7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGkpO1xuICAgICAgICAgIHNlbGZbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnRyeV9jb252ZXJ0KG9iailcbiAgICBPcGFsLmNvZXJjZV90bz8gb2JqLCBBcnJheSwgOnRvX2FyeVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICBvdGhlci50b19hXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBoYXNoID0gI3t7fX0sIGksIGxlbmd0aCwgaXRlbTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3RoZXIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIG90aGVyW2ldLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgaWYgKCRoYXNoX2RlbGV0ZShoYXNoLCBpdGVtKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB8KG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW07XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJGhhc2hfcHV0KGhhc2gsIHNlbGZbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaC4ka2V5cygpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgcmV0dXJuIGpvaW4ob3RoZXIudG9fc3RyKSBpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fc3RyXG5cbiAgICBvdGhlciA9IGAkY29lcmNlX3RvKG90aGVyLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICBpZiBgb3RoZXIgPCAwYFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFyZ3VtZW50J1xuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgY29udmVydGVkID0gI3t0b19hfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlcjsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY29udmVydGVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgYHNlbGYuY29uY2F0KG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgb3RoZXIgPSBpZiBBcnJheSA9PT0gb3RoZXJcbiAgICAgICAgICAgICAgb3RoZXIudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhvdGhlciwgI3tBcnJheX0sICd0b19hcnknKWAudG9fYVxuICAgICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gW10gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgIHJldHVybiBgc2VsZi5zbGljZSgpYCBpZiBgb3RoZXIubGVuZ3RoID09PSAwYFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sIGhhc2ggPSAje3t9fSwgaSwgbGVuZ3RoLCBpdGVtO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwgb3RoZXJbaV0sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGl0ZW0pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIDw8KG9iamVjdClcbiAgICBgc2VsZi5wdXNoKG9iamVjdClgXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PT4ob3RoZXIpXG4gICAgaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FcbiAgICBlbHNpZiBvdGhlci5yZXNwb25kX3RvPyA6dG9fYXJ5XG4gICAgICBvdGhlciA9IG90aGVyLnRvX2FyeS50b19hXG4gICAgZWxzZVxuICAgICAgcmV0dXJuXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICgje2hhc2h9ID09PSAje290aGVyLmhhc2h9KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBNYXRoLm1pbihzZWxmLmxlbmd0aCwgb3RoZXIubGVuZ3RoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB0bXAgPSAje2BzZWxmW2ldYCA8PT4gYG90aGVyW2ldYH07XG5cbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0bXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICN7YHNlbGYubGVuZ3RoYCA8PT4gYG90aGVyLmxlbmd0aGB9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKGFycmF5LCBvdGhlcikge1xuICAgICAgICB2YXIgaSwgbGVuZ3RoLCBhLCBiO1xuXG4gICAgICAgIGlmIChhcnJheSA9PT0gb3RoZXIpXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgaWYgKCRyZXNwb25kX3RvKG90aGVyLCAnJHRvX2FyeScpKSB7XG4gICAgICAgICAgICByZXR1cm4gI3tgb3RoZXJgID09IGBhcnJheWB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFycmF5LiQkY29uc3RydWN0b3IgIT09IEFycmF5KVxuICAgICAgICAgIGFycmF5ID0gI3tgYXJyYXlgLnRvX2F9O1xuICAgICAgICBpZiAob3RoZXIuJCRjb25zdHJ1Y3RvciAhPT0gQXJyYXkpXG4gICAgICAgICAgb3RoZXIgPSAje2BvdGhlcmAudG9fYX07XG5cbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzZWRbI3tgYXJyYXlgLm9iamVjdF9pZH1dID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGEgPSBhcnJheVtpXTtcbiAgICAgICAgICBiID0gb3RoZXJbaV07XG4gICAgICAgICAgaWYgKGEuJCRpc19hcnJheSkge1xuICAgICAgICAgICAgaWYgKGIuJCRpc19hcnJheSAmJiBiLmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZC5oYXNPd25Qcm9wZXJ0eSgje2BhYC5vYmplY3RfaWR9KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAgPT0gYGJgfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiAkYXJyYXlfc2xpY2VfcmFuZ2Uoc2VsZiwgaW5kZXgpIHtcbiAgICAgIHZhciBzaXplID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgZXhjbHVkZSwgZnJvbSwgdG8sIHJlc3VsdDtcblxuICAgICAgZXhjbHVkZSA9IGluZGV4LmV4Y2w7XG4gICAgICBmcm9tICAgID0gJGNvZXJjZV90byhpbmRleC5iZWdpbiwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG4gICAgICB0byAgICAgID0gJGNvZXJjZV90byhpbmRleC5lbmQsIE9wYWwuSW50ZWdlciwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgZnJvbSArPSBzaXplO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb20gPiBzaXplKSB7XG4gICAgICAgIHJldHVybiBuaWw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgdG8gKz0gc2l6ZTtcblxuICAgICAgICBpZiAodG8gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZXhjbHVkZSkge1xuICAgICAgICB0byArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGFycmF5X3NsaWNlX2luZGV4X2xlbmd0aChzZWxmLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHNlbGYubGVuZ3RoLFxuICAgICAgICAgIGV4Y2x1ZGUsIGZyb20sIHRvLCByZXN1bHQ7XG5cbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2l6ZTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHNpemUgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmW2luZGV4XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgT3BhbC5JbnRlZ2VyLCAndG9faW50Jyk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDAgfHwgaW5kZXggPiBzaXplIHx8IGluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKGluZGV4LCBpbmRleCArIGxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIGRlZiBbXShpbmRleCwgbGVuZ3RoID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGluZGV4LiQkaXNfcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9yYW5nZShzZWxmLCBpbmRleCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICRhcnJheV9zbGljZV9pbmRleF9sZW5ndGgoc2VsZiwgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGluZGV4LCB2YWx1ZSwgZXh0cmEgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICB2YXIgaSwgc2l6ZSA9IHNlbGYubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgZGF0YSA9IGlmIEFycmF5ID09PSB2YWx1ZVxuICAgICAgICAgICAgICAgdmFsdWUudG9fYVxuICAgICAgICAgICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgICAgICAgICAgIHZhbHVlLnRvX2FyeS50b19hXG4gICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgIGVuZFxuXG4gICAgICAleHtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSBpbmRleC5leGNsLFxuICAgICAgICAgICAgZnJvbSAgICA9ICRjb2VyY2VfdG8oaW5kZXguYmVnaW4sICN7SW50ZWdlcn0sICd0b19pbnQnKSxcbiAgICAgICAgICAgIHRvICAgICAgPSAkY29lcmNlX3RvKGluZGV4LmVuZCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgIGZyb20gKz0gc2l6ZTtcblxuICAgICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBSYW5nZUVycm9yLCBcIiN7aW5kZXguaW5zcGVjdH0gb3V0IG9mIHJhbmdlXCJ9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICB0byArPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFleGNsdWRlKSB7XG4gICAgICAgICAgdG8gKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcm9tID4gc2l6ZSkge1xuICAgICAgICAgIGZvciAoaSA9IHNpemU7IGkgPCBmcm9tOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvIDwgMCkge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCAwXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtmcm9tLCB0byAtIGZyb21dLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaWYgYGV4dHJhID09PSB1bmRlZmluZWRgXG4gICAgICAgIGxlbmd0aCA9IDFcbiAgICAgIGVsc2VcbiAgICAgICAgbGVuZ3RoID0gdmFsdWVcbiAgICAgICAgdmFsdWUgID0gZXh0cmFcblxuICAgICAgICBkYXRhID0gaWYgQXJyYXkgPT09IHZhbHVlXG4gICAgICAgICAgICAgICAgIHZhbHVlLnRvX2FcbiAgICAgICAgICAgICAgIGVsc2lmIHZhbHVlLnJlc3BvbmRfdG8/IDp0b19hcnlcbiAgICAgICAgICAgICAgICAgdmFsdWUudG9fYXJ5LnRvX2FcbiAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgW3ZhbHVlXVxuICAgICAgICAgICAgICAgZW5kXG4gICAgICBlbmRcblxuICAgICAgJXh7XG4gICAgICAgIHZhciBvbGQ7XG5cbiAgICAgICAgaW5kZXggID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgICBsZW5ndGggPSAkY29lcmNlX3RvKGxlbmd0aCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBvbGQgICAgPSBpbmRleDtcbiAgICAgICAgICBpbmRleCArPSBzaXplO1xuXG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9sZGB9IHRvbyBzbWFsbCBmb3IgYXJyYXk7IG1pbmltdW0gI3tgLXNlbGYubGVuZ3RoYH1cIn07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIEluZGV4RXJyb3IsIFwibmVnYXRpdmUgbGVuZ3RoICgje2xlbmd0aH0pXCJ9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPiBzaXplKSB7XG4gICAgICAgICAgZm9yIChpID0gc2l6ZTsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGZbaV0gPSBuaWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dHJhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxmW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgbGVuZ3RoXS5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgYW55PyhwYXR0ZXJuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgYGlmIChzZWxmLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlYFxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXRlbSA9IHNlbGZbaV0sIGl0ZW0ubGVuZ3RoICYmICN7YGl0ZW1bMF1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGF0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50JylcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnNlYXJjaF9pbmRleCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yIDpic2VhcmNoX2luZGV4IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IDAsXG4gICAgICAgICAgbWF4ID0gc2VsZi5sZW5ndGgsXG4gICAgICAgICAgbWlkLFxuICAgICAgICAgIHZhbCxcbiAgICAgICAgICByZXQsXG4gICAgICAgICAgc21hbGxlciA9IGZhbHNlLFxuICAgICAgICAgIHNhdGlzZmllZCA9IG5pbDtcblxuICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICBtaWQgPSBtaW4gKyBNYXRoLmZsb29yKChtYXggLSBtaW4pIC8gMik7XG4gICAgICAgIHZhbCA9IHNlbGZbbWlkXTtcbiAgICAgICAgcmV0ID0gJHlpZWxkMShibG9jaywgdmFsKTtcblxuICAgICAgICBpZiAocmV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgc2F0aXNmaWVkID0gbWlkO1xuICAgICAgICAgIHNtYWxsZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJldCA9PT0gZmFsc2UgfHwgcmV0ID09PSBuaWwpIHtcbiAgICAgICAgICBzbWFsbGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmV0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKHJldCA9PT0gMCkgeyByZXR1cm4gbWlkOyB9XG4gICAgICAgICAgc21hbGxlciA9IChyZXQgPCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBhcmd1bWVudCB0eXBlICN7YHJldGAuY2xhc3N9IChtdXN0IGJlIG51bWVyaWMsIHRydWUsIGZhbHNlIG9yIG5pbClcIn1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbWFsbGVyKSB7IG1heCA9IG1pZDsgfSBlbHNlIHsgbWluID0gbWlkICsgMTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2F0aXNmaWVkO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6YnNlYXJjaCB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBpbmRleCA9IGJzZWFyY2hfaW5kZXgoJmJsb2NrKVxuXG4gICAgJXh7XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleC4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY3ljbGUobiA9IG5pbCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6Y3ljbGUsIG4pIGRvXG4gICAgICAgIGlmIG4ubmlsP1xuICAgICAgICAgIEZsb2F0OjpJTkZJTklUWVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbiA9IE9wYWwuY29lcmNlX3RvIShuLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgICAgICAgIG4gPiAwID8gZW51bWVyYXRvcl9zaXplICogbiA6IDBcbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIHJldHVybiBpZiBlbXB0eT8gfHwgbiA9PSAwXG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW5ndGgsIHZhbHVlO1xuXG4gICAgICBpZiAobiA9PT0gbmlsKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBuID0gI3tPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAobiA8PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNsZWFyXG4gICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvdW50KG9iamVjdCA9IG5pbCwgJmJsb2NrKVxuICAgIGlmIG9iamVjdCB8fCBibG9ja1xuICAgICAgc3VwZXJcbiAgICBlbHNlXG4gICAgICBzaXplXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgcmVwbGFjZSBvdGhlclxuICBlbmRcblxuICBkZWYgY29sbGVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gJHlpZWxkMShibG9jaywgc2VsZltpXSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb2xsZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpjb2xsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBzZWxmW2ldKTtcbiAgICAgICAgc2VsZltpXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gYmlub21pYWxfY29lZmZpY2llbnQobiwgaykge1xuICAgICAgaWYgKG4gPT09IGsgfHwgayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGsgPiAwICYmIG4gPiBrKSB7XG4gICAgICAgIHJldHVybiBiaW5vbWlhbF9jb2VmZmljaWVudChuIC0gMSwgayAtIDEpICsgYmlub21pYWxfY29lZmZpY2llbnQobiAtIDEsIGspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBkZWYgY29tYmluYXRpb24obilcbiAgICBudW0gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuICAgIHJldHVybiBlbnVtX2Zvcig6Y29tYmluYXRpb24sIG51bSkgeyBgYmlub21pYWxfY29lZmZpY2llbnQoI3tzZWxmfS5sZW5ndGgsIG51bSlgIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCBzdGFjaywgY2hvc2VuLCBsZXYsIGRvbmUsIG5leHQ7XG5cbiAgICAgIGlmIChudW0gPT09IDApIHtcbiAgICAgICAgI3t5aWVsZCBbXX1cbiAgICAgIH0gZWxzZSBpZiAobnVtID09PSAxKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAje3lpZWxkIGBbc2VsZltpXV1gfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPT09IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICN7eWllbGQgYHNlbGYuc2xpY2UoKWB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChudW0gPj0gMCAmJiBudW0gPCBzZWxmLmxlbmd0aCkge1xuICAgICAgICBzdGFjayA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IG51bSArIDE7IGkrKykge1xuICAgICAgICAgIHN0YWNrLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaG9zZW4gPSBbXTtcbiAgICAgICAgbGV2ID0gMDtcbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICBzdGFja1swXSA9IC0xO1xuXG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgIGNob3NlbltsZXZdID0gc2VsZltzdGFja1tsZXYrMV1dO1xuICAgICAgICAgIHdoaWxlIChsZXYgPCBudW0gLSAxKSB7XG4gICAgICAgICAgICBsZXYrKztcbiAgICAgICAgICAgIG5leHQgPSBzdGFja1tsZXYrMV0gPSBzdGFja1tsZXZdICsgMTtcbiAgICAgICAgICAgIGNob3NlbltsZXZdID0gc2VsZltuZXh0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgI3sgeWllbGQgYGNob3Nlbi5zbGljZSgpYCB9XG4gICAgICAgICAgbGV2Kys7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgZG9uZSA9IChsZXYgPT09IDApO1xuICAgICAgICAgICAgc3RhY2tbbGV2XSsrO1xuICAgICAgICAgICAgbGV2LS07XG4gICAgICAgICAgfSB3aGlsZSAoIHN0YWNrW2xldisxXSArIG51bSA9PT0gc2VsZi5sZW5ndGggKyBsZXYgKyAxICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmVwZWF0ZWRfY29tYmluYXRpb24obilcbiAgICBudW0gPSBPcGFsLmNvZXJjZV90byEgbiwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICAgcmV0dXJuIGVudW1fZm9yKDpyZXBlYXRlZF9jb21iaW5hdGlvbiwgbnVtKSB7IGBiaW5vbWlhbF9jb2VmZmljaWVudChzZWxmLmxlbmd0aCArIG51bSAtIDEsIG51bSlgIH1cbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShtYXgsIGZyb20sIGJ1ZmZlciwgc2VsZikge1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSBtYXgpIHtcbiAgICAgICAgICB2YXIgY29weSA9IGJ1ZmZlci5zbGljZSgpO1xuICAgICAgICAgICN7eWllbGQgYGNvcHlgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBidWZmZXIucHVzaChzZWxmW2ldKTtcbiAgICAgICAgICBpdGVyYXRlKG1heCwgaSwgYnVmZmVyLCBzZWxmKTtcbiAgICAgICAgICBidWZmZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG51bSA+PSAwKSB7XG4gICAgICAgIGl0ZXJhdGUobnVtLCAwLCBbXSwgc2VsZik7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3RcbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKChpdGVtID0gc2VsZltpXSkgIT09IG5pbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdCFcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IHNlbGYubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VsZltpXSA9PT0gbmlsKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSBvcmlnaW5hbCA/IG5pbCA6IHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29uY2F0KCpvdGhlcnMpXG4gICAgb3RoZXJzID0gb3RoZXJzLm1hcCBkbyB8b3RoZXJ8XG4gICAgICBvdGhlciA9IGlmIEFycmF5ID09PSBvdGhlclxuICAgICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGAkY29lcmNlX3RvKG90aGVyLCAje0FycmF5fSwgJ3RvX2FyeScpYC50b19hXG4gICAgICAgICAgICAgIGVuZFxuXG4gICAgICBpZiBvdGhlci5lcXVhbD8oc2VsZilcbiAgICAgICAgb3RoZXIgPSBvdGhlci5kdXBcbiAgICAgIGVuZFxuXG4gICAgICBvdGhlclxuICAgIGVuZFxuXG4gICAgb3RoZXJzLmVhY2ggZG8gfG90aGVyfFxuICAgICAgJXh7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvdGhlci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYucHVzaChvdGhlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRlbGV0ZShvYmplY3QpXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWwgPSBzZWxmLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9yaWdpbmFsOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG9iamVjdH0pIHtcbiAgICAgICAgICBzZWxmLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IG9yaWdpbmFsKSB7XG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICByZXR1cm4gI3t5aWVsZH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2F0KGluZGV4KVxuICAgICV4e1xuICAgICAgaW5kZXggPSAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgaW5kZXggKz0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHNlbGZbaW5kZXhdO1xuXG4gICAgICBzZWxmLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVsZXRlX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmRlbGV0ZV9pZikgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e2ZpbHRlcklmKHNlbGYsICRmYWxzeSwgYmxvY2spfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGRpZmZlcmVuY2UoKmFycmF5cylcbiAgICBhcnJheXMucmVkdWNlKHRvX2EuZHVwKSB7IHxhLCBifCBhIC0gYiB9XG4gIGVuZFxuXG4gIGRlZiBkaWcoaWR4LCAqaWR4cylcbiAgICBpdGVtID0gc2VsZltpZHhdXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwgaWR4cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmlkeHMpXG4gIGVuZFxuXG4gIGRlZiBkcm9wKG51bWJlcilcbiAgICAleHtcbiAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvcn1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UobnVtYmVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkdXBcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkY2xhc3MgPT09IE9wYWwuQXJyYXkgJiZcbiAgICAgICAgICBzZWxmLiQkY2xhc3MuJGFsbG9jYXRlLiQkcHJpc3RpbmUgJiZcbiAgICAgICAgICBzZWxmLiRjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcy4kJHByaXN0aW5lICYmXG4gICAgICAgICAgc2VsZi4kaW5pdGlhbGl6ZV9kdXAuJCRwcmlzdGluZSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlclxuICBlbmRcblxuICBkZWYgZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICR5aWVsZDEoYmxvY2ssIHNlbGZbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGVhY2hfaW5kZXgoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaF9pbmRleCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSAkeWllbGQxKGJsb2NrLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlbXB0eT9cbiAgICBgc2VsZi5sZW5ndGggPT09IDBgXG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWwoYXJyYXksIG90aGVyKSB7XG4gICAgICAgIHZhciBpLCBsZW5ndGgsIGEsIGI7XG5cbiAgICAgICAgaWYgKCFvdGhlci4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSAje290aGVyLnRvX2F9O1xuXG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2VkWyN7YGFycmF5YC5vYmplY3RfaWR9XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhID0gYXJyYXlbaV07XG4gICAgICAgICAgYiA9IG90aGVyW2ldO1xuICAgICAgICAgIGlmIChhLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChiLiQkaXNfYXJyYXkgJiYgYi5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVjdXJzZWQuaGFzT3duUHJvcGVydHkoI3tgYWAub2JqZWN0X2lkfSkpIHtcbiAgICAgICAgICAgICAgaWYgKCFfZXFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFsKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmZXRjaChpbmRleCwgZGVmYXVsdHMgPSB1bmRlZmluZWQsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbCA9IGluZGV4O1xuXG4gICAgICBpbmRleCA9ICRjb2VyY2VfdG8oaW5kZXgsICN7SW50ZWdlcn0sICd0b19pbnQnKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBzZWxmLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc2VsZltpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsICYmIGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBibG9jayBzdXBlcnNlZGVzIGRlZmF1bHQgdmFsdWUgYXJndW1lbnQnKX1cbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrKG9yaWdpbmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlZmF1bHRzICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IDAuLi4wXCJ9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgI3tyYWlzZSBJbmRleEVycm9yLCBcImluZGV4ICN7YG9yaWdpbmFsYH0gb3V0c2lkZSBvZiBhcnJheSBib3VuZHM6IC0je2BzZWxmLmxlbmd0aGB9Li4uI3tgc2VsZi5sZW5ndGhgfVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBmaWxsKCphcmdzLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiBibG9ja1xuICAgICAgaWYgYGFyZ3MubGVuZ3RoID4gMmBcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzICgje2FyZ3MubGVuZ3RofSBmb3IgMC4uMilcIlxuICAgICAgZW5kXG5cbiAgICAgIG9uZSwgdHdvID0gYXJnc1xuICAgIGVsc2VcbiAgICAgIGlmIGBhcmdzLmxlbmd0aCA9PSAwYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoMCBmb3IgMS4uMyknXG4gICAgICBlbHNpZiBgYXJncy5sZW5ndGggPiAzYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YXJncy5sZW5ndGh9IGZvciAxLi4zKVwiXG4gICAgICBlbmRcblxuICAgICAgb2JqLCBvbmUsIHR3byA9IGFyZ3NcbiAgICBlbmRcblxuICAgIGlmIFJhbmdlID09PSBvbmVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2xlbmd0aCBpbnZhbGlkIHdpdGggcmFuZ2UnIGlmIHR3b1xuXG4gICAgICBsZWZ0ICAgPSBgJGNvZXJjZV90byhvbmUuYmVnaW4sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcIiN7b25lLmluc3BlY3R9IG91dCBvZiByYW5nZVwiIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgcmlnaHQgPSBgJGNvZXJjZV90byhvbmUuZW5kLCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICBgcmlnaHQgKz0gdGhpcy5sZW5ndGhgIGlmIGByaWdodCA8IDBgXG4gICAgICBgcmlnaHQgKz0gMWAgdW5sZXNzIG9uZS5leGNsdWRlX2VuZD9cblxuICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0IDw9IGxlZnRgXG4gICAgZWxzaWYgb25lXG4gICAgICBsZWZ0ICAgPSBgJGNvZXJjZV90byhvbmUsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGBsZWZ0ICs9IHRoaXMubGVuZ3RoYCBpZiBgbGVmdCA8IDBgXG4gICAgICBsZWZ0ICAgPSAwIGlmIGBsZWZ0IDwgMGBcblxuICAgICAgaWYgdHdvXG4gICAgICAgIHJpZ2h0ID0gYCRjb2VyY2VfdG8odHdvLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICAgcmV0dXJuIHNlbGYgaWYgYHJpZ2h0ID09IDBgXG5cbiAgICAgICAgYHJpZ2h0ICs9IGxlZnRgXG4gICAgICBlbHNlXG4gICAgICAgIHJpZ2h0ID0gYHRoaXMubGVuZ3RoYFxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgbGVmdCAgPSAwXG4gICAgICByaWdodCA9IGB0aGlzLmxlbmd0aGBcbiAgICBlbmRcblxuICAgIGlmIGBsZWZ0ID4gdGhpcy5sZW5ndGhgXG4gICAgICAleHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGg7IGkgPCByaWdodDsgaSsrKSB7XG4gICAgICAgICAgc2VsZltpXSA9IG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgaWYgYHJpZ2h0ID4gdGhpcy5sZW5ndGhgXG4gICAgICBgdGhpcy5sZW5ndGggPSByaWdodGBcbiAgICBlbmRcblxuICAgIGlmIGJsb2NrXG4gICAgICAleHtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aGlzLmxlbmd0aDsgbGVmdCA8IHJpZ2h0OyBsZWZ0KyspIHtcbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKGxlZnQpO1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRoaXMubGVuZ3RoOyBsZWZ0IDwgcmlnaHQ7IGxlZnQrKykge1xuICAgICAgICAgIHNlbGZbbGVmdF0gPSAje29ian07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGZpcnN0KGNvdW50ID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYubGVuZ3RoID09PSAwID8gbmlsIDogc2VsZlswXTtcbiAgICAgIH1cblxuICAgICAgY291bnQgPSAkY29lcmNlX3RvKGNvdW50LCAje0ludGVnZXJ9LCAndG9faW50Jyk7XG5cbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSd9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5zbGljZSgwLCBjb3VudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbihsZXZlbCA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGZ1bmN0aW9uIF9mbGF0dGVuKGFycmF5LCBsZXZlbCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICBpLCBsZW5ndGgsXG4gICAgICAgICAgICBpdGVtLCBhcnk7XG5cbiAgICAgICAgYXJyYXkgPSAje2BhcnJheWAudG9fYX07XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gYXJyYXlbaV07XG5cbiAgICAgICAgICBpZiAoISRyZXNwb25kX3RvKGl0ZW0sICckdG9fYXJ5JywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXJ5ID0gI3tgaXRlbWAudG9fYXJ5fTtcblxuICAgICAgICAgIGlmIChhcnkgPT09IG5pbCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWFyeS4kJGlzX2FycmF5KSB7XG4gICAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvcn07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyeSA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KF9mbGF0dGVuKGFyeSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJ5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIF9mbGF0dGVuKGFyeSwgbGV2ZWwgLSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldmVsID0gJGNvZXJjZV90byhsZXZlbCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2ZsYXR0ZW4oc2VsZiwgbGV2ZWwpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGZsYXR0ZW4hKGxldmVsID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIGZsYXR0ZW5lZCA9ICN7ZmxhdHRlbiBsZXZlbH07XG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PSBmbGF0dGVuZWQubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzZWxmLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHNlbGZbaV0gIT09IGZsYXR0ZW5lZFtpXSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAje3JlcGxhY2UgYGZsYXR0ZW5lZGB9O1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICAleHtcbiAgICAgIHZhciB0b3AgPSAoJGhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIHJlc3VsdCA9IFsnQSddLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICBpdGVtLCBpLCBrZXk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICAkaGFzaF9pZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGVhcmx5IGZvciByZWN1cnNpdmUgc3RydWN0dXJlc1xuICAgICAgICBpZiAoJGhhc2hfaWRzW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluICRoYXNoX2lkcykge1xuICAgICAgICAgIGl0ZW0gPSAkaGFzaF9pZHNba2V5XTtcbiAgICAgICAgICBpZiAoI3tlcWw/KGBpdGVtYCl9KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlbGYnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICRoYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICByZXN1bHQucHVzaChpdGVtLiRoYXNoKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcsJyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgJGhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5jbHVkZT8obWVtYmVyKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCN7YHNlbGZbaV1gID09IG1lbWJlcn0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5kZXgob2JqZWN0ID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGVuZ3RoLCB2YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgI3t3YXJuKCd3YXJuaW5nOiBnaXZlbiBibG9jayBub3QgdXNlZCcpfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgje2BzZWxmW2ldYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlICYmIHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDppbmRleH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaW5zZXJ0KGluZGV4LCAqb2JqZWN0cylcbiAgICAleHtcbiAgICAgIGluZGV4ID0gJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBpbmRleCArPSBzZWxmLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAjeyByYWlzZSBJbmRleEVycm9yLCBcIiN7aW5kZXh9IGlzIG91dCBvZiBib3VuZHNcIiB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBzZWxmLmxlbmd0aDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYucHVzaChuaWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuc3BsaWNlLmFwcGx5KHNlbGYsIFtpbmRleCwgMF0uY29uY2F0KG9iamVjdHMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgICAgaWQgICAgID0gI3tfX2lkX199O1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9ICN7c2VsZltgaWBdfTtcblxuICAgICAgICBpZiAoI3tgaXRlbWAuX19pZF9ffSA9PT0gaWQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgnWy4uLl0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaCgje2BpdGVtYC5pbnNwZWN0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGludGVyc2VjdGlvbigqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodG9fYS5kdXApIHsgfGEsIGJ8IGEgJiBiIH1cbiAgZW5kXG5cbiAgZGVmIGpvaW4oc2VwID0gbmlsKVxuICAgIHJldHVybiAnJyBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgc2VwID09PSBuaWxgXG4gICAgICBzZXAgPSAkLFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB2YXIgaSwgbGVuZ3RoLCBpdGVtLCB0bXA7XG5cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fc3RyJykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19zdHJ9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgje2B0bXBgLnRvX3N9KTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRyZXNwb25kX3RvKGl0ZW0sICckdG9fYXJ5JykpIHtcbiAgICAgICAgICB0bXAgPSAje2BpdGVtYC50b19hcnl9O1xuXG4gICAgICAgICAgaWYgKHRtcCA9PT0gc2VsZikge1xuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG1wICE9PSBuaWwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCN7YHRtcGAuam9pbihzZXApfSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkcmVzcG9uZF90byhpdGVtLCAnJHRvX3MnKSkge1xuICAgICAgICAgIHRtcCA9ICN7YGl0ZW1gLnRvX3N9O1xuXG4gICAgICAgICAgaWYgKHRtcCAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0bXApO1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAje3JhaXNlIE5vTWV0aG9kRXJyb3IubmV3KFwiI3tgT3BhbC5pbnNwZWN0KGl0ZW0pYH0gZG9lc24ndCByZXNwb25kIHRvICN0b19zdHIsICN0b19hcnkgb3IgI3RvX3NcIiwgJ3RvX3N0cicpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlcCA9PT0gbmlsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCN7T3BhbC5jb2VyY2VfdG8hKHNlcCwgU3RyaW5nLCA6dG9fc3RyKS50b19zfSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYga2VlcF9pZigmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDprZWVwX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgJXh7ZmlsdGVySWYoc2VsZiwgJHRydXRoeSwgYmxvY2spfVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGxhc3QoY291bnQgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoY291bnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2VsZi5sZW5ndGggPT09IDAgPyBuaWwgOiBzZWxmW3NlbGYubGVuZ3RoIC0gMV07XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID0gJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuXG4gICAgICBpZiAoY291bnQgPCAwKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ25lZ2F0aXZlIGFycmF5IHNpemUnfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvdW50ID4gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgY291bnQgPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxlbmd0aFxuICAgIGBzZWxmLmxlbmd0aGBcbiAgZW5kXG5cbiAgYWxpYXMgbWFwIGNvbGxlY3RcblxuICBhbGlhcyBtYXAhIGNvbGxlY3QhXG5cbiAgZGVmIG1heChuID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgZWFjaC5tYXgobiwgJmJsb2NrKVxuICBlbmRcblxuICBkZWYgbWluKCZibG9jaylcbiAgICBlYWNoLm1pbigmYmxvY2spXG4gIGVuZFxuXG4gICV4e1xuICAgIC8vIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgZnJvbSwgZnJvbS0xLCAuLi4sIGZyb20gLSBob3dfbWFueSArIDEuXG4gICAgZnVuY3Rpb24gZGVzY2VuZGluZ19mYWN0b3JpYWwoZnJvbSwgaG93X21hbnkpIHtcbiAgICAgIHZhciBjb3VudCA9IGhvd19tYW55ID49IDAgPyAxIDogMDtcbiAgICAgIHdoaWxlIChob3dfbWFueSkge1xuICAgICAgICBjb3VudCAqPSBmcm9tO1xuICAgICAgICBmcm9tLS07XG4gICAgICAgIGhvd19tYW55LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZGVmIHBlcm11dGF0aW9uKG51bSA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6cGVybXV0YXRpb24sIG51bSkgZG9cbiAgICAgICAgYGRlc2NlbmRpbmdfZmFjdG9yaWFsKHNlbGYubGVuZ3RoLCBudW0gPT09IHVuZGVmaW5lZCA/IHNlbGYubGVuZ3RoIDogbnVtKWBcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICB2YXIgcGVybXV0ZSwgb2ZmZW5zaXZlLCBvdXRwdXQ7XG5cbiAgICAgIGlmIChudW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBudW0gPSBzZWxmLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBudW0gPSAkY29lcmNlX3RvKG51bSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtIDwgMCB8fCBzZWxmLmxlbmd0aCA8IG51bSkge1xuICAgICAgICAvLyBubyBwZXJtdXRhdGlvbnMsIHlpZWxkIG5vdGhpbmdcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMCkge1xuICAgICAgICAvLyBleGFjdGx5IG9uZSBwZXJtdXRhdGlvbjogdGhlIHplcm8tbGVuZ3RoIGFycmF5XG4gICAgICAgICN7IHlpZWxkIFtdIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG51bSA9PT0gMSkge1xuICAgICAgICAvLyB0aGlzIGlzIGEgc3BlY2lhbCwgZWFzeSBjYXNlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICN7IHlpZWxkIGBbc2VsZltpXV1gIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGdlbmVyYWwgY2FzZVxuICAgICAgICAjeyBwZXJtID0gQXJyYXkubmV3KG51bSkgfTtcbiAgICAgICAgI3sgdXNlZCA9IEFycmF5Lm5ldyhgc2VsZi5sZW5ndGhgLCBmYWxzZSkgfTtcblxuICAgICAgICBwZXJtdXRlID0gZnVuY3Rpb24obnVtLCBwZXJtLCBpbmRleCwgdXNlZCwgYmxrKSB7XG4gICAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYoI3sgIXVzZWRbYGlgXSB9KSB7XG4gICAgICAgICAgICAgIHBlcm1baW5kZXhdID0gaTtcbiAgICAgICAgICAgICAgaWYoaW5kZXggPCBudW0gLSAxKSB7XG4gICAgICAgICAgICAgICAgdXNlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGVybXV0ZS5jYWxsKHNlbGYsIG51bSwgcGVybSwgaW5kZXggKyAxLCB1c2VkLCBibGspO1xuICAgICAgICAgICAgICAgIHVzZWRbaV0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlcm0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNlbGZbcGVybVtqXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkeWllbGQxKGJsaywgb3V0cHV0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgje2Jsb2NrX2dpdmVuP30pIHtcbiAgICAgICAgICAvLyBvZmZlbnNpdmUgKGJvdGggZGVmaW5pdGlvbnMpIGNvcHkuXG4gICAgICAgICAgb2ZmZW5zaXZlID0gc2VsZi5zbGljZSgpO1xuICAgICAgICAgIHBlcm11dGUuY2FsbChvZmZlbnNpdmUsIG51bSwgcGVybSwgMCwgdXNlZCwgYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHBlcm11dGUuY2FsbChzZWxmLCBudW0sIHBlcm0sIDAsIHVzZWQsIGJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJlcGVhdGVkX3Blcm11dGF0aW9uKG4pXG4gICAgbnVtID0gT3BhbC5jb2VyY2VfdG8hIG4sIEludGVnZXIsIDp0b19pbnRcbiAgICByZXR1cm4gZW51bV9mb3IoOnJlcGVhdGVkX3Blcm11dGF0aW9uLCBudW0pIHsgbnVtID49IDAgPyBzaXplKipudW0gOiAwIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKG1heCwgYnVmZmVyLCBzZWxmKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IG1heCkge1xuICAgICAgICAgIHZhciBjb3B5ID0gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgI3t5aWVsZCBgY29weWB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKHNlbGZbaV0pO1xuICAgICAgICAgIGl0ZXJhdGUobWF4LCBidWZmZXIsIHNlbGYpO1xuICAgICAgICAgIGJ1ZmZlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyYXRlKG51bSwgW10sIHNlbGYuc2xpY2UoKSk7XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcG9wKGNvdW50ID0gdW5kZWZpbmVkKVxuICAgIGlmIGBjb3VudCA9PT0gdW5kZWZpbmVkYFxuICAgICAgcmV0dXJuIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcbiAgICAgIHJldHVybiBgc2VsZi5wb3AoKWBcbiAgICBlbmRcblxuICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgIGlmIGBjb3VudCA8IDBgXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnbmVnYXRpdmUgYXJyYXkgc2l6ZSdcbiAgICBlbmRcblxuICAgIHJldHVybiBbXSBpZiBgc2VsZi5sZW5ndGggPT09IDBgXG5cbiAgICBpZiBgY291bnQgPT09IDFgXG4gICAgICBgW3NlbGYucG9wKCldYFxuICAgIGVsc2lmIGBjb3VudCA+IHNlbGYubGVuZ3RoYFxuICAgICAgYHNlbGYuc3BsaWNlKDAsIHNlbGYubGVuZ3RoKWBcbiAgICBlbHNlXG4gICAgICBgc2VsZi5zcGxpY2Uoc2VsZi5sZW5ndGggLSBjb3VudCwgc2VsZi5sZW5ndGgpYFxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcHJvZHVjdCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9ICN7YmxvY2tfZ2l2ZW4/fSA/IG51bGwgOiBbXSxcbiAgICAgICAgICBuID0gYXJncy5sZW5ndGggKyAxLFxuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGxlbmd0aHMgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGFycmF5cyAgID0gbmV3IEFycmF5KG4pLFxuICAgICAgICAgIGksIG0sIHN1YmFycmF5LCBsZW4sIHJlc3VsdGxlbiA9IDE7XG5cbiAgICAgIGFycmF5c1swXSA9IHNlbGY7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXSA9ICRjb2VyY2VfdG8oYXJnc1tpIC0gMV0sICN7QXJyYXl9LCAndG9fYXJ5Jyk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGVuID0gYXJyYXlzW2ldLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgc2VsZjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRsZW4gKj0gbGVuO1xuICAgICAgICBpZiAocmVzdWx0bGVuID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgJ3RvbyBiaWcgdG8gcHJvZHVjdCd9XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3Roc1tpXSA9IGxlbjtcbiAgICAgICAgY291bnRlcnNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICBvdXRlcl9sb29wOiBmb3IgKDs7KSB7XG4gICAgICAgIHN1YmFycmF5ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzdWJhcnJheS5wdXNoKGFycmF5c1tpXVtjb3VudGVyc1tpXV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzdWJhcnJheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgI3t5aWVsZCBgc3ViYXJyYXlgfVxuICAgICAgICB9XG4gICAgICAgIG0gPSBuIC0gMTtcbiAgICAgICAgY291bnRlcnNbbV0rKztcbiAgICAgICAgd2hpbGUgKGNvdW50ZXJzW21dID09PSBsZW5ndGhzW21dKSB7XG4gICAgICAgICAgY291bnRlcnNbbV0gPSAwO1xuICAgICAgICAgIGlmICgtLW0gPCAwKSBicmVhayBvdXRlcl9sb29wO1xuICAgICAgICAgIGNvdW50ZXJzW21dKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdCB8fCBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHB1c2goKm9iamVjdHMpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqZWN0cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLnB1c2gob2JqZWN0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBhcHBlbmQgcHVzaFxuXG4gIGRlZiByYXNzb2Mob2JqZWN0KVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICYmIGl0ZW1bMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgje2BpdGVtWzFdYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZWplY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6cmVqZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gYmxvY2soc2VsZltpXSk7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbmlsKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VsZltpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBvcmlnaW5hbCA9IGxlbmd0aFxuICAgIGRlbGV0ZV9pZigmYmxvY2spXG5cbiAgICB1bmxlc3MgbGVuZ3RoID09IG9yaWdpbmFsXG4gICAgICBzZWxmXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKG90aGVyKVxuICAgIG90aGVyID0gaWYgQXJyYXkgPT09IG90aGVyXG4gICAgICAgICAgICAgIG90aGVyLnRvX2FcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYCRjb2VyY2VfdG8ob3RoZXIsICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBzZWxmLnNwbGljZSgwLCBzZWxmLmxlbmd0aCk7XG4gICAgICBzZWxmLnB1c2guYXBwbHkoc2VsZiwgb3RoZXIpO1xuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VcbiAgICBgc2VsZi5zbGljZSgwKS5yZXZlcnNlKClgXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlIVxuICAgIGBzZWxmLnJldmVyc2UoKWBcbiAgZW5kXG5cbiAgZGVmIHJldmVyc2VfZWFjaCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZXZlcnNlX2VhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHJldmVyc2UuZWFjaCgmYmxvY2spXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgcmluZGV4KG9iamVjdCA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIHZhbHVlO1xuXG4gICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgYmxvY2sgIT09IG5pbCkge1xuICAgICAgICAje3dhcm4oJ3dhcm5pbmc6IGdpdmVuIGJsb2NrIG5vdCB1c2VkJyl9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGkgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoI3tgc2VsZltpXWAgPT0gYG9iamVjdGB9KSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gc2VsZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChpID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZSA9IGJsb2NrKHNlbGZbaV0pO1xuXG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBmYWxzZSAmJiB2YWx1ZSAhPT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAje2VudW1fZm9yIDpyaW5kZXh9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJvdGF0ZShuID0gMSlcbiAgICAleHtcbiAgICAgIHZhciBhcnksIGlkeCwgZmlyc3RQYXJ0LCBsYXN0UGFydDtcblxuICAgICAgbiA9ICRjb2VyY2VfdG8obiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpXG5cbiAgICAgIGlmIChzZWxmLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gc2VsZi5zbGljZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgYXJ5ID0gc2VsZi5zbGljZSgpO1xuICAgICAgaWR4ID0gbiAlIGFyeS5sZW5ndGg7XG5cbiAgICAgIGZpcnN0UGFydCA9IGFyeS5zbGljZShpZHgpO1xuICAgICAgbGFzdFBhcnQgPSBhcnkuc2xpY2UoMCwgaWR4KTtcbiAgICAgIHJldHVybiBmaXJzdFBhcnQuY29uY2F0KGxhc3RQYXJ0KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByb3RhdGUhKGNudCA9IDEpXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi5sZW5ndGggPT09IDAgfHwgc2VsZi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG4gICAgICBjbnQgPSAkY29lcmNlX3RvKGNudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpO1xuICAgIH1cbiAgICBhcnkgPSByb3RhdGUoY250KVxuICAgIHJlcGxhY2UgYXJ5XG4gIGVuZFxuXG4gIGNsYXNzIFNhbXBsZVJhbmRvbVxuICAgIGRlZiBpbml0aWFsaXplKHJuZylcbiAgICAgIEBybmcgPSBybmdcbiAgICBlbmRcblxuICAgIGRlZiByYW5kKHNpemUpXG4gICAgICByYW5kb20gPSBgJGNvZXJjZV90bygje0BybmcucmFuZChzaXplKX0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdyYW5kb20gdmFsdWUgbXVzdCBiZSA+PSAwJyBpZiBgcmFuZG9tIDwgMGBcbiAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdyYW5kb20gdmFsdWUgbXVzdCBiZSBsZXNzIHRoYW4gQXJyYXkgc2l6ZScgdW5sZXNzIGByYW5kb20gPCBzaXplYFxuXG4gICAgICByYW5kb21cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNhbXBsZShjb3VudCA9IHVuZGVmaW5lZCwgb3B0aW9ucyA9IHVuZGVmaW5lZClcbiAgICByZXR1cm4gYXQgS2VybmVsLnJhbmQoYHNlbGYubGVuZ3RoYCkgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG5cbiAgICBpZiBgb3B0aW9ucyA9PT0gdW5kZWZpbmVkYFxuICAgICAgaWYgKG8gPSBPcGFsLmNvZXJjZV90bz8gY291bnQsIEhhc2gsIDp0b19oYXNoKVxuICAgICAgICBvcHRpb25zID0gb1xuICAgICAgICBjb3VudCA9IG5pbFxuICAgICAgZWxzZVxuICAgICAgICBvcHRpb25zID0gbmlsXG4gICAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgIGNvdW50ID0gYCRjb2VyY2VfdG8oY291bnQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcbiAgICAgIG9wdGlvbnMgPSBgJGNvZXJjZV90byhvcHRpb25zLCAje0hhc2h9LCAndG9faGFzaCcpYFxuICAgIGVuZFxuXG4gICAgaWYgY291bnQgJiYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICdjb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJ1xuICAgIGVuZFxuXG4gICAgcm5nID0gb3B0aW9uc1s6cmFuZG9tXSBpZiBvcHRpb25zXG4gICAgcm5nID0gaWYgcm5nICYmIHJuZy5yZXNwb25kX3RvPyg6cmFuZClcbiAgICAgICAgICAgIFNhbXBsZVJhbmRvbS5uZXcgcm5nXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgS2VybmVsXG4gICAgICAgICAgZW5kXG5cbiAgICByZXR1cm4gYHNlbGZbI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX1dYCB1bmxlc3MgY291bnRcblxuICAgICV4e1xuXG4gICAgICB2YXIgYWJhbmRvbiwgc3BpbiwgcmVzdWx0LCBpLCBqLCBrLCB0YXJnZXRJbmRleCwgb2xkVmFsdWU7XG5cbiAgICAgIGlmIChjb3VudCA+IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgIGNvdW50ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY291bnQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBbc2VsZlsje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaSA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgIGogPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgaiA9IGkgPT09IDAgPyBpICsgMSA6IGkgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gW3NlbGZbaV0sIHNlbGZbal1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChzZWxmLmxlbmd0aCAvIGNvdW50ID4gMykge1xuICAgICAgICAgICAgYWJhbmRvbiA9IGZhbHNlO1xuICAgICAgICAgICAgc3BpbiA9IDA7XG5cbiAgICAgICAgICAgIHJlc3VsdCA9ICN7IEFycmF5Lm5ldyhjb3VudCkgfTtcbiAgICAgICAgICAgIGkgPSAxO1xuXG4gICAgICAgICAgICByZXN1bHRbMF0gPSAje3JuZy5yYW5kKGBzZWxmLmxlbmd0aGApfTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgayA9ICN7cm5nLnJhbmQoYHNlbGYubGVuZ3RoYCl9O1xuICAgICAgICAgICAgICBqID0gMDtcblxuICAgICAgICAgICAgICB3aGlsZSAoaiA8IGkpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA9PT0gcmVzdWx0W2pdKSB7XG4gICAgICAgICAgICAgICAgICBzcGluKys7XG4gICAgICAgICAgICAgICAgICBpZiAoc3BpbiA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBhYmFuZG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBrID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhYmFuZG9uKSB7IGJyZWFrOyB9XG5cbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYWJhbmRvbikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgIHJlc3VsdFtpXSA9IGs7XG5cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFiYW5kb24pIHtcbiAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChpIDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBzZWxmW3Jlc3VsdFtpXV07XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHQgPSBzZWxmLnNsaWNlKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvdW50OyBjKyspIHtcbiAgICAgICAgICAgIHRhcmdldEluZGV4ID0gI3tybmcucmFuZChgc2VsZi5sZW5ndGhgKX07XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHJlc3VsdFtjXTtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IHJlc3VsdFt0YXJnZXRJbmRleF07XG4gICAgICAgICAgICByZXN1bHRbdGFyZ2V0SW5kZXhdID0gb2xkVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvdW50ID09PSBzZWxmLmxlbmd0aCA/IHJlc3VsdCA6ICN7YHJlc3VsdGBbMCwgY291bnRdfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoLCBpdGVtLCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuXG4gICAgICAgIHZhbHVlID0gJHlpZWxkMShibG9jaywgaXRlbSk7XG5cbiAgICAgICAgaWYgKCR0cnV0aHkodmFsdWUpKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNlbGVjdCEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgICV4e1xuICAgICAgdmFyIG9yaWdpbmFsID0gc2VsZi5sZW5ndGg7XG4gICAgICAjeyBrZWVwX2lmKCZibG9jaykgfTtcbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWwgPyBuaWwgOiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmlsdGVyIHNlbGVjdFxuICBhbGlhcyBmaWx0ZXIhIHNlbGVjdCFcblxuICBkZWYgc2hpZnQoY291bnQgPSB1bmRlZmluZWQpXG4gICAgaWYgYGNvdW50ID09PSB1bmRlZmluZWRgXG4gICAgICByZXR1cm4gaWYgYHNlbGYubGVuZ3RoID09PSAwYFxuICAgICAgcmV0dXJuIGBzaGlmdE5vQXJnKHNlbGYpYFxuICAgIGVuZFxuXG4gICAgY291bnQgPSBgJGNvZXJjZV90byhjb3VudCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuXG4gICAgaWYgYGNvdW50IDwgMGBcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBhcnJheSBzaXplJ1xuICAgIGVuZFxuXG4gICAgcmV0dXJuIFtdIGlmIGBzZWxmLmxlbmd0aCA9PT0gMGBcblxuICAgIGBzZWxmLnNwbGljZSgwLCBjb3VudClgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHNodWZmbGUocm5nID0gdW5kZWZpbmVkKVxuICAgIGR1cC50b19hLnNodWZmbGUhKHJuZylcbiAgZW5kXG5cbiAgZGVmIHNodWZmbGUhKHJuZyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIHZhciByYW5kZ2VuLCBpID0gc2VsZi5sZW5ndGgsIGosIHRtcDtcblxuICAgICAgaWYgKHJuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJuZyA9ICN7T3BhbC5jb2VyY2VfdG8/KHJuZywgSGFzaCwgOnRvX2hhc2gpfTtcblxuICAgICAgICBpZiAocm5nICE9PSBuaWwpIHtcbiAgICAgICAgICBybmcgPSAje3JuZ1s6cmFuZG9tXX07XG5cbiAgICAgICAgICBpZiAocm5nICE9PSBuaWwgJiYgI3tybmcucmVzcG9uZF90bz8oOnJhbmQpfSkge1xuICAgICAgICAgICAgcmFuZGdlbiA9IHJuZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaWYgKHJhbmRnZW4pIHtcbiAgICAgICAgICBqID0gcmFuZGdlbi4kcmFuZChpKS4kdG9faW50KCk7XG5cbiAgICAgICAgICBpZiAoaiA8IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgXCJyYW5kb20gbnVtYmVyIHRvbyBzbWFsbCAje2BqYH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaiA+PSBpKSB7XG4gICAgICAgICAgICAje3JhaXNlIFJhbmdlRXJyb3IsIFwicmFuZG9tIG51bWJlciB0b28gYmlnICN7YGpgfVwifVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBqID0gI3tyYW5kKGBpYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgdG1wID0gc2VsZlstLWldO1xuICAgICAgICBzZWxmW2ldID0gc2VsZltqXTtcbiAgICAgICAgc2VsZltqXSA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBzbGljZSBbXVxuXG4gIGRlZiBzbGljZSEoaW5kZXgsIGxlbmd0aCA9IHVuZGVmaW5lZClcbiAgICByZXN1bHQgPSBuaWxcblxuICAgIGlmIGBsZW5ndGggPT09IHVuZGVmaW5lZGBcbiAgICAgIGlmIFJhbmdlID09PSBpbmRleFxuICAgICAgICByYW5nZSA9IGluZGV4XG4gICAgICAgIHJlc3VsdCA9IHNlbGZbcmFuZ2VdXG5cbiAgICAgICAgcmFuZ2Vfc3RhcnQgPSBgJGNvZXJjZV90byhyYW5nZS5iZWdpbiwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICByYW5nZV9lbmQgPSBgJGNvZXJjZV90byhyYW5nZS5lbmQsICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAocmFuZ2Vfc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICByYW5nZV9zdGFydCArPSBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFuZ2VfZW5kIDwgMCkge1xuICAgICAgICAgICAgcmFuZ2VfZW5kICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2VfZW5kID49IHNlbGYubGVuZ3RoKSB7XG4gICAgICAgICAgICByYW5nZV9lbmQgPSBzZWxmLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZXhjbCkge1xuICAgICAgICAgICAgICByYW5nZV9lbmQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmFuZ2VfbGVuZ3RoID0gcmFuZ2VfZW5kIC0gcmFuZ2Vfc3RhcnQ7XG4gICAgICAgICAgaWYgKHJhbmdlLmV4Y2wpIHtcbiAgICAgICAgICAgIHJhbmdlX2VuZCAtPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYW5nZV9sZW5ndGggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFuZ2Vfc3RhcnQgPCBzZWxmLmxlbmd0aCAmJiByYW5nZV9zdGFydCA+PSAwICYmIHJhbmdlX2VuZCA8IHNlbGYubGVuZ3RoICYmIHJhbmdlX2VuZCA+PSAwICYmIHJhbmdlX2xlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNlbGYuc3BsaWNlKHJhbmdlX3N0YXJ0LCByYW5nZV9sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBzdGFydCA9IGAkY29lcmNlX3RvKGluZGV4LCAje0ludGVnZXJ9LCAndG9faW50JylgXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0ID0gc2VsZltzdGFydF07XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIHNlbGYuc2hpZnQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zcGxpY2Uoc3RhcnQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgZW5kXG4gICAgZWxzZVxuICAgICAgc3RhcnQgPSBgJGNvZXJjZV90byhpbmRleCwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgbGVuZ3RoID0gYCRjb2VyY2VfdG8obGVuZ3RoLCAje0ludGVnZXJ9LCAndG9faW50JylgXG5cbiAgICAgICV4e1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgIHJldHVybiBuaWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBsZW5ndGg7XG5cbiAgICAgICAgcmVzdWx0ID0gI3tzZWxmW3N0YXJ0LCBsZW5ndGhdfTtcblxuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgc3RhcnQgKz0gc2VsZi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgKyBsZW5ndGggPiBzZWxmLmxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPCBzZWxmLmxlbmd0aCAmJiBzdGFydCA+PSAwKSB7XG4gICAgICAgICAgc2VsZi5zcGxpY2Uoc3RhcnQsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbmRcbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmIHNvcnQoJmJsb2NrKVxuICAgIHJldHVybiBzZWxmIHVubGVzcyBgc2VsZi5sZW5ndGggPiAxYFxuXG4gICAgJXh7XG4gICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICBibG9jayA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gI3tgYWAgPD0+IGBiYH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLnNsaWNlKCkuc29ydChmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByZXQgPSBibG9jayh4LCB5KTtcblxuICAgICAgICBpZiAocmV0ID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje2B4YC5pbnNwZWN0fSB3aXRoICN7YHlgLmluc3BlY3R9IGZhaWxlZFwifTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAje2ByZXRgID4gMH0gPyAxIDogKCN7YHJldGAgPCAwfSA/IC0xIDogMCk7XG4gICAgICB9KTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzb3J0ISgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICBpZiAoI3tibG9ja19naXZlbj99KSB7XG4gICAgICAgIHJlc3VsdCA9ICN7YHNlbGYuc2xpY2UoKWAuc29ydCgmYmxvY2spfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSAje2BzZWxmLnNsaWNlKClgLnNvcnR9O1xuICAgICAgfVxuXG4gICAgICBzZWxmLmxlbmd0aCA9IDA7XG4gICAgICBmb3IodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKHJlc3VsdFtpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvcnRfYnkhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnNvcnRfYnkhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICByZXBsYWNlIHNvcnRfYnkoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdGFrZShjb3VudClcbiAgICAleHtcbiAgICAgIGlmIChjb3VudCA8IDApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuc2xpY2UoMCwgY291bnQpO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRha2Vfd2hpbGUoJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGgsIGl0ZW0sIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG5cbiAgICAgICAgdmFsdWUgPSBibG9jayhpdGVtKTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9fYVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRjbGFzcyA9PT0gT3BhbC5BcnJheSkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gT3BhbC5BcnJheS4kbmV3KHNlbGYpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2FyeVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIGFycmF5ID0gc2VsZlxuICAgIGFycmF5ID0gYXJyYXkubWFwKCZibG9jaykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICAleHtcbiAgICAgIHZhciBpLCBsZW4gPSBhcnJheS5sZW5ndGgsIGFyeSwga2V5LCB2YWwsIGhhc2ggPSAje3t9fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGFyeSA9ICN7T3BhbC5jb2VyY2VfdG8/KGBhcnJheVtpXWAsIEFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmICghYXJ5LiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJ3cm9uZyBlbGVtZW50IHR5cGUgI3tgYXJ5YC5jbGFzc30gYXQgI3tgaWB9IChleHBlY3RlZCBhcnJheSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJ5Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ3cm9uZyBhcnJheSBsZW5ndGggYXQgI3tgaWB9IChleHBlY3RlZCAyLCB3YXMgI3tgYXJ5YC5sZW5ndGh9KVwifVxuICAgICAgICB9XG4gICAgICAgIGtleSA9IGFyeVswXTtcbiAgICAgICAgdmFsID0gYXJ5WzFdO1xuICAgICAgICAkaGFzaF9wdXQoaGFzaCwga2V5LCB2YWwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0cmFuc3Bvc2VcbiAgICByZXR1cm4gW10gaWYgZW1wdHk/XG5cbiAgICByZXN1bHQgPSBbXVxuICAgIG1heCAgICA9IG5pbFxuXG4gICAgZWFjaCBkbyB8cm93fFxuICAgICAgcm93ID0gaWYgQXJyYXkgPT09IHJvd1xuICAgICAgICAgICAgICByb3cudG9fYVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBgJGNvZXJjZV90byhyb3csICN7QXJyYXl9LCAndG9fYXJ5JylgLnRvX2FcbiAgICAgICAgICAgIGVuZFxuXG4gICAgICBtYXggfHw9IGByb3cubGVuZ3RoYFxuXG4gICAgICBpZiBgcm93Lmxlbmd0aGAgIT0gbWF4XG4gICAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwiZWxlbWVudCBzaXplIGRpZmZlcnMgKCN7YHJvdy5sZW5ndGhgfSBzaG91bGQgYmUgI3ttYXh9KVwiXG4gICAgICBlbmRcblxuICAgICAgYHJvdy5sZW5ndGhgLnRpbWVzIGRvIHxpfFxuICAgICAgICBlbnRyeSA9IChyZXN1bHRbaV0gfHw9IFtdKVxuICAgICAgICBlbnRyeSA8PCByb3cuYXQoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGRlZiB1bmlvbigqYXJyYXlzKVxuICAgIGFycmF5cy5yZWR1Y2UodW5pcSkgeyB8YSwgYnwgYSB8IGIgfVxuICBlbmRcblxuICBkZWYgdW5pcSgmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgaWYgKGJsb2NrID09PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGl0ZW0gPSBzZWxmW2ldO1xuICAgICAgICAgIGlmICgkaGFzaF9nZXQoaGFzaCwgaXRlbSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGl0ZW0sIGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpdGVtID0gc2VsZltpXTtcbiAgICAgICAgICBrZXkgPSAkeWllbGQxKGJsb2NrLCBpdGVtKTtcbiAgICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgJGhhc2hfcHV0KGhhc2gsIGtleSwgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAje2BoYXNoYC52YWx1ZXN9O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHVuaXEhKCZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBvcmlnaW5hbF9sZW5ndGggPSBzZWxmLmxlbmd0aCwgaGFzaCA9ICN7e319LCBpLCBsZW5ndGgsIGl0ZW0sIGtleTtcblxuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb3JpZ2luYWxfbGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNlbGZbaV07XG4gICAgICAgIGtleSA9IChibG9jayA9PT0gbmlsID8gaXRlbSA6ICR5aWVsZDEoYmxvY2ssIGl0ZW0pKTtcblxuICAgICAgICBpZiAoJGhhc2hfZ2V0KGhhc2gsIGtleSkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICRoYXNoX3B1dChoYXNoLCBrZXksIGl0ZW0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLmxlbmd0aCA9PT0gb3JpZ2luYWxfbGVuZ3RoID8gbmlsIDogc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB1bnNoaWZ0KCpvYmplY3RzKVxuICAgICV4e1xuICAgICAgdmFyIHNlbGZMZW5ndGggPSBzZWxmLmxlbmd0aFxuICAgICAgdmFyIG9iamVjdHNMZW5ndGggPSBvYmplY3RzLmxlbmd0aFxuICAgICAgaWYgKG9iamVjdHNMZW5ndGggPT0gMCkgcmV0dXJuIHNlbGY7XG4gICAgICB2YXIgaW5kZXggPSBzZWxmTGVuZ3RoIC0gb2JqZWN0c0xlbmd0aFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5wdXNoKHNlbGZbaW5kZXggKyBpXSlcbiAgICAgIH1cbiAgICAgIHZhciBsZW4gPSBzZWxmTGVuZ3RoIC0gMVxuICAgICAgd2hpbGUgKGxlbiAtIG9iamVjdHNMZW5ndGggPj0gMCkge1xuICAgICAgICBzZWxmW2xlbl0gPSBzZWxmW2xlbiAtIG9iamVjdHNMZW5ndGhdXG4gICAgICAgIGxlbi0tXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iamVjdHNMZW5ndGg7IGorKykge1xuICAgICAgICBzZWxmW2pdID0gb2JqZWN0c1tqXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBwcmVwZW5kIHVuc2hpZnRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIG91dCA9IFtdXG5cbiAgICBhcmdzLmVhY2ggZG8gfGVsZW18XG4gICAgICBpZiBlbGVtLmlzX2E/IFJhbmdlXG4gICAgICAgIGZpbmlzaCA9IGAkY29lcmNlX3RvKCN7ZWxlbS5sYXN0fSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICBzdGFydCA9IGAkY29lcmNlX3RvKCN7ZWxlbS5maXJzdH0sICN7SW50ZWdlcn0sICd0b19pbnQnKWBcblxuICAgICAgICAleHtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IHN0YXJ0ICsgc2VsZi5sZW5ndGg7XG4gICAgICAgICAgICAje25leHR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICV4e1xuICAgICAgICAgIGlmIChmaW5pc2ggPCAwKSB7XG4gICAgICAgICAgICBmaW5pc2ggPSBmaW5pc2ggKyBzZWxmLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCN7ZWxlbS5leGNsdWRlX2VuZD99KSB7XG4gICAgICAgICAgICBmaW5pc2gtLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpbmlzaCA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAje25leHR9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0LnVwdG8oZmluaXNoKSB7IHxpfCBvdXQgPDwgYXQoaSkgfVxuICAgICAgZWxzZVxuICAgICAgICBpID0gYCRjb2VyY2VfdG8oZWxlbSwgI3tJbnRlZ2VyfSwgJ3RvX2ludCcpYFxuICAgICAgICBvdXQgPDwgYXQoaSlcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgb3V0XG4gIGVuZFxuXG4gIGRlZiB6aXAoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdLCBzaXplID0gc2VsZi5sZW5ndGgsIHBhcnQsIG8sIGksIGosIGpqO1xuXG4gICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIG8gPSBvdGhlcnNbal07XG4gICAgICAgIGlmIChvLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby4kJGlzX3JhbmdlIHx8IG8uJCRpc19lbnVtZXJhdG9yKSB7XG4gICAgICAgICAgb3RoZXJzW2pdID0gby4kdGFrZShzaXplKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcnNbal0gPSAjeyhcbiAgICAgICAgICBPcGFsLmNvZXJjZV90bz8oYG9gLCBBcnJheSwgOnRvX2FyeSkgfHxcbiAgICAgICAgICBPcGFsLmNvZXJjZV90byEoYG9gLCBFbnVtZXJhdG9yLCA6dG9fZW51bSwgOmVhY2gpXG4gICAgICAgICkudG9fYX07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgcGFydCA9IFtzZWxmW2ldXTtcblxuICAgICAgICBmb3IgKGogPSAwLCBqaiA9IG90aGVycy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgbyA9IG90aGVyc1tqXVtpXTtcblxuICAgICAgICAgIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBuaWw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydFtqICsgMV0gPSBvO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0W2ldID0gcGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgIGJsb2NrKHJlc3VsdFtpXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuaW5oZXJpdGVkKGtsYXNzKVxuICAgICV4e1xuICAgICAga2xhc3MuJCRwcm90b3R5cGUuJHRvX2EgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluc3RhbmNlX3ZhcmlhYmxlc1xuICAgIHN1cGVyLnJlamVjdCB7IHxpdmFyfCBgL15AXFxkKyQvLnRlc3QoI3tpdmFyfSlgIHx8IGl2YXIgPT0gJ0BsZW5ndGgnIH1cbiAgZW5kXG5cbiAgT3BhbC5wcmlzdGluZSBzaW5nbGV0b25fY2xhc3MsIDphbGxvY2F0ZVxuICBPcGFsLnByaXN0aW5lIHNlbGYsIDpjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcywgOmluaXRpYWxpemVfZHVwXG5cbiAgZGVmIHBhY2soKmFyZ3MpXG4gICAgcmFpc2UgXCJUbyB1c2UgQXJyYXkjcGFjaywgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnY29yZWxpYi9hcnJheS9wYWNrJy5cIlxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpBcnJheT4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsInRvX2EiLCJbXSIsImluaXRpYWxpemUiLCJzaXplIiwib2JqIiwid2FybiIsIkludGVnZXI6Ok1BWCIsIkludGVnZXIiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJyZXBsYWNlIiwicmVzcG9uZF90bz8iLCJ0b19hcnkiLCJ0cnlfY29udmVydCIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCImIiwib3RoZXIiLCI9PT0iLCJ8IiwiKiIsImpvaW4iLCJ0b19zdHIiLCIrIiwiLSIsIjw8Iiwib2JqZWN0IiwiPD0+IiwiaGFzaCIsIj09Iiwib2JqZWN0X2lkIiwiaW5kZXgiLCJsZW5ndGgiLCJbXT0iLCJ2YWx1ZSIsImV4dHJhIiwiUmFuZ2UiLCJkYXRhIiwiUmFuZ2VFcnJvciIsImluc3BlY3QiLCIxIiwiSW5kZXhFcnJvciIsImFueT8iLCJwYXR0ZXJuIiwiYXNzb2MiLCJhdCIsImJzZWFyY2hfaW5kZXgiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsIlR5cGVFcnJvciIsImNsYXNzIiwiYnNlYXJjaCIsImJsb2NrIiwidG9fcHJvYyIsImN5Y2xlIiwibiIsImJsb2NrIGluIGN5Y2xlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBjeWNsZSIsIm5pbD8iLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsImNvZXJjZV90byEiLCI+IiwiMCIsImVudW1lcmF0b3Jfc2l6ZSIsIiRyZXRfb3JfMSIsImVtcHR5PyIsImNsZWFyIiwiY291bnQiLCIkcmV0X29yXzIiLCJpbml0aWFsaXplX2NvcHkiLCJjb2xsZWN0IiwiYmxvY2sgaW4gY29sbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gY29sbGVjdCIsImNvbGxlY3QhIiwiYmxvY2sgaW4gY29sbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIGNvbGxlY3QhIiwiY29tYmluYXRpb24iLCJudW0iLCJibG9jayBpbiBjb21iaW5hdGlvbiIsImJsb2NrICgyIGxldmVscykgaW4gY29tYmluYXRpb24iLCJyZXBlYXRlZF9jb21iaW5hdGlvbiIsImJsb2NrIGluIHJlcGVhdGVkX2NvbWJpbmF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXBlYXRlZF9jb21iaW5hdGlvbiIsImNvbXBhY3QiLCJjb21wYWN0ISIsImNvbmNhdCIsIm90aGVycyIsIm1hcCIsImJsb2NrIGluIGNvbmNhdCIsImJsb2NrICgyIGxldmVscykgaW4gY29uY2F0IiwiZXF1YWw/IiwiZHVwIiwiZWFjaCIsImRlbGV0ZSIsImRlbGV0ZV9hdCIsImRlbGV0ZV9pZiIsImJsb2NrIGluIGRlbGV0ZV9pZiIsImJsb2NrICgyIGxldmVscykgaW4gZGVsZXRlX2lmIiwiZGlmZmVyZW5jZSIsInJlZHVjZSIsImFycmF5cyIsImJsb2NrIGluIGRpZmZlcmVuY2UiLCJhIiwiYiIsImJsb2NrICgyIGxldmVscykgaW4gZGlmZmVyZW5jZSIsImRpZyIsImlkeCIsIml0ZW0iLCJpZHhzIiwiZHJvcCIsIm51bWJlciIsImJsb2NrIGluIGVhY2giLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2giLCJlYWNoX2luZGV4IiwiYmxvY2sgaW4gZWFjaF9pbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaF9pbmRleCIsImVxbD8iLCJmZXRjaCIsImRlZmF1bHRzIiwiZmlsbCIsImFyZ3MiLCJvbmUiLCJ0d28iLCJsZWZ0IiwicmlnaHQiLCJleGNsdWRlX2VuZD8iLCJmaXJzdCIsImZsYXR0ZW4iLCJsZXZlbCIsImZsYXR0ZW4hIiwiaW5jbHVkZT8iLCJtZW1iZXIiLCJpbnNlcnQiLCJfX2lkX18iLCJpbnRlcnNlY3Rpb24iLCJibG9jayBpbiBpbnRlcnNlY3Rpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIGludGVyc2VjdGlvbiIsInNlcCIsIiQsIiwidG9fcyIsIk5vTWV0aG9kRXJyb3IiLCJuZXciLCJTdHJpbmciLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxhc3QiLCJtYXgiLCJtaW4iLCJwZXJtdXRhdGlvbiIsImJsb2NrIGluIHBlcm11dGF0aW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBwZXJtdXRhdGlvbiIsInBlcm0iLCJ1c2VkIiwiISIsInJlcGVhdGVkX3Blcm11dGF0aW9uIiwiYmxvY2sgaW4gcmVwZWF0ZWRfcGVybXV0YXRpb24iLCJibG9jayAoMiBsZXZlbHMpIGluIHJlcGVhdGVkX3Blcm11dGF0aW9uIiwiPj0iLCIqKiIsInBvcCIsInByb2R1Y3QiLCJwdXNoIiwicmFzc29jIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsIm9yaWdpbmFsIiwicmV2ZXJzZSIsInJldmVyc2UhIiwicmV2ZXJzZV9lYWNoIiwiYmxvY2sgaW4gcmV2ZXJzZV9lYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZXZlcnNlX2VhY2giLCJyaW5kZXgiLCJyb3RhdGUiLCJyb3RhdGUhIiwiY250IiwiYXJ5IiwiPGNsYXNzOlNhbXBsZVJhbmRvbT4iLCJybmciLCJAcm5nIiwicmFuZCIsInJhbmRvbSIsInNhbXBsZSIsIm9wdGlvbnMiLCJLZXJuZWwiLCJvIiwiSGFzaCIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsIlNhbXBsZVJhbmRvbSIsInNlbGVjdCIsImJsb2NrIGluIHNlbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0Iiwic2VsZWN0ISIsImJsb2NrIGluIHNlbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCEiLCJzaGlmdCIsInNodWZmbGUiLCJzaHVmZmxlISIsInNsaWNlISIsInJlc3VsdCIsInJhbmdlIiwicmFuZ2Vfc3RhcnQiLCJyYW5nZV9lbmQiLCJzdGFydCIsInNvcnQiLCI8Iiwic29ydCEiLCJzb3J0X2J5ISIsImJsb2NrIGluIHNvcnRfYnkhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBzb3J0X2J5ISIsInNvcnRfYnkiLCJ0YWtlIiwidGFrZV93aGlsZSIsInRvX2giLCJhcnJheSIsInRyYW5zcG9zZSIsImJsb2NrIGluIHRyYW5zcG9zZSIsInJvdyIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNwb3NlIiwiJHJldF9vcl81IiwiIT0iLCJ0aW1lcyIsImkiLCJibG9jayAoMyBsZXZlbHMpIGluIHRyYW5zcG9zZSIsImVudHJ5IiwiJHJldF9vcl82IiwiJHdyaXRlciIsInVuaW9uIiwidW5pcSIsImJsb2NrIGluIHVuaW9uIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1bmlvbiIsInZhbHVlcyIsInVuaXEhIiwidW5zaGlmdCIsInZhbHVlc19hdCIsIm91dCIsImJsb2NrIGluIHZhbHVlc19hdCIsImVsZW0iLCJibG9jayAoMiBsZXZlbHMpIGluIHZhbHVlc19hdCIsImlzX2E/IiwiZmluaXNoIiwidXB0byIsImJsb2NrICgzIGxldmVscykgaW4gdmFsdWVzX2F0IiwiemlwIiwiJHJldF9vcl83IiwiRW51bWVyYXRvciIsImluaGVyaXRlZCIsImtsYXNzIiwiaW5zdGFuY2VfdmFyaWFibGVzIiwiYmxvY2sgaW4gaW5zdGFuY2VfdmFyaWFibGVzIiwiaXZhciIsImJsb2NrICgyIGxldmVscykgaW4gaW5zdGFuY2VfdmFyaWFibGVzIiwiJHJldF9vcl84IiwicHJpc3RpbmUiLCJzaW5nbGV0b25fY2xhc3MiLCJwYWNrIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUVBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBRUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLDBCQUFSRDtJQUdDRDs7QUFHSEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwwQ0FBNENBLENBQUNBLEdBQURBLENBQUtHLE1BQUFBLENBQUFBLENBQU1IO0FBQ3ZEQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0lBRUVJLFVBQUlOLElBQUpNLFNBQUFBLGNBQUFBLFNBeEVGLEVBd0VFQTtBQUFBQSxNQUFBQTs7OztNQXhFRjs7TUF3RWM7TUFDVkEsT0FBQ0EsOEJBQURBO0lBREZBLENBQUFBLDBCQUFBQTs7QUFJQUMsSUFBQUEsOEJBQUFBLHNCQUFBQSxzQkFBZUMsSUFBRCxFQUFhQyxHQUEzQkY7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBc0M7O01BQXZCO01BQUEsU0FBTyxHQUFQO01BQUE7O01BQVk7TUFBQSxRQUFNLEdBQU47TUFBQTs7QUFFN0JBO0FBQ0FBLFFBQVVQLElBQUFVLE1BQUFBLENBQUtILGtEQUFMRztBQUNWSDs7QUFFQUEsaUJBQW1CSSxJQUFBQyx1QkFBQUQsUUFBYUo7QUFDaENBLFFBQVVQLElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCUCxvQkFBckJNO0FBQ1ZOOztBQUVBQTtBQUNBQSxRQUFVUCxJQUFBYSxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQixFQUFBLEdBQUEsNkJBQUEsR0FBQSxDQUErQlAsZ0JBQS9CLENBQUEsR0FBQSxZQUFyQk07QUFDVk47O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSxVQUFZUCxJQUFBZSxTQUFBQSxDQUFRUCxJQUFJSCxNQUFBQSxDQUFBQSxDQUFaVTtBQUNaUjtBQUNBQSxtQkFBcUJDLElBQUlRLGdCQUFBQSxDQUFhLFFBQWJBLENBQXFCVDtBQUM5Q0EsVUFBWVAsSUFBQWUsU0FBQUEsQ0FBUVAsSUFBSVMsUUFBQUEsQ0FBQUEsQ0FBWkY7QUFDWlI7QUFDQUE7QUFDQUE7O0FBRUFBLDhCQUFnQ0ssdUJBQVFMOztBQUV4Q0E7QUFDQUEsUUFBVVAsSUFBQWEsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUJQLHFCQUFyQk07QUFDVk47O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFuREVBLENBQUFBLGtDQUFBQTtJQXNEQVcsVUFBSWxCLElBQUprQixrQkFBQUEsdUJBQUFBLHVCQUFxQlQsR0FBckJTO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQyxvQkFBSUMsZUFBQUEsQ0FBWVgsR0FBaEIsRUFBcUJZLHFCQUFyQixFQUE0QixRQUF4QkQ7SUFETkYsQ0FBQUEsa0NBQUFBOztBQUlBSSxJQUFBQSxxQkFBQUEsYUFBQUEsU0FBTUMsS0FBTkQ7QUFBQUEsTUFBQUE7OztNQUNFQyxRQUFRLGFBQUEsSUFBQSxRQUFHRixxQkFBTUcsUUFBQUEsQ0FBSUQsS0FBSkMsQ0FBVCxDQUFBO1FBQ0VGLE9BQUFDLEtBQUtsQixNQUFBQSxDQUFBQTtNQURQO1FBR0VpQixPQUFBQSxDQUFDQSxrQkFBb0JELHFCQUFNQyxXQUEzQkEsQ0FBdUNqQixNQUFBQSxDQUFBQTtNQUh6QyxDQUFBOztBQU9aaUIsOEJBQWdDLFlBQUEsRUFBR0E7O0FBRW5DQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBdEJFQSxDQUFBQSx3QkFBQUE7O0FBeUJBRyxJQUFBQSxxQkFBQUEsYUFBQUEsU0FBTUYsS0FBTkU7QUFBQUEsTUFBQUE7OztNQUNFRixRQUFRLGFBQUEsSUFBQSxRQUFHRixxQkFBTUcsUUFBQUEsQ0FBSUQsS0FBSkMsQ0FBVCxDQUFBO1FBQ0VDLE9BQUFGLEtBQUtsQixNQUFBQSxDQUFBQTtNQURQO1FBR0VvQixPQUFBQSxDQUFDQSxrQkFBb0JKLHFCQUFNSSxXQUEzQkEsQ0FBdUNwQixNQUFBQSxDQUFBQTtNQUh6QyxDQUFBOztBQU9ab0IsaUJBQW1CLFlBQUEsRUFBR0E7O0FBRXRCQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBbkJFQSxDQUFBQSx3QkFBQUE7O0FBc0JBQyxJQUFBQSxxQkFBQUEsYUFBQUEsU0FBTUgsS0FBTkc7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBNkJILEtBQUtQLGdCQUFBQSxDQUFhLFFBQWJBLENBQWxDLENBQUE7UUFBQSxPQUFPaEIsSUFBQTJCLE1BQUFBLENBQUtKLEtBQUtLLFFBQUFBLENBQUFBLENBQVZELENBQVA7TUFFQUosUUFBU0csa0JBQW9CZCx1QkFBUWM7TUFFckMsSUFBQSxRQUFJQSxTQUFKLENBQUE7UUFDRTFCLElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCWSxtQkFBckJiLENBREY7O0FBS0phO0FBQ0FBLHNCQUF3QjFCLElBQUFLLE1BQUFBLENBQUFBLENBQUtxQjs7QUFFN0JBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQWxCRUEsQ0FBQUEsd0JBQUFBOztBQXFCQUcsSUFBQUEscUJBQUFBLGlCQUFBQSxTQUFNTixLQUFOTTtBQUFBQSxNQUFBQTs7O01BQ0VOLFFBQVEsYUFBQSxJQUFBLFFBQUdGLHFCQUFNRyxRQUFBQSxDQUFJRCxLQUFKQyxDQUFULENBQUE7UUFDRUssT0FBQU4sS0FBS2xCLE1BQUFBLENBQUFBO01BRFA7UUFHRXdCLE9BQUFBLENBQUNBLGtCQUFvQlIscUJBQU1RLFdBQTNCQSxDQUF1Q3hCLE1BQUFBLENBQUFBO01BSHpDLENBQUE7TUFNUndCLE9BQUNBLGtCQUFEQTtJQVBGQSxDQUFBQSw0QkFBQUE7O0FBVUFDLElBQUFBLHFCQUFBQSxrQkFBQUEsU0FBTVAsS0FBTk87QUFBQUEsTUFBQUE7OztNQUNFUCxRQUFRLGFBQUEsSUFBQSxRQUFHRixxQkFBTUcsUUFBQUEsQ0FBSUQsS0FBSkMsQ0FBVCxDQUFBO1FBQ0VNLE9BQUFQLEtBQUtsQixNQUFBQSxDQUFBQTtNQURQO1FBR0V5QixPQUFBQSxDQUFDQSxrQkFBb0JULHFCQUFNUyxXQUEzQkEsQ0FBdUN6QixNQUFBQSxDQUFBQTtNQUh6QyxDQUFBO01BTVIsSUFBQSxRQUFjeUIsaUJBQWQsQ0FBQTtRQUFBLE9BQU8sRUFBUDtNQUNBLElBQUEsUUFBMEJBLGtCQUExQixDQUFBO1FBQUEsT0FBUUEsWUFBUjs7QUFHSkEsOEJBQWdDLFlBQUEsRUFBR0E7O0FBRW5DQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBekJFQSxDQUFBQSw2QkFBQUE7O0FBNEJBQyxJQUFBQSxzQkFBQUEsa0JBQUFBLFNBQU9DLE1BQVBEO0FBQUFBLE1BQUFBOzs7TUFDR0E7TUFFREEsT0FBQS9CO0lBSEYrQixDQUFBQSw2QkFBQUE7O0FBTUFFLElBQUFBLHVCQUFBQSxzQkFBQUEsU0FBUVYsS0FBUlU7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBR1oscUJBQU1HLFFBQUFBLENBQUlELEtBQUpDLENBQVQsQ0FBQTtRQUNFRCxRQUFRQSxLQUFLbEIsTUFBQUEsQ0FBQUE7TUFEZixPQUVBLElBQUEsUUFBTWtCLEtBQUtQLGdCQUFBQSxDQUFhLFFBQWJBLENBQVgsQ0FBQTtRQUNFTyxRQUFRQSxLQUFLTixRQUFBQSxDQUFBQSxDQUFPWixNQUFBQSxDQUFBQTtNQUR0QjtRQUdFLE9BQUE7TUFIRjs7QUFPSjRCLFVBQVlqQyxJQUFBa0MsTUFBQUEsQ0FBQUEsQ0FBS0QsS0FBT1YsS0FBS1csTUFBQUEsQ0FBQUEsQ0FBTUQ7QUFDbkNBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxPQUFEQSxDQUFVQSxRQUFBQSxDQUFLQSxRQUFMQSxDQUFlQTs7QUFFN0NBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxhQUFlQSxDQUFDQSxXQUFEQSxDQUFjQSxRQUFBQSxDQUFLQSxZQUFMQSxDQUFtQkE7QUFDaERBO0lBekJFQSxDQUFBQSxpQ0FBQUE7O0FBNEJBRSxJQUFBQSxzQkFBQUEsbUJBQUFBLFNBQU9aLEtBQVBZO0FBQUFBLE1BQUFBOzs7QUFFRkE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsbUJBQXFCQSxDQUFDQSxLQUFEQSxDQUFRQSxPQUFBQSxDQUFJQSxLQUFKQSxDQUFXQTtBQUN4Q0E7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGtCQUFvQkEsQ0FBQ0EsS0FBREEsQ0FBTzlCLE1BQUFBLENBQUFBLENBQU04QjtBQUNqQ0E7QUFDQUEsa0JBQW9CQSxDQUFDQSxLQUFEQSxDQUFPOUIsTUFBQUEsQ0FBQUEsQ0FBTThCOztBQUVqQ0E7QUFDQUE7QUFDQUE7O0FBRUFBLGlCQUFtQkEsQ0FBQ0EsS0FBREEsQ0FBT0MsV0FBQUEsQ0FBQUEsQ0FBV0Q7O0FBRXJDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSx5Q0FBMkNBLENBQUNBLENBQURBLENBQUdDLFdBQUFBLENBQUFBLENBQVdEO0FBQ3pEQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJBLENBQUNBLENBQURBLENBQUlBLE9BQUFBLENBQUlBLENBQUpBLENBQU9BO0FBQzlCQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBcERFQSxDQUFBQSw4QkFBQUE7O0FBd0RGakM7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVFSSxJQUFBQSxzQkFBQUEsZUFBQUEsU0FBTytCLEtBQUQsRUFBUUMsTUFBZGhDO0FBQUFBLE1BQUFBOzs7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVJFQSxDQUFBQSwyQkFBQUE7O0FBV0FpQyxJQUFBQSx1QkFBQUEsa0JBQUFBLFNBQVFGLEtBQUQsRUFBUUcsS0FBUixFQUFlQyxLQUF0QkY7QUFBQUEsTUFBQUE7Ozs7TUFFRkE7TUFHSSxJQUFBLFFBQUdHLHFCQUFNbEIsUUFBQUEsQ0FBSWEsS0FBSmIsQ0FBVCxDQUFBOztRQUNFbUIsT0FBTyxhQUFBLElBQUEsUUFBR3RCLHFCQUFNRyxRQUFBQSxDQUFJZ0IsS0FBSmhCLENBQVQsQ0FBQTtVQUNFZSxPQUFBQyxLQUFLbkMsTUFBQUEsQ0FBQUE7UUFEUCxPQUVBLElBQUEsUUFBTW1DLEtBQUt4QixnQkFBQUEsQ0FBYSxRQUFiQSxDQUFYLENBQUE7VUFDRXVCLE9BQUFDLEtBQUt2QixRQUFBQSxDQUFBQSxDQUFPWixNQUFBQSxDQUFBQTtRQURkO1VBR0VrQyxPQUFBLENBQUNDLEtBQUQ7UUFIRixDQUZBOztBQVNiRDtBQUNBQSw4Q0FBZ0QzQix1QkFBUTJCO0FBQ3hEQSw0Q0FBOEMzQix1QkFBUTJCOztBQUV0REE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWN2QyxJQUFBYSxPQUFBQSxDQUFNK0IsMEJBQU4sRUFBa0IsRUFBQSxHQUFBLENBQUdQLEtBQUtRLFNBQUFBLENBQUFBLENBQVIsQ0FBQSxHQUFBLGVBQWxCaEMsQ0FBa0QwQjtBQUNoRUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtNQTVDSTs7UUE4Q0UsSUFBQSxRQUFJQSxtQkFBSixDQUFBO1VBQ0VELFNBQVNRO1FBRFg7O1VBR0VSLFNBQVNFO1VBQ1RBLFFBQVNDO1VBRVRFLE9BQU8sYUFBQSxJQUFBLFFBQUd0QixxQkFBTUcsUUFBQUEsQ0FBSWdCLEtBQUpoQixDQUFULENBQUE7WUFDRWUsT0FBQUMsS0FBS25DLE1BQUFBLENBQUFBO1VBRFAsT0FFQSxJQUFBLFFBQU1tQyxLQUFLeEIsZ0JBQUFBLENBQWEsUUFBYkEsQ0FBWCxDQUFBO1lBQ0V1QixPQUFBQyxLQUFLdkIsUUFBQUEsQ0FBQUEsQ0FBT1osTUFBQUEsQ0FBQUE7VUFEZDtZQUdFa0MsT0FBQSxDQUFDQyxLQUFEO1VBSEYsQ0FGQTtRQU5UOztBQWdCTkQ7O0FBRUFBLG1DQUFxQzNCLHVCQUFRMkI7QUFDN0NBLG9DQUFzQzNCLHVCQUFRMkI7O0FBRTlDQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsWUFBY3ZDLElBQUFhLE9BQUFBLENBQU1rQywwQkFBTixFQUFrQixFQUFBLEdBQUEsUUFBQSxHQUFBLENBQVVSLEdBQVYsQ0FBQSxHQUFBLGdDQUFBLEdBQUEsQ0FBZ0RBLFlBQWhELENBQWxCMUIsQ0FBa0YwQjtBQUNoR0E7QUFDQUE7O0FBRUFBO0FBQ0FBLFVBQVl2QyxJQUFBYSxPQUFBQSxDQUFNa0MsMEJBQU4sRUFBa0IsRUFBQSxHQUFBLG1CQUFBLEdBQUEsQ0FBb0JULE1BQXBCLENBQUEsR0FBQSxHQUFsQnpCO0FBQ1owQjs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtNQTlGSTtJQUxGQSxDQUFBQSw4QkFBQUE7O0FBdUdBUyxJQUFBQSx3QkFBQUEscUJBQUFBLFNBQVNDLE9BQVREO0FBQUFBLE1BQUFBOztNQUFBQTtNQUFBQTtNQUFBQTtNQUFBQTtNQUFBQTs7O01BQThCOztNQUMzQkE7TUFDREEsT0FBQSxPQUFBaEQsSUFBQSxFQUFBLHlFQUFBLFFBQUEsRUFBQSxNQUFBLEVBQUEsS0FBQTtJQUZGZ0QsQ0FBQUEsaUNBQUFBOztBQUtBRSxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFVbEIsTUFBVmtCO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUEsMkNBQTZDQSxDQUFDQSxPQUFEQSxDQUFVZixPQUFBQSxDQUFHSCxNQUFIRyxDQUFVZTtBQUNqRUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBVEVBLENBQUFBLDZCQUFBQTs7QUFZQUMsSUFBQUEsc0JBQUFBLGVBQUFBLGNBQU9kLEtBQVBjO0FBQUFBLE1BQUFBOzs7QUFFRkEsZ0NBQWtDdkMsdUJBQVF1Qzs7QUFFMUNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFiRUEsQ0FBQUEsMEJBQUFBOztBQWdCQUMsSUFBQUEsaUNBQUFBLDBCQUFBQSx5QkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBa0I7TUFDaEIsSUFBc0NDLGVBQXRDO01BQUE7UUFBQSxPQUFPckQsSUFBQXNELFVBQUFBLENBQVMsZUFBVEE7TUFBUDs7QUFHSkY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxVQUFZcEQsSUFBQWEsT0FBQUEsQ0FBTTBDLHlCQUFOLEVBQWlCLEVBQUEsR0FBQSxzQkFBQSxHQUFBLENBQXVCSCxDQUFDQSxHQUFEQSxDQUFLSSxPQUFBQSxDQUFBQSxDQUE1QixDQUFBLEdBQUEsd0NBQWpCM0M7QUFDWnVDOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFwQ0VBLENBQUFBLHFDQUFBQTs7QUF1Q0FLLElBQUFBLDJCQUFBQSxvQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVk7TUFDVixJQUFnQ0osZUFBaEM7TUFBQTtRQUFBLE9BQU9yRCxJQUFBc0QsVUFBQUEsQ0FBUyxTQUFUQTtNQUFQO01BRUFqQixRQUFRZSxNQUFBcEQsSUFBQW9ELGlCQUFBQSxFQUFBQSxFQUFBQSxFQUFlTSxLQUFEQyxTQUFBQSxDQUFBQSxDQUFkUDs7QUFHWks7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFYRUEsQ0FBQUEsK0JBQUFBOztBQWNBRyxJQUFBQSx5QkFBQUEsa0JBQUFBLGlCQUFVQyxDQUFWRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFtQjs7TUFBVDtNQUFBLE1BQUksR0FBSjtNQUFBO01BQ1IsSUFBT1AsZUFBUDtNQUFBO1FBQ0UsT0FBT0MsTUFBQXRELElBQUFzRCxZQUFBQSxFQUFBQSxDQUFTLE9BQVQsRUFBaUJPLENBQWpCUCxDQUFBQSxFQUFvQlEsaUJBQUFBLEVBQUFDOztVQUN6QixJQUFBLFFBQUdGLENBQUNHLFNBQUFBLENBQUFBLENBQUosQ0FBQTtZQUNFRCxPQUFBRSxJQUFBQyxxQkFBQUQ7VUFERjs7WUFHRUosSUFBSTFDLG9CQUFJZ0QsZUFBQUEsQ0FBWU4sQ0FBaEIsRUFBbUJqRCx1QkFBbkIsRUFBNEIsUUFBeEJ1RDtZQUNSLElBQUEsUUFBRUMsT0FBRlAsQ0FBRU8sRUFBRUMsQ0FBRkQsQ0FBRixDQUFBO2NBQVFMLE9BQWdCckMsVUFBaEIxQixJQUFBc0UsaUJBQUFBLENBQUFBLENBQWdCNUMsRUFBRW1DLENBQUZuQztZQUF4QjtjQUE4QnFDLE9BQUFNO1lBQTlCO1VBSkYsQ0FEeUJQLG1CQUFBQSxrQkFBQUEsTUFBcEJSO01BRFQ7TUFXQSxJQUFBLFFBQVUsYUFBQSxJQUFBLFFBcG1CZGlCLENBQUFBLFlBb21CY3ZFLElBQUF3RSxXQUFBQSxDQUFBQSxDQXBtQmRELENBb21CYyxDQUFBO1FBcG1CZFgsT0FBQTtNQW9tQmM7UUFBVUEsT0FBQUMsQ0FBRTFCLE9BQUFBLENBQUdrQyxDQUFIbEM7TUFBWixDQUFBLGtCQUFWLENBQUE7UUFBQSxPQUFBLEdBQUE7O0FBR0p5Qjs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsWUFBY3pDLG9CQUFJZ0QsZUFBQUEsQ0FBWU4sQ0FBaEIsRUFBbUJqRCx1QkFBbkIsRUFBNEIsUUFBeEJ1RCxDQUFpQ1A7QUFDbkRBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSUEsT0FBQTVEO0lBeENGNEQsQ0FBQUEsOEJBQUFBOztBQTJDQWEsSUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNHQTtNQUVEQSxPQUFBekU7SUFIRnlFLENBQUFBLDZCQUFBQTs7QUFNQUMsSUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBVTFDLE1BQVYwQztBQUFBQSxNQUFBQTs7TUFBQUE7TUFBQUE7TUFBQUE7TUFBQUE7TUFBQUE7OztNQUF3Qjs7TUFBZDtNQUFBLFdBQVMsR0FBVDtNQUFBO01BQ1IsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTFvQlBDLENBQUFBLFlBMG9CTzNDLE1BMW9CUDJDLENBMG9CTyxDQUFBO1FBMW9CUEQsT0FBQTtNQTBvQk87UUFBVUEsT0FBQWhCO01BQVYsQ0FBQSxrQkFBSCxDQUFBO1FBQ0VnQixPQUFBLE9BQUExRSxJQUFBLEVBQUEsdUVBQUEsU0FBQSxFQUFBLE1BQUEsRUFBQSxLQUFBO01BREY7UUFHRTBFLE9BQUExRSxJQUFBUSxNQUFBQSxDQUFBQTtNQUhGO0lBREZrRSxDQUFBQSw4QkFBQUE7O0FBUUFFLElBQUFBLG1DQUFBQSw0QkFBQUEsMkJBQW9CckQsS0FBcEJxRDtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTVFLElBQUFlLFNBQUFBLENBQVFRLEtBQVJSO0lBREY2RCxDQUFBQSx1Q0FBQUE7O0FBSUFDLElBQUFBLDJCQUFBQSxvQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVk7TUFDVixJQUEwQ3hCLGVBQTFDO01BQUE7UUFBQSxPQUFPQyxNQUFBdEQsSUFBQXNELFlBQUFBLEVBQUFBLENBQVMsU0FBVEEsQ0FBQUEsRUFBbUJ3QixpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUEvRSxJQUFBUSxNQUFBQSxDQUFBQSxDQUFGc0UsbUJBQUFBLGtCQUFBQSxNQUFuQnhCO01BQVA7O0FBR0p1Qjs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBWkVBLENBQUFBLCtCQUFBQTs7QUFlQUcsSUFBQUEsNEJBQUFBLHlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFhO01BQ1gsSUFBMkMzQixlQUEzQztNQUFBO1FBQUEsT0FBT0MsTUFBQXRELElBQUFzRCxZQUFBQSxFQUFBQSxDQUFTLFVBQVRBLENBQUFBLEVBQW9CMkIsaUJBQUFBLEVBQUFDOztVQUFFQSxPQUFBbEYsSUFBQVEsTUFBQUEsQ0FBQUEsQ0FBRnlFLG1CQUFBQSxrQkFBQUEsTUFBcEIzQjtNQUFQOztBQUdKMEI7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7TUFFSUEsT0FBQWhGO0lBVkZnRixDQUFBQSxvQ0FBQUE7O0FBY0Y5RTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVFaUYsSUFBQUEsK0JBQUFBLHdCQUFBQSx1QkFBZ0J0QixDQUFoQnNCO0FBQUFBLE1BQUFBOztNQUFBQTs7TUFDRUMsTUFBTWpFLG9CQUFJZ0QsZUFBQUEsQ0FBWU4sQ0FBaEIsRUFBbUJqRCx1QkFBbkIsRUFBNEIsUUFBeEJ1RDtNQUNWLElBQTBGZCxnQkFBMUY7TUFBQTtRQUFBLE9BQU9DLE1BQUF0RCxJQUFBc0QsWUFBQUEsRUFBQUEsQ0FBUyxhQUFULEVBQXVCOEIsR0FBdkI5QixDQUFBQSxFQUE0QitCLGlCQUFBQSxFQUFBQzs7VUFBRUEsT0FBQ0EscUJBQXVCdEYsSUFBS3NGLGFBQS9CRCxtQkFBQUEsa0JBQUFBLE1BQTVCL0I7TUFBUDs7QUFHSjZCOztBQUVBQTtBQUNBQSxRQUFVLG9CQUFNLEVBQU47QUFDVkE7QUFDQUE7QUFDQUEsVUFBWSxvQkFBT0EsU0FBUDtBQUNaQTtBQUNBQTtBQUNBQTtBQUNBQSxRQUFVLG9CQUFPQSxZQUFQO0FBQ1ZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBYSxvQkFBT0EsY0FBUDtBQUNiQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUNJQSxPQUFBbkY7SUE3Q0ZtRixDQUFBQSxtQ0FBQUE7O0FBZ0RBSSxJQUFBQSx3Q0FBQUEsaUNBQUFBLGdDQUF5QjFCLENBQXpCMEI7QUFBQUEsTUFBQUE7O01BQUFBOztNQUNFSCxNQUFNakUsb0JBQUlnRCxlQUFBQSxDQUFZTixDQUFoQixFQUFtQmpELHVCQUFuQixFQUE0QixRQUF4QnVEO01BRVYsSUFBT2QsZ0JBQVA7TUFBQTtRQUNFLE9BQU9DLE1BQUF0RCxJQUFBc0QsWUFBQUEsRUFBQUEsQ0FBUyxzQkFBVCxFQUFnQzhCLEdBQWhDOUIsQ0FBQUEsRUFBcUNrQyxpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUNBLGdEQUFEQSxDQUFGRCxtQkFBQUEsa0JBQUFBLE1BQXJDbEM7TUFEVDs7QUFLSmlDO0FBQ0FBO0FBQ0FBO0FBQ0FBLFVBQVksb0JBQU9BLElBQVA7QUFDWkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BQ0lBLE9BQUF2RjtJQXpCRnVGLENBQUFBLDRDQUFBQTs7QUE0QkFHLElBQUFBLDJCQUFBQSxvQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQVhFQSxDQUFBQSwrQkFBQUE7O0FBY0FDLElBQUFBLDRCQUFBQSx5QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQWRFQSxDQUFBQSxvQ0FBQUE7O0FBaUJBQyxJQUFBQSwwQkFBQUEsbUJBQUFBLGtCQTF5QkYsRUEweUJFQTtBQUFBQSxNQUFBQTs7OztNQTF5QkY7O01BMHlCYTtNQUNUQyxTQUFlQyxNQUFORCxNQUFNQyxPQUFBQSxFQUFBQSxFQUFBQSxFQUFLQyxpQkFBSXhFLEtBQUp3RSxFQUFBQzs7OztRQUFJO1FBQUE7UUFBQTtRQUN0QnpFLFFBQVEsYUFBQSxJQUFBLFFBQUdGLHFCQUFNRyxRQUFBQSxDQUFJRCxLQUFKQyxDQUFULENBQUE7VUFDRXdFLE9BQUF6RSxLQUFLbEIsTUFBQUEsQ0FBQUE7UUFEUDtVQUdFMkYsT0FBQUEsQ0FBQ0Esa0JBQW9CM0UscUJBQU0yRSxXQUEzQkEsQ0FBdUMzRixNQUFBQSxDQUFBQTtRQUh6QyxDQUFBO1FBTVIsSUFBQSxRQUFHa0IsS0FBSzBFLFdBQUFBLENBQVFqRyxJQUFSaUcsQ0FBUixDQUFBO1VBQ0UxRSxRQUFRQSxLQUFLMkUsS0FBQUEsQ0FBQUEsQ0FEZjtRQUlBRixPQUFBekUsTUFYa0J3RSxtQkFBQUEsa0JBQUFBLE1BQUxEO01BY1RLLE1BQU5OLE1BQU1NLFFBQUFBLEVBQUFBLEVBQUFBLEVBQU1KLGlCQUFJeEUsS0FBSndFLEVBQUFDOzs7O1FBQUk7UUFBQTtRQUFBOztBQUVwQkE7QUFDQUE7QUFDQUE7QUFDQUEsT0FMZ0JELG1CQUFBQSxrQkFBQUEsTUFBTkk7TUFRTlAsT0FBQTVGO0lBdkJGNEYsQ0FBQUEsK0JBQUFBOztBQTBCQVEsSUFBQUEsMEJBQUFBLG1CQUFBQSxTQUFXcEUsTUFBWG9FO0FBQUFBLE1BQUFBOztNQUFBQTs7QUFFRkE7O0FBRUFBO0FBQ0FBLFlBQWNBLENBQUNBLE9BQURBLENBQVVqRSxPQUFBQSxDQUFHSCxNQUFIRyxDQUFVaUU7QUFDbENBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsWUFBYy9DLGdCQUFhK0M7QUFDM0JBLGlCQUFtQixxQkFBQSxFQUFNQTtBQUN6QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFwQkVBLENBQUFBLDhCQUFBQTs7QUF1QkFDLElBQUFBLDZCQUFBQSxzQkFBQUEscUJBQWNoRSxLQUFkZ0U7QUFBQUEsTUFBQUE7OztBQUVGQSxnQ0FBa0N6Rix1QkFBUXlGOztBQUUxQ0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0lBakJFQSxDQUFBQSxpQ0FBQUE7O0FBb0JBQyxJQUFBQSw2QkFBQUEsc0JBQUFBLHFCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFjO01BQ1osSUFBNENqRCxlQUE1QztNQUFBO1FBQUEsT0FBT0MsTUFBQXRELElBQUFzRCxZQUFBQSxFQUFBQSxDQUFTLFdBQVRBLENBQUFBLEVBQXFCaUQsaUJBQUFBLEVBQUFDOztVQUFFQSxPQUFBeEcsSUFBQVEsTUFBQUEsQ0FBQUEsQ0FBRitGLG1CQUFBQSxrQkFBQUEsTUFBckJqRDtNQUFQO01BQ0dnRDtNQUNIQSxPQUFBdEc7SUFIRnNHLENBQUFBLGlDQUFBQTs7QUFNQUcsSUFBQUEsOEJBQUFBLHVCQUFBQSxzQkFyM0JGLEVBcTNCRUE7QUFBQUEsTUFBQUE7Ozs7TUFyM0JGOztNQXEzQmlCO01BQ2JBLE9BQU1DLE1BQU5DLE1BQU1ELFVBQUFBLEVBQUFBLENBQVExRyxJQUFBSyxNQUFBQSxDQUFBQSxDQUFJNkYsS0FBQUEsQ0FBQUEsQ0FBWlEsQ0FBQUEsRUFBa0JFLGlCQUFHQyxDQUFELEVBQUlDLENBQU5GLEVBQUFHOzs7O1FBQUc7UUFBQTtRQUFBOztRQUFHO1FBQUE7UUFBQTtRQUFHQSxPQUFFakYsVUFBRitFLENBQUUvRSxFQUFFZ0YsQ0FBRmhGLEVBQVg4RSxtQkFBQUEsa0JBQUFBLE1BQWxCRjtJQURSRCxDQUFBQSxtQ0FBQUE7O0FBSUFPLElBQUFBLHVCQUFBQSxnQkFBQUEsZUFBUUMsR0FBRCxFQXozQlQsRUF5M0JFRDtBQUFBQSxNQUFBQTs7OztNQXozQkY7O01BeTNCZTtNQUNYRSxPQUFPbEgsSUFBSU0sT0FBQUEsQ0FBQzJHLEdBQUQzRzs7QUFHZjBHO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUksSUFBQSxRQUFPRSxJQUFJbEcsZ0JBQUFBLENBQWEsS0FBYkEsQ0FBWCxDQUFBO01BQUE7UUFDRWhCLElBQUFhLE9BQUFBLENBQU0wQyx5QkFBTixFQUFpQixFQUFBLEdBQUEsQ0FBRzJELElBQUkxRCxPQUFBQSxDQUFBQSxDQUFQLENBQUEsR0FBQSw0QkFBakIzQztNQURGO01BSUFtRyxPQUFJQSxNQUFKRSxJQUFJRixPQUFBQSxFQUFLLFVBQUNHLElBQUQsQ0FBTEg7SUFiTkEsQ0FBQUEsNEJBQUFBOztBQWdCQUksSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkFBU0MsTUFBVEQ7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxRQUFVcEgsSUFBQWEsT0FBQUEsQ0FBTUMsNkJBQU5EO0FBQ1Z1Rzs7QUFFQUE7QUFDQUE7SUFQRUEsQ0FBQUEsNEJBQUFBOztBQVVBbEIsSUFBQUEsdUJBQUFBLGdCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7TUFBQUE7TUFBQUE7TUFBQUE7TUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBLE9BQUFsRyxJQUFBLEVBQUEsbUVBQUEsT0FBQSxFQUFBLE1BQUEsRUFBQSxLQUFBO0lBVkZrRyxDQUFBQSwyQkFBQUE7O0FBYUFDLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVM7TUFDUCxJQUF1QzlDLGVBQXZDO01BQUE7UUFBQSxPQUFPQyxNQUFBdEQsSUFBQXNELFlBQUFBLEVBQUFBLENBQVMsTUFBVEEsQ0FBQUEsRUFBZ0JnRSxpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUF2SCxJQUFBUSxNQUFBQSxDQUFBQSxDQUFGOEcsbUJBQUFBLGtCQUFBQSxNQUFoQmhFO01BQVA7O0FBR0o2QztBQUNBQTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBbkc7SUFURm1HLENBQUFBLDRCQUFBQTs7QUFZQXFCLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWU7TUFDYixJQUE2Q25FLGVBQTdDO01BQUE7UUFBQSxPQUFPQyxNQUFBdEQsSUFBQXNELFlBQUFBLEVBQUFBLENBQVMsWUFBVEEsQ0FBQUEsRUFBc0JtRSxpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUExSCxJQUFBUSxNQUFBQSxDQUFBQSxDQUFGaUgsbUJBQUFBLGtCQUFBQSxNQUF0Qm5FO01BQVA7O0FBR0prRTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBeEg7SUFURndILENBQUFBLGtDQUFBQTs7QUFZQWhELElBQUFBLDBCQUFBQSx1QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLGlCQUFEQTtJQURGQSxDQUFBQSxrQ0FBQUE7O0FBSUFtRCxJQUFBQSx3QkFBQUEscUJBQUFBLFNBQVNwRyxLQUFUb0c7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxnQkFBa0JwRyxLQUFLbEIsTUFBQUEsQ0FBQUEsQ0FBTXNIOztBQUU3QkE7QUFDQUE7QUFDQUE7O0FBRUFBLGlCQUFtQkEsQ0FBQ0EsS0FBREEsQ0FBT3ZGLFdBQUFBLENBQUFBLENBQVd1Rjs7QUFFckNBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHlDQUEyQ0EsQ0FBQ0EsQ0FBREEsQ0FBR3ZGLFdBQUFBLENBQUFBLENBQVd1RjtBQUN6REE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CQSxDQUFDQSxDQUFEQSxDQUFHQSxTQUFBQSxDQUFPQSxDQUFQQSxDQUFXQTtBQUNqQ0E7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQTFDRUEsQ0FBQUEsZ0NBQUFBOztBQTZDQUMsSUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBVXZGLEtBQUQsRUFBUXdGLFFBQWpCRDtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUF1Qzs7O0FBRXpDQTs7QUFFQUEsZ0NBQWtDaEgsdUJBQVFnSDs7QUFFMUNBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsUUFBVTVILElBQUFVLE1BQUFBLENBQUtrSCxrREFBTGxIO0FBQ1ZrSDs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxRQUFVNUgsSUFBQWEsT0FBQUEsQ0FBTWtDLDBCQUFOLEVBQWtCLEVBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBVTZFLFFBQVYsQ0FBQSxHQUFBLGlDQUFsQi9HO0FBQ1YrRztBQUNBQTtBQUNBQSxRQUFVNUgsSUFBQWEsT0FBQUEsQ0FBTWtDLDBCQUFOLEVBQWtCLEVBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBVTZFLFFBQVYsQ0FBQSxHQUFBLDZCQUFBLEdBQUEsQ0FBa0RBLFdBQWxELENBQUEsR0FBQSxLQUFBLEdBQUEsQ0FBcUVBLFdBQXJFLENBQWxCL0csQ0FBc0crRztBQUNoSEE7QUFDQUE7SUFoQ0VBLENBQUFBLDhCQUFBQTs7QUFtQ0FFLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBNWdDRixFQTRnQ0VBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWdCOztNQTVnQ2xCOztNQTRnQ1c7TUFFWEE7TUFHSSxJQUFBLFFBQUdwRSxLQUFILENBQUE7O1FBQ0UsSUFBQSxRQUFJb0UsZUFBSixDQUFBO1VBQ0U5SCxJQUFBYSxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQixFQUFBLEdBQUEsNkJBQUEsR0FBQSxDQUE4QmlILElBQUl6RixRQUFBQSxDQUFBQSxDQUFsQyxDQUFBLEdBQUEsWUFBckJ6QixDQURGO1FBSUEsS0FBV2tILElBQVgsc0JBQUEsRUFBQUMsQ0FBQUEsTUFBQSw2QkFBQUEsQ0FBQSxFQUFLQyxDQUFBQSxNQUFMLDZCQUFLQSxDQUFMO01BTEY7O1FBT0UsSUFBQSxRQUFJSCxnQkFBSixDQUFBO1VBQ0U5SCxJQUFBYSxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQmdILHdDQUFyQmpIO1FBREYsT0FFQSxJQUFBLFFBQU9pSCxlQUFQLENBQUE7VUFDRTlILElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQThCaUgsSUFBSXpGLFFBQUFBLENBQUFBLENBQWxDLENBQUEsR0FBQSxZQUFyQnpCLENBREY7UUFJQSxLQUFnQmtILElBQWhCLHNCQUFBLEVBQUF0SCxDQUFBQSxNQUFBLDZCQUFBQSxDQUFBLEVBQUt1SCxDQUFBQSxNQUFMLDZCQUFLQSxDQUFMLEVBQVVDLENBQUFBLE1BQVYsNkJBQVVBLENBQVY7TUFiRjtNQWdCQSxJQUFBLFFBQUd2RixxQkFBTWxCLFFBQUFBLENBQUl3RyxHQUFKeEcsQ0FBVCxDQUFBOztRQUNFLElBQUEsUUFBZ0R5RyxHQUFoRCxDQUFBO1VBQUFqSSxJQUFBYSxPQUFBQSxDQUFNMEMseUJBQU4sRUFBaUJ1RSwyQkFBakJqSCxDQUFBO1FBRUFxSCxPQUFVSixzQkFBd0JsSCx1QkFBUWtIO1FBQzFDLElBQUEsUUFBMEJBLFFBQTFCLENBQUE7VUFBQ0EsbUJBQUQ7UUFDQSxJQUFBLFFBQW9EQSxRQUFwRCxDQUFBO1VBQUE5SCxJQUFBYSxPQUFBQSxDQUFNK0IsMEJBQU4sRUFBa0IsRUFBQSxHQUFBLENBQUdvRixHQUFHbkYsU0FBQUEsQ0FBQUEsQ0FBTixDQUFBLEdBQUEsZUFBbEJoQyxDQUFBO1FBRUFzSCxRQUFTTCxvQkFBc0JsSCx1QkFBUWtIO1FBQ3ZDLElBQUEsUUFBMkJBLFNBQTNCLENBQUE7VUFBQ0Esb0JBQUQ7UUFDQSxJQUFBLFFBQW9CRSxHQUFHSSxpQkFBQUEsQ0FBQUEsQ0FBdkIsQ0FBQTtRQUFBO1VBQUNOO1FBQUQ7UUFFQSxJQUFBLFFBQWdCQSxhQUFoQixDQUFBO1VBQUEsT0FBTzlILElBQVA7TUFYRixPQVlBLElBQUEsUUFBTWdJLEdBQU4sQ0FBQTs7UUFDRUUsT0FBVUosZ0JBQWtCbEgsdUJBQVFrSDtRQUNwQyxJQUFBLFFBQTBCQSxRQUExQixDQUFBO1VBQUNBLG1CQUFEO1FBQ0EsSUFBQSxRQUFlQSxRQUFmLENBQUE7VUFBQUksT0FBUzdELENBQVQ7UUFFQSxJQUFBLFFBQUc0RCxHQUFILENBQUE7O1VBQ0VFLFFBQVNMLGdCQUFrQmxILHVCQUFRa0g7VUFFbkMsSUFBQSxRQUFnQkEsVUFBaEIsQ0FBQTtZQUFBLE9BQU85SCxJQUFQO1VBRUM4SDtRQUxIO1VBT0VLLFFBQVNMO1FBUFg7TUFMRjs7UUFlRUksT0FBUTdEO1FBQ1I4RCxRQUFTTDtNQWhCWDtNQW1CQSxJQUFBLFFBQUlBLGtCQUFKLENBQUE7O0FBRUpBO0FBQ0FBO0FBQ0FBO0FBQ0FBLE1BTEk7TUFRQSxJQUFBLFFBQUlBLG1CQUFKLENBQUE7UUFDR0EsbUJBREg7TUFJQSxJQUFBLFFBQUdwRSxLQUFILENBQUE7O0FBRUpvRTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtNQU5JOztBQVNKQTtBQUNBQSx1QkFBeUJySCxHQUFJcUg7QUFDN0JBO0FBQ0FBO01BWkk7TUFlQUEsT0FBQTlIO0lBL0VGOEgsQ0FBQUEsNkJBQUFBOztBQWtGQU8sSUFBQUEseUJBQUFBLGtCQUFBQSxpQkFBVTNELEtBQVYyRDtBQUFBQSxNQUFBQTs7Ozs7QUFFRkE7QUFDQUE7QUFDQUE7O0FBRUFBLGdDQUFrQ3pILHVCQUFReUg7O0FBRTFDQTtBQUNBQSxRQUFVckksSUFBQWEsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUJ1SCxxQkFBckJ4SCxDQUEyQ3dIO0FBQ3JEQTs7QUFFQUE7QUFDQUE7SUFiRUEsQ0FBQUEsOEJBQUFBOztBQWdCQUMsSUFBQUEsMkJBQUFBLG9CQUFBQSxtQkFBWUMsS0FBWkQ7QUFBQUEsTUFBQUE7Ozs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxnQkFBa0JBLENBQUNBLEtBQURBLENBQU9qSSxNQUFBQSxDQUFBQSxDQUFNaUk7O0FBRS9CQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBLGdCQUFrQkEsQ0FBQ0EsSUFBREEsQ0FBTXJILFFBQUFBLENBQUFBLENBQVFxSDs7QUFFaENBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxZQUFjdEksSUFBQWEsT0FBQUEsQ0FBTTBDLHlCQUFOMUMsQ0FBZ0J5SDtBQUM5QkE7O0FBRUFBO0FBQ0FBLFlBQWN0SSxJQUFBYSxPQUFBQSxDQUFNQyw2QkFBTkQsQ0FBb0J5SDtBQUNsQ0E7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQSxrQ0FBb0MxSCx1QkFBUTBIO0FBQzVDQTs7QUFFQUE7QUFDQUE7SUFuREVBLENBQUFBLGdDQUFBQTs7QUFzREFFLElBQUFBLDRCQUFBQSx5QkFBQUEsU0FBYUQsS0FBYkM7QUFBQUEsTUFBQUE7Ozs7O0FBRUZBLHNCQUF3QnhJLElBQUFzSSxTQUFBQSxDQUFRQyxLQUFSRCxDQUFjRTs7QUFFdENBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUEsTUFBUXhJLElBQUFlLFNBQUFBLENBQVN5SCxTQUFUekgsQ0FBb0J5SDtBQUM1QkE7TUFFSUEsT0FBQXhJO0lBbkJGd0ksQ0FBQUEscUNBQUFBOztBQXNCQXRHLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUEsY0FBZ0JsQyxJQUFBMkgsU0FBQUEsQ0FBTXpGLElBQU55RixDQUFhekY7QUFDN0JBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBckNFQSxDQUFBQSw0QkFBQUE7O0FBd0NBdUcsSUFBQUEsNEJBQUFBLHlCQUFBQSxTQUFhQyxNQUFiRDtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLFlBQWNBLENBQUNBLE9BQURBLENBQVV0RyxPQUFBQSxDQUFHdUcsTUFBSHZHLENBQVVzRztBQUNsQ0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBVEVBLENBQUFBLG9DQUFBQTs7QUFZQXBHLElBQUFBLHlCQUFBQSxrQkFBQUEsaUJBQVVMLE1BQVZLO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQThCOzs7QUFFaENBOztBQUVBQTtBQUNBQSxRQUFVckMsSUFBQVUsTUFBQUEsQ0FBSzJCLCtCQUFMM0I7QUFDVjJCOztBQUVBQTtBQUNBQTtBQUNBQSxjQUFnQkEsQ0FBQ0EsT0FBREEsQ0FBVUYsT0FBQUEsQ0FBR0gsTUFBSEcsQ0FBVUU7QUFDcENBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxlQUFpQnJDLElBQUFzRCxVQUFBQSxDQUFTLE9BQVRBLENBQWdCakI7QUFDakNBOztBQUVBQTtBQUNBQTtJQTdCRUEsQ0FBQUEsOEJBQUFBOztBQWdDQXNHLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVd0RyxLQUFELEVBOXdDWixFQTh3Q0VzRztBQUFBQSxNQUFBQTs7OztNQTl3Q0Y7O01BOHdDb0I7O0FBRXBCQSxnQ0FBa0MvSCx1QkFBUStIOztBQUUxQ0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWUzSSxJQUFBYSxPQUFBQSxDQUFNa0MsMEJBQU4sRUFBa0IsRUFBQSxHQUFBLENBQUdWLEtBQUgsQ0FBQSxHQUFBLG1CQUFsQnhCLENBQStDOEg7QUFDOURBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBM0k7SUF0QkYySSxDQUFBQSwrQkFBQUE7O0FBeUJBOUYsSUFBQUEsMkJBQUFBLG9CQUFBQSxtQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxtQkFBcUI3QyxJQUFBNEksUUFBQUEsQ0FBQUEsQ0FBTy9GOztBQUU1QkE7QUFDQUEsbUJBQXFCN0MsSUFBSU0sT0FBQUEsQ0FBRXVDLENBQUZ2QyxDQUFNdUM7O0FBRS9CQSxZQUFjQSxDQUFDQSxJQUFEQSxDQUFNK0YsUUFBQUEsQ0FBQUEsQ0FBUS9GO0FBQzVCQTtBQUNBQTtBQUNBQTtBQUNBQSxzQkFBd0JBLENBQUNBLElBQURBLENBQU1BLFNBQUFBLENBQUFBLENBQVNBO0FBQ3ZDQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFqQkVBLENBQUFBLCtCQUFBQTs7QUFvQkFnRyxJQUFBQSxnQ0FBQUEseUJBQUFBLHdCQTN6Q0YsRUEyekNFQTtBQUFBQSxNQUFBQTs7OztNQTN6Q0Y7O01BMnpDbUI7TUFDZkEsT0FBTW5DLE1BQU5DLE1BQU1ELFVBQUFBLEVBQUFBLENBQVExRyxJQUFBSyxNQUFBQSxDQUFBQSxDQUFJNkYsS0FBQUEsQ0FBQUEsQ0FBWlEsQ0FBQUEsRUFBa0JvQyxpQkFBR2pDLENBQUQsRUFBSUMsQ0FBTmdDLEVBQUFDOzs7O1FBQUc7UUFBQTtRQUFBOztRQUFHO1FBQUE7UUFBQTtRQUFHQSxPQUFBbEMsQ0FBRXZGLE1BQUFBLENBQUV3RixDQUFGeEYsRUFBWHdILG1CQUFBQSxrQkFBQUEsTUFBbEJwQztJQURSbUMsQ0FBQUEscUNBQUFBOztBQUlBbEgsSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkFBU3FILEdBQVRySDtBQUFBQSxNQUFBQTtBQUFBQTs7OztNQUFTO01BQUEsUUFBTSxHQUFOO01BQUE7TUFDUCxJQUFBLFFBQWNBLGlCQUFkLENBQUE7UUFBQSxPQUFPQSxFQUFQO01BRUEsSUFBQSxRQUFJQSxXQUFKLENBQUE7UUFDRXFILE1BQU1DLFdBRFI7O0FBS0p0SDtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGdCQUFrQkEsQ0FBQ0EsSUFBREEsQ0FBTUMsUUFBQUEsQ0FBQUEsQ0FBUUQ7O0FBRWhDQTtBQUNBQSx3QkFBMEJBLENBQUNBLEdBQURBLENBQUt1SCxNQUFBQSxDQUFBQSxDQUFNdkg7O0FBRXJDQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsZ0JBQWtCQSxDQUFDQSxJQUFEQSxDQUFNVixRQUFBQSxDQUFBQSxDQUFRVTs7QUFFaENBO0FBQ0FBLFlBQWMzQixJQUFBYSxPQUFBQSxDQUFNQyw2QkFBTkQsQ0FBb0JjO0FBQ2xDQTs7QUFFQUE7QUFDQUEsd0JBQTBCQSxDQUFDQSxHQUFEQSxDQUFLQSxNQUFBQSxDQUFNcUgsR0FBTnJILENBQVdBOztBQUUxQ0E7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLGdCQUFrQkEsQ0FBQ0EsSUFBREEsQ0FBTXVILE1BQUFBLENBQUFBLENBQU12SDs7QUFFOUJBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUEsUUFBVTNCLElBQUFhLE9BQUFBLENBQU1zSSw2QkFBYUMsS0FBQUEsQ0FBSyxFQUFBLEdBQUEsQ0FBSXpILGtCQUFKLENBQUEsR0FBQSwrQ0FBbEIsRUFBMEZBLFFBQTdFeUgsQ0FBbkJ2SSxDQUEwR2M7QUFDcEhBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSwyQkFBNkJSLG9CQUFJZ0QsZUFBQUEsQ0FBWTZFLEdBQWhCLEVBQXFCSyxzQkFBckIsRUFBNkIsUUFBekJsRixDQUFpQytFLE1BQUFBLENBQUFBLENBQU12SDtBQUN4RUE7QUFDQUE7SUF6REVBLENBQUFBLDZCQUFBQTs7QUE0REEySCxJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFZO01BQ1YsSUFBMENqRyxlQUExQztNQUFBO1FBQUEsT0FBT0MsTUFBQXRELElBQUFzRCxZQUFBQSxFQUFBQSxDQUFTLFNBQVRBLENBQUFBLEVBQW1CaUcsaUJBQUFBLEVBQUFDOztVQUFFQSxPQUFBeEosSUFBQVEsTUFBQUEsQ0FBQUEsQ0FBRitJLG1CQUFBQSxrQkFBQUEsTUFBbkJqRztNQUFQO01BQ0dnRztNQUNIQSxPQUFBdEo7SUFIRnNKLENBQUFBLCtCQUFBQTs7QUFNQUcsSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkFBUy9FLEtBQVQrRTtBQUFBQSxNQUFBQTs7Ozs7QUFFRkE7QUFDQUE7QUFDQUE7O0FBRUFBLGdDQUFrQzdJLHVCQUFRNkk7O0FBRTFDQTtBQUNBQSxRQUFVekosSUFBQWEsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUIySSxxQkFBckI1SSxDQUEyQzRJO0FBQ3JEQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBakJFQSxDQUFBQSw2QkFBQUE7O0FBb0JBbkgsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUNBLFdBQURBO0lBREZBLENBQUFBLDhCQUFBQTtJQUlBLGFBQU0sS0FBTixFQUFVLFNBQVY7SUFFQSxhQUFNLE1BQU4sRUFBVyxVQUFYOztBQUVBb0gsSUFBQUEsdUJBQUFBLGdCQUFBQSxlQUFRN0YsQ0FBUjZGO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQXVCOztNQUNyQkEsT0FBSUEsTUFBSjFKLElBQUFtRyxNQUFBQSxDQUFBQSxDQUFJdUQsT0FBQUEsRUFBQUEsQ0FBSzdGLENBQUw2RixDQUFBQSxFQUFTaEcsS0FBREMsU0FBQUEsQ0FBQUEsQ0FBUitGO0lBRE5BLENBQUFBLDRCQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLGdCQUFBQSxlQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFRO01BQ05BLE9BQUlBLE1BQUozSixJQUFBbUcsTUFBQUEsQ0FBQUEsQ0FBSXdELE9BQUFBLEVBQUFBLEVBQUFBLEVBQU1qRyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFMZ0c7SUFETkEsQ0FBQUEsMkJBQUFBOztBQUtGeko7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUUwSixJQUFBQSwrQkFBQUEsd0JBQUFBLHVCQUFnQnhFLEdBQWhCd0U7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBaUM7O01BQy9CLElBQU92RyxlQUFQO01BQUE7UUFDRSxPQUFPQyxNQUFBdEQsSUFBQXNELFlBQUFBLEVBQUFBLENBQVMsYUFBVCxFQUF1QjhCLEdBQXZCOUIsQ0FBQUEsRUFBNEJ1RyxpQkFBQUEsRUFBQUM7O1VBQ2pDQSxPQUFDQSx3RUFBREEsQ0FEaUNELG1CQUFBQSxrQkFBQUEsTUFBNUJ2RztNQURUOztBQU9Kc0c7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLDhCQUFnQ2hKLHVCQUFRZ0o7QUFDeENBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxRQUFXLG1CQUFNLEVBQU47QUFDWEE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBYSxtQkFBT0EsU0FBUDtBQUNiQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxRQUFXRyxDQUFBQSxPQUFPMUkscUJBQUsrSCxLQUFBQSxDQUFLaEUsR0FBTGdFLENBQVpXLENBQXVCSDtBQUNsQ0EsUUFBV0ksQ0FBQUEsT0FBTzNJLHFCQUFLK0gsS0FBQUEsQ0FBTVEsV0FBWCxFQUF5QixLQUFwQlIsQ0FBWlksQ0FBd0NKOztBQUVuREE7QUFDQUE7QUFDQUE7QUFDQUEsZUFBbUJJLElBQUkxSixPQUFBQSxDQUFFc0osQ0FBRnRKLENBQUwySixNQUFBQSxDQUFBQSxDQUFZTDtBQUM5QkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBLFlBQWN2RyxlQUFhdUc7QUFDM0JBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BRUlBLE9BQUE1SjtJQW5FRjRKLENBQUFBLG9DQUFBQTs7QUFzRUFNLElBQUFBLHdDQUFBQSxpQ0FBQUEsZ0NBQXlCckcsQ0FBekJxRztBQUFBQSxNQUFBQTs7TUFBQUE7O01BQ0U5RSxNQUFNakUsb0JBQUlnRCxlQUFBQSxDQUFZTixDQUFoQixFQUFtQmpELHVCQUFuQixFQUE0QixRQUF4QnVEO01BQ1YsSUFBZ0ZkLGdCQUFoRjtNQUFBO1FBQUEsT0FBT0MsTUFBQXRELElBQUFzRCxZQUFBQSxFQUFBQSxDQUFTLHNCQUFULEVBQWdDOEIsR0FBaEM5QixDQUFBQSxFQUFxQzZHLGlCQUFBQSxFQUFBQzs7VUFBRSxJQUFBLFFBQUlDLE9BQUpqRixHQUFJaUYsRUFBR2hHLENBQUhnRyxDQUFKLENBQUE7WUFBV0QsT0FBQXBLLElBQUFRLE1BQUFBLENBQUFBLENBQUk4SixPQUFBQSxDQUFFbEYsR0FBRmtGO1VBQWY7WUFBdUJGLE9BQUEvRjtVQUF2QixDQUFGOEYsbUJBQUFBLGtCQUFBQSxNQUFyQzdHO01BQVA7O0FBR0o0RztBQUNBQTtBQUNBQTtBQUNBQSxVQUFZLG9CQUFPQSxJQUFQO0FBQ1pBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtNQUVJQSxPQUFBbEs7SUFyQkZrSyxDQUFBQSw0Q0FBQUE7O0FBd0JBSyxJQUFBQSx1QkFBQUEsZ0JBQUFBLGVBQVE3RixLQUFSNkY7QUFBQUEsTUFBQUE7Ozs7TUFDRSxJQUFBLFFBQUlBLG1CQUFKLENBQUE7O1FBQ0UsSUFBQSxRQUFXQSxpQkFBWCxDQUFBO1VBQUEsT0FBQSxHQUFBO1FBQ0EsT0FBUUEsV0FGVjtNQUtBN0YsUUFBUzZGLGtCQUFvQjNKLHVCQUFRMko7TUFFckMsSUFBQSxRQUFJQSxTQUFKLENBQUE7UUFDRXZLLElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCeUoscUJBQXJCMUosQ0FERjtNQUlBLElBQUEsUUFBYzBKLGlCQUFkLENBQUE7UUFBQSxPQUFPLEVBQVA7TUFFQSxJQUFBLFFBQUlBLFdBQUosQ0FBQTtRQUNFQSxPQUFDQSxZQUFEQTtNQURGLE9BRUEsSUFBQSxRQUFPQSxtQkFBUCxDQUFBO1FBQ0VBLE9BQUNBLDJCQUFEQTtNQURGO1FBR0VBLE9BQUNBLDZDQUFEQTtNQUhGO0lBaEJGQSxDQUFBQSw0QkFBQUE7O0FBdUJBQyxJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQXZpREYsRUF1aURFQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFtQjs7TUF2aURyQjs7TUF1aURjOztBQUVkQSxtQkFBcUJuSCxlQUFhbUg7QUFDbENBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQSw0Q0FBOENuSixxQkFBTW1KO0FBQ3BEQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBWXhLLElBQUFhLE9BQUFBLENBQU0rQiwwQkFBTixFQUFrQjRILG9CQUFsQjNKO0FBQ1oySjtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsVUFBWSxtQkFBT0EsUUFBUDtBQUNaQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUEvQ0VBLENBQUFBLGdDQUFBQTs7QUFrREFDLElBQUFBLHdCQUFBQSxpQkFBQUEsZ0JBemxERixFQXlsREVBO0FBQUFBLE1BQUFBOzs7O01BemxERjs7TUF5bERXOztBQUVYQTtBQUNBQTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBeks7SUFQRnlLLENBQUFBLDZCQUFBQTtJQVVBLGFBQU0sUUFBTixFQUFhLE1BQWI7O0FBRUFDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVcxSSxNQUFYMEk7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTs7QUFFQUE7QUFDQUEsY0FBZ0JBLENBQUNBLE9BQURBLENBQVV2SSxPQUFBQSxDQUFHSCxNQUFIRyxDQUFVdUk7QUFDcENBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQWJFQSxDQUFBQSw4QkFBQUE7O0FBZ0JBQyxJQUFBQSwwQkFBQUEsbUJBQUFBLGtCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFXO01BQ1QsSUFBeUN0SCxlQUF6QztNQUFBO1FBQUEsT0FBT0MsTUFBQXRELElBQUFzRCxZQUFBQSxFQUFBQSxDQUFTLFFBQVRBLENBQUFBLEVBQWtCc0gsaUJBQUFBLEVBQUFDOztVQUFFQSxPQUFBN0ssSUFBQVEsTUFBQUEsQ0FBQUEsQ0FBRm9LLG1CQUFBQSxrQkFBQUEsTUFBbEJ0SDtNQUFQOztBQUdKcUg7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQWRFQSxDQUFBQSw4QkFBQUE7O0FBaUJBRyxJQUFBQSwyQkFBQUEsd0JBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVk7TUFDVixJQUEwQ3pILGVBQTFDO01BQUE7UUFBQSxPQUFPQyxNQUFBdEQsSUFBQXNELFlBQUFBLEVBQUFBLENBQVMsU0FBVEEsQ0FBQUEsRUFBbUJ5SCxpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUFoTCxJQUFBUSxNQUFBQSxDQUFBQSxDQUFGdUssbUJBQUFBLGtCQUFBQSxNQUFuQnpIO01BQVA7TUFFQTJILFdBQVdqTCxJQUFBc0MsUUFBQUEsQ0FBQUE7TUFDWGdFLE1BQUF0RyxJQUFBc0csYUFBQUEsRUFBQUEsRUFBQUEsRUFBVzVDLEtBQURDLFNBQUFBLENBQUFBLENBQVYyQztNQUVBLElBQU90RyxJQUFBc0MsUUFBQUEsQ0FBQUEsQ0FBT0gsT0FBQUEsQ0FBRzhJLFFBQUg5SSxDQUFkO1FBNW9ESjJJLE9BQUE7TUE0b0RJO1FBQ0VBLE9BQUE5SztNQURGO0lBTkY4SyxDQUFBQSxtQ0FBQUE7O0FBV0EvSixJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQUFZUSxLQUFaUjtBQUFBQSxNQUFBQTs7O01BQ0VRLFFBQVEsYUFBQSxJQUFBLFFBQUdGLHFCQUFNRyxRQUFBQSxDQUFJRCxLQUFKQyxDQUFULENBQUE7UUFDRVQsT0FBQVEsS0FBS2xCLE1BQUFBLENBQUFBO01BRFA7UUFHRVUsT0FBQUEsQ0FBQ0Esa0JBQW9CTSxxQkFBTU4sV0FBM0JBLENBQXVDVixNQUFBQSxDQUFBQTtNQUh6QyxDQUFBOztBQU9aVTtBQUNBQTtBQUNBQTtNQUVJQSxPQUFBZjtJQVpGZSxDQUFBQSwrQkFBQUE7O0FBZUFtSyxJQUFBQSwyQkFBQUEsb0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsdUJBQURBO0lBREZBLENBQUFBLCtCQUFBQTs7QUFJQUMsSUFBQUEsNEJBQUFBLHlCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQ0EsY0FBREE7SUFERkEsQ0FBQUEsb0NBQUFBOztBQUlBQyxJQUFBQSxnQ0FBQUEseUJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFpQjtNQUNmLElBQStDL0gsZUFBL0M7TUFBQTtRQUFBLE9BQU9DLE1BQUF0RCxJQUFBc0QsWUFBQUEsRUFBQUEsQ0FBUyxjQUFUQSxDQUFBQSxFQUF3QitILGlCQUFBQSxFQUFBQzs7VUFBRUEsT0FBQXRMLElBQUFRLE1BQUFBLENBQUFBLENBQUY2SyxtQkFBQUEsa0JBQUFBLE1BQXhCL0g7TUFBUDtNQUVPNkMsTUFBUG5HLElBQUFrTCxTQUFBQSxDQUFBQSxDQUFPL0UsUUFBQUEsRUFBQUEsRUFBQUEsRUFBT3pDLEtBQURDLFNBQUFBLENBQUFBLENBQU53QztNQUNQaUYsT0FBQXBMO0lBSkZvTCxDQUFBQSxvQ0FBQUE7O0FBT0FHLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVd2SixNQUFYdUo7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBK0I7OztBQUVqQ0E7O0FBRUFBO0FBQ0FBLFFBQVV2TCxJQUFBVSxNQUFBQSxDQUFLNkssK0JBQUw3SztBQUNWNks7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGNBQWdCQSxDQUFDQSxPQUFEQSxDQUFVcEosT0FBQUEsQ0FBSW9KLE1BQUpwSixDQUFZb0o7QUFDdENBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsZUFBaUJ2TCxJQUFBc0QsVUFBQUEsQ0FBUyxRQUFUQSxDQUFpQmlJO0FBQ2xDQTs7QUFFQUE7QUFDQUE7SUFwQ0VBLENBQUFBLCtCQUFBQTs7QUF1Q0FDLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQVczSCxDQUFYMkg7QUFBQUEsTUFBQUE7Ozs7TUFBVztNQUFBLE1BQUkxSSxDQUFKO01BQUE7O0FBRWIwSTs7QUFFQUEsd0JBQTBCNUssdUJBQVE0Szs7QUFFbENBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFuQkVBLENBQUFBLCtCQUFBQTs7QUFzQkFDLElBQUFBLDJCQUFBQSx3QkFBQUEsU0FBWUMsR0FBWkQ7QUFBQUEsTUFBQUE7Ozs7TUFBWTtNQUFBLFFBQU0zSSxDQUFOO01BQUE7O0FBRWQySTtBQUNBQTtBQUNBQTtBQUNBQSw0QkFBOEI3Syx1QkFBUTZLO0FBQ3RDQTtNQUNJRSxNQUFNM0wsSUFBQXdMLFFBQUFBLENBQU9FLEdBQVBGO01BQ05DLE9BQUF6TCxJQUFBZSxTQUFBQSxDQUFRNEssR0FBUjVLO0lBUkYwSyxDQUFBQSxvQ0FBQUE7SUFXQUc7SUFBQUE7O01BQUFBOztBQUFBQTs7O0FBQ0VyTCxNQUFBQSw4QkFBQUEsOEJBQUFBLHNCQUFlc0wsR0FBZnRMO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFBdUwsQ0FBQUEsV0FBT0QsR0FBUEM7TUFERnZMLENBQUFBLHlDQUFBQTtNQUlBcUwsT0FBQUcsQ0FBQUEsd0JBQUFBLHdCQUFBQSxnQkFBU3ZMLElBQVR1TDtBQUFBQSxRQUFBQTs7O1FBQ0VDLFNBQVVELFdBQWFELFFBQUlDLE1BQUFBLENBQU12TCxJQUFOdUwsQ0FBWUEsRUFBSW5MLHVCQUFRbUw7UUFDbkQsSUFBQSxRQUFrREEsVUFBbEQsQ0FBQTtVQUFBL0wsSUFBQWEsT0FBQUEsQ0FBTStCLDBCQUFOLEVBQWtCbUosMkJBQWxCbEwsQ0FBQTtRQUNBLElBQUEsUUFBc0VrTCxhQUF0RSxDQUFBO1FBQUE7VUFBQS9MLElBQUFhLE9BQUFBLENBQU0rQiwwQkFBTixFQUFrQm1KLDJDQUFsQmxMO1FBQUE7UUFFQWtMLE9BQUFDO01BTEZELENBQUFBLG1DQUFBQSxDQUFBQTtJQUxGSCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTs7QUFjQUssSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBV3ZILEtBQUQsRUFBb0J3SCxPQUE5QkQ7QUFBQUEsTUFBQUE7Ozs7O01BQ0UsSUFBQSxRQUF5Q0EsbUJBQXpDLENBQUE7UUFBQSxPQUFPak0sSUFBQW1ELElBQUFBLENBQUdnSixzQkFBTUosTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBVDVJLENBQVA7TUFFQSxJQUFBLFFBQUk4SSxxQkFBSixDQUFBO1FBQ0UsSUFBQSxRQUFJRyxDQUFBQSxJQUFJakwsb0JBQUlDLGVBQUFBLENBQVlzRCxLQUFoQixFQUF1QjJILG9CQUF2QixFQUE2QixTQUF6QmpMLENBQVJnTCxDQUFKLENBQUE7O1VBQ0VGLFVBQVVFO1VBQ1YxSCxRQUFRO1FBRlY7O1VBSUV3SCxVQUFVO1VBQ1Z4SCxRQUFTdUgsa0JBQW9CckwsdUJBQVFxTDtRQUx2QztNQURGOztRQVNFdkgsUUFBU3VILGtCQUFvQnJMLHVCQUFRcUw7UUFDckNDLFVBQVdELG9CQUFzQkksb0JBQUtKO01BVnhDO01BYUEsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQXJ4RFBLLENBQUFBLFlBcXhETzVILEtBcnhEUDRILENBcXhETyxDQUFBO1FBQVNMLE9BQUNBLFNBQURBO01BQVQ7UUFyeERQQSxPQUFBO01BcXhETyxDQUFBLGtCQUFILENBQUE7UUFDRWpNLElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCbUwsOEJBQXJCcEwsQ0FERjtNQUlBLElBQUEsUUFBMEJxTCxPQUExQixDQUFBO1FBQUFMLE1BQU1LLE9BQU81TCxPQUFBQSxDQUFDLFFBQURBLENBQWI7TUFDQXVMLE1BQU0sYUFBQSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBMXhEYlUsQ0FBQUEsWUEweERhVixHQTF4RGJVLENBMHhEYSxDQUFBO1FBQU9OLE9BQUFKLEdBQUc3SyxnQkFBQUEsQ0FBYSxNQUFiQTtNQUFWO1FBMXhEYmlMLE9BQUE7TUEweERhLENBQUEsa0JBQUgsQ0FBQTtRQUNFQSxPQUFBTyw0QkFBWXBELEtBQUFBLENBQUt5QyxHQUFMekM7TUFEZDtRQUdFNkMsT0FBQUU7TUFIRixDQUFBO01BTU4sSUFBQSxRQUFpRHpILEtBQWpELENBQUE7TUFBQTtRQUFBLE9BQVF1SCxLQUFPSixHQUFHRSxNQUFBQSxDQUFPRSxXQUFQRixDQUFxQkU7TUFBdkM7OztBQUlKQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHVCQUF5QkosR0FBR0UsTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBcUJFO0FBQ2pEQTtBQUNBQTtBQUNBQSxjQUFnQkosR0FBR0UsTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBcUJFO0FBQ3hDQSxjQUFnQkosR0FBR0UsTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBcUJFO0FBQ3hDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUEscUJBQXdCNUsscUJBQUsrSCxLQUFBQSxDQUFLMUUsS0FBTDBFLENBQWE2QztBQUMxQ0E7O0FBRUFBLHdCQUEwQkosR0FBR0UsTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBcUJFO0FBQ2xEQTtBQUNBQSxrQkFBb0JKLEdBQUdFLE1BQUFBLENBQU9FLFdBQVBGLENBQXFCRTtBQUM1Q0E7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLHNCQUF3QkosR0FBR0UsTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBcUJFO0FBQ2hEQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBOztBQUVBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLDBCQUE0QkosR0FBR0UsTUFBQUEsQ0FBT0UsV0FBUEYsQ0FBcUJFO0FBQ3BEQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUEsa0RBQW9EQSxDQUFDQSxNQUFEQSxDQUFRM0wsT0FBQUEsQ0FBQytELENBQVQsRUFBWUssS0FBSnBFLENBQVcyTDtBQUN2RUE7QUFDQUE7SUE1R0VBLENBQUFBLCtCQUFBQTs7QUErR0FRLElBQUFBLDBCQUFBQSxtQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVc7TUFDVCxJQUF5Q3BKLGVBQXpDO01BQUE7UUFBQSxPQUFPQyxNQUFBdEQsSUFBQXNELFlBQUFBLEVBQUFBLENBQVMsUUFBVEEsQ0FBQUEsRUFBa0JvSixpQkFBQUEsRUFBQUM7O1VBQUVBLE9BQUEzTSxJQUFBUSxNQUFBQSxDQUFBQSxDQUFGa00sbUJBQUFBLGtCQUFBQSxNQUFsQnBKO01BQVA7O0FBR0ptSjs7QUFFQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFqQkVBLENBQUFBLDhCQUFBQTs7QUFvQkFHLElBQUFBLDJCQUFBQSx3QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBWTtNQUNWLElBQTBDdkosZUFBMUM7TUFBQTtRQUFBLE9BQU9DLE1BQUF0RCxJQUFBc0QsWUFBQUEsRUFBQUEsQ0FBUyxTQUFUQSxDQUFBQSxFQUFtQnVKLGlCQUFBQSxFQUFBQzs7VUFBRUEsT0FBQTlNLElBQUFRLE1BQUFBLENBQUFBLENBQUZxTSxtQkFBQUEsa0JBQUFBLE1BQW5Cdko7TUFBUDs7QUFHSnNKO0FBQ0FBLE1BQVN0RCxNQUFBdEosSUFBQXNKLFdBQUFBLEVBQUFBLEVBQUFBLEVBQVM1RixLQUFEQyxTQUFBQSxDQUFBQSxDQUFSMkYsQ0FBaUJzRDtBQUMxQkE7QUFDQUE7SUFQRUEsQ0FBQUEsbUNBQUFBO0lBVUEsYUFBTSxRQUFOLEVBQWEsUUFBYjtJQUNBLGFBQU0sU0FBTixFQUFjLFNBQWQ7O0FBRUFHLElBQUFBLHlCQUFBQSxrQkFBQUEsaUJBQVVySSxLQUFWcUk7QUFBQUEsTUFBQUE7Ozs7TUFDRSxJQUFBLFFBQUlBLG1CQUFKLENBQUE7O1FBQ0UsSUFBQSxRQUFXQSxpQkFBWCxDQUFBO1VBQUEsT0FBQSxHQUFBO1FBQ0EsT0FBUUEsaUJBRlY7TUFLQXJJLFFBQVNxSSxrQkFBb0JuTSx1QkFBUW1NO01BRXJDLElBQUEsUUFBSUEsU0FBSixDQUFBO1FBQ0UvTSxJQUFBYSxPQUFBQSxDQUFNQyw2QkFBTixFQUFxQmlNLHFCQUFyQmxNLENBREY7TUFJQSxJQUFBLFFBQWNrTSxpQkFBZCxDQUFBO1FBQUEsT0FBTyxFQUFQO01BRUFBLE9BQUNBLHFCQUFEQTtJQWRGQSxDQUFBQSw4QkFBQUE7SUFpQkEsYUFBTSxNQUFOLEVBQVcsUUFBWDs7QUFFQUMsSUFBQUEsMkJBQUFBLG9CQUFBQSxtQkFBWW5CLEdBQVptQjtBQUFBQSxNQUFBQTs7OztNQUNFQSxPQUFBaE4sSUFBQWtHLEtBQUFBLENBQUFBLENBQUc3RixNQUFBQSxDQUFBQSxDQUFLNE0sYUFBQUEsQ0FBVXBCLEdBQVZvQjtJQURWRCxDQUFBQSxnQ0FBQUE7O0FBSUFDLElBQUFBLDRCQUFBQSwwQkFBQUEsU0FBYXBCLEdBQWJvQjtBQUFBQSxNQUFBQTs7Ozs7QUFFRkE7O0FBRUFBO0FBQ0FBLGNBQWdCOUwsb0JBQUlDLGVBQUFBLENBQVl5SyxHQUFoQixFQUFxQlEsb0JBQXJCLEVBQTJCLFNBQXZCakwsQ0FBaUM2TDs7QUFFckRBO0FBQ0FBLGdCQUFrQnBCLEdBQUd2TCxPQUFBQSxDQUFDLFFBQURBLENBQVUyTTs7QUFFL0JBLDZCQUErQnBCLEdBQUc3SyxnQkFBQUEsQ0FBYSxNQUFiQSxDQUFvQmlNO0FBQ3REQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFlBQWNqTixJQUFBYSxPQUFBQSxDQUFNK0IsMEJBQU4sRUFBa0IsRUFBQSxHQUFBLDBCQUFBLEdBQUEsQ0FBNEJxSyxDQUE1QixDQUFsQnBNO0FBQ2RvTTs7QUFFQUE7QUFDQUEsWUFBY2pOLElBQUFhLE9BQUFBLENBQU0rQiwwQkFBTixFQUFrQixFQUFBLEdBQUEsd0JBQUEsR0FBQSxDQUEwQnFLLENBQTFCLENBQWxCcE07QUFDZG9NO0FBQ0FBO0FBQ0FBO0FBQ0FBLGNBQWdCak4sSUFBQStMLE1BQUFBLENBQU1rQixDQUFObEIsQ0FBVWtCO0FBQzFCQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBdENFQSxDQUFBQSxzQ0FBQUE7SUF5Q0EsYUFBTSxPQUFOLEVBQVksSUFBWjs7QUFFQUMsSUFBQUEsMEJBQUFBLHdCQUFBQSxTQUFXN0ssS0FBRCxFQUFRQyxNQUFsQjRLO0FBQUFBLE1BQUFBOzs7O01BQ0VDLFNBQVM7TUFFVCxJQUFBLFFBQUlELG9CQUFKLENBQUE7UUFDRSxJQUFBLFFBQUd4SyxxQkFBTWxCLFFBQUFBLENBQUlhLEtBQUpiLENBQVQsQ0FBQTs7VUFDRTRMLFFBQVEvSztVQUNSOEssU0FBU25OLElBQUlNLE9BQUFBLENBQUM4TSxLQUFEOU07VUFFYitNLGNBQWVILHdCQUEwQnRNLHVCQUFRc007VUFDakRJLFlBQWFKLHNCQUF3QnRNLHVCQUFRc007O0FBR3JEQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQS9CTTs7VUFpQ0VLLFFBQVNMLGtCQUFvQnRNLHVCQUFRc007O0FBRTdDQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtRQWxETTtNQURGOztRQXNERUssUUFBU0wsa0JBQW9CdE0sdUJBQVFzTTtRQUNyQzVLLFNBQVU0SyxtQkFBcUJ0TSx1QkFBUXNNOztBQUc3Q0E7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQSxpQkFBbUJsTixJQUFJTSxPQUFBQSxDQUFDaU4sS0FBTCxFQUFZakwsTUFBUmhDLENBQWdCNE07O0FBRXZDQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO01BN0VJO01BK0VBQSxPQUFBQztJQWxGRkQsQ0FBQUEsb0NBQUFBOztBQXFGQU0sSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBUztNQUNQLElBQUEsUUFBb0JBLGVBQXBCLENBQUE7TUFBQTtRQUFBLE9BQU94TjtNQUFQOztBQUdKd047QUFDQUE7QUFDQUEsaUJBQW1CQSxDQUFDQSxDQUFEQSxDQUFJdkwsUUFBQUEsQ0FBS3VMLENBQUx2TCxDQUFRdUw7QUFDL0JBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUEsVUFBWXhOLElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCME0sQ0FBQ0EsQ0FBREEsQ0FBRzNLLFNBQUFBLENBQUFBLENBQXBCLENBQUEsR0FBQSxRQUFBLEdBQUEsQ0FBcUMySyxDQUFDQSxDQUFEQSxDQUFHM0ssU0FBQUEsQ0FBQUEsQ0FBeEMsQ0FBQSxHQUFBLFNBQXJCaEMsQ0FBK0UyTTtBQUMzRkE7O0FBRUFBLGVBQXVCcEosT0FBTG9KLEdBQUtwSixFQUFFQyxDQUFGRCxDQUFJb0osUUFBZ0JDLE9BQUxELEdBQUtDLEVBQUVwSixDQUFGb0osQ0FBSUQ7QUFDL0NBO0FBQ0FBO0lBbkJFQSxDQUFBQSw2QkFBQUE7O0FBc0JBRSxJQUFBQSx5QkFBQUEsdUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVU7O0FBRVpBOztBQUVBQSxVQUFZckssZUFBYXFLO0FBQ3pCQSxpQkFBaUNGLE1BQWRFLENBQUNBLFlBQURBLENBQWNGLFFBQUFBLEVBQUFBLEVBQUFBLEVBQU85SixLQUFEQyxTQUFBQSxDQUFBQSxDQUFONkosQ0FBY0U7QUFDL0NBO0FBQ0FBO0FBQ0FBLGlCQUFtQkEsQ0FBQ0EsWUFBREEsQ0FBY0YsTUFBQUEsQ0FBQUEsQ0FBTUU7QUFDdkNBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFqQkVBLENBQUFBLGtDQUFBQTs7QUFvQkFDLElBQUFBLDRCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBYTtNQUNYLElBQTJDdEssZUFBM0M7TUFBQTtRQUFBLE9BQU9DLE1BQUF0RCxJQUFBc0QsWUFBQUEsRUFBQUEsQ0FBUyxVQUFUQSxDQUFBQSxFQUFvQnNLLGtCQUFBQSxFQUFBQzs7VUFBRUEsT0FBQTdOLElBQUFRLE1BQUFBLENBQUFBLENBQUZvTixvQkFBQUEsbUJBQUFBLE9BQXBCdEs7TUFBUDtNQUVBcUssT0FBQTNOLElBQUFlLFNBQUFBLENBQVErTSxNQUFBOU4sSUFBQThOLFdBQUFBLEVBQUFBLEVBQUFBLEVBQVNwSyxLQUFEQyxTQUFBQSxDQUFBQSxDQUFSbUssQ0FBUi9NO0lBSEY0TSxDQUFBQSxxQ0FBQUE7O0FBTUFJLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQVNySixLQUFUcUo7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQSxRQUFVL04sSUFBQWEsT0FBQUEsQ0FBTUMsNkJBQU5ELENBQW9Ca047QUFDOUJBOztBQUVBQTtBQUNBQTtJQVBFQSxDQUFBQSw2QkFBQUE7O0FBVUFDLElBQUFBLDhCQUFBQSx3QkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWU7O0FBRWpCQTs7QUFFQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBakJFQSxDQUFBQSxtQ0FBQUE7O0FBb0JBM04sSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQVJFQSxDQUFBQSw2QkFBQUE7O0FBV0FZLElBQUFBLDBCQUFBQSxvQkFBQUEsa0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBakI7SUFERmlCLENBQUFBLCtCQUFBQTs7QUFJQWdOLElBQUFBLHdCQUFBQSxrQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQVM7TUFDUEMsUUFBUWxPO01BQ1IsSUFBNkJxRCxlQUE3QjtRQUFBNkssUUFBYXBJLE1BQUxvSSxLQUFLcEksT0FBQUEsRUFBQUEsRUFBQUEsRUFBTXBDLEtBQURDLFNBQUFBLENBQUFBLENBQUxtQyxDQUFiOztBQUdKbUksdURBQXlELFlBQUEsRUFBR0E7O0FBRTVEQTtBQUNBQSxjQUFnQjlNLG9CQUFJQyxlQUFBQSxDQUFhNk0sUUFBakIsRUFBNEI1TSxxQkFBNUIsRUFBbUMsUUFBL0JELENBQXdDNk07QUFDNURBO0FBQ0FBLFVBQVlqTyxJQUFBYSxPQUFBQSxDQUFNMEMseUJBQU4sRUFBaUIsRUFBQSxHQUFBLHFCQUFBLEdBQUEsQ0FBc0IwSyxDQUFDQSxHQUFEQSxDQUFLekssT0FBQUEsQ0FBQUEsQ0FBM0IsQ0FBQSxHQUFBLE1BQUEsR0FBQSxDQUF5Q3lLLENBQXpDLENBQUEsR0FBQSxtQkFBakJwTjtBQUNab047QUFDQUE7QUFDQUEsVUFBWWpPLElBQUFhLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSx3QkFBQSxHQUFBLENBQTBCbU4sQ0FBMUIsQ0FBQSxHQUFBLG9CQUFBLEdBQUEsQ0FBaURBLENBQUNBLEdBQURBLENBQUszTCxRQUFBQSxDQUFBQSxDQUF0RCxDQUFBLEdBQUEsR0FBckJ6QjtBQUNab047QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0lBckJFQSxDQUFBQSw2QkFBQUE7SUF3QkEsYUFBTSxNQUFOLEVBQVcsU0FBWDs7QUFFQUUsSUFBQUEsNkJBQUFBLHVCQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBYW5PLElBQUF3RSxXQUFBQSxDQUFBQSxDQUFiLENBQUE7UUFBQSxPQUFPLEVBQVA7TUFFQTJJLFNBQVM7TUFDVHpELE1BQVM7TUFFVHZELE1BQUFuRyxJQUFBbUcsUUFBQUEsRUFBQUEsRUFBQUEsRUFBS2lJLGtCQUFJQyxHQUFKRCxFQUFBRTs7OztRQUFJO1FBQUE7UUFBQTtRQUNQRCxNQUFNLGFBQUEsSUFBQSxRQUFHaE4scUJBQU1HLFFBQUFBLENBQUk2TSxHQUFKN00sQ0FBVCxDQUFBO1VBQ0U4TSxPQUFBRCxHQUFHaE8sTUFBQUEsQ0FBQUE7UUFETDtVQUdFaU8sT0FBQUEsQ0FBQ0EsZ0JBQWtCak4scUJBQU1pTixXQUF6QkEsQ0FBcUNqTyxNQUFBQSxDQUFBQTtRQUh2QyxDQUFBO1FBTU5xSixNQWhyRU4sYUFBQSxJQUFBLFFBQUE2RSxDQUFBQSxZQWdyRU03RSxHQWhyRU42RSxDQUFBLENBQUE7VUFBQUQsT0FBQTtRQUFBO1VBZ3JFY0EsT0FBQ0EsVUFBREE7UUFockVkLENBQUE7UUFrckVNLElBQUEsUUFBR0EsQ0FBQ0EsVUFBREEsQ0FBYUUsT0FBQUEsQ0FBRzlFLEdBQUg4RSxDQUFoQixDQUFBO1VBQ0V4TyxJQUFBYSxPQUFBQSxDQUFNa0MsMEJBQU4sRUFBa0IsRUFBQSxHQUFBLHdCQUFBLEdBQUEsQ0FBMEJ1TCxVQUExQixDQUFBLEdBQUEsYUFBQSxHQUFBLENBQW1ENUUsR0FBbkQsQ0FBQSxHQUFBLEdBQWxCN0ksQ0FERjtRQUlBeU4sT0FBWUcsTUFBWkgsQ0FBQ0EsVUFBREEsQ0FBWUcsU0FBQUEsRUFBQUEsRUFBQUEsRUFBT0gsa0JBQUlJLENBQUpKLEVBQUFLOzs7O1VBQUk7VUFBQTtVQUFBO1VBQ3JCQyxRQXZyRVIsYUFBQSxJQUFBLFFBQUFDLENBQUFBLFlBdXJFaUIxQixNQUFNN00sT0FBQUEsQ0FBQ29PLENBQURwTyxDQXZyRXZCdU8sQ0FBQSxDQUFBO1lBQUFGLE9BQUE7VUFBQTs7WUFBQUcsVUFBQSxDQXVyRXdCSixDQXZyRXhCLEVBdXJFK0IsRUF2ckUvQjtZQXVyRXVCbk0sTUFBTjRLLE1BQU01SyxPQUFBQSxFQXZyRXZCLFVBQUF1TSxPQUFBLENBdXJFdUJ2TTtZQXZyRXZCb00sT0FBQUcsT0FBQSxDQUFBaE4sVUFBQWdOLE9BQUEsQ0FBQUgsUUFBQSxDQUFBN00sRUFBQWdCLENBQUFoQixDQUFBO1VBQUEsQ0FBQTtVQXdyRVE2TSxPQUFBQyxLQUFNN00sT0FBQUEsQ0FBR3NNLEdBQUdsTCxJQUFBQSxDQUFJdUwsQ0FBSnZMLENBQU5wQixFQUZXdU0sb0JBQUFBLG1CQUFBQSxPQUFQRyxFQWJUTCxvQkFBQUEsbUJBQUFBLE9BQUxqSTtNQW1CQWdJLE9BQUFoQjtJQXpCRmdCLENBQUFBLGtDQUFBQTs7QUE0QkFZLElBQUFBLHlCQUFBQSxtQkFBQUEsaUJBL3JFRixFQStyRUVBO0FBQUFBLE1BQUFBOzs7O01BL3JFRjs7TUErckVZO01BQ1JBLE9BQU1ySSxNQUFOQyxNQUFNRCxVQUFBQSxFQUFBQSxDQUFRMUcsSUFBQWdQLE1BQUFBLENBQUFBLENBQVJ0SSxDQUFBQSxFQUFjdUksa0JBQUdwSSxDQUFELEVBQUlDLENBQU5tSSxFQUFBQzs7OztRQUFHO1FBQUE7UUFBQTs7UUFBRztRQUFBO1FBQUE7UUFBR0EsT0FBQXJJLENBQUVwRixNQUFBQSxDQUFFcUYsQ0FBRnJGLEVBQVh3TixvQkFBQUEsbUJBQUFBLE9BQWR2STtJQURScUksQ0FBQUEsK0JBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsa0JBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7OztNQUFTOztBQUVYQSxpQkFBbUIsWUFBQSxFQUFHQTs7QUFFdEJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQSxhQUFlQSxDQUFDQSxJQUFEQSxDQUFNRyxRQUFBQSxDQUFBQSxDQUFRSDtBQUM3QkE7SUF2QkVBLENBQUFBLDZCQUFBQTs7QUEwQkFJLElBQUFBLHlCQUFBQSx1QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBVTs7QUFFWkEsZ0RBQWtELFlBQUEsRUFBR0E7O0FBRXJEQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQW5CRUEsQ0FBQUEsa0NBQUFBOztBQXNCQUMsSUFBQUEsMkJBQUFBLHFCQUFBQSxtQkFudkVGLEVBbXZFRUE7QUFBQUEsTUFBQUE7Ozs7TUFudkVGOztNQW12RWM7O0FBRWRBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBbEJFQSxDQUFBQSxpQ0FBQUE7SUFxQkEsYUFBTSxTQUFOLEVBQWMsU0FBZDs7QUFFQUMsSUFBQUEsNkJBQUFBLHVCQUFBQSxxQkExd0VGLEVBMHdFRUE7QUFBQUEsTUFBQUE7Ozs7TUExd0VGOztNQTB3RWdCO01BQ1pDLE1BQU07TUFFRnBKLE1BQUo0QixJQUFJNUIsUUFBQUEsRUFBQUEsRUFBQUEsRUFBTXFKLGtCQUFJQyxJQUFKRCxFQUFBRTs7OztRQUFJO1FBQUE7UUFBQTtRQUNaLElBQUEsUUFBR0QsSUFBSUUsVUFBQUEsQ0FBT2pOLHFCQUFQaU4sQ0FBUCxDQUFBOztVQUNFQyxTQUFVRixXQUFhRCxJQUFJaEcsTUFBQUEsQ0FBQUEsQ0FBTWlHLEVBQUk5Tyx1QkFBUThPO1VBQzdDbkMsUUFBU21DLFdBQWFELElBQUlwSCxPQUFBQSxDQUFBQSxDQUFPcUgsRUFBSTlPLHVCQUFROE87O0FBR3JEQTtBQUNBQTtBQUNBQSxZQUFjLE9BQUEsR0FBQSxDQUFLQTtBQUNuQkE7QUFDQUE7O0FBR0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGNBQWdCRCxJQUFJckgsaUJBQUFBLENBQUFBLENBQWNzSDtBQUNsQ0E7QUFDQUE7QUFDQUE7QUFDQUEsWUFBYyxPQUFBLEdBQUEsQ0FBS0E7QUFDbkJBO0FBQ0FBO1VBRVFBLE9BQUtHLE1BQUx0QyxLQUFLc0MsUUFBQUEsRUFBQUEsQ0FBTUQsTUFBTkMsQ0FBQUEsRUFBY0gsa0JBQUdoQixDQUFIZ0IsRUFBQUk7Ozs7WUFBRztZQUFBO1lBQUE7WUFBR0EsT0FBQVAsR0FBSXhOLE9BQUFBLENBQUcvQixJQUFBbUQsSUFBQUEsQ0FBR3VMLENBQUh2TCxDQUFIcEIsRUFBVjJOLG9CQUFBQSxtQkFBQUEsT0FBZEc7UUF2QlA7O1VBeUJFbkIsSUFBS2dCLGlCQUFtQjlPLHVCQUFROE87VUFDaENBLE9BQUFILEdBQUl4TixPQUFBQSxDQUFHL0IsSUFBQW1ELElBQUFBLENBQUd1TCxDQUFIdkwsQ0FBSHBCO1FBMUJOLEVBRFF5TixvQkFBQUEsbUJBQUFBLE9BQU5ySjtNQStCSm1KLE9BQUFDO0lBbENGRCxDQUFBQSxtQ0FBQUE7O0FBcUNBUyxJQUFBQSx1QkFBQUEsaUJBQUFBLGVBL3lFRixFQSt5RUVBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWlCOztNQS95RW5COztNQSt5RVU7O0FBRVZBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxvQkFDVSxhQUFBLElBQUEsUUE3ekVWQyxDQUFBQSxZQTZ6RVU3TyxvQkFBSUMsZUFBQUEsQ0FBYTJPLENBQWpCLEVBQXFCMU8scUJBQXJCLEVBQTRCLFFBQXhCRCxDQTd6RWQ0TyxDQTZ6RVUsQ0FBQTtRQTd6RVZELE9BQUE7TUE2ekVVO1FBQ0FBLE9BQUE1TyxvQkFBSWdELGVBQUFBLENBQWE0TCxDQUFqQixFQUFxQkUsMEJBQXJCLEVBQWlDLFNBQWpDLEVBQTJDLE1BQXZDOUw7TUFESixDQUFBLGtCQUVEOUQsTUFBQUEsQ0FBQUEsQ0FBTTBQO0FBQ2ZBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUE1Q0VBLENBQUFBLDZCQUFBQTtJQStDQUcsVUFBSWxRLElBQUprUSxnQkFBQUEsdUJBQUFBLHFCQUFtQkMsS0FBbkJEO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRUEsQ0FBQUEsa0NBQUFBOztBQVFBRSxJQUFBQSxzQ0FBQUEsZ0NBQUFBLDhCQUFBQTtBQUFBQSxNQUFBQTs7TUFBQUE7TUFBQUE7TUFBQUE7TUFBQUE7TUFBQUE7TUFDRUEsT0FBS3pGLE1BQUwsT0FBQTNLLElBQUEsRUFBQSxrR0FBQSxzQkFBQSxFQUFBLE1BQUEsRUFBQSxLQUFBLENBQUsySyxVQUFBQSxFQUFBQSxFQUFBQSxFQUFRMEYsa0JBQUdDLElBQUhELEVBQUFFOzs7O1FBQUc7UUFBQTtRQUFBO1FBQU0sSUFBQSxRQXYyRTFCQyxDQUFBQSxZQXUyRTJCRCxjQUFnQkQsSUFBS0MsQ0F2MkVoREMsQ0F1MkUwQixDQUFBO1VBdjJFMUJELE9BQUE7UUF1MkUwQjtVQUE0QkEsT0FBQUQsSUFBS25PLE9BQUFBLENBQUdvTyxTQUFIcE87UUFBakMsRUFBVGtPLG9CQUFBQSxtQkFBQUEsT0FBUjFGO0lBRFB5RixDQUFBQSwyQ0FBQUE7SUFJQWpQLG9CQUFJc1AsVUFBQUEsQ0FBVXpRLElBQUEwUSxpQkFBQUEsQ0FBQUEsQ0FBZCxFQUErQixVQUEzQkQ7SUFDSnRQLG9CQUFJc1AsVUFBQUEsQ0FBVXpRLElBQWQsRUFBb0IseUJBQXBCLEVBQThDLGdCQUExQ3lRO0lBRUp2USxPQUFBeVEsQ0FBQUEsd0JBQUFBLGtCQUFBQSxnQkE3MkVGLEVBNjJFRUE7QUFBQUEsTUFBQUE7Ozs7TUE3MkVGOztNQTYyRVc7TUFDUEEsT0FBQTNRLElBQUFhLE9BQUFBLENBQU04UCxpRUFBTjlQO0lBREY4UCxDQUFBQSw4QkFBQUEsQ0FBQUE7RUF4MkVGelEsR0FBQUEsV0FBQUEsRUFBZUgsS0FBZkc7QUFMQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE1NzI0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9oYXNoLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuIyAtLS1cbiMgSW50ZXJuYWwgcHJvcGVydGllczpcbiNcbiMgLSAkJG1hcCAgICAgICAgIFtKUzo6T2JqZWN0PFN0cmluZyA9PiBoYXNoLWJ1Y2tldD5dIHRoZSBoYXNoIHRhYmxlIGZvciBvcmRpbmFyeSBrZXlzXG4jIC0gJCRzbWFwICAgICAgICBbSlM6Ok9iamVjdDxTdHJpbmcgPT4gaGFzaC1idWNrZXQ+XSB0aGUgaGFzaCB0YWJsZSBmb3Igc3RyaW5nIGtleXNcbiMgLSAkJGtleXMgICAgICAgIFtBcnJheTxoYXNoLWJ1Y2tldD5dIHRoZSBsaXN0IG9mIGFsbCBrZXlzXG4jIC0gJCRwcm9jICAgICAgICBbUHJvYyxudWxsLG5pbF0gdGhlIGRlZmF1bHQgcHJvYyB1c2VkIGZvciBtaXNzaW5nIGtleXNcbiMgLSBoYXNoLWJ1Y2tldCAgIFtKUzo6T2JqZWN0XSBhbiBlbGVtZW50IG9mIGEgbGlua2VkIGxpc3QgdGhhdCBob2xkcyBoYXNoIHZhbHVlcywga2V5cyBhcmUgYHtrZXk6LGtleV9oYXNoOix2YWx1ZTosbmV4dDp9YFxuY2xhc3MgSGFzaFxuICBpbmNsdWRlIEVudW1lcmFibGVcblxuICAjIE1hcmsgYWxsIGhhc2ggaW5zdGFuY2VzIGFzIHZhbGlkIGhhc2hlcyAodXNlZCB0byBjaGVjayBrZXl3b3JkIGFyZ3MsIGV0YylcbiAgYHNlbGYuJCRwcm90b3R5cGUuJCRpc19oYXNoID0gdHJ1ZWBcblxuICBkZWYgc2VsZi5bXSgqYXJndilcbiAgICAleHtcbiAgICAgIHZhciBoYXNoLCBhcmdjID0gYXJndi5sZW5ndGgsIGk7XG5cbiAgICAgIGlmIChhcmdjID09PSAxKSB7XG4gICAgICAgIGhhc2ggPSAje09wYWwuY29lcmNlX3RvPyhhcmd2WzBdLCBIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgICBpZiAoaGFzaCAhPT0gbmlsKSB7XG4gICAgICAgICAgcmV0dXJuICN7YWxsb2NhdGUubWVyZ2UhKGBoYXNoYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgYXJndiA9ICN7T3BhbC5jb2VyY2VfdG8/KGFyZ3ZbMF0sIEFycmF5LCA6dG9fYXJ5KX07XG4gICAgICAgIGlmIChhcmd2ID09PSBuaWwpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICAgIH1cblxuICAgICAgICBhcmdjID0gYXJndi5sZW5ndGg7XG4gICAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnYzsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFhcmd2W2ldLiQkaXNfYXJyYXkpIGNvbnRpbnVlO1xuICAgICAgICAgIHN3aXRjaChhcmd2W2ldLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGhhc2guJHN0b3JlKGFyZ3ZbaV1bMF0sIG5pbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldWzBdLCBhcmd2W2ldWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgKCN7YGFyZ3ZbaV0ubGVuZ3RoYH0gZm9yIDEuLjIpXCJ9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdjICUgMiAhPT0gMCkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgSGFzaCd9XG4gICAgICB9XG5cbiAgICAgIGhhc2ggPSAje2FsbG9jYXRlfTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ2M7IGkgKz0gMikge1xuICAgICAgICBoYXNoLiRzdG9yZShhcmd2W2ldLCBhcmd2W2kgKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYuYWxsb2NhdGVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjb25zdHJ1Y3RvcigpO1xuXG4gICAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcblxuICAgICAgaGFzaC4kJG5vbmUgPSBuaWw7XG4gICAgICBoYXNoLiQkcHJvYyA9IG5pbDtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi50cnlfY29udmVydChvYmopXG4gICAgT3BhbC5jb2VyY2VfdG8/KG9iaiwgSGFzaCwgOnRvX2hhc2gpXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGRlZmF1bHRzID0gdW5kZWZpbmVkLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCAmJiBibG9jayAhPT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3dyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKDEgZm9yIDApJ31cbiAgICAgIH1cbiAgICAgIHNlbGYuJCRub25lID0gKGRlZmF1bHRzID09PSB1bmRlZmluZWQgPyBuaWwgOiBkZWZhdWx0cyk7XG4gICAgICBzZWxmLiQkcHJvYyA9IGJsb2NrO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvdGhlci4kJGlzX2hhc2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoICE9PSBvdGhlci4kJGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0gb3RoZXIuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgb3RoZXJfdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KG90aGVyLCBrZXkua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdGhlcl92YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF2YWx1ZVsnJGVxbD8nXShvdGhlcl92YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDwgb3RoZXIuJCRrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQgPSB0cnVlXG5cbiAgICBvdGhlci5lYWNoIGRvIHxvdGhlcl9rZXksIG90aGVyX3ZhbHxcbiAgICAgIHZhbCA9IGZldGNoKG90aGVyX2tleSwgYG51bGxgKVxuXG4gICAgICAleHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCAhPT0gb3RoZXJfdmFsKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICByZXN1bHRcbiAgZW5kXG5cbiAgZGVmID4ob3RoZXIpXG4gICAgb3RoZXIgPSBPcGFsLmNvZXJjZV90byEob3RoZXIsIEhhc2gsIDp0b19oYXNoKVxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGtleXMubGVuZ3RoIDw9IG90aGVyLiQka2V5cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZiA+PSBvdGhlclxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPiBzZWxmXG4gIGVuZFxuXG4gIGRlZiA8PShvdGhlcilcbiAgICBvdGhlciA9IE9wYWwuY29lcmNlX3RvIShvdGhlciwgSGFzaCwgOnRvX2hhc2gpXG4gICAgb3RoZXIgPj0gc2VsZlxuICBlbmRcblxuICBkZWYgW10oa2V5KVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmLiRkZWZhdWx0KGtleSk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgW109KGtleSwgdmFsdWUpXG4gICAgJXh7XG4gICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGFzc29jKG9iamVjdClcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBpZiAoI3tga2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgc2VsZi4kJHNtYXBba2V5XV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgje2BrZXkua2V5YCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgICByZXR1cm4gW2tleS5rZXksIGtleS52YWx1ZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xlYXJcbiAgICAleHtcbiAgICAgIE9wYWwuaGFzaF9pbml0KHNlbGYpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2xvbmVcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gbmV3IHNlbGYuJCRjbGFzcygpO1xuXG4gICAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcbiAgICAgIE9wYWwuaGFzaF9jbG9uZShzZWxmLCBoYXNoKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY29tcGFjdFxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSBuaWwpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhY3QhXG4gICAgJXh7XG4gICAgICB2YXIgY2hhbmdlc193ZXJlX21hZGUgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoYW5nZXNfd2VyZV9tYWRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhbmdlc193ZXJlX21hZGUgPyBzZWxmIDogbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvbXBhcmVfYnlfaWRlbnRpdHlcbiAgICAleHtcbiAgICAgIHZhciBpLCBpaSwga2V5LCBrZXlzID0gc2VsZi4kJGtleXMsIGlkZW50aXR5X2hhc2g7XG5cbiAgICAgIGlmIChzZWxmLiQkYnlfaWRlbnRpdHkpIHJldHVybiBzZWxmO1xuICAgICAgaWYgKHNlbGYuJCRrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkYnlfaWRlbnRpdHkgPSB0cnVlXG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICBpZGVudGl0eV9oYXNoID0gI3sge30uY29tcGFyZV9ieV9pZGVudGl0eSB9O1xuICAgICAgZm9yKGkgPSAwLCBpaSA9IGtleXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoIWtleS4kJGlzX3N0cmluZykga2V5ID0ga2V5LmtleTtcbiAgICAgICAgT3BhbC5oYXNoX3B1dChpZGVudGl0eV9oYXNoLCBrZXksIE9wYWwuaGFzaF9nZXQoc2VsZiwga2V5KSk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuJCRieV9pZGVudGl0eSA9IHRydWU7XG4gICAgICBzZWxmLiQkbWFwID0gaWRlbnRpdHlfaGFzaC4kJG1hcDtcbiAgICAgIHNlbGYuJCRzbWFwID0gaWRlbnRpdHlfaGFzaC4kJHNtYXA7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjb21wYXJlX2J5X2lkZW50aXR5P1xuICAgIGBzZWxmLiQkYnlfaWRlbnRpdHkgPT09IHRydWVgXG4gIGVuZFxuXG4gIGRlZiBkZWZhdWx0KGtleSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiBzZWxmLiQkcHJvYyAhPT0gbmlsICYmIHNlbGYuJCRwcm9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuJCRwcm9jLiRjYWxsKHNlbGYsIGtleSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi4kJG5vbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGYuJCRub25lO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHQ9KG9iamVjdClcbiAgICAleHtcbiAgICAgIHNlbGYuJCRwcm9jID0gbmlsO1xuICAgICAgc2VsZi4kJG5vbmUgPSBvYmplY3Q7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZGVmYXVsdF9wcm9jXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJHByb2MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gc2VsZi4kJHByb2M7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRlZmF1bHRfcHJvYz0oZGVmYXVsdF9wcm9jKVxuICAgICV4e1xuICAgICAgdmFyIHByb2MgPSBkZWZhdWx0X3Byb2M7XG5cbiAgICAgIGlmIChwcm9jICE9PSBuaWwpIHtcbiAgICAgICAgcHJvYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGBwcm9jYCwgUHJvYywgOnRvX3Byb2MpfTtcblxuICAgICAgICBpZiAoI3tgcHJvY2AubGFtYmRhP30gJiYgI3tgcHJvY2AuYXJpdHkuYWJzfSAhPT0gMikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCAnZGVmYXVsdF9wcm9jIHRha2VzIHR3byBhcmd1bWVudHMnfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLiQkbm9uZSA9IG5pbDtcbiAgICAgIHNlbGYuJCRwcm9jID0gcHJvYztcblxuICAgICAgcmV0dXJuIGRlZmF1bHRfcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGUoa2V5LCAmYmxvY2spXG4gICAgJXh7XG4gICAgICB2YXIgdmFsdWUgPSBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJsb2NrICE9PSBuaWwpIHtcbiAgICAgICAgcmV0dXJuICN7eWllbGQga2V5fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBkZWxldGVfaWYoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZGVsZXRlX2lmKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBpZiAoT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGR1cCBjbG9uZVxuXG4gIGRlZiBkaWcoa2V5LCAqa2V5cylcbiAgICBpdGVtID0gc2VsZltrZXldXG5cbiAgICAleHtcbiAgICAgIGlmIChpdGVtID09PSBuaWwgfHwga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5sZXNzIGl0ZW0ucmVzcG9uZF90bz8oOmRpZylcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje2l0ZW0uY2xhc3N9IGRvZXMgbm90IGhhdmUgI2RpZyBtZXRob2RcIlxuICAgIGVuZFxuXG4gICAgaXRlbS5kaWcoKmtleXMpXG4gIGVuZFxuXG4gIGRlZiBlYWNoKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2gpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIFtrZXksIHZhbHVlXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfa2V5KCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfa2V5KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgYmxvY2soa2V5LiQkaXNfc3RyaW5nID8ga2V5IDoga2V5LmtleSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZWFjaF9wYWlyIGVhY2hcblxuICBkZWYgZWFjaF92YWx1ZSgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3ZhbHVlKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgYmxvY2soa2V5LiQkaXNfc3RyaW5nID8gc2VsZi4kJHNtYXBba2V5XSA6IGtleS52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVtcHR5P1xuICAgIGBzZWxmLiQka2V5cy5sZW5ndGggPT09IDBgXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgZXhjZXB0KCprZXlzKVxuICAgIGR1cC5leGNlcHQhKCprZXlzKVxuICBlbmRcblxuICBkZWYgZXhjZXB0ISgqa2V5cylcbiAgICBrZXlzLmVhY2ggeyB8a2V5fCBkZWxldGUoa2V5KSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZmV0Y2goa2V5LCBkZWZhdWx0cyA9IHVuZGVmaW5lZCwgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHJldHVybiBibG9jayhrZXkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVmYXVsdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmFpc2UgS2V5RXJyb3IubmV3KFwia2V5IG5vdCBmb3VuZDogI3trZXkuaW5zcGVjdH1cIiwga2V5OiBrZXksIHJlY2VpdmVyOiBzZWxmKVxuICBlbmRcblxuICBkZWYgZmV0Y2hfdmFsdWVzKCprZXlzLCAmYmxvY2spXG4gICAga2V5cy5tYXAgeyB8a2V5fCBmZXRjaChrZXksICZibG9jaykgfVxuICBlbmRcblxuICBkZWYgZmxhdHRlbihsZXZlbCA9IDEpXG4gICAgbGV2ZWwgPSBPcGFsLmNvZXJjZV90byEobGV2ZWwsIEludGVnZXIsIDp0b19pbnQpXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLiQkaXNfYXJyYXkpIHtcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoI3tgdmFsdWVgLmZsYXR0ZW4oYGxldmVsIC0gMmApfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzX2tleT8oa2V5KVxuICAgIGBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZGBcbiAgZW5kXG5cbiAgZGVmIGhhc192YWx1ZT8odmFsdWUpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoI3tgKGtleS4kJGlzX3N0cmluZyA/IHNlbGYuJCRzbWFwW2tleV0gOiBrZXkudmFsdWUpYCA9PSB2YWx1ZX0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgICV4e1xuICAgICAgdmFyIHRvcCA9IChPcGFsLmhhc2hfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbJ0hhc2gnXSxcbiAgICAgICAgICBrZXksIGl0ZW07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBPcGFsLmhhc2hfaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChPcGFsW2hhc2hfaWRdKSB7XG4gICAgICAgICAgcmV0dXJuICdzZWxmJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoa2V5IGluIE9wYWwuaGFzaF9pZHMpIHtcbiAgICAgICAgICBpdGVtID0gT3BhbC5oYXNoX2lkc1trZXldO1xuICAgICAgICAgIGlmICgje2VxbD8oYGl0ZW1gKX0pIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VsZic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT3BhbC5oYXNoX2lkc1toYXNoX2lkXSA9IHNlbGY7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChba2V5LCBzZWxmLiQkc21hcFtrZXldLiRoYXNoKCldKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW2tleS5rZXlfaGFzaCwga2V5LnZhbHVlLiRoYXNoKCldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LnNvcnQoKS5qb2luKCk7XG5cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0b3ApIHtcbiAgICAgICAgICBPcGFsLmhhc2hfaWRzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbmNsdWRlPyBoYXNfa2V5P1xuXG4gIGRlZiBpbmRleChvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGluZGV4ZXMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGFyZ3NbaV07XG4gICAgICAgIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goI3tkZWZhdWx0fSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBpbmRpY2VzIGluZGV4ZXNcblxuICBgdmFyIGluc3BlY3RfaWRzYFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgJXh7XG4gICAgICB2YXIgdG9wID0gKGluc3BlY3RfaWRzID09PSB1bmRlZmluZWQpLFxuICAgICAgICAgIGhhc2hfaWQgPSBzZWxmLiRvYmplY3RfaWQoKSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRvcCkge1xuICAgICAgICAgIGluc3BlY3RfaWRzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zcGVjdF9pZHMuaGFzT3duUHJvcGVydHkoaGFzaF9pZCkpIHtcbiAgICAgICAgICByZXR1cm4gJ3suLi59JztcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3BlY3RfaWRzW2hhc2hfaWRdID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS4kaW5zcGVjdCgpICsgJz0+JyArIHZhbHVlLiRpbnNwZWN0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICd7JyArIHJlc3VsdC5qb2luKCcsICcpICsgJ30nO1xuXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgaW5zcGVjdF9pZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnZlcnRcbiAgICAleHtcbiAgICAgIHZhciBoYXNoID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIHZhbHVlLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFzaDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBrZWVwX2lmKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmtlZXBfaWYpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIGlmIChPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMga2V5IGluZGV4XG5cbiAgYWxpYXMga2V5PyBoYXNfa2V5P1xuXG4gIGRlZiBrZXlzXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleS5rZXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgYHNlbGYuJCRrZXlzLmxlbmd0aGBcbiAgZW5kXG5cbiAgYWxpYXMgbWVtYmVyPyBoYXNfa2V5P1xuXG4gIGRlZiBtZXJnZSgqb3RoZXJzLCAmYmxvY2spXG4gICAgZHVwLm1lcmdlISgqb3RoZXJzLCAmYmxvY2spXG4gIGVuZFxuXG4gIGRlZiBtZXJnZSEoKm90aGVycywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgdmFyIGksIGosIG90aGVyLCBvdGhlcl9rZXlzLCBsZW5ndGgsIGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG90aGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdGhlciA9ICN7T3BhbC5jb2VyY2VfdG8hKGBvdGhlcnNbaV1gLCBIYXNoLCA6dG9faGFzaCl9O1xuICAgICAgICBvdGhlcl9rZXlzID0gb3RoZXIuJCRrZXlzLCBsZW5ndGggPSBvdGhlcl9rZXlzLmxlbmd0aDtcblxuICAgICAgICBpZiAoYmxvY2sgPT09IG5pbCkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tqXTtcblxuICAgICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwga2V5LCBvdGhlcl92YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAga2V5ID0gb3RoZXJfa2V5c1tqXTtcblxuICAgICAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3RoZXJfdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gT3BhbC5oYXNoX2dldChzZWxmLCBrZXkpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT3BhbC5oYXNoX3B1dChzZWxmLCBrZXksIGJsb2NrKGtleSwgdmFsdWUsIG90aGVyX3ZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJhc3NvYyhvYmplY3QpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7YHZhbHVlYCA9PSBvYmplY3R9KSB7XG4gICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmlsO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlaGFzaFxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX3JlaGFzaChzZWxmKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHJlamVjdCgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgaGFzaCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb2JqOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmogPSBibG9jayhrZXksIHZhbHVlKTtcblxuICAgICAgICBpZiAob2JqID09PSBmYWxzZSB8fCBvYmogPT09IG5pbCkge1xuICAgICAgICAgIE9wYWwuaGFzaF9wdXQoaGFzaCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgcmVqZWN0ISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDpyZWplY3QhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGNoYW5nZXNfd2VyZV9tYWRlID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogIT09IGZhbHNlICYmIG9iaiAhPT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGFuZ2VzX3dlcmVfbWFkZSA9IHRydWU7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYW5nZXNfd2VyZV9tYWRlID8gc2VsZiA6IG5pbDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiByZXBsYWNlKG90aGVyKVxuICAgIG90aGVyID0gT3BhbC5jb2VyY2VfdG8hKG90aGVyLCBIYXNoLCA6dG9faGFzaClcblxuICAgICV4e1xuICAgICAgT3BhbC5oYXNoX2luaXQoc2VsZik7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBvdGhlcl9rZXlzID0gb3RoZXIuJCRrZXlzLCBsZW5ndGggPSBvdGhlcl9rZXlzLmxlbmd0aCwga2V5LCB2YWx1ZSwgb3RoZXJfdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBvdGhlcl9rZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICBvdGhlcl92YWx1ZSA9IG90aGVyLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyX3ZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgb3RoZXJfdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIG90aGVyLmRlZmF1bHRfcHJvY1xuICAgICAgc2VsZi5kZWZhdWx0X3Byb2MgPSBvdGhlci5kZWZhdWx0X3Byb2NcbiAgICBlbHNlXG4gICAgICBzZWxmLmRlZmF1bHQgPSBvdGhlci5kZWZhdWx0XG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBzZWxlY3QoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0KSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIGhhc2ggPSBPcGFsLmhhc2goKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG9iajsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gYmxvY2soa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG9iaiAhPT0gZmFsc2UgJiYgb2JqICE9PSBuaWwpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KGhhc2gsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXNoO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGVjdCEoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6c2VsZWN0ISkgeyBzaXplIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBuaWw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlLCBvYmo7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IGJsb2NrKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIGlmIChvYmogPT09IGZhbHNlIHx8IG9iaiA9PT0gbmlsKSB7XG4gICAgICAgICAgaWYgKE9wYWwuaGFzaF9kZWxldGUoc2VsZiwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gc2VsZjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmlsdGVyIHNlbGVjdFxuICBhbGlhcyBmaWx0ZXIhIHNlbGVjdCFcblxuICBkZWYgc2hpZnRcbiAgICAleHtcbiAgICAgIHZhciBrZXlzID0gc2VsZi4kJGtleXMsXG4gICAgICAgICAga2V5O1xuXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGtleSA9IGtleXNbMF07XG5cbiAgICAgICAga2V5ID0ga2V5LiQkaXNfc3RyaW5nID8ga2V5IDoga2V5LmtleTtcblxuICAgICAgICByZXR1cm4gW2tleSwgT3BhbC5oYXNoX2RlbGV0ZShzZWxmLCBrZXkpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuJGRlZmF1bHQobmlsKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgZGVmIHNsaWNlKCprZXlzKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXSwgdmFsdWUgPSBPcGFsLmhhc2hfZ2V0KHNlbGYsIGtleSk7XG5cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBPcGFsLmhhc2hfcHV0KHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHN0b3JlIFtdPVxuXG4gIGRlZiB0b19hXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRvX2goJmJsb2NrKVxuICAgIHJldHVybiBtYXAoJmJsb2NrKS50b19oIGlmIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZi4kJGNsYXNzID09PSBPcGFsLkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNoID0gbmV3IE9wYWwuSGFzaCgpO1xuXG4gICAgICBPcGFsLmhhc2hfaW5pdChoYXNoKTtcbiAgICAgIE9wYWwuaGFzaF9jbG9uZShzZWxmLCBoYXNoKTtcblxuICAgICAgcmV0dXJuIGhhc2g7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdG9faGFzaFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX3Byb2NcbiAgICBwcm9jIGRvIHxrZXkgPSB1bmRlZmluZWR8XG4gICAgICAleHtcbiAgICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnbm8ga2V5IGdpdmVuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmW2tleV1cbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgdG9fcyBpbnNwZWN0XG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV9rZXlzKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IE9wYWwuaGFzaCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCB2YWx1ZTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYgKGtleS4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHZhbHVlID0gc2VsZi4kJHNtYXBba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGtleS52YWx1ZTtcbiAgICAgICAgICBrZXkgPSBrZXkua2V5O1xuICAgICAgICB9XG5cbiAgICAgICAga2V5ID0gT3BhbC55aWVsZDEoYmxvY2ssIGtleSk7XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV9rZXlzISgmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0cmFuc2Zvcm1fa2V5cyEpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIga2V5cyA9IE9wYWwuc2xpY2UuY2FsbChzZWxmLiQka2V5cyksXG4gICAgICAgICAgaSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWUsIG5ld19rZXk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld19rZXkgPSBPcGFsLnlpZWxkMShibG9jaywga2V5KTtcblxuICAgICAgICBPcGFsLmhhc2hfZGVsZXRlKHNlbGYsIGtleSk7XG4gICAgICAgIE9wYWwuaGFzaF9wdXQoc2VsZiwgbmV3X2tleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiB0cmFuc2Zvcm1fdmFsdWVzKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMpIHsgc2l6ZSB9IHVubGVzcyBibG9ja1xuXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gT3BhbC5oYXNoKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBrZXlzID0gc2VsZi4kJGtleXMsIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIHZhbHVlOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgdmFsdWUgPSBzZWxmLiQkc21hcFtrZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0ga2V5LnZhbHVlO1xuICAgICAgICAgIGtleSA9IGtleS5rZXk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IE9wYWwueWllbGQxKGJsb2NrLCB2YWx1ZSk7XG5cbiAgICAgICAgT3BhbC5oYXNoX3B1dChyZXN1bHQsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHRyYW5zZm9ybV92YWx1ZXMhKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOnRyYW5zZm9ybV92YWx1ZXMhKSB7IHNpemUgfSB1bmxlc3MgYmxvY2tcblxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBzZWxmLiQka2V5cywgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwgdmFsdWU7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmIChrZXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNlbGYuJCRzbWFwW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBrZXkudmFsdWU7XG4gICAgICAgICAga2V5ID0ga2V5LmtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gT3BhbC55aWVsZDEoYmxvY2ssIHZhbHVlKTtcblxuICAgICAgICBPcGFsLmhhc2hfcHV0KHNlbGYsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHVwZGF0ZSBtZXJnZSFcblxuICBhbGlhcyB2YWx1ZT8gaGFzX3ZhbHVlP1xuXG4gIGFsaWFzIHZhbHVlc19hdCBpbmRleGVzXG5cbiAgZGVmIHZhbHVlc1xuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwga2V5cyA9IHNlbGYuJCRrZXlzLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5OyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiAoa2V5LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi4kJHNtYXBba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6SGFzaD4iLCJpbmNsdWRlIiwiRW51bWVyYWJsZSIsIltdIiwiT3BhbCIsImNvZXJjZV90bz8iLCJhcmd2IiwiMCIsIkhhc2giLCJhbGxvY2F0ZSIsIm1lcmdlISIsIkFycmF5IiwicmFpc2UiLCJBcmd1bWVudEVycm9yIiwidHJ5X2NvbnZlcnQiLCJvYmoiLCJpbml0aWFsaXplIiwiZGVmYXVsdHMiLCI9PSIsIm90aGVyIiwiPj0iLCJjb2VyY2VfdG8hIiwicmVzdWx0IiwiZWFjaCIsImJsb2NrIGluID49Iiwib3RoZXJfa2V5Iiwib3RoZXJfdmFsIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA+PSIsInZhbCIsImZldGNoIiwiPiIsIjwiLCI8PSIsImtleSIsIltdPSIsInZhbHVlIiwiYXNzb2MiLCJvYmplY3QiLCJjbGVhciIsImNsb25lIiwiY29tcGFjdCIsImNvbXBhY3QhIiwiY29tcGFyZV9ieV9pZGVudGl0eSIsImNvbXBhcmVfYnlfaWRlbnRpdHk/IiwiZGVmYXVsdCIsImRlZmF1bHQ9IiwiZGVmYXVsdF9wcm9jIiwiZGVmYXVsdF9wcm9jPSIsIlByb2MiLCJsYW1iZGE/IiwiYXJpdHkiLCJhYnMiLCJUeXBlRXJyb3IiLCJkZWxldGUiLCJkZWxldGVfaWYiLCJibG9jayIsImVudW1fZm9yIiwiYmxvY2sgaW4gZGVsZXRlX2lmIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBkZWxldGVfaWYiLCJzaXplIiwiZGlnIiwiaXRlbSIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCJrZXlzIiwiYmxvY2sgaW4gZWFjaCIsImJsb2NrICgyIGxldmVscykgaW4gZWFjaCIsImVhY2hfa2V5IiwiYmxvY2sgaW4gZWFjaF9rZXkiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfa2V5IiwiZWFjaF92YWx1ZSIsImJsb2NrIGluIGVhY2hfdmFsdWUiLCJibG9jayAoMiBsZXZlbHMpIGluIGVhY2hfdmFsdWUiLCJlbXB0eT8iLCJleGNlcHQiLCJleGNlcHQhIiwiZHVwIiwiYmxvY2sgaW4gZXhjZXB0ISIsImJsb2NrICgyIGxldmVscykgaW4gZXhjZXB0ISIsIktleUVycm9yIiwibmV3IiwiaW5zcGVjdCIsImZldGNoX3ZhbHVlcyIsIm1hcCIsImJsb2NrIGluIGZldGNoX3ZhbHVlcyIsImJsb2NrICgyIGxldmVscykgaW4gZmV0Y2hfdmFsdWVzIiwidG9fcHJvYyIsImZsYXR0ZW4iLCJsZXZlbCIsIjEiLCJJbnRlZ2VyIiwiaGFzX2tleT8iLCJoYXNfdmFsdWU/IiwiaGFzaCIsImVxbD8iLCJpbmRleCIsImluZGV4ZXMiLCJpbnZlcnQiLCJrZWVwX2lmIiwiYmxvY2sgaW4ga2VlcF9pZiIsImJsb2NrICgyIGxldmVscykgaW4ga2VlcF9pZiIsImxlbmd0aCIsIm1lcmdlIiwib3RoZXJzIiwicmFzc29jIiwicmVoYXNoIiwicmVqZWN0IiwiYmxvY2sgaW4gcmVqZWN0IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByZWplY3QiLCJyZWplY3QhIiwiYmxvY2sgaW4gcmVqZWN0ISIsImJsb2NrICgyIGxldmVscykgaW4gcmVqZWN0ISIsInJlcGxhY2UiLCIkd3JpdGVyIiwiLSIsInNlbGVjdCIsImJsb2NrIGluIHNlbGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gc2VsZWN0Iiwic2VsZWN0ISIsImJsb2NrIGluIHNlbGVjdCEiLCJibG9jayAoMiBsZXZlbHMpIGluIHNlbGVjdCEiLCJzaGlmdCIsInNsaWNlIiwidG9fYSIsInRvX2giLCJibG9ja19naXZlbj8iLCJ0b19oYXNoIiwicHJvYyIsImJsb2NrIGluIHRvX3Byb2MiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX3Byb2MiLCJ0cmFuc2Zvcm1fa2V5cyIsImJsb2NrIGluIHRyYW5zZm9ybV9rZXlzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fa2V5cyIsInRyYW5zZm9ybV9rZXlzISIsImJsb2NrIGluIHRyYW5zZm9ybV9rZXlzISIsImJsb2NrICgyIGxldmVscykgaW4gdHJhbnNmb3JtX2tleXMhIiwidHJhbnNmb3JtX3ZhbHVlcyIsImJsb2NrIGluIHRyYW5zZm9ybV92YWx1ZXMiLCJibG9jayAoMiBsZXZlbHMpIGluIHRyYW5zZm9ybV92YWx1ZXMiLCJ0cmFuc2Zvcm1fdmFsdWVzISIsImJsb2NrIGluIHRyYW5zZm9ybV92YWx1ZXMhIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB0cmFuc2Zvcm1fdmFsdWVzISIsInZhbHVlcyJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBVUFGLE9BQUFHO0VBQUFBOztJQUFBQTs7O0lBQ0VGLElBQUFHLFNBQUFBLENBQVFDLDBCQUFSRDtJQUdDRDtJQUVERyxVQUFJTCxJQUFKSyxTQUFBQSxhQUFBQSxTQWhCRixFQWdCRUE7QUFBQUEsTUFBQUE7Ozs7TUFoQkY7O01BZ0JjOztBQUVkQTs7QUFFQUE7QUFDQUEsZUFBaUJDLG9CQUFJQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxDQUFDSSxDQUFESixDQUFwQixFQUF5Qkssb0JBQXpCLEVBQStCLFNBQTNCSCxDQUFxQ0Y7QUFDMURBO0FBQ0FBLGlCQUFtQkwsSUFBQVcsVUFBQUEsQ0FBQUEsQ0FBUUMsV0FBQUEsQ0FBU1AsSUFBVE8sQ0FBZ0JQO0FBQzNDQTs7QUFFQUEsZUFBaUJDLG9CQUFJQyxlQUFBQSxDQUFZQyxJQUFJSCxPQUFBQSxDQUFDSSxDQUFESixD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QSxhQUFNLFFBQU4sRUFBYSxZQUFiO0lBRUEsYUFBTSxXQUFOLEVBQWdCLFNBQWhCO0lBRUEzSSxPQUFBOEksQ0FBQUEsMEJBQUFBLGtCQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtJQWZFQSxDQUFBQSw2QkFBQUEsQ0FBQUE7RUFycUNGOUksR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFWQUg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE3MjY0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9udW1iZXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBOdW1iZXIgPCBOdW1lcmljXG4gIE9wYWwuYnJpZGdlKGBOdW1iZXJgLCBzZWxmKVxuICBgT3BhbC5kZWZpbmVQcm9wZXJ0eShzZWxmLiQkcHJvdG90eXBlLCAnJCRpc19udW1iZXInLCB0cnVlKWBcbiAgYHNlbGYuJCRpc19udW1iZXJfY2xhc3MgPSB0cnVlYFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgYWxsb2NhdGVcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJhbGxvY2F0b3IgdW5kZWZpbmVkIGZvciAje25hbWV9XCJcbiAgICBlbmRcblxuICAgIHVuZGVmIDpuZXdcbiAgZW5kXG5cbiAgZGVmIGNvZXJjZShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlciA9PT0gbmlsKSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tvdGhlci5jbGFzc30gaW50byBGbG9hdFwifTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG90aGVyLiQkaXNfc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBbI3tGbG9hdChvdGhlcil9LCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8oOnRvX2YpfSkge1xuICAgICAgICByZXR1cm4gWyN7T3BhbC5jb2VyY2VfdG8hKG90aGVyLCBGbG9hdCwgOnRvX2YpfSwgc2VsZl07XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gW290aGVyLCBzZWxmXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7b3RoZXIuY2xhc3N9IGludG8gRmxvYXRcIn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgX19pZF9fXG4gICAgYChzZWxmICogMikgKyAxYFxuICBlbmRcblxuICBhbGlhcyBvYmplY3RfaWQgX19pZF9fXG5cbiAgZGVmICsob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6LSwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmICoob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgKiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Kiwgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIC8ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgLyBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6Lywgb3RoZXJ9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgZmRpdiAvXG5cbiAgZGVmICUob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBaZXJvRGl2aXNpb25FcnJvciwgJ2RpdmlkZWQgYnkgMCd9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyIDwgMCB8fCBzZWxmIDwgMCkge1xuICAgICAgICAgIHJldHVybiAoc2VsZiAlIG90aGVyICsgb3RoZXIpICUgb3RoZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYgJSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDolLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgJihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiAmIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDomLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgfChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiB8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDp8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgXihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiBeIG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDpeLCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPChvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA8IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo8LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPD0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOjw9LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPihvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZiA+IG90aGVyO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAje19fY29lcmNlZF9fIDo+LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgPj0ob3RoZXIpXG4gICAgJXh7XG4gICAgICBpZiAob3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYgPj0gb3RoZXI7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICN7X19jb2VyY2VkX18gOj49LCBvdGhlcn07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICAjIENvbXB1dGUgdGhlIHJlc3VsdCBvZiB0aGUgc3BhY2VzaGlwIG9wZXJhdG9yIGluc2lkZSBpdHMgb3duIGZ1bmN0aW9uIHNvIGl0XG4gICMgY2FuIGJlIG9wdGltaXplZCBkZXNwaXRlIGEgdHJ5L2ZpbmFsbHkgY29uc3RydWN0LlxuICAleHtcbiAgICB2YXIgc3BhY2VzaGlwX29wZXJhdG9yID0gZnVuY3Rpb24oc2VsZiwgb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoaXNOYU4oc2VsZikgfHwgaXNOYU4ob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmID4gb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxmIDwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tfX2NvZXJjZWRfXyA6PD0+LCBgb3RoZXJgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGBzcGFjZXNoaXBfb3BlcmF0b3Ioc2VsZiwgb3RoZXIpYFxuICByZXNjdWUgQXJndW1lbnRFcnJvclxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgPDwoY291bnQpXG4gICAgY291bnQgPSBPcGFsLmNvZXJjZV90byEgY291bnQsIEludGVnZXIsIDp0b19pbnRcblxuICAgIGAje2NvdW50fSA+IDAgPyBzZWxmIDw8ICN7Y291bnR9IDogc2VsZiA+PiAtI3tjb3VudH1gXG4gIGVuZFxuXG4gIGRlZiA+Pihjb3VudClcbiAgICBjb3VudCA9IE9wYWwuY29lcmNlX3RvISBjb3VudCwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgYCN7Y291bnR9ID4gMCA/IHNlbGYgPj4gI3tjb3VudH0gOiBzZWxmIDw8IC0je2NvdW50fWBcbiAgZW5kXG5cbiAgZGVmIFtdKGJpdClcbiAgICBiaXQgPSBPcGFsLmNvZXJjZV90byEgYml0LCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICAleHtcbiAgICAgIGlmICgje2JpdH0gPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKCN7Yml0fSA+PSAzMikge1xuICAgICAgICByZXR1cm4gI3sgc2VsZiB9IDwgMCA/IDEgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzZWxmID4+ICN7Yml0fSkgJiAxO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmICtAXG4gICAgYCtzZWxmYFxuICBlbmRcblxuICBkZWYgLUBcbiAgICBgLXNlbGZgXG4gIGVuZFxuXG4gIGRlZiB+XG4gICAgYH5zZWxmYFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmICEoSW50ZWdlciA9PT0gc2VsZikgfHwgb3RoZXIgPiAwXG4gICAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKSoqb3RoZXJcbiAgICAgIGVuZFxuICAgIGVsc2lmIHNlbGYgPCAwICYmIChGbG9hdCA9PT0gb3RoZXIgfHwgUmF0aW9uYWwgPT09IG90aGVyKVxuICAgICAgQ29tcGxleC5uZXcoc2VsZiwgMCkqKm90aGVyLnRvX2ZcbiAgICBlbHNpZiBgb3RoZXIuJCRpc19udW1iZXIgIT0gbnVsbGBcbiAgICAgIGBNYXRoLnBvdyhzZWxmLCBvdGhlcilgXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOioqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT09KG90aGVyKVxuICAgICV4e1xuICAgICAgaWYgKG90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoI3tvdGhlci5yZXNwb25kX3RvPyA6PT19KSB7XG4gICAgICAgIHJldHVybiAje290aGVyID09IHNlbGZ9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICAleHtcbiAgICAgIGlmIChvdGhlci4kJGlzX251bWJlcikge1xuICAgICAgICByZXR1cm4gc2VsZi52YWx1ZU9mKCkgPT09IG90aGVyLnZhbHVlT2YoKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKCN7b3RoZXIucmVzcG9uZF90bz8gOj09fSkge1xuICAgICAgICByZXR1cm4gI3tvdGhlciA9PSBzZWxmfTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYWJzXG4gICAgYE1hdGguYWJzKHNlbGYpYFxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIGBNYXRoLmFicyhzZWxmICogc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBhbGxiaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IG1hc2tgXG4gIGVuZFxuXG4gIGRlZiBhbnliaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spICE9PSAwYFxuICBlbmRcblxuICBkZWYgYW5nbGVcbiAgICByZXR1cm4gc2VsZiBpZiBuYW4/XG5cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IDApIHtcbiAgICAgICAgaWYgKDEgLyBzZWxmID4gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzZWxmIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGFyZyBhbmdsZVxuICBhbGlhcyBwaGFzZSBhbmdsZVxuXG4gIGRlZiBiaXRfbGVuZ3RoXG4gICAgdW5sZXNzIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHJhaXNlIE5vTWV0aG9kRXJyb3IubmV3KFwidW5kZWZpbmVkIG1ldGhvZCBgYml0X2xlbmd0aGAgZm9yICN7c2VsZn06RmxvYXRcIiwgJ2JpdF9sZW5ndGgnKVxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoc2VsZiA9PT0gMCB8fCBzZWxmID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgdmFsdWUgID0gc2VsZiA8IDAgPyB+c2VsZiA6IHNlbGY7XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPSAwKSB7XG4gICAgICAgIHJlc3VsdCAgICs9IDE7XG4gICAgICAgIHZhbHVlICA+Pj49IDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2VpbChuZGlnaXRzID0gMClcbiAgICAleHtcbiAgICAgIHZhciBmID0gI3t0b19mfTtcblxuICAgICAgaWYgKGYgJSAxID09PSAwICYmIG5kaWdpdHMgPj0gMCkge1xuICAgICAgICByZXR1cm4gZjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KDEwLCBuZGlnaXRzKSxcbiAgICAgICAgICByZXN1bHQgPSBNYXRoLmNlaWwoZiAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCkge1xuICAgICAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hyKGVuY29kaW5nID0gdW5kZWZpbmVkKVxuICAgIGBPcGFsLmVuYyhTdHJpbmcuZnJvbUNoYXJDb2RlKHNlbGYpLCBlbmNvZGluZyB8fCBcIkJJTkFSWVwiKWBcbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgIDFcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgZG93bnRvKHN0b3AsICZibG9jaylcbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOmRvd250bywgc3RvcCkgZG9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyBOdW1lcmljID09PSBzdG9wXG4gICAgICAgIHN0b3AgPiBzZWxmID8gMCA6IHNlbGYgLSBzdG9wICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghc3RvcC4kJGlzX251bWJlcikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIn1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzZWxmOyBpID49IHN0b3A7IGktLSkge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGFsaWFzIGVxbD8gPT1cblxuICBkZWYgZXF1YWw/KG90aGVyKVxuICAgIHNlbGYgPT0gb3RoZXIgfHwgYGlzTmFOKHNlbGYpICYmIGlzTmFOKG90aGVyKWBcbiAgZW5kXG5cbiAgZGVmIGV2ZW4/XG4gICAgYHNlbGYgJSAyID09PSAwYFxuICBlbmRcblxuICBkZWYgZmxvb3IobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gTWF0aC5mbG9vcihmICogZmFjdG9yKSAvIGZhY3RvcjtcblxuICAgICAgaWYgKGYgJSAxID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnY2Qob3RoZXIpXG4gICAgdW5sZXNzIEludGVnZXIgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIG1pbiA9IE1hdGguYWJzKHNlbGYpLFxuICAgICAgICAgIG1heCA9IE1hdGguYWJzKG90aGVyKTtcblxuICAgICAgd2hpbGUgKG1pbiA+IDApIHtcbiAgICAgICAgdmFyIHRtcCA9IG1pbjtcblxuICAgICAgICBtaW4gPSBtYXggJSBtaW47XG4gICAgICAgIG1heCA9IHRtcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnY2RsY20ob3RoZXIpXG4gICAgW2djZChvdGhlciksIGxjbShvdGhlcildXG4gIGVuZFxuXG4gIGRlZiBpbnRlZ2VyP1xuICAgIGBzZWxmICUgMSA9PT0gMGBcbiAgZW5kXG5cbiAgZGVmIGlzX2E/KGtsYXNzKVxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEludGVnZXIgJiYgSW50ZWdlciA9PT0gc2VsZlxuICAgIHJldHVybiB0cnVlIGlmIGtsYXNzID09IEZsb2F0ICYmIEZsb2F0ID09PSBzZWxmXG5cbiAgICBzdXBlclxuICBlbmRcblxuICBhbGlhcyBraW5kX29mPyBpc19hP1xuXG4gIGRlZiBpbnN0YW5jZV9vZj8oa2xhc3MpXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gSW50ZWdlciAmJiBJbnRlZ2VyID09PSBzZWxmXG4gICAgcmV0dXJuIHRydWUgaWYga2xhc3MgPT0gRmxvYXQgJiYgRmxvYXQgPT09IHNlbGZcblxuICAgIHN1cGVyXG4gIGVuZFxuXG4gIGRlZiBsY20ob3RoZXIpXG4gICAgdW5sZXNzIEludGVnZXIgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYW4gaW50ZWdlcidcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCB8fCBvdGhlciA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyhzZWxmICogb3RoZXIgLyAje2djZChvdGhlcil9KTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIG1hZ25pdHVkZSBhYnNcblxuICBhbGlhcyBtb2R1bG8gJVxuXG4gIGRlZiBuZXh0XG4gICAgYHNlbGYgKyAxYFxuICBlbmRcblxuICBkZWYgbm9iaXRzPyhtYXNrKVxuICAgIG1hc2sgPSBPcGFsLmNvZXJjZV90byEgbWFzaywgSW50ZWdlciwgOnRvX2ludFxuICAgIGAoc2VsZiAmIG1hc2spID09IDBgXG4gIGVuZFxuXG4gIGRlZiBub256ZXJvP1xuICAgIGBzZWxmID09IDAgPyBuaWwgOiBzZWxmYFxuICBlbmRcblxuICBkZWYgbnVtZXJhdG9yXG4gICAgaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgIHNlbGZcbiAgICBlbHNlXG4gICAgICBzdXBlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgb2RkP1xuICAgIGBzZWxmICUgMiAhPT0gMGBcbiAgZW5kXG5cbiAgZGVmIG9yZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHBvdyhiLCBtID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgaWYgKHNlbGYgPT0gMCkge1xuICAgICAgICAje3JhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ31cbiAgICAgIH1cblxuICAgICAgaWYgKG0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gI3tzZWxmKipifTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKCN7SW50ZWdlciA9PT0gYn0pKSB7XG4gICAgICAgICAgI3tyYWlzZSBUeXBlRXJyb3IsICdJbnRlZ2VyI3BvdygpIDJuZCBhcmd1bWVudCBub3QgYWxsb3dlZCB1bmxlc3MgYSAxc3QgYXJndW1lbnQgaXMgaW50ZWdlcid9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMXN0IGFyZ3VtZW50IGNhbm5vdCBiZSBuZWdhdGl2ZSB3aGVuIDJuZCBhcmd1bWVudCBzcGVjaWZpZWQnfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEoI3tJbnRlZ2VyID09PSBtfSkpIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ0ludGVnZXIjcG93KCkgMm5kIGFyZ3VtZW50IG5vdCBhbGxvd2VkIHVubGVzcyBhbGwgYXJndW1lbnRzIGFyZSBpbnRlZ2Vycyd9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobSA9PT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICN7KHNlbGYqKmIpICUgbX1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBwcmVkXG4gICAgYHNlbGYgLSAxYFxuICBlbmRcblxuICBkZWYgcXVvKG90aGVyKVxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIHN1cGVyXG4gICAgZWxzZVxuICAgICAgc2VsZiAvIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgSW50ZWdlciA9PT0gc2VsZlxuICAgICAgUmF0aW9uYWwubmV3KHNlbGYsIDEpXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzaWYgbmFuP1xuICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICBlbHNpZiBgZXBzID09IG51bGxgXG4gICAgICBmLCBuICA9IE1hdGguZnJleHAgc2VsZlxuICAgICAgZiAgICAgPSBNYXRoLmxkZXhwKGYsIEZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgbiAgICAtPSBGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgUmF0aW9uYWwubmV3KDIgKiBmLCAxIDw8ICgxIC0gbikpLnJhdGlvbmFsaXplKFJhdGlvbmFsLm5ldygxLCAxIDw8ICgxIC0gbikpKVxuICAgIGVsc2VcbiAgICAgIHRvX3IucmF0aW9uYWxpemUoZXBzKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgcmVtYWluZGVyKHkpXG4gICAgc2VsZiAtIHkgKiAoc2VsZiAvIHkpLnRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiByb3VuZChuZGlnaXRzID0gdW5kZWZpbmVkKVxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIGlmIGBuZGlnaXRzID09IG51bGxgXG4gICAgICAgIHJldHVybiBzZWxmXG4gICAgICBlbmRcblxuICAgICAgaWYgRmxvYXQgPT09IG5kaWdpdHMgJiYgbmRpZ2l0cy5pbmZpbml0ZT9cbiAgICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ0luZmluaXR5J1xuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSBPcGFsLmNvZXJjZV90byEobmRpZ2l0cywgSW50ZWdlciwgOnRvX2ludClcblxuICAgICAgaWYgbmRpZ2l0cyA8IEludGVnZXI6Ok1JTlxuICAgICAgICByYWlzZSBSYW5nZUVycm9yLCAnb3V0IG9mIGJvdW5kcydcbiAgICAgIGVuZFxuXG4gICAgICBpZiBgbmRpZ2l0cyA+PSAwYFxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIG5kaWdpdHMgPSAtbmRpZ2l0c1xuXG4gICAgICAleHtcbiAgICAgICAgaWYgKDAuNDE1MjQxICogbmRpZ2l0cyAtIDAuMTI1ID4gI3tzaXplfSkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGYgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgICB4ID0gTWF0aC5mbG9vcigoTWF0aC5hYnMoc2VsZikgKyBmIC8gMikgLyBmKSAqIGY7XG5cbiAgICAgICAgcmV0dXJuIHNlbGYgPCAwID8gLXggOiB4O1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGlmIG5hbj8gJiYgYG5kaWdpdHMgPT0gbnVsbGBcbiAgICAgICAgcmFpc2UgRmxvYXREb21haW5FcnJvciwgJ05hTidcbiAgICAgIGVuZFxuXG4gICAgICBuZGlnaXRzID0gT3BhbC5jb2VyY2VfdG8hKGBuZGlnaXRzIHx8IDBgLCBJbnRlZ2VyLCA6dG9faW50KVxuXG4gICAgICBpZiBuZGlnaXRzIDw9IDBcbiAgICAgICAgaWYgbmFuP1xuICAgICAgICAgIHJhaXNlIFJhbmdlRXJyb3IsICdOYU4nXG4gICAgICAgIGVsc2lmIGluZmluaXRlP1xuICAgICAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdJbmZpbml0eSdcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBuZGlnaXRzID09IDBcbiAgICAgICAgcmV0dXJuIGBNYXRoLnJvdW5kKHNlbGYpYFxuICAgICAgZWxzaWYgbmFuPyB8fCBpbmZpbml0ZT9cbiAgICAgICAgcmV0dXJuIHNlbGZcbiAgICAgIGVuZFxuXG4gICAgICBfLCBleHAgPSBNYXRoLmZyZXhwKHNlbGYpXG5cbiAgICAgIGlmIG5kaWdpdHMgPj0gKEZsb2F0OjpESUcgKyAyKSAtIChleHAgPiAwID8gZXhwIC8gNCA6IGV4cCAvIDMgLSAxKVxuICAgICAgICByZXR1cm4gc2VsZlxuICAgICAgZW5kXG5cbiAgICAgIGlmIG5kaWdpdHMgPCAtKGV4cCA+IDAgPyBleHAgLyAzICsgMSA6IGV4cCAvIDQpXG4gICAgICAgIHJldHVybiAwXG4gICAgICBlbmRcblxuICAgICAgYE1hdGgucm91bmQoc2VsZiAqIE1hdGgucG93KDEwLCBuZGlnaXRzKSkgLyBNYXRoLnBvdygxMCwgbmRpZ2l0cylgXG4gICAgZW5kXG4gIGVuZFxuXG4gIGFsaWFzIHN1Y2MgbmV4dFxuXG4gIGRlZiB0aW1lcygmYmxvY2spXG4gICAgcmV0dXJuIGVudW1fZm9yKDp0aW1lcykgeyBzZWxmIH0gdW5sZXNzIGJsb2NrXG5cbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZjsgaSsrKSB7XG4gICAgICAgIGJsb2NrKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHNlbGYgPCAwID8gTWF0aC5jZWlsKHNlbGYpIDogTWF0aC5mbG9vcihzZWxmKWBcbiAgZW5kXG5cbiAgYWxpYXMgdG9faW50IHRvX2lcblxuICBkZWYgdG9fclxuICAgIGlmIEludGVnZXIgPT09IHNlbGZcbiAgICAgIFJhdGlvbmFsLm5ldyhzZWxmLCAxKVxuICAgIGVsc2VcbiAgICAgIGYsIGUgID0gTWF0aC5mcmV4cChzZWxmKVxuICAgICAgZiAgICAgPSBNYXRoLmxkZXhwKGYsIEZsb2F0OjpNQU5UX0RJRykudG9faVxuICAgICAgZSAgICAtPSBGbG9hdDo6TUFOVF9ESUdcblxuICAgICAgKGYgKiAoRmxvYXQ6OlJBRElYKiplKSkudG9fclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgdG9fcyhiYXNlID0gMTApXG4gICAgYmFzZSA9IE9wYWwuY29lcmNlX3RvISBiYXNlLCBJbnRlZ2VyLCA6dG9faW50XG5cbiAgICBpZiBiYXNlIDwgMiB8fCBiYXNlID4gMzZcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJcbiAgICBlbmRcblxuICAgIGBzZWxmLnRvU3RyaW5nKGJhc2UpYFxuICBlbmRcblxuICBkZWYgdHJ1bmNhdGUobmRpZ2l0cyA9IDApXG4gICAgJXh7XG4gICAgICB2YXIgZiA9ICN7dG9fZn07XG5cbiAgICAgIGlmIChmICUgMSA9PT0gMCAmJiBuZGlnaXRzID49IDApIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWN0b3IgPSBNYXRoLnBvdygxMCwgbmRpZ2l0cyksXG4gICAgICAgICAgcmVzdWx0ID0gcGFyc2VJbnQoZiAqIGZhY3RvciwgMTApIC8gZmFjdG9yO1xuXG4gICAgICBpZiAoZiAlIDEgPT09IDApIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5yb3VuZChyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgaW5zcGVjdCB0b19zXG5cbiAgZGVmIGRpZ2l0cyhiYXNlID0gMTApXG4gICAgaWYgc2VsZiA8IDBcbiAgICAgIHJhaXNlIE1hdGg6OkRvbWFpbkVycm9yLCAnb3V0IG9mIGRvbWFpbidcbiAgICBlbmRcblxuICAgIGJhc2UgPSBPcGFsLmNvZXJjZV90byEgYmFzZSwgSW50ZWdlciwgOnRvX2ludFxuXG4gICAgaWYgYmFzZSA8IDJcbiAgICAgIHJhaXNlIEFyZ3VtZW50RXJyb3IsIFwiaW52YWxpZCByYWRpeCAje2Jhc2V9XCJcbiAgICBlbmRcblxuICAgICV4e1xuICAgICAgdmFyIHZhbHVlID0gc2VsZiwgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlICh2YWx1ZSAhPT0gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSAlIGJhc2UpO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHZhbHVlIC8gYmFzZSwgMTApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpdm1vZChvdGhlcilcbiAgICBpZiBuYW4/IHx8IG90aGVyLm5hbj9cbiAgICAgIHJhaXNlIEZsb2F0RG9tYWluRXJyb3IsICdOYU4nXG4gICAgZWxzaWYgaW5maW5pdGU/XG4gICAgICByYWlzZSBGbG9hdERvbWFpbkVycm9yLCAnSW5maW5pdHknXG4gICAgZWxzZVxuICAgICAgc3VwZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHVwdG8oc3RvcCwgJmJsb2NrKVxuICAgIHVubGVzcyBibG9ja19naXZlbj9cbiAgICAgIHJldHVybiBlbnVtX2Zvcig6dXB0bywgc3RvcCkgZG9cbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgXCJjb21wYXJpc29uIG9mICN7c2VsZi5jbGFzc30gd2l0aCAje3N0b3AuY2xhc3N9IGZhaWxlZFwiIHVubGVzcyBOdW1lcmljID09PSBzdG9wXG4gICAgICAgIHN0b3AgPCBzZWxmID8gMCA6IHN0b3AgLSBzZWxmICsgMVxuICAgICAgZW5kXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghc3RvcC4kJGlzX251bWJlcikge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiY29tcGFyaXNvbiBvZiAje3NlbGYuY2xhc3N9IHdpdGggI3tzdG9wLmNsYXNzfSBmYWlsZWRcIn1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSBzZWxmOyBpIDw9IHN0b3A7IGkrKykge1xuICAgICAgICBibG9jayhpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiB6ZXJvP1xuICAgIGBzZWxmID09IDBgXG4gIGVuZFxuXG4gICMgU2luY2UgYml0d2lzZSBvcGVyYXRpb25zIGFyZSAzMiBiaXQsIGRlY2xhcmUgaXQgdG8gYmUgc28uXG4gIGRlZiBzaXplXG4gICAgNFxuICBlbmRcblxuICBkZWYgbmFuP1xuICAgIGBpc05hTihzZWxmKWBcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBgc2VsZiAhPSBJbmZpbml0eSAmJiBzZWxmICE9IC1JbmZpbml0eSAmJiAhaXNOYU4oc2VsZilgXG4gIGVuZFxuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICAleHtcbiAgICAgIGlmIChzZWxmID09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiArMTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbGYgPT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHBvc2l0aXZlP1xuICAgIGBzZWxmICE9IDAgJiYgKHNlbGYgPT0gSW5maW5pdHkgfHwgMSAvIHNlbGYgPiAwKWBcbiAgZW5kXG5cbiAgZGVmIG5lZ2F0aXZlP1xuICAgIGBzZWxmID09IC1JbmZpbml0eSB8fCAxIC8gc2VsZiA8IDBgXG4gIGVuZFxuZW5kXG5cbkZpeG51bSA9IE51bWJlclxuXG5jbGFzcyBJbnRlZ2VyIDwgTnVtZXJpY1xuICBgc2VsZi4kJGlzX251bWJlcl9jbGFzcyA9IHRydWVgXG4gIGBzZWxmLiQkaXNfaW50ZWdlcl9jbGFzcyA9IHRydWVgXG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhbGxvY2F0ZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImFsbG9jYXRvciB1bmRlZmluZWQgZm9yICN7bmFtZX1cIlxuICAgIGVuZFxuXG4gICAgdW5kZWYgOm5ld1xuXG4gICAgZGVmIHNxcnQobilcbiAgICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcbiAgICAgICV4e1xuICAgICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgICAje3JhaXNlIE1hdGg6OkRvbWFpbkVycm9yLCAnTnVtZXJpY2FsIGFyZ3VtZW50IGlzIG91dCBvZiBkb21haW4gLSBcImlzcXJ0XCInfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KE1hdGguc3FydChuKSwgMTApO1xuICAgICAgfVxuICAgIGVuZFxuICBlbmRcblxuICBNQVggPSBgTWF0aC5wb3coMiwgMzApIC0gMWBcbiAgTUlOID0gYC1NYXRoLnBvdygyLCAzMClgXG5lbmRcblxuY2xhc3MgRmxvYXQgPCBOdW1lcmljXG4gIGBzZWxmLiQkaXNfbnVtYmVyX2NsYXNzID0gdHJ1ZWBcblxuICBjbGFzcyA8PCBzZWxmXG4gICAgZGVmIGFsbG9jYXRlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwiYWxsb2NhdG9yIHVuZGVmaW5lZCBmb3IgI3tuYW1lfVwiXG4gICAgZW5kXG5cbiAgICB1bmRlZiA6bmV3XG5cbiAgICBkZWYgPT09KG90aGVyKVxuICAgICAgYCEhb3RoZXIuJCRpc19udW1iZXJgXG4gICAgZW5kXG4gIGVuZFxuXG4gIElORklOSVRZID0gYEluZmluaXR5YFxuICBNQVggICAgICA9IGBOdW1iZXIuTUFYX1ZBTFVFYFxuICBNSU4gICAgICA9IGBOdW1iZXIuTUlOX1ZBTFVFYFxuICBOQU4gICAgICA9IGBOYU5gXG5cbiAgRElHICAgICAgPSAxNVxuICBNQU5UX0RJRyA9IDUzXG4gIFJBRElYICAgID0gMlxuXG4gIEVQU0lMT04gPSBgTnVtYmVyLkVQU0lMT04gfHwgMi4yMjA0NDYwNDkyNTAzMTMwODA4NDcyNjMzMzYxODE2RS0xNmBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpOdW1iZXI+IiwiT3BhbCIsImJyaWRnZSIsImFsbG9jYXRlIiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuYW1lIiwiY29lcmNlIiwib3RoZXIiLCJjbGFzcyIsIkZsb2F0IiwicmVzcG9uZF90bz8iLCJjb2VyY2VfdG8hIiwiX19pZF9fIiwiKyIsIl9fY29lcmNlZF9fIiwiLSIsIioiLCIvIiwiJSIsIlplcm9EaXZpc2lvbkVycm9yIiwiJiIsInwiLCJeIiwiPCIsIjw9IiwiPiIsIj49IiwiPD0+IiwiQXJndW1lbnRFcnJvciIsIjw8IiwiY291bnQiLCJJbnRlZ2VyIiwiPj4iLCJbXSIsImJpdCIsIitAIiwiLUAiLCJ+IiwiKioiLCI9PT0iLCIkcmV0X29yXzEiLCIhIiwiMCIsIlJhdGlvbmFsIiwibmV3IiwiMSIsIiRyZXRfb3JfMiIsIiRyZXRfb3JfMyIsIkNvbXBsZXgiLCJ0b19mIiwiPT0iLCJhYnMiLCJhYnMyIiwiYWxsYml0cz8iLCJtYXNrIiwiYW55Yml0cz8iLCJhbmdsZSIsIm5hbj8iLCJiaXRfbGVuZ3RoIiwiTm9NZXRob2RFcnJvciIsImNlaWwiLCJuZGlnaXRzIiwiY2hyIiwiZW5jb2RpbmciLCJkZW5vbWluYXRvciIsIiRyZXRfb3JfNCIsImluZmluaXRlPyIsImRvd250byIsInN0b3AiLCJibG9ja19naXZlbj8iLCJlbnVtX2ZvciIsImJsb2NrIGluIGRvd250byIsImJsb2NrICgyIGxldmVscykgaW4gZG93bnRvIiwiTnVtZXJpYyIsImVxdWFsPyIsIiRyZXRfb3JfNSIsImV2ZW4/IiwiZmxvb3IiLCJnY2QiLCJnY2RsY20iLCJsY20iLCJpbnRlZ2VyPyIsImlzX2E/Iiwia2xhc3MiLCIkcmV0X29yXzYiLCIkcmV0X29yXzciLCIkcmV0X29yXzgiLCJpbnN0YW5jZV9vZj8iLCIkcmV0X29yXzkiLCIkcmV0X29yXzEwIiwiJHJldF9vcl8xMSIsIm5leHQiLCJub2JpdHM/Iiwibm9uemVybz8iLCJudW1lcmF0b3IiLCIkcmV0X29yXzEyIiwib2RkPyIsIm9yZCIsInBvdyIsImIiLCJtIiwicHJlZCIsInF1byIsInJhdGlvbmFsaXplIiwiZXBzIiwiRmxvYXREb21haW5FcnJvciIsIk1hdGgiLCJmcmV4cCIsImYiLCJuIiwibGRleHAiLCJGbG9hdDo6TUFOVF9ESUciLCJ0b19pIiwiMiIsInRvX3IiLCJyZW1haW5kZXIiLCJ5IiwidHJ1bmNhdGUiLCJyb3VuZCIsIiRyZXRfb3JfMTMiLCJSYW5nZUVycm9yIiwiSW50ZWdlcjo6TUlOIiwic2l6ZSIsIiRyZXRfb3JfMTQiLCIkcmV0X29yXzE1IiwiXyIsImV4cCIsIkZsb2F0OjpESUciLCI0IiwiMyIsInRpbWVzIiwiYmxvY2siLCJibG9jayBpbiB0aW1lcyIsImJsb2NrICgyIGxldmVscykgaW4gdGltZXMiLCJlIiwiRmxvYXQ6OlJBRElYIiwidG9fcyIsImJhc2UiLCIxMCIsIiRyZXRfb3JfMTYiLCIzNiIsImRpZ2l0cyIsIk1hdGg6OkRvbWFpbkVycm9yIiwiZGl2bW9kIiwiJHJldF9vcl8xNyIsInVwdG8iLCJibG9jayBpbiB1cHRvIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiB1cHRvIiwiemVybz8iLCJmaW5pdGU/IiwicG9zaXRpdmU/IiwibmVnYXRpdmU/IiwiTnVtYmVyIiwiPGNsYXNzOkludGVnZXI+Iiwic3FydCIsIjxjbGFzczpGbG9hdD4iLCIxNSIsIjUzIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFB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O01BREZELENBQUFBLDBCQUFBQTs7TUFJQSxzQkFBTSxLQUFOO01BRUEsT0FBQXFDLENBQUFBLHVCQUFBQSxlQUFBQSxTQUFRaEMsS0FBUmdDO0FBQUFBLFFBQUFBOztRQUNFQSxPQUFDQSxtQkFBREE7TUFERkEsQ0FBQUEsMEJBQUFBLENBQUFBO0lBUEYsNEJBQVMxQyxJQUFUO0lBWUEsd0NBQVk4SixRQUFaO0lBQ0EsbUNBQVlBLGdCQUFaO0lBQ0EsbUNBQVlBLGdCQUFaO0lBQ0EsbUNBQVlBLEdBQVo7SUFFQSxtQ0FBV0MsRUFBWDtJQUNBLHdDQUFXQyxFQUFYO0lBQ0EscUNBQVc1QyxDQUFYO0lBRUEwQyxPQUFBLHVDQUFXQSx1REFBWDtFQXhCRkEsR0FBQUEsV0FBQUEsRUFBY2xGLHVCQUFka0Y7QUEzMUJBL0o7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE4NDk1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5nZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5cbmNsYXNzIFJhbmdlXG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGBzZWxmLiQkcHJvdG90eXBlLiQkaXNfcmFuZ2UgPSB0cnVlYFxuXG4gIGF0dHJfcmVhZGVyIDpiZWdpbiwgOmVuZFxuXG4gIGRlZiBpbml0aWFsaXplKGZpcnN0LCBsYXN0LCBleGNsdWRlID0gZmFsc2UpXG4gICAgcmFpc2UgTmFtZUVycm9yLCBcIidpbml0aWFsaXplJyBjYWxsZWQgdHdpY2VcIiBpZiBAYmVnaW5cbiAgICByYWlzZSBBcmd1bWVudEVycm9yLCAnYmFkIHZhbHVlIGZvciByYW5nZScgdW5sZXNzIGZpcnN0IDw9PiBsYXN0IHx8IGZpcnN0Lm5pbD8gfHwgbGFzdC5uaWw/XG5cbiAgICBAYmVnaW4gPSBmaXJzdFxuICAgIEBlbmQgICA9IGxhc3RcbiAgICBAZXhjbCAgPSBleGNsdWRlXG4gIGVuZFxuXG4gIGRlZiA9PT0odmFsdWUpXG4gICAgaW5jbHVkZT8gdmFsdWVcbiAgZW5kXG5cbiAgJXh7XG4gICAgZnVuY3Rpb24gaXNfaW5maW5pdGUoc2VsZikge1xuICAgICAgaWYgKHNlbGYuYmVnaW4gPT09IG5pbCB8fCBzZWxmLmVuZCA9PT0gbmlsIHx8XG4gICAgICAgICAgc2VsZi5iZWdpbiA9PT0gLUluZmluaXR5IHx8IHNlbGYuZW5kID09PSBJbmZpbml0eSB8fFxuICAgICAgICAgIHNlbGYuYmVnaW4gPT09IEluZmluaXR5IHx8IHNlbGYuZW5kID09PSAtSW5maW5pdHkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBjb3VudCgmYmxvY2spXG4gICAgaWYgIWJsb2NrX2dpdmVuPyAmJiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgICByZXR1cm4gRmxvYXQ6OklORklOSVRZXG4gICAgZW5kXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICByYWlzZSBUeXBlRXJyb3IsICdjYW5ub3QgY29udmVydCBlbmRsZXNzIHJhbmdlIHRvIGFuIGFycmF5JyBpZiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgZGVmIGNvdmVyPyh2YWx1ZSlcbiAgICBiZWdfY21wID0gKEBiZWdpbi5uaWw/ICYmIC0xKSB8fCAoQGJlZ2luIDw9PiB2YWx1ZSkgfHwgZmFsc2VcbiAgICBlbmRfY21wID0gKEBlbmQubmlsPyAmJiAtMSkgfHwgKHZhbHVlIDw9PiBAZW5kKSB8fCBmYWxzZVxuICAgIGlmIEBleGNsXG4gICAgICBlbmRfY21wICYmIGVuZF9jbXAgPCAwXG4gICAgZWxzZVxuICAgICAgZW5kX2NtcCAmJiBlbmRfY21wIDw9IDBcbiAgICBlbmQgJiYgYmVnX2NtcCAmJiBiZWdfY21wIDw9IDBcbiAgZW5kXG5cbiAgZGVmIGVhY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgbGltaXQ7XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19udW1iZXIgJiYgI3tAZW5kfS4kJGlzX251bWJlcikge1xuICAgICAgICBpZiAoI3tAYmVnaW59ICUgMSAhPT0gMCB8fCAje0BlbmR9ICUgMSAhPT0gMCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSBGbG9hdFwifVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gI3tAYmVnaW59LCBsaW1pdCA9ICN7QGVuZH0gKyAje0BleGNsID8gMCA6IDF9OyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgICAgIGJsb2NrKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIGlmICgje0BiZWdpbn0uJCRpc19zdHJpbmcgJiYgI3tAZW5kfS4kJGlzX3N0cmluZykge1xuICAgICAgICAje0BiZWdpbi51cHRvKEBlbmQsIEBleGNsLCAmYmxvY2spfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50ID0gQGJlZ2luXG4gICAgbGFzdCAgICA9IEBlbmRcblxuICAgIHVubGVzcyBjdXJyZW50LnJlc3BvbmRfdG8/KDpzdWNjKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGl0ZXJhdGUgZnJvbSAje2N1cnJlbnQuY2xhc3N9XCJcbiAgICBlbmRcblxuICAgIHdoaWxlIEBlbmQubmlsPyB8fCAoY3VycmVudCA8PT4gbGFzdCkgPCAwXG4gICAgICB5aWVsZCBjdXJyZW50XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnN1Y2NcbiAgICBlbmRcblxuICAgIHlpZWxkIGN1cnJlbnQgaWYgIUBleGNsICYmIGN1cnJlbnQgPT0gbGFzdFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIFJhbmdlID09PSBvdGhlclxuXG4gICAgQGV4Y2wgPT09IG90aGVyLmV4Y2x1ZGVfZW5kPyAmJlxuICAgICAgQGJlZ2luLmVxbD8ob3RoZXIuYmVnaW4pICYmXG4gICAgICBAZW5kLmVxbD8ob3RoZXIuZW5kKVxuICBlbmRcblxuICBhbGlhcyA9PSBlcWw/XG5cbiAgZGVmIGV4Y2x1ZGVfZW5kP1xuICAgIEBleGNsXG4gIGVuZFxuXG4gIGRlZiBmaXJzdChuID0gdW5kZWZpbmVkKVxuICAgIHJhaXNlIFJhbmdlRXJyb3IsICdjYW5ub3QgZ2V0IHRoZSBtaW5pbXVtIG9mIGJlZ2lubGVzcyByYW5nZScgaWYgQGJlZ2luLm5pbD9cbiAgICByZXR1cm4gQGJlZ2luIGlmIGBuID09IG51bGxgXG4gICAgc3VwZXJcbiAgZW5kXG5cbiAgYWxpYXMgaW5jbHVkZT8gY292ZXI/XG5cbiAgZGVmIGxhc3QobiA9IHVuZGVmaW5lZClcbiAgICByYWlzZSBSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWF4aW11bSBvZiBlbmRsZXNzIHJhbmdlJyBpZiBAZW5kLm5pbD9cbiAgICByZXR1cm4gQGVuZCBpZiBgbiA9PSBudWxsYFxuICAgIHRvX2EubGFzdChuKVxuICBlbmRcblxuICAjIEZJWE1FOiBjdXJyZW50bHkgaGFyZGNvZGVkIHRvIGFzc3VtZSByYW5nZSBob2xkcyBudW1lcmljc1xuICBkZWYgbWF4XG4gICAgaWYgQGVuZC5uaWw/XG4gICAgICByYWlzZSBSYW5nZUVycm9yLCAnY2Fubm90IGdldCB0aGUgbWF4aW11bSBvZiBlbmRsZXNzIHJhbmdlJ1xuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiAhQGJlZ2luLm5pbD8gJiYgKEBiZWdpbiA+IEBlbmQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIEBleGNsICYmIEBiZWdpbiA9PSBAZW5kKVxuICAgICAgbmlsXG4gICAgZWxzZVxuICAgICAgYCN7QGV4Y2x9ID8gI3tAZW5kfSAtIDEgOiAje0BlbmR9YFxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBtZW1iZXI/IGNvdmVyP1xuXG4gIGRlZiBtaW5cbiAgICBpZiBAYmVnaW4ubmlsP1xuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgJ2Nhbm5vdCBnZXQgdGhlIG1pbmltdW0gb2YgYmVnaW5sZXNzIHJhbmdlJ1xuICAgIGVsc2lmIGJsb2NrX2dpdmVuP1xuICAgICAgc3VwZXJcbiAgICBlbHNpZiAhQGVuZC5uaWw/ICYmIChAYmVnaW4gPiBAZW5kIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgQGV4Y2wgJiYgQGJlZ2luID09IEBlbmQpXG4gICAgICBuaWxcbiAgICBlbHNlXG4gICAgICBAYmVnaW5cbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNpemVcbiAgICBpbmZpbml0eSA9IEZsb2F0OjpJTkZJTklUWVxuXG4gICAgcmV0dXJuIDAgaWYgKEBiZWdpbiA9PSBpbmZpbml0eSAmJiAhQGVuZC5uaWw/KSB8fCAoQGVuZCA9PSAtaW5maW5pdHkgJiYgIUBiZWdpbi5uaWw/KVxuICAgIHJldHVybiBpbmZpbml0eSBpZiBgaXNfaW5maW5pdGUoc2VsZilgXG4gICAgcmV0dXJuIG5pbCB1bmxlc3MgTnVtZXJpYyA9PT0gQGJlZ2luICYmIE51bWVyaWMgPT09IEBlbmRcblxuICAgIHJhbmdlX2JlZ2luID0gQGJlZ2luXG4gICAgcmFuZ2VfZW5kICAgPSBAZW5kXG4gICAgcmFuZ2VfZW5kICAtPSAxIGlmIEBleGNsXG5cbiAgICByZXR1cm4gMCBpZiByYW5nZV9lbmQgPCByYW5nZV9iZWdpblxuXG4gICAgYE1hdGguYWJzKHJhbmdlX2VuZCAtIHJhbmdlX2JlZ2luKSArIDFgLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHN0ZXAobiA9IDEpXG4gICAgJXh7XG4gICAgICBmdW5jdGlvbiBjb2VyY2VTdGVwU2l6ZSgpIHtcbiAgICAgICAgaWYgKCFuLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgbiA9ICN7T3BhbC5jb2VyY2VfdG8hKG4sIEludGVnZXIsIDp0b19pbnQpfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgbmVnYXRpdmVcIn1cbiAgICAgICAgfSBlbHNlIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInN0ZXAgY2FuJ3QgYmUgMFwifVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVudW1lcmF0b3JTaXplKCkge1xuICAgICAgICBpZiAoISN7QGJlZ2luLnJlc3BvbmRfdG8/KDpzdWNjKX0pIHtcbiAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCN7QGJlZ2lufS4kJGlzX3N0cmluZyAmJiAje0BlbmR9LiQkaXNfc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuICUgMSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAjeyhzaXplIC8gbikuY2VpbH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbiBpcyBhIGZsb2F0XG4gICAgICAgICAgdmFyIGJlZ2luID0gc2VsZi5iZWdpbiwgZW5kID0gc2VsZi5lbmQsXG4gICAgICAgICAgICAgIGFicyA9IE1hdGguYWJzLCBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgICAgICAgIGVyciA9IChhYnMoYmVnaW4pICsgYWJzKGVuZCkgKyBhYnMoZW5kIC0gYmVnaW4pKSAvIGFicyhuKSAqICN7RmxvYXQ6OkVQU0lMT059LFxuICAgICAgICAgICAgICBzaXplO1xuXG4gICAgICAgICAgaWYgKGVyciA+IDAuNSkge1xuICAgICAgICAgICAgZXJyID0gMC41O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLmV4Y2wpIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiAtIGVycik7XG4gICAgICAgICAgICBpZiAoc2l6ZSAqIG4gKyBiZWdpbiA8IGVuZCkge1xuICAgICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSBmbG9vcigoZW5kIC0gYmVnaW4pIC8gbiArIGVycikgKyAxXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG4gICAgICByZXR1cm4gZW51bV9mb3IoOnN0ZXAsIG4pIGRvXG4gICAgICAgICV4e1xuICAgICAgICAgIGNvZXJjZVN0ZXBTaXplKCk7XG4gICAgICAgICAgcmV0dXJuIGVudW1lcmF0b3JTaXplKCk7XG4gICAgICAgIH1cbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYGNvZXJjZVN0ZXBTaXplKClgXG5cbiAgICBpZiBgc2VsZi5iZWdpbi4kJGlzX251bWJlciAmJiBzZWxmLmVuZC4kJGlzX251bWJlcmBcbiAgICAgIGkgPSAwXG4gICAgICBsb29wIGRvXG4gICAgICAgIGN1cnJlbnQgPSBAYmVnaW4gKyBpICogblxuICAgICAgICBpZiBAZXhjbFxuICAgICAgICAgIGJyZWFrIGlmIGN1cnJlbnQgPj0gQGVuZFxuICAgICAgICBlbHNpZiBjdXJyZW50ID4gQGVuZFxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGVuZFxuICAgICAgICB5aWVsZChjdXJyZW50KVxuICAgICAgICBpICs9IDFcbiAgICAgIGVuZFxuICAgIGVsc2VcbiAgICAgICV4e1xuICAgICAgICBpZiAoI3tAYmVnaW59LiQkaXNfc3RyaW5nICYmICN7QGVuZH0uJCRpc19zdHJpbmcgJiYgbiAlIDEgIT09IDApIHtcbiAgICAgICAgICAje3JhaXNlIFR5cGVFcnJvciwgJ25vIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gZmxvYXQgZnJvbSBzdHJpbmcnfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlYWNoX3dpdGhfaW5kZXggZG8gfHZhbHVlLCBpZHh8XG4gICAgICAgIHlpZWxkKHZhbHVlKSBpZiBpZHggJSBuID09IDBcbiAgICAgIGVuZFxuICAgIGVuZFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGJzZWFyY2goJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2Zvcig6YnNlYXJjaCkgdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgaWYgYGlzX2luZmluaXRlKHNlbGYpICYmIChzZWxmLmJlZ2luLiQkaXNfbnVtYmVyIHx8IHNlbGYuZW5kLiQkaXNfbnVtYmVyKWBcbiAgICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIFwiQ2FuJ3QgI2JzZWFyY2ggYW4gaW5maW5pdGUgcmFuZ2VcIlxuICAgIGVuZFxuXG4gICAgdW5sZXNzIGBzZWxmLmJlZ2luLiQkaXNfbnVtYmVyICYmIHNlbGYuZW5kLiQkaXNfbnVtYmVyYFxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGRvIGJpbmFyeSBzZWFyY2ggZm9yICN7QGJlZ2luLmNsYXNzfVwiXG4gICAgZW5kXG5cbiAgICB0b19hLmJzZWFyY2goJmJsb2NrKVxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiI3tAYmVnaW4gfHwgJyd9I3tAZXhjbCA/ICcuLi4nIDogJy4uJ30je0BlbmQgfHwgJyd9XCJcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiN7QGJlZ2luICYmIEBiZWdpbi5pbnNwZWN0fSN7QGV4Y2wgPyAnLi4uJyA6ICcuLid9I3tAZW5kICYmIEBlbmQuaW5zcGVjdH1cIlxuICBlbmRcblxuICBkZWYgbWFyc2hhbF9sb2FkKGFyZ3MpXG4gICAgQGJlZ2luID0gYXJnc1s6YmVnaW5dXG4gICAgQGVuZCA9IGFyZ3NbOmVuZF1cbiAgICBAZXhjbCA9IGFyZ3NbOmV4Y2xdXG4gIGVuZFxuXG4gIGRlZiBoYXNoXG4gICAgW0BiZWdpbiwgQGVuZCwgQGV4Y2xdLmhhc2hcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6UmFuZ2U+IiwiaW5jbHVkZSIsIkVudW1lcmFibGUiLCJhdHRyX3JlYWRlciIsImluaXRpYWxpemUiLCJmaXJzdCIsImxhc3QiLCJleGNsdWRlIiwiQGJlZ2luIiwicmFpc2UiLCJOYW1lRXJyb3IiLCIkcmV0X29yXzEiLCIkcmV0X29yXzIiLCI8PT4iLCJuaWw/IiwiQXJndW1lbnRFcnJvciIsIkBlbmQiLCJAZXhjbCIsIj09PSIsInZhbHVlIiwiaW5jbHVkZT8iLCJjb3VudCIsIiRyZXRfb3JfMyIsImJsb2NrX2dpdmVuPyIsIiEiLCJGbG9hdDo6SU5GSU5JVFkiLCJGbG9hdCIsInRvX2EiLCJUeXBlRXJyb3IiLCJjb3Zlcj8iLCJiZWdfY21wIiwiJHJldF9vcl80IiwiJHJldF9vcl81IiwiJHJldF9vcl82IiwiLTEiLCJlbmRfY21wIiwiJHJldF9vcl83IiwiJHJldF9vcl84IiwiJHJldF9vcl85IiwiJHJldF9vcl8xMCIsIiRyZXRfb3JfMTEiLCIkcmV0X29yXzEyIiwiPCIsIjAiLCIkcmV0X29yXzEzIiwiPD0iLCJlYWNoIiwiZW51bV9mb3IiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwic2l6ZSIsIjEiLCJ1cHRvIiwiYmxvY2siLCJ0b19wcm9jIiwiY3VycmVudCIsInJlc3BvbmRfdG8/IiwiY2xhc3MiLCIkcmV0X29yXzE0Iiwic3VjYyIsIiRyZXRfb3JfMTUiLCI9PSIsImVxbD8iLCJvdGhlciIsIlJhbmdlIiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJleGNsdWRlX2VuZD8iLCJiZWdpbiIsImVuZCIsIm4iLCJSYW5nZUVycm9yIiwibWF4IiwiJHJldF9vcl8xOCIsIiRyZXRfb3JfMTkiLCI+IiwiJHJldF9vcl8yMCIsIm1pbiIsIiRyZXRfb3JfMjEiLCIkcmV0X29yXzIyIiwiJHJldF9vcl8yMyIsImluZmluaXR5IiwiJHJldF9vcl8yNCIsIiRyZXRfb3JfMjUiLCIkcmV0X29yXzI2IiwiLUAiLCIkcmV0X29yXzI3IiwiTnVtZXJpYyIsInJhbmdlX2JlZ2luIiwicmFuZ2VfZW5kIiwiLSIsInRvX2kiLCJzdGVwIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiLyIsImNlaWwiLCJGbG9hdDo6RVBTSUxPTiIsImJsb2NrIGluIHN0ZXAiLCJibG9jayAoMiBsZXZlbHMpIGluIHN0ZXAiLCJpIiwibG9vcCIsIisiLCIqIiwiPj0iLCJlYWNoX3dpdGhfaW5kZXgiLCJpZHgiLCIlIiwiYnNlYXJjaCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19zIiwiJHJldF9vcl8yOCIsIiRyZXRfb3JfMjkiLCJpbnNwZWN0IiwiJHJldF9vcl8zMCIsIiRyZXRfb3JfMzEiLCJtYXJzaGFsX2xvYWQiLCJhcmdzIiwiW10iLCJoYXNoIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFFQUYsT0FBQUc7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUYsSUFBQUcsU0FBQUEsQ0FBUUMsMEJBQVJEO0lBRUNEO0lBRURGLElBQUFLLGFBQUFBLENBQVksT0FBWixFQUFvQixLQUFwQkE7O0FBRUFDLElBQUFBLDhCQUFBQSxzQkFBQUEsc0JBQWVDLEtBQUQsRUFBUUMsSUFBUixFQUFjQyxPQUE1Qkg7QUFBQUEsTUFBQUE7Ozs7TUFBNEI7TUFBQSxZQUFVLEtBQVY7TUFBQTtNQUMxQixJQUFBLFFBQWdESSxVQUFoRCxDQUFBO1FBQUFWLElBQUFXLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCTiwyQkFBakJLLENBQUE7TUFDQSxJQUFBLFFBQWtE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QUFBLE1BQUFBOztNQUNFQSxPQUFBLEVBQUEsR0FBQSxDQUFHLGFBQUEsSUFBQSxRQWpSUEMsQ0FBQUEsYUFpUk8zRyxVQWpSUDJHLENBaVJPLENBQUE7UUFBVUQsT0FBQTFHLFVBQU0wRyxTQUFBQSxDQUFBQTtNQUFoQjtRQWpSUEEsT0FBQTtNQWlSTyxDQUFBLGtCQUFILENBQUEsR0FBQSxDQUE4QixhQUFBLElBQUEsUUFBQWpHLFNBQUEsQ0FBQTtRQUFRaUcsT0FBQUE7TUFBUjtRQUFnQkEsT0FBQUE7TUFBaEIsQ0FBQSxrQkFBOUIsQ0FBQSxHQUFBLENBQXFELGFBQUEsSUFBQSxRQWpSekRFLENBQUFBLGFBaVJ5RHBHLFFBalJ6RG9HLENBaVJ5RCxDQUFBO1FBQVFGLE9BQUFsRyxRQUFJa0csU0FBQUEsQ0FBQUE7TUFBWjtRQWpSekRBLE9BQUE7TUFpUnlELENBQUEsa0JBQXJEO0lBREZBLENBQUFBLCtCQUFBQTs7QUFJQUcsSUFBQUEsZ0NBQUFBLHlCQUFBQSx3QkFBaUJDLElBQWpCRDtBQUFBQSxNQUFBQTs7O01BQ0U3RyxhQUFTOEcsSUFBSUMsT0FBQUEsQ0FBQyxPQUFEQTtNQUNidkcsV0FBT3NHLElBQUlDLE9BQUFBLENBQUMsS0FBREE7TUFDWEYsT0FBQXBHLENBQUFBLFlBQVFxRyxJQUFJQyxPQUFBQSxDQUFDLE1BQURBLENBQVp0RztJQUhGb0csQ0FBQUEsb0NBQUFBO0lBTUFySCxPQUFBd0gsQ0FBQUEsd0JBQUFBLGlCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEsQ0FBQ2hILFVBQUQsRUFBU1EsUUFBVCxFQUFlQyxTQUFmLENBQXFCdUcsTUFBQUEsQ0FBQUE7SUFEdkJBLENBQUFBLDRCQUFBQSxDQUFBQTtFQXhSRnhILEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoxOTA2OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcHJvYy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHNsaWNlXG5cbmNsYXNzIFByb2MgPCBgRnVuY3Rpb25gXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KHNlbGYuJCRwcm90b3R5cGUsICckJGlzX3Byb2MnLCB0cnVlKWBcbiAgYE9wYWwuZGVmaW5lUHJvcGVydHkoc2VsZi4kJHByb3RvdHlwZSwgJyQkaXNfbGFtYmRhJywgZmFsc2UpYFxuXG4gIGRlZiBzZWxmLm5ldygmYmxvY2spXG4gICAgdW5sZXNzIGJsb2NrXG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndHJpZWQgdG8gY3JlYXRlIGEgUHJvYyBvYmplY3Qgd2l0aG91dCBhIGJsb2NrJ1xuICAgIGVuZFxuXG4gICAgYmxvY2tcbiAgZW5kXG5cbiAgZGVmIGNhbGwoKmFyZ3MsICZibG9jaylcbiAgICAleHtcbiAgICAgIGlmIChibG9jayAhPT0gbmlsKSB7XG4gICAgICAgIHNlbGYuJCRwID0gYmxvY2s7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQsICRicmsgPSBzZWxmLiQkYnJrO1xuXG4gICAgICBpZiAoJGJyaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzZWxmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IE9wYWwueWllbGRYKHNlbGYsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciA9PT0gJGJyaykge1xuICAgICAgICAgICAgcmV0dXJuICRicmsuJHZcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSkge1xuICAgICAgICAgIHJlc3VsdCA9IHNlbGYuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gT3BhbC55aWVsZFgoc2VsZiwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcbiAgYWxpYXMgPT09IGNhbGxcbiAgYWxpYXMgeWllbGQgY2FsbFxuXG4gIGRlZiA+PihvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgb3RoZXIuY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiA8PChvdGhlcilcbiAgICBwcm9jIGRvIHwqYXJncywgJmJsb2NrfFxuICAgICAgb3V0ID0gb3RoZXIuY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICAgY2FsbChvdXQpXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB0b19wcm9jXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGFtYmRhP1xuICAgICMgVGhpcyBtZXRob2Qgc2hvdWxkIHRlbGwgdGhlIHVzZXIgaWYgdGhlIHByb2MgdHJpY2tzIGFyZSB1bmF2YWlsYWJsZSxcbiAgICAjIChzZWUgUHJvYyNsYW1iZGE/IG9uIHJ1YnkgZG9jcyB0byBmaW5kIG91dCBtb3JlKS5cbiAgICBgISFzZWxmLiQkaXNfbGFtYmRhYFxuICBlbmRcblxuICBkZWYgYXJpdHlcbiAgICAleHtcbiAgICAgIGlmIChzZWxmLiQkaXNfY3VycmllZCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2VsZi4kJGFyaXR5O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGBpZiAoc2VsZi4kJGlzX2N1cnJpZWQpIHsgcmV0dXJuIG5pbDsgfWBcbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGJpbmRpbmdcbiAgICBgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJDYW4ndCBjcmVhdGUgQmluZGluZ1wifSB9YFxuICAgIG5pbFxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgICV4e1xuICAgICAgaWYgKHNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgIHJldHVybiAje1tbOnJlc3RdXX07XG4gICAgICB9IGVsc2UgaWYgKHNlbGYuJCRwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmIChzZWxmLiQkaXNfbGFtYmRhKSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuJCRwYXJhbWV0ZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gc2VsZi4kJHBhcmFtZXRlcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbWV0ZXIgPSBzZWxmLiQkcGFyYW1ldGVyc1tpXTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlclswXSA9PT0gJ3JlcScpIHtcbiAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRzIGFsd2F5cyBoYXZlIG5hbWVcbiAgICAgICAgICAgICAgcGFyYW1ldGVyID0gWydvcHQnLCBwYXJhbWV0ZXJbMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjdXJyeShhcml0eSA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyaXR5ID0gc2VsZi5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJpdHkgPSAje09wYWwuY29lcmNlX3RvIShhcml0eSwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgICBpZiAoc2VsZi4kJGlzX2xhbWJkYSAmJiBhcml0eSAhPT0gc2VsZi5sZW5ndGgpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJpdHlgfSBmb3IgI3tgc2VsZi5sZW5ndGhgfSlcIn1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXJyaWVkICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGgsXG4gICAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IGFyaXR5ICYmIHNlbGYuJCRpc19sYW1iZGEgJiYgIXNlbGYuJCRpc19jdXJyaWVkKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGxlbmd0aGB9IGZvciAje2Bhcml0eWB9KVwifVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBhcml0eSkge1xuICAgICAgICAgIHJldHVybiBzZWxmLiRjYWxsLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyaWVkLmFwcGx5KG51bGwsXG4gICAgICAgICAgICBhcmdzLmNvbmNhdCgkc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LiQkaXNfbGFtYmRhID0gc2VsZi4kJGlzX2xhbWJkYTtcbiAgICAgICAgcmVzdWx0LiQkaXNfY3VycmllZCA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIGN1cnJpZWQuJCRpc19sYW1iZGEgPSBzZWxmLiQkaXNfbGFtYmRhO1xuICAgICAgY3VycmllZC4kJGlzX2N1cnJpZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGN1cnJpZWQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZHVwXG4gICAgJXh7XG4gICAgICB2YXIgb3JpZ2luYWxfcHJvYyA9IHNlbGYuJCRvcmlnaW5hbF9wcm9jIHx8IHNlbGYsXG4gICAgICAgICAgcHJvYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF9wcm9jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzZWxmKSB7XG4gICAgICAgIGlmIChzZWxmLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgcHJvY1twcm9wXSA9IHNlbGZbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2M7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBjbG9uZSBkdXBcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6UHJvYz4iLCJuZXciLCJzZWxmIiwiYmxvY2siLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJjYWxsIiwiPj4iLCJvdGhlciIsInByb2MiLCJibG9jayBpbiA+PiIsImJsb2NrICgyIGxldmVscykgaW4gPj4iLCJvdXQiLCJhcmdzIiwidG9fcHJvYyIsIjw8IiwiYmxvY2sgaW4gPDwiLCJibG9jayAoMiBsZXZlbHMpIGluIDw8IiwibGFtYmRhPyIsImFyaXR5Iiwic291cmNlX2xvY2F0aW9uIiwiYmluZGluZyIsInBhcmFtZXRlcnMiLCJjdXJyeSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImR1cCJdLCJt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LEVBQVksS0FBWjtFQXpMRkEsR0FBQUEsV0FBQUEsRUFBY0QsUUFBZEM7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5MzE4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9tZXRob2QucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTWV0aG9kXG4gIGF0dHJfcmVhZGVyIDpvd25lciwgOnJlY2VpdmVyLCA6bmFtZVxuXG4gIGRlZiBpbml0aWFsaXplKHJlY2VpdmVyLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEByZWNlaXZlciA9IHJlY2VpdmVyXG4gICAgQG93bmVyICAgID0gb3duZXJcbiAgICBAbmFtZSAgICAgPSBuYW1lXG4gICAgQG1ldGhvZCAgID0gbWV0aG9kXG4gIGVuZFxuXG4gIGRlZiBhcml0eVxuICAgIEBtZXRob2QuYXJpdHlcbiAgZW5kXG5cbiAgZGVmIHBhcmFtZXRlcnNcbiAgICBgI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnNgXG4gIGVuZFxuXG4gIGRlZiBzb3VyY2VfbG9jYXRpb25cbiAgICBgI3tAbWV0aG9kfS4kJHNvdXJjZV9sb2NhdGlvbmAgfHwgWycoZXZhbCknLCAwXVxuICBlbmRcblxuICBkZWYgY29tbWVudHNcbiAgICBgI3tAbWV0aG9kfS4kJGNvbW1lbnRzYCB8fCBbXVxuICBlbmRcblxuICBkZWYgY2FsbCgqYXJncywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgI3tAbWV0aG9kfS4kJHAgPSBibG9jaztcblxuICAgICAgcmV0dXJuICN7QG1ldGhvZH0uYXBwbHkoI3tAcmVjZWl2ZXJ9LCBhcmdzKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIFtdIGNhbGxcblxuICBkZWYgPj4ob3RoZXIpXG4gICAgQG1ldGhvZCA+PiBvdGhlclxuICBlbmRcblxuICBkZWYgPDwob3RoZXIpXG4gICAgQG1ldGhvZCA8PCBvdGhlclxuICBlbmRcblxuICBkZWYgdW5iaW5kXG4gICAgVW5ib3VuZE1ldGhvZC5uZXcoQHJlY2VpdmVyLmNsYXNzLCBAb3duZXIsIEBtZXRob2QsIEBuYW1lKVxuICBlbmRcblxuICBkZWYgdG9fcHJvY1xuICAgICV4e1xuICAgICAgdmFyIHByb2MgPSBzZWxmLiRjYWxsLmJpbmQoc2VsZik7XG4gICAgICBwcm9jLiQkdW5ib3VuZCA9ICN7QG1ldGhvZH07XG4gICAgICBwcm9jLiQkaXNfbGFtYmRhID0gdHJ1ZTtcbiAgICAgIHByb2MuJCRhcml0eSA9ICN7QG1ldGhvZH0uJCRhcml0eTtcbiAgICAgIHByb2MuJCRwYXJhbWV0ZXJzID0gI3tAbWV0aG9kfS4kJHBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gcHJvYztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHJlY2VpdmVyLmNsYXNzfSMje0BuYW1lfSAoZGVmaW5lZCBpbiAje0Bvd25lcn0gaW4gI3tzb3VyY2VfbG9jYXRpb24uam9pbignOicpfSk+XCJcbiAgZW5kXG5lbmRcblxuY2xhc3MgVW5ib3VuZE1ldGhvZFxuICBhdHRyX3JlYWRlciA6c291cmNlLCA6b3duZXIsIDpuYW1lXG5cbiAgZGVmIGluaXRpYWxpemUoc291cmNlLCBvd25lciwgbWV0aG9kLCBuYW1lKVxuICAgIEBzb3VyY2UgPSBzb3VyY2VcbiAgICBAb3duZXIgID0gb3duZXJcbiAgICBAbWV0aG9kID0gbWV0aG9kXG4gICAgQG5hbWUgICA9IG5hbWVcbiAgZW5kXG5cbiAgZGVmIGFyaXR5XG4gICAgQG1ldGhvZC5hcml0eVxuICBlbmRcblxuICBkZWYgcGFyYW1ldGVyc1xuICAgIGAje0BtZXRob2R9LiQkcGFyYW1ldGVyc2BcbiAgZW5kXG5cbiAgZGVmIHNvdXJjZV9sb2NhdGlvblxuICAgIGAje0BtZXRob2R9LiQkc291cmNlX2xvY2F0aW9uYCB8fCBbJyhldmFsKScsIDBdXG4gIGVuZFxuXG4gIGRlZiBjb21tZW50c1xuICAgIGAje0BtZXRob2R9LiQkY29tbWVudHNgIHx8IFtdXG4gIGVuZFxuXG4gIGRlZiBiaW5kKG9iamVjdClcbiAgICAleHtcbiAgICAgIGlmICgje0Bvd25lcn0uJCRpc19tb2R1bGUgfHwgT3BhbC5pc19hKCN7b2JqZWN0fSwgI3tAb3duZXJ9KSkge1xuICAgICAgICByZXR1cm4gI3tNZXRob2QubmV3KG9iamVjdCwgQG93bmVyLCBAbWV0aG9kLCBAbmFtZSl9O1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGJpbmQgc2luZ2xldG9uIG1ldGhvZCB0byBhIGRpZmZlcmVudCBjbGFzcyAoZXhwZWN0ZWQgI3tvYmplY3R9LmtpbmRfb2Y/KCN7QG93bmVyfSB0byBiZSB0cnVlKVwifTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIjPCN7c2VsZi5jbGFzc306ICN7QHNvdXJjZX0jI3tAbmFtZX0gKGRlZmluZWQgaW4gI3tAb3duZXJ9IGluICN7c291cmNlX2xvY2F0aW9uLmpvaW4oJzonKX0pPlwiXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpNZXRob2Q+Iiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsInJlY2VpdmVyIiwib3duZXIiLCJtZXRob2QiLCJuYW1lIiwiQHJlY2VpdmVyIiwiQG93bmVyIiwiQG5hbWUiLCJAbWV0aG9kIiwiYXJpdHkiLCJwYXJhbWV0ZXJzIiwic291cmNlX2xvY2F0aW9uIiwiJHJldF9vcl8xIiwiMCIsImNvbW1lbnRzIiwiJHJldF9vcl8yIiwiY2FsbCIsIj4+Iiwib3RoZXIiLCI8PCIsInVuYmluZCIsIlVuYm91bmRNZXRob2QiLCJuZXciLCJjbGFzcyIsInRvX3Byb2MiLCJpbnNwZWN0Iiwiam9pbiIsIjxjbGFzczpVbmJvdW5kTWV0aG9kPiIsInNvdXJjZSIsIkBzb3VyY2UiLCIkcmV0X29yXzMiLCIkcmV0X29yXzQiLCJiaW5kIiwib2JqZWN0IiwiTWV0aG9kIiwicmFpc2UiLCJUeXBlRXJyb3IiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLElBQUFDLGFBQUFBLENBQVksT0FBWixFQUFvQixVQUFwQixFQUErQixNQUEvQkE7O0FBRUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQWVDLFFBQUQsRUFBV0MsS0FBWCxFQUFrQkMsTUFBbEIsRUFBMEJDLElBQXhDSjtBQUFBQSxNQUFBQTs7O01BQ0VLLGdCQUFZSjtNQUNaSyxhQUFZSjtNQUNaSyxZQUFZSDtNQUNaSixPQUFBUSxDQUFBQSxjQUFZTCxNQUFaSztJQUpGUixDQUFBQSxrQ0FBQUE7O0FBT0FTLElBQUFBLHlCQUFBQSxrQkFBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRCxXQUFPQyxPQUFBQSxDQUFBQTtJQURUQSxDQUFBQSw2QkFBQUE7O0FBSUFDLElBQUFBLDhCQUFBQSx1QkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFHRixXQUFRRTtJQURiQSxDQUFBQSxrQ0FBQUE7O0FBSUFDLElBQUFBLG1DQUFBQSw0QkFBQUEsMkJBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFuQkpDLENBQUFBLFlBbUJPSixXQUFRRyxrQkFuQmZDLENBbUJJLENBQUE7UUFuQkpELE9BQUE7TUFtQkk7UUFBa0NBLE9BQUEsQ0FBQ0EsUUFBRCxFQUFXRSxDQUFYO01BQWxDO0lBREZGLENBQUFBLHVDQUFBQTs7QUFJQUcsSUFBQUEsNEJBQUFBLHFCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQXZCSkMsQ0FBQUEsWUF1Qk9QLFdBQVFNLFdBdkJmQyxDQXVCSSxDQUFBO1FBdkJKRCxPQUFBO01BdUJJO1FBQTJCQSxPQUFBO01BQTNCO0lBREZBLENBQUFBLGdDQUFBQTs7QUFJQUUsSUFBQUEsd0JBQUFBLGlCQUFBQSxnQkExQkYsRUEwQkVBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWdCOztNQTFCbEI7O01BMEJXOztBQUVYQSxNQUFRUixXQUFRUTs7QUFFaEJBLGFBQWVSLFdBQVFRLE9BQVNYLGFBQVVXO0FBQzFDQTtJQUxFQSxDQUFBQSw2QkFBQUE7SUFRQSxhQUFNLElBQU4sRUFBUyxNQUFUOztBQUVBQyxJQUFBQSxzQkFBQUEsbUJBQUFBLFNBQU9DLEtBQVBEO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBVCxXQUFRUyxPQUFBQSxDQUFHQyxLQUFIRDtJQURWQSxDQUFBQSw4QkFBQUE7O0FBSUFFLElBQUFBLHNCQUFBQSxtQkFBQUEsU0FBT0QsS0FBUEM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFYLFdBQVFXLE9BQUFBLENBQUdELEtBQUhDO0lBRFZBLENBQUFBLDhCQUFBQTs7QUFJQUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFDLDZCQUFhQyxLQUFBQSxDQUFLakIsYUFBU2tCLE9BQUFBLENBQUFBLENBQTNCLEVBQW1DakIsVUFBbkMsRUFBMkNFLFdBQTNDLEVBQW9ERCxTQUF2Q2U7SUFEZkYsQ0FBQUEsOEJBQUFBOztBQUlBSSxJQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBLHVCQUF5QmhCLFdBQVFnQjtBQUNqQ0E7QUFDQUEscUJBQXVCaEIsV0FBUWdCO0FBQy9CQSwwQkFBNEJoQixXQUFRZ0I7QUFDcENBO0FBQ0FBO0lBUkVBLENBQUFBLGdDQUFBQTtJQVdBM0IsT0FBQTRCLENBQUFBLDJCQUFBQSxxQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLEVBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBSzNCLElBQUl5QixPQUFBQSxDQUFBQSxDQUFULENBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBb0JsQixhQUFTa0IsT0FBQUEsQ0FBQUEsQ0FBN0IsQ0FBQSxHQUFBLEdBQUEsR0FBQSxDQUF1Q2hCLFNBQXZDLENBQUEsR0FBQSxlQUFBLEdBQUEsQ0FBNERELFVBQTVELENBQUEsR0FBQSxNQUFBLEdBQUEsQ0FBeUVSLElBQUFhLGlCQUFBQSxDQUFBQSxDQUFlZSxNQUFBQSxDQUFNRCxHQUFOQyxDQUF4RixDQUFBLEdBQUE7SUFERkQsQ0FBQUEsZ0NBQUFBLENBQUFBO0VBM0RGNUIsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7RUFnRUFELE9BQUErQjtFQUFBQTs7SUFBQUE7O0FBQUFBOztJQUNFN0IsSUFBQUMsYUFBQUEsQ0FBWSxRQUFaLEVBQXFCLE9BQXJCLEVBQTZCLE1BQTdCQTs7QUFFQUMsSUFBQUEsOEJBQUFBLCtCQUFBQSxzQkFBZTRCLE1BQUQsRUFBUzFCLEtBQVQsRUFBZ0JDLE1BQWhCLEVBQXdCQyxJQUF0Q0o7QUFBQUEsTUFBQUE7OztNQUNFNkIsY0FBVUQ7TUFDVnRCLGFBQVVKO01BQ1ZNLGNBQVVMO01BQ1ZILE9BQUFPLENBQUFBLFlBQVVILElBQVZHO0lBSkZQLENBQUFBLDBDQUFBQTs7QUFPQVMsSUFBQUEseUJBQUFBLDBCQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFELFdBQU9DLE9BQUFBLENBQUFBO0lBRFRBLENBQUFBLHFDQUFBQTs7QUFJQUMsSUFBQUEsOEJBQUFBLCtCQUFBQSxzQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUdGLFdBQVFFO0lBRGJBLENBQUFBLDBDQUFBQTs7QUFJQUMsSUFBQUEsbUNBQUFBLG9DQUFBQSwyQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQW5GSm1CLENBQUFBLFlBbUZPdEIsV0FBUUcsa0JBbkZmbUIsQ0FtRkksQ0FBQTtRQW5GSm5CLE9BQUE7TUFtRkk7UUFBa0NBLE9BQUEsQ0FBQ0EsUUFBRCxFQUFXRSxDQUFYO01BQWxDO0lBREZGLENBQUFBLCtDQUFBQTs7QUFJQUcsSUFBQUEsNEJBQUFBLDZCQUFBQSxvQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQXZGSmlCLENBQUFBLFlBdUZPdkIsV0FBUU0sV0F2RmZpQixDQXVGSSxDQUFBO1FBdkZKakIsT0FBQTtNQXVGSTtRQUEyQkEsT0FBQTtNQUEzQjtJQURGQSxDQUFBQSx3Q0FBQUE7O0FBSUFrQixJQUFBQSx3QkFBQUEseUJBQUFBLGdCQUFTQyxNQUFURDtBQUFBQSxNQUFBQTs7O0FBRUZBLFVBQVkxQixVQUFPMEIsMEJBQTRCQyxNQUFPRCxFQUFJMUIsVUFBTzBCO0FBQ2pFQSxlQUFpQkUsc0JBQU1aLEtBQUFBLENBQUtXLE1BQVgsRUFBbUIzQixVQUFuQixFQUEyQkUsV0FBM0IsRUFBb0NELFNBQTlCZSxDQUFxQ1U7QUFDNURBO0FBQ0FBO0FBQ0FBLFFBQVVsQyxJQUFBcUMsT0FBQUEsQ0FBTUMseUJBQU4sRUFBaUIsRUFBQSxHQUFBLDZEQUFBLEdBQUEsQ0FBOERILE1BQTlELENBQUEsR0FBQSxZQUFBLEdBQUEsQ0FBaUYzQixVQUFqRixDQUFBLEdBQUEsY0FBakI2QixDQUF1SEg7QUFDaklBO0FBQ0FBO0lBUkVBLENBQUFBLG9DQUFBQTtJQVdBTCxPQUFBRixDQUFBQSwyQkFBQUEsNEJBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxFQUFBLEdBQUEsSUFBQSxHQUFBLENBQUszQixJQUFJeUIsT0FBQUEsQ0FBQUEsQ0FBVCxDQUFBLEdBQUEsSUFBQSxHQUFBLENBQW9CTSxXQUFwQixDQUFBLEdBQUEsR0FBQSxHQUFBLENBQStCdEIsU0FBL0IsQ0FBQSxHQUFBLGVBQUEsR0FBQSxDQUFvREQsVUFBcEQsQ0FBQSxHQUFBLE1BQUEsR0FBQSxDQUFpRVIsSUFBQWEsaUJBQUFBLENBQUFBLENBQWVlLE1BQUFBLENBQU1ELEdBQU5DLENBQWhGLENBQUEsR0FBQTtJQURGRCxDQUFBQSx1Q0FBQUEsQ0FBQUE7RUFyQ0ZFLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBaEVBL0I7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjE5NTAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi92YXJpYWJsZXMucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyByZWdleHAgbWF0Y2hlc1xuJXh7JGd2YXJzWycmJ10gPSAkZ3ZhcnNbJ34nXSA9ICRndmFyc1snYCddID0gJGd2YXJzW1wiJ1wiXSA9IG5pbH1cblxuIyByZXF1aXJlc1xuJExPQURFRF9GRUFUVVJFUyA9ICRcIiA9IGBPcGFsLmxvYWRlZF9mZWF0dXJlc2BcbiRMT0FEX1BBVEggICAgICAgPSAkOiA9IFtdXG5cbiMgc3BsaXQgbGluZXNcbiQvID0gXCJcXG5cIlxuJCwgPSBuaWxcblxuQVJHViA9IFtdXG5BUkdGID0gT2JqZWN0Lm5ld1xuRU5WICA9IHt9XG5cbiRWRVJCT1NFID0gZmFsc2VcbiRERUJVRyAgID0gZmFsc2VcbiRTQUZFICAgID0gMFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCIkTE9BREVEX0ZFQVRVUkVTIiwiJFwiIiwiJExPQURfUEFUSCIsIiQ6IiwiJC8iLCIkLCIsIk9iamVjdCIsIm5ldyIsIiRWRVJCT1NFIiwiJERFQlVHIiwiJFNBRkUiLCIwIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUNHQTtFQUdIQyx5QkFBbUJDLENBQUFBLGVBQU1GLG9CQUFORTtFQUNuQkMsbUJBQW1CQyxDQUFBQSxjQUFLLEVBQUxBO0VBR25CQyxjQUFLTDtFQUNMTSxjQUFLO0VBRUwsb0NBQU8sRUFBUDtFQUNBLG9DQUFPQyxzQkFBTUMsS0FBQUEsQ0FBQUEsQ0FBYjtFQUNBLG1DQUFPLFlBQUEsRUFBUDtFQUVBQyxpQkFBVztFQUNYQyxlQUFXO0VBQ1hWLE9BQUFXLENBQUFBLGNBQVdDLENBQVhEO0FBakJBWDsifX0seyJvZmZzZXQiOnsibGluZSI6MTk1MjAsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2lvLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIElPXG4gIFNFRUtfU0VUID0gMFxuICBTRUVLX0NVUiA9IDFcbiAgU0VFS19FTkQgPSAyXG4gIFNFRUtfREFUQSA9IDNcbiAgU0VFS19IT0xFID0gNFxuXG4gIFJFQURBQkxFID0gMVxuICBXUklUQUJMRSA9IDRcblxuICBkZWYgaW5pdGlhbGl6ZShmZCwgZmxhZ3MgPSAncicpXG4gICAgQGZkID0gZmRcbiAgICBAZmxhZ3MgPSBmbGFnc1xuICAgIEBlb2YgPSBmYWxzZVxuXG4gICAgaWYgZmxhZ3MuaW5jbHVkZT8oJ3InKSAmJiAhZmxhZ3MubWF0Y2g/KC9bd2ErXS8pXG4gICAgICBAY2xvc2VkID0gOndyaXRlXG4gICAgZWxzaWYgZmxhZ3MubWF0Y2g/KC9bd2FdLykgJiYgIWZsYWdzLm1hdGNoPygvW3IrXS8pXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHR0eT9cbiAgICBgc2VsZi50dHkgPT0gdHJ1ZWBcbiAgZW5kXG5cbiAgYXR0cl9hY2Nlc3NvciA6d3JpdGVfcHJvY1xuICBhdHRyX2FjY2Vzc29yIDpyZWFkX3Byb2NcblxuICBkZWYgd3JpdGUoc3RyaW5nKVxuICAgIGBzZWxmLndyaXRlX3Byb2Moc3RyaW5nKWBcbiAgICBzdHJpbmcuc2l6ZVxuICBlbmRcblxuICBhdHRyX2FjY2Vzc29yIDpzeW5jLCA6dHR5XG5cbiAgYXR0cl9yZWFkZXIgOmVvZlxuICBhbGlhcyBlb2Y/IGVvZlxuXG4gIGRlZiBmbHVzaFxuICAgICMgbm9vcFxuICBlbmRcblxuICBkZWYgPDwoc3RyaW5nKVxuICAgIHdyaXRlKHN0cmluZylcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBwcmludCgqYXJncylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGFyZ3MubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gI3tTdHJpbmcoYGFyZ3NbaV1gKX1cbiAgICAgIH1cbiAgICAgIHNlbGYuJHdyaXRlKGFyZ3Muam9pbigjeyQsfSkpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIHB1dHMoKmFyZ3MpXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9ICN7U3RyaW5nKGBhcmdzW2ldYCkuY2hvbXB9XG4gICAgICB9XG4gICAgICBzZWxmLiR3cml0ZShhcmdzLmNvbmNhdChbbmlsXSkuam9pbigjeyQvfSkpO1xuICAgIH1cbiAgICBuaWxcbiAgZW5kXG5cbiAgIyBSZWFkaW5nXG5cbiAgZGVmIGdldGNcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydHMgPSAnJ1xuXG4gICAgIyBXaWxsIGV4ZWN1cmUgYXQgbW9zdCB0d2ljZSAtIG9uZSB0aW1lIHJlYWRpbmcgZnJvbSBhIGJ1ZmZlclxuICAgICMgc2Vjb25kIHRpbWVcbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IHBhcnRzXG4gICAgICBpZiBAcmVhZF9idWZmZXIgIT0gJydcbiAgICAgICAgcmV0ID0gQHJlYWRfYnVmZmVyWzBdXG4gICAgICAgIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclsxLi4tMV1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKDEpXG5cbiAgICBuaWxcbiAgZW5kXG5cbiAgZGVmIGdldGJ5dGVcbiAgICBnZXRjJi5vcmRcbiAgZW5kXG5cbiAgZGVmIHJlYWRieXRlXG4gICAgcmVhZGNoYXIub3JkXG4gIGVuZFxuXG4gIGRlZiByZWFkY2hhclxuICAgIGdldGMgfHwgcmFpc2UoRU9GRXJyb3IsICdlbmQgb2YgZmlsZSByZWFjaGVkJylcbiAgZW5kXG5cbiAgZGVmIHJlYWRsaW5lKCphcmdzKVxuICAgIGdldHMoKmFyZ3MpIHx8IHJhaXNlKEVPRkVycm9yLCAnZW5kIG9mIGZpbGUgcmVhY2hlZCcpXG4gIGVuZFxuXG4gIGRlZiBnZXRzKHNlcCA9IGZhbHNlLCBsaW1pdCA9IG5pbCwgb3B0cyA9IHt9KVxuICAgIGlmIGBzZXAuJCRpc19udW1iZXJgICYmICFsaW1pdFxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IGZhbHNlLCBzZXAsIGxpbWl0XG4gICAgZW5kXG4gICAgaWYgYHNlcC4kJGlzX2hhc2hgICYmICFsaW1pdCAmJiBvcHRzID09IHt9XG4gICAgICBzZXAsIGxpbWl0LCBvcHRzID0gZmFsc2UsIG5pbCwgc2VwXG4gICAgZWxzaWYgYGxpbWl0LiQkaXNfaGFzaGAgJiYgb3B0cyA9PSB7fVxuICAgICAgc2VwLCBsaW1pdCwgb3B0cyA9IHNlcCwgbmlsLCBsaW1pdFxuICAgIGVuZFxuXG4gICAgb3JpZ19zZXAgPSBzZXBcblxuICAgIHNlcCA9ICQvIGlmIHNlcCA9PSBmYWxzZVxuICAgIHNlcCA9IC9cXHI/XFxuXFxyP1xcbi8gaWYgc2VwID09ICcnXG4gICAgc2VwIHx8PSAnJ1xuICAgIHNlcCA9IHNlcC50b19zdHIgdW5sZXNzIG9yaWdfc2VwID09ICcnXG5cbiAgICAjIFRyeSB0byBkZWR1Y2UgbGVuZ3RoIG9mIGEgcmVnZXhwXG4gICAgc2VwbGVuID0gYG9yaWdfc2VwID09ICcnID8gMiA6IHNlcC5sZW5ndGhgXG5cbiAgICBzZXAgPSAvIC8gaWYgc2VwID09ICcgJyAjIFdURiBpcyB0aGlzLCBTdHJpbmcjc3BsaXQoXCIgXCIpIG1hdGNoZXMgYWxsIHdoaXRlc3BhY2VzPz8/XG5cbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgZGF0YSA9ICcnXG4gICAgcmV0ID0gbmlsXG5cbiAgICBiZWdpblxuICAgICAgQHJlYWRfYnVmZmVyICs9IGRhdGFcbiAgICAgIGlmIHNlcCAhPSAnJyAmJiAoYHNlcC4kJGlzX3JlZ2V4cGAgPyBAcmVhZF9idWZmZXIubWF0Y2g/KHNlcCkgOiBAcmVhZF9idWZmZXIuaW5jbHVkZT8oc2VwKSlcbiAgICAgICAgb3JpZ19idWZmZXIgPSBAcmVhZF9idWZmZXJcbiAgICAgICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIuc3BsaXQoc2VwLCAyKVxuICAgICAgICByZXQgKz0gb3JpZ19idWZmZXJbcmV0Lmxlbmd0aCwgc2VwbGVuXSBpZiByZXQgIT0gb3JpZ19idWZmZXJcbiAgICAgICAgYnJlYWtcbiAgICAgIGVuZFxuICAgIGVuZCB3aGlsZSBkYXRhID0gc3lzcmVhZF9ub3JhaXNlKHNlcCA9PSAnJyA/IDY1XzUzNiA6IDEpXG5cbiAgICB1bmxlc3MgcmV0XG4gICAgICByZXQsIEByZWFkX2J1ZmZlciA9IChAcmVhZF9idWZmZXIgfHwgJycpLCAnJ1xuICAgICAgcmV0ID0gbmlsIGlmIHJldCA9PSAnJ1xuICAgIGVuZFxuXG4gICAgaWYgcmV0XG4gICAgICBpZiBsaW1pdFxuICAgICAgICByZXQgPSByZXRbMC4uLmxpbWl0XVxuICAgICAgICBAcmVhZF9idWZmZXIgPSByZXRbbGltaXQuLi0xXSArIEByZWFkX2J1ZmZlclxuICAgICAgZW5kXG4gICAgICByZXQgPSByZXQuc3ViKC9cXHI/XFxuXFx6LywgJycpIGlmIG9wdHNbOmNob21wXVxuICAgICAgcmV0ID0gcmV0LnN1YigvXFxBW1xcclxcbl0rLywgJycpIGlmIG9yaWdfc2VwID09ICcnXG4gICAgZW5kXG5cbiAgICAkXyA9IHJldCBpZiBvcmlnX3NlcCA9PSBmYWxzZVxuICAgIHJldFxuICBlbmRcblxuICAjIFRoaXMgbWV0aG9kIGlzIHRvIGJlIG92ZXJsb2FkZWQsIG9yIHJlYWRfcHJvYyBjYW4gYmUgY2hhbmdlZFxuICBkZWYgc3lzcmVhZChpbnRlZ2VyKVxuICAgIGBzZWxmLnJlYWRfcHJvYyhpbnRlZ2VyKWAgfHwgYmVnaW5cbiAgICAgIEBlb2YgPSB0cnVlXG4gICAgICByYWlzZSBFT0ZFcnJvciwgJ2VuZCBvZiBmaWxlIHJlYWNoZWQnXG4gICAgZW5kXG4gIGVuZFxuXG4gICMgQHByaXZhdGVcbiAgZGVmIHN5c3JlYWRfbm9yYWlzZShpbnRlZ2VyKVxuICAgIHN5c3JlYWQoaW50ZWdlcilcbiAgcmVzY3VlIEVPRkVycm9yXG4gICAgbmlsXG4gIGVuZFxuXG4gIGRlZiByZWFkcGFydGlhbChpbnRlZ2VyKVxuICAgIEByZWFkX2J1ZmZlciB8fD0gJydcbiAgICBwYXJ0ID0gc3lzcmVhZChpbnRlZ2VyKVxuICAgIHJldCwgQHJlYWRfYnVmZmVyID0gQHJlYWRfYnVmZmVyICsgKHBhcnQgfHwgJycpLCAnJ1xuICAgIHJldCA9IG5pbCBpZiByZXQgPT0gJydcbiAgICByZXRcbiAgZW5kXG5cbiAgZGVmIHJlYWQoaW50ZWdlciA9IG5pbClcbiAgICBAcmVhZF9idWZmZXIgfHw9ICcnXG4gICAgcGFydHMgPSAnJ1xuICAgIHJldCA9IG5pbFxuXG4gICAgYmVnaW5cbiAgICAgIEByZWFkX2J1ZmZlciArPSBwYXJ0c1xuICAgICAgaWYgaW50ZWdlciAmJiBAcmVhZF9idWZmZXIubGVuZ3RoID4gaW50ZWdlclxuICAgICAgICByZXQsIEByZWFkX2J1ZmZlciA9IEByZWFkX2J1ZmZlclswLi4uaW50ZWdlcl0sIEByZWFkX2J1ZmZlcltpbnRlZ2VyLi4tMV1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgZW5kXG4gICAgZW5kIHdoaWxlIHBhcnRzID0gc3lzcmVhZF9ub3JhaXNlKGludGVnZXIgfHwgNjVfNTM2KVxuXG4gICAgcmV0LCBAcmVhZF9idWZmZXIgPSBAcmVhZF9idWZmZXIsICcnXG4gICAgcmV0XG4gIGVuZFxuXG4gICMgRWFjaGVzXG5cbiAgZGVmIHJlYWRsaW5lcyhzZXBhcmF0b3IgPSAkLylcbiAgICBlYWNoX2xpbmUoc2VwYXJhdG9yKS50b19hXG4gIGVuZFxuXG4gIGRlZiBlYWNoKHNlcCA9ICQvLCAqYXJncywgJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaCwgc2VwLCAqYXJncyB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICB3aGlsZSAocyA9IGdldHMoc2VwLCAqYXJncykpXG4gICAgICB5aWVsZChzKVxuICAgIGVuZFxuXG4gICAgc2VsZlxuICBlbmRcblxuICBhbGlhcyBlYWNoX2xpbmUgZWFjaFxuXG4gIGRlZiBlYWNoX2J5dGUoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9ieXRlIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0Ynl0ZSlcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBlYWNoX2NoYXIoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jaGFyIHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHdoaWxlIChzID0gZ2V0YylcbiAgICAgIHlpZWxkKHMpXG4gICAgZW5kXG5cbiAgICBzZWxmXG4gIGVuZFxuXG4gICMgQ2xvc2VkbmVzc1xuXG4gIGRlZiBjbG9zZVxuICAgIEBjbG9zZWQgPSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VfcmVhZFxuICAgIGlmIEBjbG9zZWQgPT0gOndyaXRlXG4gICAgICBAY2xvc2VkID0gOmJvdGhcbiAgICBlbHNlXG4gICAgICBAY2xvc2VkID0gOnJlYWRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGNsb3NlX3dyaXRlXG4gICAgaWYgQGNsb3NlZCA9PSA6cmVhZFxuICAgICAgQGNsb3NlZCA9IDpib3RoXG4gICAgZWxzZVxuICAgICAgQGNsb3NlZCA9IDp3cml0ZVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgY2xvc2VkP1xuICAgIEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgZGVmIGNsb3NlZF9yZWFkP1xuICAgIEBjbG9zZWQgPT0gOnJlYWQgfHwgQGNsb3NlZCA9PSA6Ym90aFxuICBlbmRcblxuICBkZWYgY2xvc2VkX3dyaXRlP1xuICAgIEBjbG9zZWQgPT0gOndyaXRlIHx8IEBjbG9zZWQgPT0gOmJvdGhcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfd3JpdGFibGVcbiAgICBpZiBjbG9zZWRfd3JpdGU/XG4gICAgICByYWlzZSBJT0Vycm9yLCAnbm90IG9wZW5lZCBmb3Igd3JpdGluZydcbiAgICBlbmRcbiAgZW5kXG5cbiAgIyBAcHJpdmF0ZVxuICBkZWYgY2hlY2tfcmVhZGFibGVcbiAgICBpZiBjbG9zZWRfcmVhZD9cbiAgICAgIHJhaXNlIElPRXJyb3IsICdub3Qgb3BlbmVkIGZvciByZWFkaW5nJ1xuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5TVERJTiAgPSAkc3RkaW4gID0gSU8ubmV3KDAsICdyJylcblNURE9VVCA9ICRzdGRvdXQgPSBJTy5uZXcoMSwgJ3cnKVxuU1RERVJSID0gJHN0ZGVyciA9IElPLm5ldygyLCAndycpXG5cbmB2YXIgY29uc29sZSA9IE9wYWwuZ2xvYmFsLmNvbnNvbGVgXG5TVERPVVQud3JpdGVfcHJvYyA9IGB0eXBlb2YocHJvY2VzcykgPT09ICdvYmplY3QnICYmIHR5cGVvZihwcm9jZXNzLnN0ZG91dCkgPT09ICdvYmplY3QnID8gZnVuY3Rpb24ocyl7cHJvY2Vzcy5zdGRvdXQud3JpdGUocyl9IDogZnVuY3Rpb24ocyl7Y29uc29sZS5sb2cocyl9YFxuU1RERVJSLndyaXRlX3Byb2MgPSBgdHlwZW9mKHByb2Nlc3MpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YocHJvY2Vzcy5zdGRlcnIpID09PSAnb2JqZWN0JyA/IGZ1bmN0aW9uKHMpe3Byb2Nlc3Muc3RkZXJyLndyaXRlKHMpfSA6IGZ1bmN0aW9uKHMpe2NvbnNvbGUud2FybihzKX1gXG5cblNURElOLnJlYWRfcHJvYyA9IGBmdW5jdGlvbihzKSB7IHZhciBwID0gcHJvbXB0KCk7IGlmIChwICE9PSBudWxsKSByZXR1cm4gcCArIFwiXFxuXCI7IHJldHVybiBuaWw7IH1gXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpJTz4iLCIwIiwiMSIsIjIiLCIzIiwiNCIsImluaXRpYWxpemUiLCJmZCIsImZsYWdzIiwiQGZkIiwiQGZsYWdzIiwiQGVvZiIsIiRyZXRfb3JfMSIsImluY2x1ZGU/IiwibWF0Y2g/IiwiISIsIkBjbG9zZWQiLCIkcmV0X29yXzIiLCJ0dHk/Iiwic2VsZiIsImF0dHJfYWNjZXNzb3IiLCJ3cml0ZSIsInN0cmluZyIsInNpemUiLCJhdHRyX3JlYWRlciIsImZsdXNoIiwiPDwiLCJwcmludCIsIlN0cmluZyIsIiQsIiwicHV0cyIsImNob21wIiwiJC8iLCJnZXRjIiwiQHJlYWRfYnVmZmVyIiwiJHJldF9vcl8zIiwicGFydHMiLCIrIiwiIT0iLCJyZXQiLCJbXSIsIi0xIiwic3lzcmVhZF9ub3JhaXNlIiwiZ2V0Ynl0ZSIsInJlYWRieXRlIiwicmVhZGNoYXIiLCJvcmQiLCIkcmV0X29yXzQiLCJyYWlzZSIsIkVPRkVycm9yIiwicmVhZGxpbmUiLCIkcmV0X29yXzUiLCJnZXRzIiwiYXJncyIsInNlcCIsImxpbWl0Iiwib3B0cyIsIiRyZXRfb3JfNiIsIiRyZXRfb3JfNyIsIiRyZXRfb3JfOCIsIj09IiwiJHJldF9vcl85Iiwib3JpZ19zZXAiLCIkcmV0X29yXzEwIiwidG9fc3RyIiwic2VwbGVuIiwiJHJldF9vcl8xMSIsImRhdGEiLCIkcmV0X29yXzEyIiwib3JpZ19idWZmZXIiLCJzcGxpdCIsImxlbmd0aCIsIjY1NTM2IiwiJHJldF9vcl8xMyIsInN1YiIsIiRfIiwic3lzcmVhZCIsImludGVnZXIiLCIkcmV0X29yXzE0IiwicmVhZHBhcnRpYWwiLCIkcmV0X29yXzE1IiwicGFydCIsIiRyZXRfb3JfMTYiLCJyZWFkIiwiJHJldF9vcl8xNyIsIiRyZXRfb3JfMTkiLCI+IiwiJHJldF9vcl8xOCIsInJlYWRsaW5lcyIsInNlcGFyYXRvciIsImVhY2hfbGluZSIsInRvX2EiLCJlYWNoIiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJzIiwiZWFjaF9ieXRlIiwiZWFjaF9jaGFyIiwiY2xvc2UiLCJjbG9zZV9yZWFkIiwiY2xvc2Vfd3JpdGUiLCJjbG9zZWQ/IiwiY2xvc2VkX3JlYWQ/IiwiJHJldF9vcl8yMCIsImNsb3NlZF93cml0ZT8iLCIkcmV0X29yXzIxIiwiY2hlY2tfd3JpdGFibGUiLCJJT0Vycm9yIiwiY2hlY2tfcmVhZGFibGUiLCIkc3RkaW4iLCJJTyIsIm5ldyIsIiRzdGRvdXQiLCIkc3RkZXJyIiwiJHdyaXRlciIsIndyaXRlX3Byb2M9IiwiU1RET1VUIiwiLSIsIlNUREVSUiIsInJlYWRfcHJvYz0iLCJTVERJTiJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRSx3Q0FBV0MsQ0FBWDtJQUNBLHdDQUFXQyxDQUFYO0lBQ0Esd0NBQVdDLENBQVg7SUFDQSx5Q0FBWUMsQ0FBWjtJQUNBLHlDQUFZQyxDQUFaO0lBRUEsd0NBQVdILENBQVg7SUFDQSx3Q0FBV0csQ0FBWDs7QUFFQUMsSUFBQUEsOEJBQUFBLG1CQUFBQSxzQkFBZUMsRUFBRCxFQUFLQyxLQUFuQkY7QUFBQUEsTUFBQUE7Ozs7TUFBbUI7TUFBQSxVQUFRQSxHQUFSO01BQUE7TUFDakJHLFVBQU1GO01BQ05HLGFBQVNGO01BQ1RHLFdBQU87TUFFUCxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBZlBDLENBQUFBLFlBZU9KLEtBQUtLLGFBQUFBLENBQVVQLEdBQVZPLENBZlpELENBZU8sQ0FBQTtRQUF1Qk4sT0FBQ0UsS0FBS00sV0FBQUEsQ0FBUSxPQUFSQSxDQUFOQyxNQUFBQSxDQUFBQTtNQUF2QjtRQWZQVCxPQUFBO01BZU8sQ0FBQSxrQkFBSCxDQUFBO1FBQ0VBLE9BQUFVLENBQUFBLGNBQVUsT0FBVkE7TUFERixPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUFqQlZDLENBQUFBLFlBaUJVVCxLQUFLTSxXQUFBQSxDQUFRLE1BQVJBLENBakJmRyxDQWlCVSxDQUFBO1FBQXdCWCxPQUFDRSxLQUFLTSxXQUFBQSxDQUFRLE1BQVJBLENBQU5DLE1BQUFBLENBQUFBO01BQXhCO1FBakJWVCxPQUFBO01BaUJVLENBQUEsa0JBQU4sQ0FBQTtRQUNFQSxPQUFBVSxDQUFBQSxjQUFVLE1BQVZBO01BREY7UUFqQkpWLE9BQUE7TUFpQkk7SUFQRkEsQ0FBQUEsK0JBQUFBOztBQVlBWSxJQUFBQSx3QkFBQUEsaUJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFDQSxnQkFBREE7SUFERkEsQ0FBQUEsNEJBQUFBO0lBSUFDLElBQUFDLGVBQUFBLENBQWMsWUFBZEE7SUFDQUQsSUFBQUMsZUFBQUEsQ0FBYyxXQUFkQTs7QUFFQUMsSUFBQUEseUJBQUFBLGNBQUFBLGlCQUFVQyxNQUFWRDtBQUFBQSxNQUFBQTs7O01BQ0dBO01BQ0RBLE9BQUFDLE1BQU1DLE1BQUFBLENBQUFBO0lBRlJGLENBQUFBLHlCQUFBQTtJQUtBRixJQUFBQyxlQUFBQSxDQUFjLE1BQWQsRUFBcUIsS0FBckJBO0lBRUFELElBQUFLLGFBQUFBLENBQVksS0FBWkE7SUFDQSxhQUFNLE1BQU4sRUFBVyxLQUFYOztBQUVBQyxJQUFBQSx5QkFBQUEsY0FBQUEsaUJBQUFBO0FBQUFBLE1BQUFBOztNQXZDRkEsT0FBQTtJQXVDRUEsQ0FBQUEseUJBQUFBOztBQUlBQyxJQUFBQSxzQkFBQUEsZUFBQUEsU0FBT0osTUFBUEk7QUFBQUEsTUFBQUE7OztNQUNFUCxJQUFBRSxPQUFBQSxDQUFNQyxNQUFORDtNQUNBSyxPQUFBUDtJQUZGTyxDQUFBQSwwQkFBQUE7O0FBS0FDLElBQUFBLHlCQUFBQSxjQUFBQSxpQkFoREYsRUFnREVBO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BaERGOztNQWdEWTs7QUFFWkE7QUFDQUEsa0JBQW9CUixJQUFBUyxRQUFBQSxDQUFRRCxPQUFSQztBQUNwQkQ7QUFDQUEsNEJBQThCRSxXQUFHRjtBQUNqQ0E7TUFDSUEsT0FBQTtJQVBGQSxDQUFBQSwwQkFBQUE7O0FBVUFHLElBQUFBLHdCQUFBQSxhQUFBQSxnQkExREYsRUEwREVBO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BMURGOztNQTBEVzs7QUFFWEE7QUFDQUEsa0JBQW9CWCxJQUFBUyxRQUFBQSxDQUFRRSxPQUFSRixDQUFpQkcsT0FBQUEsQ0FBQUE7QUFDckNEO0FBQ0FBLDBDQUE0Q0UsV0FBR0Y7QUFDL0NBO01BQ0lBLE9BQUE7SUFQRkEsQ0FBQUEseUJBQUFBOztBQVlBRyxJQUFBQSx3QkFBQUEsYUFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsbUJBdkVKLGFBQUEsSUFBQSxRQUFBQyxDQUFBQSxZQXVFSUQsZ0JBdkVKQyxDQUFBLENBQUE7UUFBQUYsT0FBQTtNQUFBO1FBdUVxQkEsT0FBQUE7TUF2RXJCLENBQUE7TUF3RUlHLFFBQVFIO01BSVI7O1FBQ0VDLG1CQUFhRyxTQUFiSCxnQkFBYUcsRUFBR0QsS0FBSEM7UUFDYixJQUFBLFFBQUdILGdCQUFhSSxPQUFBQSxDQUFHTCxFQUFISyxDQUFoQixDQUFBOztVQUNFQyxNQUFNTCxnQkFBWU0sT0FBQUEsQ0FBQ3ZDLENBQUR1QztVQUNsQk4sbUJBQWVBLGdCQUFZTSxPQUFBQSxDQUFDLE9BQUF0QyxDQUFBLEVBQUd1QyxFQUFILFFBQUREO1VBQzNCLE9BQU9ELElBSFQ7TUFGRixFQUFBLE9BQUEsUUFPVUgsQ0FBQUEsUUFBUWpCLElBQUF1QixpQkFBQUEsQ0FBZ0J4QyxDQUFoQndDLENBQVJOLENBUFYsQ0FBQTtNQVNBSCxPQUFBO0lBZkZBLENBQUFBLHdCQUFBQTs7QUFrQkFVLElBQUFBLDJCQUFBQSxnQkFBQUEsbUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUEsS0FBQXhCLElBQUFjLE1BQUFBLENBQUFBLENBQUEscUNBQUEsTUFBQSxFQUFBLE9BQUEsRUFBQSxFQUFBLENBQUE7SUFERlUsQ0FBQUEsMkJBQUFBOztBQUlBQyxJQUFBQSw0QkFBQUEsa0JBQUFBLG9CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXpCLElBQUEwQixVQUFBQSxDQUFBQSxDQUFRQyxLQUFBQSxDQUFBQTtJQURWRixDQUFBQSw2QkFBQUE7O0FBSUFDLElBQUFBLDRCQUFBQSxrQkFBQUEsb0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFqR0pFLENBQUFBLFlBaUdJNUIsSUFBQWMsTUFBQUEsQ0FBQUEsQ0FqR0pjLENBaUdJLENBQUE7UUFqR0pGLE9BQUE7TUFpR0k7UUFBUUEsT0FBQTFCLElBQUE2QixPQUFBQSxDQUFNQyx3QkFBTixFQUFnQkoscUJBQWhCRztNQUFSO0lBREZILENBQUFBLDZCQUFBQTs7QUFJQUssSUFBQUEsNEJBQUFBLGtCQUFBQSxvQkFwR0YsRUFvR0VBO0FBQUFBLE1BQUFBOzs7O01BcEdGOztNQW9HZTtNQUNYLElBQUEsUUFyR0pDLENBQUFBLFlBcUdJQyxNQUFBakMsSUFBQWlDLFFBQUFBLEVBQUssVUFBQ0MsSUFBRCxDQUFMRCxDQXJHSkQsQ0FxR0ksQ0FBQTtRQXJHSkQsT0FBQTtNQXFHSTtRQUFlQSxPQUFBL0IsSUFBQTZCLE9BQUFBLENBQU1DLHdCQUFOLEVBQWdCQyxxQkFBaEJGO01BQWY7SUFERkUsQ0FBQUEsOEJBQUFBOztBQUlBRSxJQUFBQSx3QkFBQUEsY0FBQUEsZ0JBQVNFLEdBQUQsRUFBY0MsS0FBZCxFQUEyQkMsSUFBbkNKO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BQVM7TUFBQSxRQUFNLEtBQU47TUFBQTs7TUFBYTtNQUFBLFVBQVEsR0FBUjtNQUFBOztNQUFhO01BQUEsU0FBTyxZQUFBLEVBQVA7TUFBQTtNQUNqQyxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBekdQSyxDQUFBQSxZQXlHUUwsZUF6R1JLLENBeUdPLENBQUE7UUFBcUJMLE9BQUNHLEtBQUR4QyxNQUFBQSxDQUFBQTtNQUFyQjtRQXpHUHFDLE9BQUE7TUF5R08sQ0FBQSxrQkFBSCxDQUFBO1FBQ0UsS0FBbUIsQ0FBQSxLQUFBLEVBQU9FLEdBQVAsRUFBWUMsS0FBWixDQUFuQixFQUFBRCxDQUFBQSxNQUFBLEtBQUFBLENBQUEsRUFBS0MsQ0FBQUEsUUFBTCxLQUFLQSxDQUFMLEVBQVlDLENBQUFBLE9BQVosS0FBWUEsQ0FBWixJQURGO01BR0EsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTVHUEUsQ0FBQUEsWUE0R08sYUFBQSxJQUFBLFFBNUdQQyxDQUFBQSxZQTRHUVAsYUE1R1JPLENBNEdPLENBQUE7UUFBbUJQLE9BQUNHLEtBQUR4QyxNQUFBQSxDQUFBQTtNQUFuQjtRQTVHUHFDLE9BQUE7TUE0R08sQ0FBQSxrQkE1R1BNLENBNEdPLENBQUE7UUFBNkJOLE9BQUFJLElBQUtJLE9BQUFBLENBQUcsWUFBQSxFQUFIQTtNQUFsQztRQTVHUFIsT0FBQTtNQTRHTyxDQUFBLGtCQUFILENBQUE7UUFDRSxLQUFtQixDQUFBLEtBQUEsRUFBTyxHQUFQLEVBQVlFLEdBQVosQ0FBbkIsRUFBQUEsQ0FBQUEsTUFBQSxLQUFBQSxDQUFBLEVBQUtDLENBQUFBLFFBQUwsS0FBS0EsQ0FBTCxFQUFZQyxDQUFBQSxPQUFaLEtBQVlBLENBQVo7TUFERixPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUE5R1ZLLENBQUFBLFlBOEdXVCxlQTlHWFMsQ0E4R1UsQ0FBQTtRQUFxQlQsT0FBQUksSUFBS0ksT0FBQUEsQ0FBRyxZQUFBLEVBQUhBO01BQTFCO1FBOUdWUixPQUFBO01BOEdVLENBQUEsa0JBQU4sQ0FBQTtRQUNFLEtBQW1CLENBQUFFLEdBQUEsRUFBSyxHQUFMLEVBQVVDLEtBQVYsQ0FBbkIsRUFBQUQsQ0FBQUEsTUFBQSxLQUFBQSxDQUFBLEVBQUtDLENBQUFBLFFBQUwsS0FBS0EsQ0FBTCxFQUFZQyxDQUFBQSxPQUFaLEtBQVlBLENBQVosSUFERjtNQUlBTSxXQUFXUjtNQUVYLElBQVlBLEdBQUlNLE9BQUFBLENBQUcsS0FBSEEsQ0FBaEI7UUFBQU4sTUFBTXRCLFdBQU47TUFDQSxJQUFzQnNCLEdBQUlNLE9BQUFBLENBQUdSLEVBQUhRLENBQTFCO1FBQUFOLE1BQU0sWUFBTjtNQUNBQSxNQXRISixhQUFBLElBQUEsUUFBQVMsQ0FBQUEsYUFzSElULEdBdEhKUyxDQUFBLENBQUE7UUFBQVgsT0FBQTtNQUFBO1FBc0hZQSxPQUFBQTtNQXRIWixDQUFBO01BdUhJLElBQXdCVSxRQUFTRixPQUFBQSxDQUFHUixFQUFIUSxDQUFqQztNQUFBO1FBQUFOLE1BQU1BLEdBQUdVLFFBQUFBLENBQUFBO01BQVQ7TUFHQUMsU0FBVWI7TUFFVixJQUFhRSxHQUFJTSxPQUFBQSxDQUFHUixHQUFIUSxDQUFqQjtRQUFBTixNQUFNLEdBQU47TUFFQXBCLG1CQTlISixhQUFBLElBQUEsUUFBQWdDLENBQUFBLGFBOEhJaEMsZ0JBOUhKZ0MsQ0FBQSxDQUFBO1FBQUFkLE9BQUE7TUFBQTtRQThIcUJBLE9BQUFBO01BOUhyQixDQUFBO01BK0hJZSxPQUFPZjtNQUNQYixNQUFNO01BRU47O1FBQ0VMLG1CQUFhRyxTQUFiSCxnQkFBYUcsRUFBRzhCLElBQUg5QjtRQUNiLElBQUEsUUFBRyxhQUFBLElBQUEsUUFwSVQrQixDQUFBQSxhQW9JU2QsR0FBSWhCLE9BQUFBLENBQUdjLEVBQUhkLENBcEliOEIsQ0FvSVMsQ0FBQTs7VUFBYyxJQUFBLFFBQUNoQixlQUFELENBQUE7WUFBb0JBLE9BQUFsQixnQkFBWXBCLFdBQUFBLENBQVF3QyxHQUFSeEM7VUFBaEM7WUFBK0NzQyxPQUFBbEIsZ0JBQVlyQixhQUFBQSxDQUFVeUMsR0FBVnpDO1VBQTNEO1FBQWQ7VUFwSVR1QyxPQUFBO1FBb0lTLENBQUEsa0JBQUgsQ0FBQTs7VUFDRWlCLGNBQWNuQztVQUNkLEtBQW9CQSxnQkFBWW9DLE9BQUFBLENBQU9oQixHQUFuQixFQUF3Qm5ELENBQVptRSxDQUFoQyxzQkFBQSxFQUFBL0IsQ0FBQUEsTUFBQSw2QkFBQUEsQ0FBQSxFQUFLTCxDQUFBQSxtQkFBTCw2QkFBS0EsQ0FBTDtVQUNBLElBQUEsUUFBMENLLEdBQUlELE9BQUFBLENBQUcrQixXQUFIL0IsQ0FBOUMsQ0FBQTtZQUFBQyxNQUFJRixTQUFKRSxHQUFJRixFQUFHZ0MsV0FBVzdCLE9BQUFBLENBQUNELEdBQUdnQyxRQUFBQSxDQUFBQSxDQUFmLEVBQXdCTixNQUFiekIsQ0FBZEgsQ0FBSjtVQUNBLE9BSkY7TUFGRixFQUFBLE9BQUEsUUFRVThCLENBQUFBLE9BQU9oRCxJQUFBdUIsaUJBQUFBLENBQWdCLGFBQUEsSUFBQVksR0FBSU0sT0FBQUEsQ0FBR1IsRUFBSFEsQ0FBSjtRQUFZUixPQUFBb0I7TUFBWjtRQUFxQnBCLE9BQUFsRDtNQUFyQixDQUFBLGtCQUFoQndDLENBQVB5QixDQVJWLENBQUE7TUFVQSxJQUFBLFFBQU81QixHQUFQLENBQUE7TUFBQTs7UUFDRSxLQUFvQixDQUFDLGFBQUEsSUFBQSxRQTdJM0JrQyxDQUFBQSxhQTZJMkJ2QyxnQkE3STNCdUMsQ0E2STJCLENBQUE7VUE3STNCckIsT0FBQTtRQTZJMkI7VUFBZ0JBLE9BQUFBO1FBQWhCLENBQUEsa0JBQUQsRUFBc0JBLEVBQXRCLENBQXBCLEVBQUFiLENBQUFBLE1BQUEsS0FBQUEsQ0FBQSxFQUFLTCxDQUFBQSxtQkFBTCxLQUFLQSxDQUFMO1FBQ0EsSUFBYUssR0FBSXFCLE9BQUFBLENBQUdSLEVBQUhRLENBQWpCO1VBQUFyQixNQUFNLEdBQU47TUFGRjtNQUtBLElBQUEsUUFBR0EsR0FBSCxDQUFBOztRQUNFLElBQUEsUUFBR2dCLEtBQUgsQ0FBQTs7VUFDRWhCLE1BQU1BLEdBQUdDLE9BQUFBLENBQUMsZ0JBQUF2QyxDQUFBLENBQUlzRCxLQUFKLE9BQURmO1VBQ1ROLG1CQUE4QkcsU0FBZkUsR0FBR0MsT0FBQUEsQ0FBQyxnQkFBQWUsS0FBQSxFQUFPZCxFQUFQLFFBQURELENBQVlILEVBQUVILGdCQUFGRyxFQUZoQztRQUlBLElBQUEsUUFBZ0NtQixJQUFJaEIsT0FBQUEsQ0FBQyxPQUFEQSxDQUFwQyxDQUFBO1VBQUFELE1BQU1BLEdBQUdtQyxLQUFBQSxDQUFLLFFBQVIsRUFBbUJ0QixFQUFoQnNCLENBQVQ7UUFDQSxJQUFrQ1osUUFBU0YsT0FBQUEsQ0FBR1IsRUFBSFEsQ0FBM0M7VUFBQXJCLE1BQU1BLEdBQUdtQyxLQUFBQSxDQUFLLFVBQVIsRUFBcUJ0QixFQUFsQnNCLENBQVQsRUFORjtNQVNBLElBQVlaLFFBQVNGLE9BQUFBLENBQUcsS0FBSEEsQ0FBckI7UUFBQWUsV0FBS3BDLEdBQUw7TUFDQWEsT0FBQWI7SUFuREZhLENBQUFBLDBCQUFBQTs7QUF1REF3QixJQUFBQSwyQkFBQUEsaUJBQUFBLG1CQUFZQyxPQUFaRDtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBaEtKRSxDQUFBQSxhQWdLS0YsdUJBaEtMRSxDQWdLSSxDQUFBO1FBaEtKRixPQUFBO01BZ0tJOztRQUNFakUsV0FBTztRQUNQaUUsT0FBQXpELElBQUE2QixPQUFBQSxDQUFNQyx3QkFBTixFQUFnQjJCLHFCQUFoQjVCO01BRkY7SUFERjRCLENBQUFBLDRCQUFBQTs7QUFRQWxDLElBQUFBLG1DQUFBQSx5QkFBQUEsMkJBQW9CbUMsT0FBcEJuQztBQUFBQSxNQUFBQTs7TUFDRTtRQUFBQSxPQUFBdkIsSUFBQXlELFNBQUFBLENBQVFDLE9BQVJEO01BQUE7UUFDRixzQkFBTyxDQUFBM0Isd0JBQUEsQ0FBUDtVQUFBO1lBQ0VQLE9BQUE7VUFERjtRQUFBLENBREU7TUFBQTtJQURGQSxDQUFBQSxvQ0FBQUE7O0FBTUFxQyxJQUFBQSwrQkFBQUEscUJBQUFBLHVCQUFnQkYsT0FBaEJFO0FBQUFBLE1BQUFBOzs7TUFDRTdDLG1CQTlLSixhQUFBLElBQUEsUUFBQThDLENBQUFBLGFBOEtJOUMsZ0JBOUtKOEMsQ0FBQSxDQUFBO1FBQUFELE9BQUE7TUFBQTtRQThLcUJBLE9BQUFBO01BOUtyQixDQUFBO01BK0tJRSxPQUFPOUQsSUFBQXlELFNBQUFBLENBQVFDLE9BQVJEO01BQ1AsS0FBb0IsQ0FBYXZDLFNBQWJILGdCQUFhRyxFQUFHLGFBQUEsSUFBQSxRQWhMeEM2QyxDQUFBQSxhQWdMd0NELElBaEx4Q0MsQ0FnTHdDLENBQUE7UUFoTHhDSCxPQUFBO01BZ0x3QztRQUFRQSxPQUFBQTtNQUFSLENBQUEsa0JBQUgxQyxDQUFiLEVBQTZCMEMsRUFBN0IsQ0FBcEIsRUFBQXhDLENBQUFBLE1BQUEsS0FBQUEsQ0FBQSxFQUFLTCxDQUFBQSxtQkFBTCxLQUFLQSxDQUFMO01BQ0EsSUFBYUssR0FBSXFCLE9BQUFBLENBQUdtQixFQUFIbkIsQ0FBakI7UUFBQXJCLE1BQU0sR0FBTjtNQUNBd0MsT0FBQXhDO0lBTEZ3QyxDQUFBQSxnQ0FBQUE7O0FBUUFJLElBQUFBLHdCQUFBQSxjQUFBQSxnQkFBU04sT0FBVE07QUFBQUEsTUFBQUE7Ozs7TUFBUztNQUFBLFlBQVUsR0FBVjtNQUFBO01BQ1BqRCxtQkF0TEosYUFBQSxJQUFBLFFBQUFrRCxDQUFBQSxhQXNMSWxELGdCQXRMSmtELENBQUEsQ0FBQTtRQUFBRCxPQUFBO01BQUE7UUFzTHFCQSxPQUFBQTtNQXRMckIsQ0FBQTtNQXVMSS9DLFFBQVErQztNQUNSNUMsTUFBTTtNQUVOOztRQUNFTCxtQkFBYUcsU0FBYkgsZ0JBQWFHLEVBQUdELEtBQUhDO1FBQ2IsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQTVMVGdELENBQUFBLGFBNExTUixPQTVMVFEsQ0E0TFMsQ0FBQTtVQUFXRixPQUFvQkcsT0FBcEJwRCxnQkFBWXFDLFFBQUFBLENBQUFBLENBQVFlLEVBQUVULE9BQUZTO1FBQS9CO1VBNUxUSCxPQUFBO1FBNExTLENBQUEsa0JBQUgsQ0FBQTs7VUFDRSxLQUFvQixDQUFBakQsZ0JBQVlNLE9BQUFBLENBQUMsZ0JBQUF2QyxDQUFBLENBQUk0RSxPQUFKLE9BQURyQyxDQUFaLEVBQTJCTixnQkFBWU0sT0FBQUEsQ0FBQyxnQkFBQXFDLE9BQUEsRUFBU3BDLEVBQVQsUUFBREQsQ0FBdkMsQ0FBcEIsRUFBQUQsQ0FBQUEsTUFBQSxLQUFBQSxDQUFBLEVBQUtMLENBQUFBLG1CQUFMLEtBQUtBLENBQUw7VUFDQSxPQUFPSyxJQUZUO01BRkYsRUFBQSxPQUFBLFFBTVVILENBQUFBLFFBQVFqQixJQUFBdUIsaUJBQUFBLENBQWdCLGFBQUEsSUFBQSxRQWhNdEM2QyxDQUFBQSxhQWdNc0NWLE9BaE10Q1UsQ0FnTXNDLENBQUE7UUFoTXRDSixPQUFBO01BZ01zQztRQUFXQSxPQUFBWDtNQUFYLENBQUEsa0JBQWhCOUIsQ0FBUk4sQ0FOVixDQUFBO01BUUEsS0FBb0IsQ0FBQUYsZ0JBQUEsRUFBY2lELEVBQWQsQ0FBcEIsRUFBQTVDLENBQUFBLE1BQUEsS0FBQUEsQ0FBQSxFQUFLTCxDQUFBQSxtQkFBTCxLQUFLQSxDQUFMO01BQ0FpRCxPQUFBNUM7SUFkRjRDLENBQUFBLDBCQUFBQTs7QUFtQkFLLElBQUFBLDZCQUFBQSxtQkFBQUEscUJBQWNDLFNBQWREO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BQWM7TUFBQSxjQUFZeEQsV0FBWjtNQUFBO01BQ1p3RCxPQUFBckUsSUFBQXVFLFdBQUFBLENBQVVELFNBQVZDLENBQW9CQyxNQUFBQSxDQUFBQTtJQUR0QkgsQ0FBQUEsK0JBQUFBOztBQUlBSSxJQUFBQSx3QkFBQUEsY0FBQUEsZ0JBNU1GLEVBNE1VLEVBNU1WLEVBNE1FQTtBQUFBQSxNQUFBQTtBQUFBQTs7TUFBQUE7OztNQUEwQjs7TUE1TTVCOztNQTRNVztNQUFBO01BQUE7TUFBQTtNQUFBO01BQUEsUUFBTTVELFdBQU47TUFBQTs7TUFBVTtNQUNqQixJQUF5QzZELGVBQXpDO01BQUE7UUFBQSxPQUFPQyxNQUFBM0UsSUFBQTJFLFlBQUFBLEVBQUEsQ0FBUyxNQUFULEVBQWdCeEMsR0FBaEIsQ0FBQSxRQUFxQixVQUFDRCxJQUFELENBQXJCLENBQUF5QztNQUFQO01BRUEsT0FBQSxRQUFPQyxDQUFBQSxJQUFJM0MsTUFBQWpDLElBQUFpQyxRQUFBQSxFQUFBLENBQUtFLEdBQUwsQ0FBQSxRQUFVLFVBQUNELElBQUQsQ0FBVixDQUFBRCxDQUFKMkMsQ0FBUCxDQUFBO1FBQ0UsbUJBQU1BLENBQU47TUFERjtNQUlBSCxPQUFBekU7SUFQRnlFLENBQUFBLDBCQUFBQTtJQVVBLGFBQU0sV0FBTixFQUFnQixNQUFoQjs7QUFFQUksSUFBQUEsNkJBQUFBLG1CQUFBQSxxQkFBQUE7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBYztNQUNaLElBQWtDSCxlQUFsQztNQUFBO1FBQUEsT0FBTzFFLElBQUEyRSxVQUFBQSxDQUFTLFdBQVRBO01BQVA7TUFFQSxPQUFBLFFBQU9DLENBQUFBLElBQUk1RSxJQUFBd0IsU0FBQUEsQ0FBQUEsQ0FBSm9ELENBQVAsQ0FBQTtRQUNFLG1CQUFNQSxDQUFOO01BREY7TUFJQUMsT0FBQTdFO0lBUEY2RSxDQUFBQSw4QkFBQUE7O0FBVUFDLElBQUFBLDZCQUFBQSxtQkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQWM7TUFDWixJQUFrQ0osZUFBbEM7TUFBQTtRQUFBLE9BQU8xRSxJQUFBMkUsVUFBQUEsQ0FBUyxXQUFUQTtNQUFQO01BRUEsT0FBQSxRQUFPQyxDQUFBQSxJQUFJNUUsSUFBQWMsTUFBQUEsQ0FBQUEsQ0FBSjhELENBQVAsQ0FBQTtRQUNFLG1CQUFNQSxDQUFOO01BREY7TUFJQUUsT0FBQTlFO0lBUEY4RSxDQUFBQSw4QkFBQUE7O0FBWUFDLElBQUFBLHlCQUFBQSxlQUFBQSxpQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFsRixDQUFBQSxjQUFVLE1BQVZBO0lBREZrRixDQUFBQSwwQkFBQUE7O0FBSUFDLElBQUFBLDhCQUFBQSxvQkFBQUEsc0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUduRixXQUFRNEMsT0FBQUEsQ0FBRyxPQUFIQSxDQUFYO1FBQ0V1QyxPQUFBbkYsQ0FBQUEsY0FBVSxNQUFWQTtNQURGO1FBR0VtRixPQUFBbkYsQ0FBQUEsY0FBVSxNQUFWQTtNQUhGO0lBREZtRixDQUFBQSwrQkFBQUE7O0FBUUFDLElBQUFBLCtCQUFBQSxxQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUdwRixXQUFRNEMsT0FBQUEsQ0FBRyxNQUFIQSxDQUFYO1FBQ0V3QyxPQUFBcEYsQ0FBQUEsY0FBVSxNQUFWQTtNQURGO1FBR0VvRixPQUFBcEYsQ0FBQUEsY0FBVSxPQUFWQTtNQUhGO0lBREZvRixDQUFBQSxnQ0FBQUE7O0FBUUFDLElBQUFBLDJCQUFBQSxxQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFyRixXQUFRNEMsT0FBQUEsQ0FBRyxNQUFIQTtJQURWeUMsQ0FBQUEsZ0NBQUFBOztBQUlBQyxJQUFBQSxnQ0FBQUEsMEJBQUFBLFNBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUF2UUpDLENBQUFBLGFBdVFJdkYsV0FBUTRDLE9BQUFBLENBQUcsTUFBSEEsQ0F2UVoyQyxDQXVRSSxDQUFBO1FBdlFKRCxPQUFBO01BdVFJO1FBQW9CQSxPQUFBdEYsV0FBUTRDLE9BQUFBLENBQUcsTUFBSEE7TUFBNUI7SUFERjBDLENBQUFBLHFDQUFBQTs7QUFJQUUsSUFBQUEsaUNBQUFBLDJCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBM1FKQyxDQUFBQSxhQTJRSXpGLFdBQVE0QyxPQUFBQSxDQUFHLE9BQUhBLENBM1FaNkMsQ0EyUUksQ0FBQTtRQTNRSkQsT0FBQTtNQTJRSTtRQUFxQkEsT0FBQXhGLFdBQVE0QyxPQUFBQSxDQUFHLE1BQUhBO01BQTdCO0lBREY0QyxDQUFBQSxzQ0FBQUE7O0FBS0FFLElBQUFBLGtDQUFBQSx3QkFBQUEsMEJBQUFBO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR3ZGLElBQUFxRixrQkFBQUEsQ0FBQUEsQ0FBSCxDQUFBO1FBQ0VFLE9BQUF2RixJQUFBNkIsT0FBQUEsQ0FBTTJELHVCQUFOLEVBQWVELHdCQUFmMUQ7TUFERjtRQWhSSjBELE9BQUE7TUFnUkk7SUFERkEsQ0FBQUEsbUNBQUFBO0lBT0ExRyxPQUFBNEcsQ0FBQUEsa0NBQUFBLHdCQUFBQSwwQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFHekYsSUFBQW1GLGlCQUFBQSxDQUFBQSxDQUFILENBQUE7UUFDRU0sT0FBQXpGLElBQUE2QixPQUFBQSxDQUFNMkQsdUJBQU4sRUFBZUMsd0JBQWY1RDtNQURGO1FBdlJKNEQsT0FBQTtNQXVSSTtJQURGQSxDQUFBQSxtQ0FBQUEsQ0FBQUE7RUF0UkY1RyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQTZSQSxxQ0FBUzZHLENBQUFBLGVBQVVDLGtCQUFFQyxLQUFBQSxDQUFLOUcsQ0FBUCxFQUFVRixHQUFSZ0gsQ0FBWkYsQ0FBVDtFQUNBLHNDQUFTRyxDQUFBQSxnQkFBVUYsa0JBQUVDLEtBQUFBLENBQUs3RyxDQUFQLEVBQVVILEdBQVJnSCxDQUFaQyxDQUFUO0VBQ0Esc0NBQVNDLENBQUFBLGdCQUFVSCxrQkFBRUMsS0FBQUEsQ0FBSzVHLENBQVAsRUFBVUosR0FBUmdILENBQVpFLENBQVQ7RUFFQ2xIOztFQWpTRG1ILFVBQUEsQ0FrU3FCbkgsd0lBbFNyQjtFQWtTTW9ILE1BQU5DLHNCQUFNRCxlQUFBQSxFQWxTTixVQUFBRCxPQUFBLENBa1NNQztFQWxTTkQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFuSCxRQUFBLENBQUFzSCxFQUFBbkgsQ0FBQW1ILENBQUE7O0VBQUFILFVBQUEsQ0FtU3FCbkgseUlBblNyQjtFQW1TTW9ILE1BQU5HLHNCQUFNSCxlQUFBQSxFQW5TTixVQUFBRCxPQUFBLENBbVNNQztFQW5TTkQsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFuSCxRQUFBLENBQUFzSCxFQUFBbkgsQ0FBQW1ILENBQUE7O0VBQUFILFVBQUEsQ0FxU21CbkgsOEVBclNuQjtFQXFTS3dILE1BQUxDLHFCQUFLRCxjQUFBQSxFQXJTTCxVQUFBTCxPQUFBLENBcVNLSztFQXJTTHhILE9BQUFtSCxPQUFBLENBQUFHLFVBQUFILE9BQUEsQ0FBQW5ILFFBQUEsQ0FBQXNILEVBQUFuSCxDQUFBbUgsQ0FBQTtBQUFBdEg7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwMDY2LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9yZWdleHBfYW5jaG9ycy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGZyb3plbl9zdHJpbmdfbGl0ZXJhbDogdHJ1ZVxuXG5tb2R1bGUgT3BhbFxuICBSRUdFWFBfU1RBUlQgPSBSVUJZX0VOR0lORSA9PSAnb3BhbCcgPyAnXicgOiAnXFxBJ1xuICBSRUdFWFBfRU5EID0gUlVCWV9FTkdJTkUgPT0gJ29wYWwnID8gJyQnIDogJ1xceidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyRiAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UgKyAhXCIjJCUmJygpKissLS4vIGNoYXJzKVxuICAjIFxcdTAwM0EgLSBcXHUwMDQwICg6Ozw9Pj9AIGNoYXJzKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGJlZ2dpbmluZyBvciBtaWRkbGUgb2YgaXRzIG5hbWVcbiAgRk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDJGXFx1MDAzQS1cXHUwMDQwXFx1MDA1Qi1cXHUwMDVFXFx1MDA2MFxcdTAwN0ItXFx1MDA3RidcblxuICAjIFVuaWNvZGUgY2hhcmFjdGVycyBpbiByYW5nZXNcbiAgIyBcXHUwMDAxIC0gXFx1MDAyMCAoYmxhbmsgdW5pY29kZSBjaGFyYWN0ZXJzICsgc3BhY2UpXG4gICMgXFx1MDAyMiAtIFxcdTAwMkYgKFwiIyQlJicoKSorLC0uLyBjaGFycylcbiAgIyBcXHUwMDNBIC0gXFx1MDAzRSAoOjs8PT4gY2hhcnMpXG4gICMgXFx1MDA0MCAgICAgICAgICAoQCBjaGFyKVxuICAjIFxcdTAwNUIgLSBcXHUwMDVFIChbXFxdXiBjaGFycylcbiAgIyBcXHUwMDYwICAgICAgICAgIChgIGNoYXIpXG4gICMgXFx1MDA3QiAtIFxcdTAwN0YgKHt8fX4gY2hhcnN9KVxuICAjIGFyZSBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIGlkZW50aWZpZXIgaW4gdGhlIGVuZCBvZiBpdHMgbmFtZVxuICAjIEluIGZhY3QsIEZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTID0gRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICsgXFx1MDAyMSAoJz8nKSArIFxcdTAwM0YgKCchJylcbiAgRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTICAgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMi1cXHUwMDJGXFx1MDAzQS1cXHUwMDNFXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIElOTElORV9JREVOVElGSUVSX1JFR0VYUCA9IFJlZ2V4cC5uZXcoXCJbXiN7Rk9SQklEREVOX1NUQVJUSU5HX0lERU5USUZJRVJfQ0hBUlN9XSpbXiN7Rk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTfV1cIilcblxuICAjIEZvciBjb25zdGFudHMgcnVsZXMgYXJlIHByZXR0eSBtdWNoIHRoZSBzYW1lLCBidXQgJzonIGlzIGFsbG93ZWQgYW5kICc/IScgYXJlIG5vdC5cbiAgIyBQbHVzIGl0IG1heSBzdGFydCB3aXRoIGEgJzo6JyB3aGljaCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29uc3RhbnQgY29tZXMgZnJvbSB0b3BsZXZlbC5cbiAgRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMgPSAnXFx1MDAwMS1cXHUwMDIwXFx1MDAyMS1cXHUwMDJGXFx1MDAzQi1cXHUwMDNGXFx1MDA0MFxcdTAwNUItXFx1MDA1RVxcdTAwNjBcXHUwMDdCLVxcdTAwN0YnXG4gIENPTlNUX05BTUVfUkVHRVhQID0gUmVnZXhwLm5ldyhcIiN7UkVHRVhQX1NUQVJUfSg6Oik/W0EtWl1bXiN7Rk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlN9XSoje1JFR0VYUF9FTkR9XCIpXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpPcGFsPiIsIlJlZ2V4cCIsIm5ldyIsIkZPUkJJRERFTl9TVEFSVElOR19JREVOVElGSUVSX0NIQVJTIiwiRk9SQklEREVOX0VORElOR19JREVOVElGSUVSX0NIQVJTIiwiUkVHRVhQX1NUQVJUIiwiRk9SQklEREVOX0NPTlNUX05BTUVfQ0hBUlMiLCJSRUdFWFBfRU5EIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0UsNENBQXVDQSxHQUF2QztJQUNBLDBDQUFxQ0EsR0FBckM7SUFTQSxtRUFBc0NBLHFFQUF0QztJQVlBLGlFQUFzQ0EsMkZBQXRDO0lBQ0Esd0RBQTJCQyxzQkFBTUMsS0FBQUEsQ0FBSyxFQUFBLEdBQUEsSUFBQSxHQUFBLENBQUtDLG1EQUFMLENBQUEsR0FBQSxNQUFBLEdBQUEsQ0FBK0NDLGlEQUEvQyxDQUFBLEdBQUEsR0FBTEYsQ0FBakM7SUFJQSwwREFBNkJGLDJGQUE3QjtJQUNBQSxPQUFBLGlEQUFvQkMsc0JBQU1DLEtBQUFBLENBQUssRUFBQSxHQUFBLENBQUdHLDRCQUFILENBQUEsR0FBQSxjQUFBLEdBQUEsQ0FBOEJDLDBDQUE5QixDQUFBLEdBQUEsSUFBQSxHQUFBLENBQTZEQywwQkFBN0QsQ0FBTEwsQ0FBMUI7RUE3QkZGLEdBQUFBLFdBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDA4NywiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm9wYWwvbWluaS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdvcGFsL2Jhc2UnXG5cbnJlcXVpcmUgJ2NvcmVsaWIvbmlsJ1xucmVxdWlyZSAnY29yZWxpYi9ib29sZWFuJ1xucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmFibGUnXG5yZXF1aXJlICdjb3JlbGliL2VudW1lcmF0b3InXG5yZXF1aXJlICdjb3JlbGliL2FycmF5J1xucmVxdWlyZSAnY29yZWxpYi9oYXNoJ1xucmVxdWlyZSAnY29yZWxpYi9udW1iZXInXG5yZXF1aXJlICdjb3JlbGliL3JhbmdlJ1xucmVxdWlyZSAnY29yZWxpYi9wcm9jJ1xucmVxdWlyZSAnY29yZWxpYi9tZXRob2QnXG5yZXF1aXJlICdjb3JlbGliL3JlZ2V4cCdcbnJlcXVpcmUgJ2NvcmVsaWIvdmFyaWFibGVzJ1xucmVxdWlyZSAnY29yZWxpYi9pbydcbnJlcXVpcmUgJ29wYWwvcmVnZXhwX2FuY2hvcnMnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixXQUFSRTtFQUVBRCxJQUFBQyxTQUFBQSxDQUFRRixhQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixvQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsb0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGVBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGNBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLG1CQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixZQUFSRTtFQUNBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixxQkFBUkU7QUFqQkFGOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMDExMiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIva2VybmVsL2Zvcm1hdC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IGNvZXJjZV90b1xuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBmb3JtYXQoZm9ybWF0X3N0cmluZywgKmFyZ3MpXG4gICAgaWYgYXJncy5sZW5ndGggPT0gMSAmJiBhcmdzWzBdLnJlc3BvbmRfdG8/KDp0b19hcnkpXG4gICAgICBhcnkgPSBPcGFsLmNvZXJjZV90bz8oYXJnc1swXSwgQXJyYXksIDp0b19hcnkpXG4gICAgICBhcmdzID0gYXJ5LnRvX2EgdW5sZXNzIGFyeS5uaWw/XG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSAnJyxcbiAgICAgICAgICAvL3VzZWQgZm9yIHNsaWNpbmc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSAwLFxuICAgICAgICAgIGVuZF9zbGljZSxcbiAgICAgICAgICAvL3VzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nOlxuICAgICAgICAgIGksXG4gICAgICAgICAgbGVuID0gZm9ybWF0X3N0cmluZy5sZW5ndGgsXG4gICAgICAgICAgLy91c2VkIGZvciBwcm9jZXNzaW5nIGZpZWxkIHZhbHVlczpcbiAgICAgICAgICBhcmcsXG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAlZyBhbmQgJUcgZmllbGRzOlxuICAgICAgICAgIGV4cG9uZW50LFxuICAgICAgICAgIC8vdXNlZCBmb3Iga2VlcGluZyB0cmFjayBvZiB3aWR0aCBhbmQgcHJlY2lzaW9uOlxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgICAvL3VzZWQgZm9yIGhvbGRpbmcgdGVtcG9yYXJ5IHZhbHVlczpcbiAgICAgICAgICB0bXBfbnVtLFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyAle30gYW5kICU8PiBmaWxlZHM6XG4gICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5LFxuICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhcixcbiAgICAgICAgICAvL3VzZWQgZm9yIHByb2Nlc3NpbmcgJWIsICVCLCAlbywgJXgsIGFuZCAlWCBmaWVsZHM6XG4gICAgICAgICAgYmFzZV9udW1iZXIsXG4gICAgICAgICAgYmFzZV9wcmVmaXgsXG4gICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCxcbiAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0LFxuICAgICAgICAgIC8vdXNlZCBmb3IgcHJvY2Vzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgbmV4dF9hcmcsXG4gICAgICAgICAgc2VxX2FyZ19udW0gPSAxLFxuICAgICAgICAgIHBvc19hcmdfbnVtID0gMCxcbiAgICAgICAgICAvL3VzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgZmxhZ3M6XG4gICAgICAgICAgZmxhZ3MsXG4gICAgICAgICAgRk5PTkUgID0gMCxcbiAgICAgICAgICBGU0hBUlAgPSAxLFxuICAgICAgICAgIEZNSU5VUyA9IDIsXG4gICAgICAgICAgRlBMVVMgID0gNCxcbiAgICAgICAgICBGWkVSTyAgPSA4LFxuICAgICAgICAgIEZTUEFDRSA9IDE2LFxuICAgICAgICAgIEZXSURUSCA9IDMyLFxuICAgICAgICAgIEZQUkVDICA9IDY0LFxuICAgICAgICAgIEZQUkVDMCA9IDEyODtcblxuICAgICAgZnVuY3Rpb24gQ0hFQ0tfRk9SX0ZMQUdTKCkge1xuICAgICAgICBpZiAoZmxhZ3MmRldJRFRIKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ2ZsYWcgYWZ0ZXIgd2lkdGgnfSB9XG4gICAgICAgIGlmIChmbGFncyZGUFJFQzApIHsgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnZmxhZyBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIENIRUNLX0ZPUl9XSURUSCgpIHtcbiAgICAgICAgaWYgKGZsYWdzJkZXSURUSCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3aWR0aCBnaXZlbiB0d2ljZSd9IH1cbiAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkgeyAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICd3aWR0aCBhZnRlciBwcmVjaXNpb24nfSB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9OVEhfQVJHKG51bSkge1xuICAgICAgICBpZiAobnVtID49IGFyZ3MubGVuZ3RoKSB7ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBmZXcgYXJndW1lbnRzJ30gfVxuICAgICAgICByZXR1cm4gYXJnc1tudW1dO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBHRVRfTkVYVF9BUkcoKSB7XG4gICAgICAgIHN3aXRjaCAocG9zX2FyZ19udW0pIHtcbiAgICAgICAgY2FzZSAtMTogI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInVubnVtYmVyZWQoI3tgc2VxX2FyZ19udW1gfSkgbWl4ZWQgd2l0aCBudW1iZXJlZFwifSAvLyByYWlzZVxuICAgICAgICBjYXNlIC0yOiAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwidW5udW1iZXJlZCgje2BzZXFfYXJnX251bWB9KSBtaXhlZCB3aXRoIG5hbWVkXCJ9IC8vIHJhaXNlXG4gICAgICAgIH1cbiAgICAgICAgcG9zX2FyZ19udW0gPSBzZXFfYXJnX251bSsrO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcocG9zX2FyZ19udW0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gR0VUX1BPU19BUkcobnVtKSB7XG4gICAgICAgIGlmIChwb3NfYXJnX251bSA+IDApIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibnVtYmVyZWQoI3tgbnVtYH0pIGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zX2FyZ19udW0gPT09IC0yKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm51bWJlcmVkKCN7YG51bWB9KSBhZnRlciBuYW1lZFwifVxuICAgICAgICB9XG4gICAgICAgIGlmIChudW0gPCAxKSB7XG4gICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcImludmFsaWQgaW5kZXggLSAje2BudW1gfSRcIn1cbiAgICAgICAgfVxuICAgICAgICBwb3NfYXJnX251bSA9IC0xO1xuICAgICAgICByZXR1cm4gR0VUX05USF9BUkcobnVtIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIEdFVF9BUkcoKSB7XG4gICAgICAgIHJldHVybiAobmV4dF9hcmcgPT09IHVuZGVmaW5lZCA/IEdFVF9ORVhUX0FSRygpIDogbmV4dF9hcmcpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBSRUFEX05VTShsYWJlbCkge1xuICAgICAgICB2YXIgbnVtLCBzdHIgPSAnJztcbiAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbGVuKSB7XG4gICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUqWzAtOV0nfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpIDwgNDggfHwgZm9ybWF0X3N0cmluZy5jaGFyQ29kZUF0KGkpID4gNTcpIHtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIG51bSA9IHBhcnNlSW50KHN0ciwgMTApIHx8IDA7XG4gICAgICAgICAgICBpZiAobnVtID4gMjE0NzQ4MzY0Nykge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiI3tgbGFiZWxgfSB0b28gYmlnXCJ9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gZm9ybWF0X3N0cmluZy5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gUkVBRF9OVU1fQUZURVJfQVNURVIobGFiZWwpIHtcbiAgICAgICAgdmFyIGFyZywgbnVtID0gUkVBRF9OVU0obGFiZWwpO1xuICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgYXJnID0gR0VUX1BPU19BUkcobnVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmcgPSBHRVRfTkVYVF9BUkcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gI3tgYXJnYC50b19pbnR9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnKTsgaSAhPT0gLTE7IGkgPSBmb3JtYXRfc3RyaW5nLmluZGV4T2YoJyUnLCBpKSkge1xuICAgICAgICBzdHIgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgZmxhZ3MgPSBGTk9ORTtcbiAgICAgICAgd2lkdGggPSAtMTtcbiAgICAgICAgcHJlY2lzaW9uID0gLTE7XG4gICAgICAgIG5leHRfYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIGVuZF9zbGljZSA9IGk7XG5cbiAgICAgICAgaSsrO1xuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgYmVnaW5fc2xpY2UgPSBpO1xuICAgICAgICAgIC8vIG5vLWJyZWFrXG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xcMCc6XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0X3NlcXVlbmNlOiBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuXG4gICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZTUEFDRTtcbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgQ0hFQ0tfRk9SX0ZMQUdTKCk7XG4gICAgICAgICAgICBmbGFncyB8PSBGU0hBUlA7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRlBMVVM7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIENIRUNLX0ZPUl9GTEFHUygpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMCc6XG4gICAgICAgICAgICBDSEVDS19GT1JfRkxBR1MoKTtcbiAgICAgICAgICAgIGZsYWdzIHw9IEZaRVJPO1xuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgY2FzZSAnMic6XG4gICAgICAgICAgY2FzZSAnMyc6XG4gICAgICAgICAgY2FzZSAnNCc6XG4gICAgICAgICAgY2FzZSAnNSc6XG4gICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgY2FzZSAnOSc6XG4gICAgICAgICAgICB0bXBfbnVtID0gUkVBRF9OVU0oJ3dpZHRoJyk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSArIDEpID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgaWYgKGkgKyAyID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnJSc7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV4dF9hcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ2YWx1ZSBnaXZlbiB0d2ljZSAtICUje2B0bXBfbnVtYH0kXCJ9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmV4dF9hcmcgPSBHRVRfUE9TX0FSRyh0bXBfbnVtKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQ0hFQ0tfRk9SX1dJRFRIKCk7XG4gICAgICAgICAgICAgIGZsYWdzIHw9IEZXSURUSDtcbiAgICAgICAgICAgICAgd2lkdGggPSB0bXBfbnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgY2FzZSAnXFx7JzpcbiAgICAgICAgICAgIGNsb3NpbmdfYnJhY2VfY2hhciA9IChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJzwnID8gJz4nIDogJ1xcfScpO1xuICAgICAgICAgICAgaGFzaF9wYXJhbWV0ZXJfa2V5ID0gJyc7XG5cbiAgICAgICAgICAgIGkrKztcblxuICAgICAgICAgICAgZm9yICg7OyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IGxlbikge1xuICAgICAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ21hbGZvcm1lZCBuYW1lIC0gdW5tYXRjaGVkIHBhcmVudGhlc2lzJ31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGNsb3NpbmdfYnJhY2VfY2hhcikge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID4gMCkge1xuICAgICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIHVubnVtYmVyZWQoI3tgcG9zX2FyZ19udW1gfSlcIn1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc19hcmdfbnVtID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm5hbWVkICN7YGhhc2hfcGFyYW1ldGVyX2tleWB9IGFmdGVyIG51bWJlcmVkXCJ9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvc19hcmdfbnVtID0gLTI7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSA9PT0gdW5kZWZpbmVkIHx8ICFhcmdzWzBdLiQkaXNfaGFzaCkge1xuICAgICAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnb25lIGhhc2ggcmVxdWlyZWQnfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5leHRfYXJnID0gI3tgYXJnc1swXWAuZmV0Y2goYGhhc2hfcGFyYW1ldGVyX2tleWApfTtcblxuICAgICAgICAgICAgICAgIGlmIChjbG9zaW5nX2JyYWNlX2NoYXIgPT09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgY29udGludWUgZm9ybWF0X3NlcXVlbmNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSBuZXh0X2FyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGhhc2hfcGFyYW1ldGVyX2tleSArPSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIENIRUNLX0ZPUl9XSURUSCgpO1xuICAgICAgICAgICAgZmxhZ3MgfD0gRldJRFRIO1xuICAgICAgICAgICAgd2lkdGggPSBSRUFEX05VTV9BRlRFUl9BU1RFUignd2lkdGgnKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgZmxhZ3MgfD0gRk1JTlVTO1xuICAgICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgaWYgKGZsYWdzJkZQUkVDMCkge1xuICAgICAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdwcmVjaXNpb24gZ2l2ZW4gdHdpY2UnfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmxhZ3MgfD0gRlBSRUN8RlBSRUMwO1xuICAgICAgICAgICAgcHJlY2lzaW9uID0gMDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSA9PT0gJyonKSB7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgcHJlY2lzaW9uID0gUkVBRF9OVU1fQUZURVJfQVNURVIoJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICBpZiAocHJlY2lzaW9uIDwgMCkge1xuICAgICAgICAgICAgICAgIGZsYWdzICY9IH5GUFJFQztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBSRUFEX05VTSgncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICBjb250aW51ZSBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIGFyZyA9ICN7SW50ZWdlcihgR0VUX0FSRygpYCl9O1xuICAgICAgICAgICAgaWYgKGFyZyA+PSAwKSB7XG4gICAgICAgICAgICAgIHN0ciA9IGFyZy50b1N0cmluZygpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAoKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgPyAxIDogMCkpIHsgc3RyID0gJzAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgY2FzZSAnQic6XG4gICAgICAgICAgY2FzZSAnbyc6XG4gICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgY2FzZSAnWCc6XG4gICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDI7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzBiJztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19yZWdleCA9IC9eMSsvO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX2RpZ2l0ID0gJzEnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDg7XG4gICAgICAgICAgICAgIGJhc2VfcHJlZml4ID0gJzAnO1xuICAgICAgICAgICAgICBiYXNlX25lZ196ZXJvX3JlZ2V4ID0gL14zPzcrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICc3JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGNhc2UgJ1gnOlxuICAgICAgICAgICAgICBiYXNlX251bWJlciA9IDE2O1xuICAgICAgICAgICAgICBiYXNlX3ByZWZpeCA9ICcweCc7XG4gICAgICAgICAgICAgIGJhc2VfbmVnX3plcm9fcmVnZXggPSAvXmYrLztcbiAgICAgICAgICAgICAgYmFzZV9uZWdfemVyb19kaWdpdCA9ICdmJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmcgPSAje0ludGVnZXIoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCkge1xuICAgICAgICAgICAgICBzdHIgPSBhcmcudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHByZWNpc2lvbikgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgcHJlY2lzaW9uID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSAtICgoZmxhZ3MmRlNIQVJQICYmIGFyZyAhPT0gMCkgPyBiYXNlX3ByZWZpeC5sZW5ndGggOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlAgJiYgYXJnICE9PSAwKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCAmJiBhcmcgIT09IDApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9TdHJpbmcoYmFzZV9udW1iZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgcHJlY2lzaW9uKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGU0hBUlApIHsgc3RyID0gYmFzZV9wcmVmaXggKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGWkVSTyAmJiBwcmVjaXNpb24gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxIC0gKGZsYWdzJkZTSEFSUCA/IDIgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9ICctJyArIHN0cjtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RyID0gKGFyZyA+Pj4gMCkudG9TdHJpbmcoYmFzZV9udW1iZXIpLnJlcGxhY2UoYmFzZV9uZWdfemVyb19yZWdleCwgYmFzZV9uZWdfemVyb19kaWdpdCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBwcmVjaXNpb24gLSAyKSB7IHN0ciA9IGJhc2VfbmVnX3plcm9fZGlnaXQgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZTSEFSUCkgeyBzdHIgPSBiYXNlX3ByZWZpeCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZaRVJPICYmIHByZWNpc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtIDIgLSAoZmxhZ3MmRlNIQVJQID8gYmFzZV9wcmVmaXgubGVuZ3RoIDogMCkpIHsgc3RyID0gYmFzZV9uZWdfemVyb19kaWdpdCArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnLi4nICsgc3RyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlNIQVJQKSB7IHN0ciA9IGJhc2VfcHJlZml4ICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0X3N0cmluZy5jaGFyQXQoaSkgPT09IGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIGFyZyA9ICN7RmxvYXQoYEdFVF9BUkcoKWApfTtcbiAgICAgICAgICAgIGlmIChhcmcgPj0gMCB8fCBpc05hTihhcmcpKSB7XG4gICAgICAgICAgICAgIGlmIChhcmcgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgc3RyID0gJ0luZic7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXRfc3RyaW5nLmNoYXJBdChpKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gYXJnLnRvRml4ZWQocHJlY2lzaW9uID09PSAtMSA/IDYgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgICBzdHIgPSBhcmcudG9FeHBvbmVudGlhbChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b0V4cG9uZW50aWFsKCk7XG4gICAgICAgICAgICAgICAgICBleHBvbmVudCA9IHBhcnNlSW50KHN0ci5zcGxpdCgnZScpWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgICBpZiAoIShleHBvbmVudCA8IC00IHx8IGV4cG9uZW50ID49IChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGFyZy50b1ByZWNpc2lvbihwcmVjaXNpb24gPT09IC0xID8gKGZsYWdzJkZTSEFSUCA/IDYgOiB1bmRlZmluZWQpIDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzJkZQTFVTIHx8IGZsYWdzJkZTUEFDRSkgeyBzdHIgPSAoZmxhZ3MmRlBMVVMgPyAnKycgOiAnICcpICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSBJbmZpbml0eSAmJiAhaXNOYU4oYXJnKSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCAtICgoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSA/IDEgOiAwKSkgeyBzdHIgPSAnMCcgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChmbGFncyZGUExVUyB8fCBmbGFncyZGU1BBQ0UpIHsgc3RyID0gKGZsYWdzJkZQTFVTID8gJysnIDogJyAnKSArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlBMVVMgfHwgZmxhZ3MmRlNQQUNFKSB7IHN0ciA9IChmbGFncyZGUExVUyA/ICcrJyA6ICcgJykgKyBzdHI7IH1cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYXJnID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnSW5mJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICBzdHIgPSAoLWFyZykudG9GaXhlZChwcmVjaXNpb24gPT09IC0xID8gNiA6IHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICAgIHN0ciA9ICgtYXJnKS50b0V4cG9uZW50aWFsKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvRXhwb25lbnRpYWwoKTtcbiAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQoc3RyLnNwbGl0KCdlJylbMV0sIDEwKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGV4cG9uZW50IDwgLTQgfHwgZXhwb25lbnQgPj0gKHByZWNpc2lvbiA9PT0gLTEgPyA2IDogcHJlY2lzaW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gKC1hcmcpLnRvUHJlY2lzaW9uKHByZWNpc2lvbiA9PT0gLTEgPyAoZmxhZ3MmRlNIQVJQID8gNiA6IHVuZGVmaW5lZCkgOiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxhZ3MmRlpFUk8gJiYgYXJnICE9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGggLSAxKSB7IHN0ciA9ICcwJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgICAgc3RyID0gJy0nICsgc3RyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpID09PSBmb3JtYXRfc3RyaW5nLmNoYXJBdChpKS50b1VwcGVyQ2FzZSgpICYmIGFyZyAhPT0gSW5maW5pdHkgJiYgYXJnICE9PSAtSW5maW5pdHkgJiYgIWlzTmFOKGFyZykpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFtlRV1bLStdPykoWzAtOV0pJC8sICckMTAkMicpO1xuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgYmVjYXVzZSB0aGVyZSBhcmUgbm8gc3BlY3MgZm9yIHRoaXMgZmllbGQgdHlwZS5cbiAgICAgICAgICAgICN7cmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgJ2BBYCBhbmQgYGFgIGZvcm1hdCBmaWVsZCB0eXBlcyBhcmUgbm90IGltcGxlbWVudGVkIGluIE9wYWwgeWV0J31cbiAgICAgICAgICAgIC8vIHJhaXNlXG5cbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGFyZyA9IEdFVF9BUkcoKTtcbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19hcnkpfSkgeyBhcmcgPSAje2BhcmdgLnRvX2FyeX1bMF07IH1cbiAgICAgICAgICAgIGlmICgje2BhcmdgLnJlc3BvbmRfdG8/KDp0b19zdHIpfSkge1xuICAgICAgICAgICAgICBzdHIgPSAje2BhcmdgLnRvX3N0cn07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCRjb2VyY2VfdG8oYXJnLCAje0ludGVnZXJ9LCAndG9faW50JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnJWMgcmVxdWlyZXMgYSBjaGFyYWN0ZXInfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzJkZNSU5VUykge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9IHN0ciArICcgJzsgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSAnICcgKyBzdHI7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrIGZvcm1hdF9zZXF1ZW5jZTtcblxuICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgc3RyID0gI3tgR0VUX0FSRygpYC5pbnNwZWN0fTtcbiAgICAgICAgICAgIGlmIChwcmVjaXNpb24gIT09IC0xKSB7IHN0ciA9IHN0ci5zbGljZSgwLCBwcmVjaXNpb24pOyB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MmRk1JTlVTKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gc3RyICsgJyAnOyB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IHdpZHRoKSB7IHN0ciA9ICcgJyArIHN0cjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWsgZm9ybWF0X3NlcXVlbmNlO1xuXG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBzdHIgPSAje2BHRVRfQVJHKClgLnRvX3N9O1xuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiAhPT0gLTEpIHsgc3RyID0gc3RyLnNsaWNlKDAsIHByZWNpc2lvbik7IH1cbiAgICAgICAgICAgIGlmIChmbGFncyZGTUlOVVMpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCB3aWR0aCkgeyBzdHIgPSBzdHIgKyAnICc7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChzdHIubGVuZ3RoIDwgd2lkdGgpIHsgc3RyID0gJyAnICsgc3RyOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhayBmb3JtYXRfc2VxdWVuY2U7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1hbGZvcm1lZCBmb3JtYXQgc3RyaW5nIC0gJSN7YGZvcm1hdF9zdHJpbmcuY2hhckF0KGkpYH1cIn1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICdtYWxmb3JtZWQgZm9ybWF0IHN0cmluZyAtICUnfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ICs9IGZvcm1hdF9zdHJpbmcuc2xpY2UoYmVnaW5fc2xpY2UsIGVuZF9zbGljZSkgKyBzdHI7XG4gICAgICAgIGJlZ2luX3NsaWNlID0gaSArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgjeyRERUJVR30gJiYgcG9zX2FyZ19udW0gPj0gMCAmJiBzZXFfYXJnX251bSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgJ3RvbyBtYW55IGFyZ3VtZW50cyBmb3IgZm9ybWF0IHN0cmluZyd9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQgKyBmb3JtYXRfc3RyaW5nLnNsaWNlKGJlZ2luX3NsaWNlKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIHNwcmludGYgZm9ybWF0XG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpLZXJuZWw+IiwiZm9ybWF0IiwiZm9ybWF0X3N0cmluZyIsIiRyZXRfb3JfMSIsImFyZ3MiLCJsZW5ndGgiLCI9PSIsIjEiLCJbXSIsIjAiLCJyZXNwb25kX3RvPyIsImFyeSIsIk9wYWwiLCJjb2VyY2VfdG8/IiwiQXJyYXkiLCJuaWw/IiwidG9fYSIsInNlbGYiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJ0b19pbnQiLCJmZXRjaCIsIkludGVnZXIiLCJGbG9hdCIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJ0b19hcnkiLCJ0b19zdHIiLCJpbnNwZWN0IiwidG9fcyIsIiRERUJVRyJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7Ozs7QUFDRUMsSUFBQUEsMEJBQUFBLG1CQUFBQSxrQkFBV0MsYUFBRCxFQUhaLEVBR0VEO0FBQUFBLE1BQUFBO0FBQUFBOzs7O01BSEY7O01BRzRCO01BQ3hCLElBQUEsUUFBRyxhQUFBLElBQUEsUUFKUEUsQ0FBQUEsWUFJT0MsSUFBSUMsUUFBQUEsQ0FBQUEsQ0FBUUMsT0FBQUEsQ0FBR0MsQ0FBSEQsQ0FKbkJILENBSU8sQ0FBQTtRQUFvQkYsT0FBQUcsSUFBSUksT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBR0UsZ0JBQUFBLENBQWEsUUFBYkE7TUFBM0I7UUFKUFQsT0FBQTtNQUlPLENBQUEsa0JBQUgsQ0FBQTs7UUFDRVUsTUFBTUMsb0JBQUlDLGVBQUFBLENBQVlULElBQUlJLE9BQUFBLENBQUNDLENBQURELENBQXBCLEVBQXlCTSxxQkFBekIsRUFBZ0MsUUFBNUJEO1FBQ1YsSUFBQSxRQUF1QkYsR0FBR0ksU0FBQUEsQ0FBQUEsQ0FBMUIsQ0FBQTtRQUFBO1VBQUFYLE9BQU9PLEdBQUdLLE1BQUFBLENBQUFBO1FBQVYsRUFGRjs7QUFNSmY7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7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QUFBLENBQU1DLDZCQUFOLEVBQXFCbEIsdUJBQXJCaUI7QUFDaEJqQjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CZ0IsSUFBQUssU0FBQUEsQ0FBU3JCLFNBQVRxQixDQUFxQnJCO0FBQ3pDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CZ0IsSUFBQUssU0FBQUEsQ0FBU3JCLFNBQVRxQixDQUFxQnJCO0FBQ3pDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0JBQW9CZ0IsSUFBQU0sT0FBQUEsQ0FBT3RCLFNBQVBzQixDQUFtQnRCO0FBQ3ZDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUEsWUFBY2dCLElBQUFDLE9BQUFBLENBQU1NLG1DQUFOLEVBQTJCdkIsZ0VBQTNCaUI7QUFDZGpCOztBQUVBQTtBQUNBQTtBQUNBQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQUtTLGdCQUFBQSxDQUFhLFFBQWJBLENBQXNCVCxVQUFZQSxDQUFDQSxHQUFEQSxDQUFLd0IsUUFBQUEsQ0FBQUEsQ0FBUXhCO0FBQ3RFQSxnQkFBa0JBLENBQUNBLEdBQURBLENBQUtTLGdCQUFBQSxDQUFhLFFBQWJBLENBQXNCVDtBQUM3Q0Esb0JBQXNCQSxDQUFDQSxHQUFEQSxDQUFLeUIsUUFBQUEsQ0FBQUEsQ0FBUXpCO0FBQ25DQTtBQUNBQSx3REFBMERxQix1QkFBUXJCO0FBQ2xFQTtBQUNBQTtBQUNBQSxjQUFnQmdCLElBQUFDLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCbEIseUJBQXJCaUI7QUFDaEJqQjtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxTQUFEQSxDQUFXMEIsU0FBQUEsQ0FBQUEsQ0FBUzFCO0FBQ3hDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0JBQW9CQSxDQUFDQSxTQUFEQSxDQUFXMkIsTUFBQUEsQ0FBQUEsQ0FBTTNCO0FBQ3JDQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsWUFBY2dCLElBQUFDLE9BQUFBLENBQU1DLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQStCbEIsdUJBQS9CLENBQXJCaUI7QUFDZGpCO0FBQ0FBOztBQUVBQTtBQUNBQSxVQUFZZ0IsSUFBQUMsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUJsQiw2QkFBckJpQjtBQUNaakI7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQSxVQUFZNEIsWUFBTzVCO0FBQ25CQSxRQUFVZ0IsSUFBQUMsT0FBQUEsQ0FBTUMsNkJBQU4sRUFBcUJsQixzQ0FBckJpQjtBQUNWakI7O0FBRUFBO0FBQ0FBO0lBN2hCRUEsQ0FBQUEsK0JBQUFBO0lBZ2lCQUQsT0FBQSxhQUFNLFNBQU4sRUFBYyxRQUFkO0VBamlCRkEsR0FBQUEsV0FBQUE7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjIwNjg1LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9zdHJpbmcnXG5cbmNsYXNzIEVuY29kaW5nXG4gIGRlZiBzZWxmLnJlZ2lzdGVyKG5hbWUsIG9wdGlvbnMgPSB7fSwgJmJsb2NrKVxuICAgIG5hbWVzID0gW25hbWVdICsgKG9wdGlvbnNbOmFsaWFzZXNdIHx8IFtdKVxuICAgIGFzY2lpID0gb3B0aW9uc1s6YXNjaWldIHx8IGZhbHNlXG4gICAgZHVtbXkgPSBvcHRpb25zWzpkdW1teV0gfHwgZmFsc2VcblxuICAgIGlmIG9wdGlvbnNbOmluaGVyaXRzXVxuICAgICAgZW5jb2RpbmcgPSBvcHRpb25zWzppbmhlcml0c10uY2xvbmVcbiAgICAgIGVuY29kaW5nLmluaXRpYWxpemUobmFtZSwgbmFtZXMsIGFzY2lpLCBkdW1teSlcbiAgICBlbHNlXG4gICAgICBlbmNvZGluZyA9IG5ldyhuYW1lLCBuYW1lcywgYXNjaWksIGR1bW15KVxuICAgIGVuZFxuICAgIGVuY29kaW5nLmluc3RhbmNlX2V2YWwoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cblxuICAgIHJlZ2lzdGVyID0gYE9wYWwuZW5jb2RpbmdzYFxuICAgIG5hbWVzLmVhY2ggZG8gfGVuY29kaW5nX25hbWV8XG4gICAgICBjb25zdF9zZXQgZW5jb2RpbmdfbmFtZS50cignLScsICdfJyksIGVuY29kaW5nXG4gICAgICByZWdpc3Rlci5KU1tlbmNvZGluZ19uYW1lXSA9IGVuY29kaW5nXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbmQobmFtZSlcbiAgICByZXR1cm4gZGVmYXVsdF9leHRlcm5hbCBpZiBuYW1lID09IDpkZWZhdWx0X2V4dGVybmFsXG4gICAgYHJldHVybiBPcGFsLmZpbmRfZW5jb2RpbmcobmFtZSlgXG4gIGVuZFxuXG4gIHNpbmdsZXRvbl9jbGFzcy5hdHRyX2FjY2Vzc29yIDpkZWZhdWx0X2V4dGVybmFsXG5cbiAgYXR0cl9yZWFkZXIgOm5hbWUsIDpuYW1lc1xuXG4gIGRlZiBpbml0aWFsaXplKG5hbWUsIG5hbWVzLCBhc2NpaSwgZHVtbXkpXG4gICAgQG5hbWUgID0gbmFtZVxuICAgIEBuYW1lcyA9IG5hbWVzXG4gICAgQGFzY2lpID0gYXNjaWlcbiAgICBAZHVtbXkgPSBkdW1teVxuICBlbmRcblxuICBkZWYgYXNjaWlfY29tcGF0aWJsZT9cbiAgICBAYXNjaWlcbiAgZW5kXG5cbiAgZGVmIGR1bW15P1xuICAgIEBkdW1teVxuICBlbmRcblxuICBkZWYgYmluYXJ5P1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgQG5hbWVcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIiM8RW5jb2Rpbmc6I3tAbmFtZX0jeycgKGR1bW15KScgaWYgQGR1bW15fT5cIlxuICBlbmRcblxuICAjIG1ldGhvZHMgdG8gaW1wbGVtZW50IHBlciBlbmNvZGluZ1xuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgICV4e1xuICAgICAgdmFyIGxlbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoIShjaGFyY29kZSA+PSAweEQ4MDAgJiYgY2hhcmNvZGUgPD0gMHhEQkZGKSkge1xuICAgICAgICAgIGxlbisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIHZhciBsb3dfc3Vycm9nYXRlID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBjaHIgPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hhcmNvZGUgPj0gMHhEQzAwICYmIGNoYXJjb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgIGxvd19zdXJyb2dhdGUgPSBjaHI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPj0gMHhEODAwICYmIGNoYXJjb2RlIDw9IDB4REJGRikge1xuICAgICAgICAgIGNociA9IGxvd19zdXJyb2dhdGUgKyBjaHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZy5lbmNvZGluZy5uYW1lICE9IFwiVVRGLThcIikge1xuICAgICAgICAgIGNociA9IG5ldyBTdHJpbmcoY2hyKTtcbiAgICAgICAgICBjaHIuZW5jb2RpbmcgPSBzdHJpbmcuZW5jb2Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgT3BhbC55aWVsZDEoYmxvY2ssIGNocik7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvclxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yXG4gIGVuZFxuXG4gIGNsYXNzIEVuY29kaW5nRXJyb3IgPCBTdGFuZGFyZEVycm9yOyBlbmRcbiAgY2xhc3MgQ29tcGF0aWJpbGl0eUVycm9yIDwgRW5jb2RpbmdFcnJvcjsgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi04JywgYWxpYXNlczogWydDUDY1MDAxJ10sIGFzY2lpOiB0cnVlIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICAvLyBUYWtlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9ibG9iL2Y1MmRmZmQ5ZGYwNDQ1YjkzYzBjOTA2NWMyZjhmMGY0NmIyYzcyOWEvaW5kZXguanMjTDE5NTQtTDIwMzJcbiAgICAgIHZhciB1bml0cyA9IEluZmluaXR5O1xuICAgICAgdmFyIGNvZGVQb2ludDtcbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4QkRgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkge1xuICAgICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRGB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAgICN7eWllbGQgYDB4RUZgfTtcbiAgICAgICAgICAgICAgI3t5aWVsZCBgMHhCRmB9O1xuICAgICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICAgICAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSB7XG4gICAgICAgICAgICAje3lpZWxkIGAweEVGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJGYH07XG4gICAgICAgICAgICAje3lpZWxkIGAweEJEYH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5jb2RlIHV0ZjhcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50YH07XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4NiB8IDB4QzBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgI3t5aWVsZCBgY29kZVBvaW50ID4+IDB4QyB8IDB4RTBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODBgfTtcbiAgICAgICAgICAje3lpZWxkIGBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrO1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MGB9O1xuICAgICAgICAgICN7eWllbGQgYGNvZGVQb2ludCAmIDB4M0YgfCAweDgwYH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSW52YWxpZCBjb2RlIHBvaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZShzdHJpbmcpXG4gICAgc3RyaW5nLmJ5dGVzLmxlbmd0aFxuICBlbmRcbmVuZFxuXG5FbmNvZGluZy5yZWdpc3RlciAnVVRGLTE2TEUnIGRvXG4gIGRlZiBlYWNoX2J5dGUoc3RyaW5nLCAmYmxvY2spXG4gICAgJXh7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSA+PiA4YH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYnl0ZXNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoICogMmBcbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0xNkJFJywgaW5oZXJpdHM6IEVuY29kaW5nOjpVVEZfMTZMRSBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcblxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VURi0zMkxFJyBkb1xuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgICN7eWllbGQgYGNvZGUgJiAweGZmYH07XG4gICAgICAgICN7eWllbGQgYGNvZGUgPj4gOGB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aCAqIDRgXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdVVEYtMzJCRScsIGluaGVyaXRzOiBFbmNvZGluZzo6VVRGXzMyTEUgZG9cbiAgZGVmIGVhY2hfYnl0ZShzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIDB9O1xuICAgICAgICAje3lpZWxkIGBjb2RlID4+IDhgfTtcbiAgICAgICAgI3t5aWVsZCBgY29kZSAmIDB4ZmZgfTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdBU0NJSS04QklUJywgYWxpYXNlczogWydCSU5BUlknXSwgYXNjaWk6IHRydWUgZG9cbiAgZGVmIGVhY2hfY2hhcihzdHJpbmcsICZibG9jaylcbiAgICAleHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IG5ldyBTdHJpbmcoc3RyaW5nLmNoYXJBdChpKSk7XG4gICAgICAgIGNoci5lbmNvZGluZyA9IHN0cmluZy5lbmNvZGluZztcbiAgICAgICAgI3t5aWVsZCBgY2hyYH07XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgY2hhcnNpemUoc3RyaW5nKVxuICAgIGBzdHJpbmcubGVuZ3RoYFxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKHN0cmluZywgJmJsb2NrKVxuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAje3lpZWxkIGBjb2RlICYgMHhmZmB9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGJ5dGVzaXplKHN0cmluZylcbiAgICBgc3RyaW5nLmxlbmd0aGBcbiAgZW5kXG5cbiAgZGVmIGJpbmFyeT9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLnJlZ2lzdGVyICdJU08tODg1OS0xJywgYWxpYXNlczogWydJU084ODU5LTEnXSwgYXNjaWk6IHRydWUsIGluaGVyaXRzOiBFbmNvZGluZzo6QVNDSUlfOEJJVFxuRW5jb2RpbmcucmVnaXN0ZXIgJ1VTLUFTQ0lJJywgYWxpYXNlczogWydBU0NJSSddLCBhc2NpaTogdHJ1ZSwgaW5oZXJpdHM6IEVuY29kaW5nOjpBU0NJSV84QklUXG5cbmNsYXNzIFN0cmluZ1xuICBhdHRyX3JlYWRlciA6ZW5jb2RpbmdcbiAgYXR0cl9yZWFkZXIgOmludGVybmFsX2VuY29kaW5nXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdieXRlcycsIG5pbClgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdlbmNvZGluZycsICN7RW5jb2Rpbmc6OlVURl84fSlgXG4gIGBPcGFsLmRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdpbnRlcm5hbF9lbmNvZGluZycsICN7RW5jb2Rpbmc6OlVURl84fSlgXG5cbiAgZGVmIGJcbiAgICBkdXAuZm9yY2VfZW5jb2RpbmcoJ2JpbmFyeScpXG4gIGVuZFxuXG4gIGRlZiBieXRlc2l6ZVxuICAgIEBpbnRlcm5hbF9lbmNvZGluZy5ieXRlc2l6ZShzZWxmKVxuICBlbmRcblxuICBkZWYgZWFjaF9ieXRlKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfYnl0ZSkgeyBieXRlc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIEBpbnRlcm5hbF9lbmNvZGluZy5lYWNoX2J5dGUoc2VsZiwgJmJsb2NrKVxuXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgYnl0ZXNcbiAgICAjIFJFTUlORDogcmVxdWlyZWQgd2hlbiBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBvdGhlcndpc2UgdGhlIGZvbGxvd2luZyBlcnJvciB3aWxsIGJlIHRocm93bjpcbiAgICAjIENhbm5vdCBjcmVhdGUgcHJvcGVydHkgJ2J5dGVzJyBvbiBzdHJpbmcgJ2FiYydcbiAgICAleHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuICN7YG5ldyBTdHJpbmcoc2VsZilgLmVhY2hfYnl0ZS50b19hfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBAYnl0ZXMgfHw9IGVhY2hfYnl0ZS50b19hXG4gICAgQGJ5dGVzLmR1cFxuICBlbmRcblxuICBkZWYgZWFjaF9jaGFyKCZibG9jaylcbiAgICByZXR1cm4gZW51bV9mb3IoOmVhY2hfY2hhcikgeyBsZW5ndGggfSB1bmxlc3MgYmxvY2tfZ2l2ZW4/XG5cbiAgICBAZW5jb2RpbmcuZWFjaF9jaGFyKHNlbGYsICZibG9jaylcblxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIGNoYXJzKCZibG9jaylcbiAgICByZXR1cm4gZWFjaF9jaGFyLnRvX2EgdW5sZXNzIGJsb2NrXG5cbiAgICBlYWNoX2NoYXIoJmJsb2NrKVxuICBlbmRcblxuICBkZWYgZWFjaF9jb2RlcG9pbnQoJmJsb2NrKVxuICAgIHJldHVybiBlbnVtX2ZvciA6ZWFjaF9jb2RlcG9pbnQgdW5sZXNzIGJsb2NrX2dpdmVuP1xuICAgICV4e1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IHNlbGYubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgI3t5aWVsZCBgc2VsZi5jb2RlUG9pbnRBdChpKWB9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBjb2RlcG9pbnRzKCZibG9jaylcbiAgICAjIElmIGEgYmxvY2sgaXMgZ2l2ZW4sIHdoaWNoIGlzIGEgZGVwcmVjYXRlZCBmb3JtLCB3b3JrcyB0aGUgc2FtZSBhcyBlYWNoX2NvZGVwb2ludC5cbiAgICByZXR1cm4gZWFjaF9jb2RlcG9pbnQoJmJsb2NrKSBpZiBibG9ja19naXZlbj9cbiAgICBlYWNoX2NvZGVwb2ludC50b19hXG4gIGVuZFxuXG4gIGRlZiBlbmNvZGUoZW5jb2RpbmcpXG4gICAgYE9wYWwuZW5jKHNlbGYsIGVuY29kaW5nKWBcbiAgZW5kXG5cbiAgZGVmIGZvcmNlX2VuY29kaW5nKGVuY29kaW5nKVxuICAgICV4e1xuICAgICAgdmFyIHN0ciA9IHNlbGY7XG5cbiAgICAgIGlmIChlbmNvZGluZyA9PT0gc3RyLmVuY29kaW5nKSB7IHJldHVybiBzdHI7IH1cblxuICAgICAgZW5jb2RpbmcgPSAje09wYWwuY29lcmNlX3RvIShlbmNvZGluZywgU3RyaW5nLCA6dG9fcyl9O1xuICAgICAgZW5jb2RpbmcgPSAje0VuY29kaW5nLmZpbmQoZW5jb2RpbmcpfTtcblxuICAgICAgaWYgKGVuY29kaW5nID09PSBzdHIuZW5jb2RpbmcpIHsgcmV0dXJuIHN0cjsgfVxuXG4gICAgICBzdHIgPSBPcGFsLnNldF9lbmNvZGluZyhzdHIsIGVuY29kaW5nKTtcblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRieXRlKGlkeClcbiAgICBzdHJpbmdfYnl0ZXMgPSBieXRlc1xuICAgIGlkeCA9IE9wYWwuY29lcmNlX3RvIShpZHgsIEludGVnZXIsIDp0b19pbnQpXG4gICAgcmV0dXJuIGlmIHN0cmluZ19ieXRlcy5sZW5ndGggPCBpZHhcblxuICAgIHN0cmluZ19ieXRlc1tpZHhdXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkob3RoZXIpXG4gICAgJXtcbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBvdGhlci5lbmNvZGluZztcbiAgICAgIHNlbGYuaW50ZXJuYWxfZW5jb2RpbmcgPSBvdGhlci5pbnRlcm5hbF9lbmNvZGluZztcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsZW5ndGhcbiAgICBgc2VsZi5sZW5ndGhgXG4gIGVuZFxuXG4gIGFsaWFzIHNpemUgbGVuZ3RoXG5cbiAgIyBzdHViXG4gIGRlZiB2YWxpZF9lbmNvZGluZz9cbiAgICB0cnVlXG4gIGVuZFxuZW5kXG5cbkVuY29kaW5nLmRlZmF1bHRfZXh0ZXJuYWwgPSBfX0VOQ09ESU5HX19cbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6RW5jb2Rpbmc+IiwicmVnaXN0ZXIiLCJuYW1lIiwib3B0aW9ucyIsIm5hbWVzIiwiKyIsIiRyZXRfb3JfMSIsIltdIiwiYXNjaWkiLCIkcmV0X29yXzIiLCJkdW1teSIsIiRyZXRfb3JfMyIsImVuY29kaW5nIiwiY2xvbmUiLCJpbml0aWFsaXplIiwibmV3IiwiYmxvY2tfZ2l2ZW4/IiwiaW5zdGFuY2VfZXZhbCIsImJsb2NrIiwidG9fcHJvYyIsImVhY2giLCJibG9jayBpbiByZWdpc3RlciIsImVuY29kaW5nX25hbWUiLCJibG9jayAoMiBsZXZlbHMpIGluIHJlZ2lzdGVyIiwiY29uc3Rfc2V0IiwidHIiLCJmaW5kIiwiPT0iLCJkZWZhdWx0X2V4dGVybmFsIiwic2luZ2xldG9uX2NsYXNzIiwiYXR0cl9hY2Nlc3NvciIsImF0dHJfcmVhZGVyIiwiQG5hbWUiLCJAbmFtZXMiLCJAYXNjaWkiLCJAZHVtbXkiLCJhc2NpaV9jb21wYXRpYmxlPyIsImR1bW15PyIsImJpbmFyeT8iLCJ0b19zIiwiaW5zcGVjdCIsImNoYXJzaXplIiwic3RyaW5nIiwiZWFjaF9jaGFyIiwiZWFjaF9ieXRlIiwicmFpc2UiLCJOb3RJbXBsZW1lbnRlZEVycm9yIiwiYnl0ZXNpemUiLCI8Y2xhc3M6RW5jb2RpbmdFcnJvcj4iLCJTdGFuZGFyZEVycm9yIiwiPGNsYXNzOkNvbXBhdGliaWxpdHlFcnJvcj4iLCJFbmNvZGluZ0Vycm9yIiwiRW5jb2RpbmciLCJibG9jayBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiA8dG9wIChyZXF1aXJlZCk+IiwiYnl0ZXMiLCJsZW5ndGgiLCJFbmNvZGluZzo6VVRGXzE2TEUiLCIwIiwiRW5jb2Rpbmc6OlVURl8zMkxFIiwiRW5jb2Rpbmc6OkFTQ0lJXzhCSVQiLCI8Y2xhc3M6U3RyaW5nPiIsIkVuY29kaW5nOjpVVEZfOCIsImIiLCJkdXAiLCJmb3JjZV9lbmNvZGluZyIsIkBpbnRlcm5hbF9lbmNvZGluZyIsImVudW1fZm9yIiwiYmxvY2sgaW4gZWFjaF9ieXRlIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2J5dGUiLCJ0b19hIiwiQGJ5dGVzIiwiJHJldF9vcl80IiwiYmxvY2sgaW4gZWFjaF9jaGFyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX2NoYXIiLCJAZW5jb2RpbmciLCJjaGFycyIsImVhY2hfY29kZXBvaW50IiwiY29kZXBvaW50cyIsImVuY29kZSIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiZ2V0Ynl0ZSIsImlkeCIsInN0cmluZ19ieXRlcyIsIkludGVnZXIiLCI8IiwiaW5pdGlhbGl6ZV9jb3B5Iiwib3RoZXIiLCJ2YWxpZF9lbmNvZGluZz8iLCIkd3JpdGVyIiwiZGVmYXVsdF9leHRlcm5hbD0iLCItIiwiMSJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsZ0JBQVJFO0VBRUFDO0VBQUFBOztJQUFBQTs7QUFBQUE7O0lBQ0VDLFVBQUlILElBQUpHLGVBQUFBLHVCQUFBQSxvQkFBa0JDLElBQUQsRUFBT0MsT0FBeEJGO0FBQUFBLE1BQUFBOztNQUFBQTs7O01BQXNDOztNQUFkO01BQUEsWUFBVSxZQUFBLEVBQVY7TUFBQTtNQUN0QkcsUUFBZUMsU0FBUCxDQUFDSCxJQUFELENBQU9HLEVBQUcsYUFBQSxJQUFBLFFBSnRCQyxDQUFBQSxZQUlzQkgsT0FBT0ksT0FB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MTMxNCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWF0aC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIGhlbHBlcnM6IHR5cGVfZXJyb3JcblxubW9kdWxlIE1hdGhcbiAgRSAgPSBgTWF0aC5FYFxuICBQSSA9IGBNYXRoLlBJYFxuXG4gIERvbWFpbkVycm9yID0gQ2xhc3MubmV3KFN0YW5kYXJkRXJyb3IpXG5cbiAgZGVmIHNlbGYuY2hlY2tlZChtZXRob2QsICphcmdzKVxuICAgICV4e1xuICAgICAgaWYgKGlzTmFOKGFyZ3NbMF0pIHx8IChhcmdzLmxlbmd0aCA9PSAyICYmIGlzTmFOKGFyZ3NbMV0pKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gTWF0aFttZXRob2RdLmFwcGx5KG51bGwsIGFyZ3MpO1xuXG4gICAgICBpZiAoaXNOYU4ocmVzdWx0KSkge1xuICAgICAgICAje3JhaXNlIERvbWFpbkVycm9yLCBcIk51bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXFxcIiN7bWV0aG9kfVxcXCJcIn07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5mbG9hdCEodmFsdWUpXG4gICAgRmxvYXQodmFsdWUpXG4gIHJlc2N1ZSBBcmd1bWVudEVycm9yXG4gICAgcmFpc2UgYCR0eXBlX2Vycm9yKHZhbHVlLCAje0Zsb2F0fSlgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmludGVnZXIhKHZhbHVlKVxuICAgIEludGVnZXIodmFsdWUpXG4gIHJlc2N1ZSBBcmd1bWVudEVycm9yXG4gICAgcmFpc2UgYCR0eXBlX2Vycm9yKHZhbHVlLCAje0ludGVnZXJ9KWBcbiAgZW5kXG5cbiAgbW9kdWxlX2Z1bmN0aW9uXG5cbiAgZGVmIGFjb3MoeClcbiAgICBNYXRoLmNoZWNrZWQgOmFjb3MsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5hY29zaGApXG4gICAgJXh7XG4gICAgICBNYXRoLmFjb3NoID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCArIE1hdGguc3FydCh4ICogeCAtIDEpKTtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhY29zaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6YWNvc2gsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhc2luKHgpXG4gICAgTWF0aC5jaGVja2VkIDphc2luLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguYXNpbmhgKVxuICAgICV4e1xuICAgICAgTWF0aC5hc2luaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHggKyBNYXRoLnNxcnQoeCAqIHggKyAxKSlcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBhc2luaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6YXNpbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBhdGFuKHgpXG4gICAgTWF0aC5jaGVja2VkIDphdGFuLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgYXRhbjIoeSwgeClcbiAgICBNYXRoLmNoZWNrZWQgOmF0YW4yLCBNYXRoLmZsb2F0ISh5KSwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmF0YW5oYClcbiAgICAleHtcbiAgICAgIE1hdGguYXRhbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBNYXRoLmxvZygoMSArIHgpIC8gKDEgLSB4KSk7XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgYXRhbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOmF0YW5oLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguY2JydGApXG4gICAgJXh7XG4gICAgICBNYXRoLmNicnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4IDwgMCkge1xuICAgICAgICAgIHJldHVybiAtTWF0aC5jYnJ0KC14KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByICA9IHgsXG4gICAgICAgICAgICBleCA9IDA7XG5cbiAgICAgICAgd2hpbGUgKHIgPCAwLjEyNSkge1xuICAgICAgICAgIHIgKj0gODtcbiAgICAgICAgICBleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHIgPiAxLjApIHtcbiAgICAgICAgICByICo9IDAuMTI1O1xuICAgICAgICAgIGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICByID0gKC0wLjQ2OTQ2MTE2ICogciArIDEuMDcyMzAyKSAqIHIgKyAwLjM4MTI1MTM7XG5cbiAgICAgICAgd2hpbGUgKGV4IDwgMCkge1xuICAgICAgICAgIHIgKj0gMC41O1xuICAgICAgICAgIGV4Kys7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoZXggPiAwKSB7XG4gICAgICAgICAgciAqPSAyO1xuICAgICAgICAgIGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcbiAgICAgICAgciA9ICgyLjAgLyAzLjApICogciArICgxLjAgLyAzLjApICogeCAvIChyICogcik7XG4gICAgICAgIHIgPSAoMi4wIC8gMy4wKSAqIHIgKyAoMS4wIC8gMy4wKSAqIHggLyAociAqIHIpO1xuICAgICAgICByID0gKDIuMCAvIDMuMCkgKiByICsgKDEuMCAvIDMuMCkgKiB4IC8gKHIgKiByKTtcblxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBjYnJ0KHgpXG4gICAgTWF0aC5jaGVja2VkIDpjYnJ0LCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgY29zKHgpXG4gICAgTWF0aC5jaGVja2VkIDpjb3MsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5jb3NoYClcbiAgICAleHtcbiAgICAgIE1hdGguY29zaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh4KSArIE1hdGguZXhwKC14KSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGNvc2goeClcbiAgICBNYXRoLmNoZWNrZWQgOmNvc2gsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5lcmZgKVxuICAgICV4e1xuICAgICAgT3BhbC5kZWZpbmVQcm9wZXJ0eShNYXRoLCAnZXJmJywgZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgQTEgPSAgMC4yNTQ4Mjk1OTIsXG4gICAgICAgICAgICBBMiA9IC0wLjI4NDQ5NjczNixcbiAgICAgICAgICAgIEEzID0gIDEuNDIxNDEzNzQxLFxuICAgICAgICAgICAgQTQgPSAtMS40NTMxNTIwMjcsXG4gICAgICAgICAgICBBNSA9ICAxLjA2MTQwNTQyOSxcbiAgICAgICAgICAgIFAgID0gIDAuMzI3NTkxMTtcblxuICAgICAgICB2YXIgc2lnbiA9IDE7XG5cbiAgICAgICAgaWYgKHggPCAwKSB7XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gTWF0aC5hYnMoeCk7XG5cbiAgICAgICAgdmFyIHQgPSAxLjAgLyAoMS4wICsgUCAqIHgpO1xuICAgICAgICB2YXIgeSA9IDEuMCAtICgoKCgoQTUgKiB0ICsgQTQpICogdCkgKyBBMykgKiB0ICsgQTIpICogdCArIEExKSAqIHQgKiBNYXRoLmV4cCgteCAqIHgpO1xuXG4gICAgICAgIHJldHVybiBzaWduICogeTtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVyZih4KVxuICAgIE1hdGguY2hlY2tlZCA6ZXJmLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGguZXJmY2ApXG4gICAgJXh7XG4gICAgICBPcGFsLmRlZmluZVByb3BlcnR5KE1hdGgsICdlcmZjJywgZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgeiA9IE1hdGguYWJzKHgpLFxuICAgICAgICAgICAgdCA9IDEuMCAvICgwLjUgKiB6ICsgMS4wKTtcblxuICAgICAgICB2YXIgQTEgPSB0ICogMC4xNzA4NzI3NyArIC0wLjgyMjE1MjIzLFxuICAgICAgICAgICAgQTIgPSB0ICogQTEgKyAxLjQ4ODUxNTg3LFxuICAgICAgICAgICAgQTMgPSB0ICogQTIgKyAtMS4xMzUyMDM5OCxcbiAgICAgICAgICAgIEE0ID0gdCAqIEEzICsgMC4yNzg4NjgwNyxcbiAgICAgICAgICAgIEE1ID0gdCAqIEE0ICsgLTAuMTg2Mjg4MDYsXG4gICAgICAgICAgICBBNiA9IHQgKiBBNSArIDAuMDk2Nzg0MTgsXG4gICAgICAgICAgICBBNyA9IHQgKiBBNiArIDAuMzc0MDkxOTYsXG4gICAgICAgICAgICBBOCA9IHQgKiBBNyArIDEuMDAwMDIzNjgsXG4gICAgICAgICAgICBBOSA9IHQgKiBBOCxcbiAgICAgICAgICAgIEExMCA9IC16ICogeiAtIDEuMjY1NTEyMjMgKyBBOTtcblxuICAgICAgICB2YXIgYSA9IHQgKiBNYXRoLmV4cChBMTApO1xuXG4gICAgICAgIGlmICh4IDwgMC4wKSB7XG4gICAgICAgICAgcmV0dXJuIDIuMCAtIGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGVyZmMoeClcbiAgICBNYXRoLmNoZWNrZWQgOmVyZmMsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBleHAoeClcbiAgICBNYXRoLmNoZWNrZWQgOmV4cCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgZGVmIGZyZXhwKHgpXG4gICAgeCA9IE1hdGguZmxvYXQhKHgpXG5cbiAgICAleHtcbiAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICByZXR1cm4gW05hTiwgMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBleCAgID0gTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyh4KSkgLyBNYXRoLmxvZygyKSkgKyAxLFxuICAgICAgICAgIGZyYWMgPSB4IC8gTWF0aC5wb3coMiwgZXgpO1xuXG4gICAgICByZXR1cm4gW2ZyYWMsIGV4XTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnYW1tYShuKVxuICAgIG4gPSBNYXRoLmZsb2F0IShuKVxuXG4gICAgJXh7XG4gICAgICB2YXIgaSwgdCwgeCwgdmFsdWUsIHJlc3VsdCwgdHdvTiwgdGhyZWVOLCBmb3VyTiwgZml2ZU47XG5cbiAgICAgIHZhciBHID0gNC43NDIxODc1O1xuXG4gICAgICB2YXIgUCA9IFtcbiAgICAgICAgIDAuOTk5OTk5OTk5OTk5OTk3MDkxODIsXG4gICAgICAgICA1Ny4xNTYyMzU2NjU4NjI5MjM1MTcsXG4gICAgICAgIC01OS41OTc5NjAzNTU0NzU0OTEyNDgsXG4gICAgICAgICAxNC4xMzYwOTc5NzQ3NDE3NDcxNzQsXG4gICAgICAgIC0wLjQ5MTkxMzgxNjA5NzYyMDE5OTc4LFxuICAgICAgICAgMC4zMzk5NDY0OTk4NDgxMTg4ODY5OWUtNCxcbiAgICAgICAgIDAuNDY1MjM2Mjg5MjcwNDg1NzU2NjVlLTQsXG4gICAgICAgIC0wLjk4Mzc0NDc1MzA0ODc5NTY0Njc3ZS00LFxuICAgICAgICAgMC4xNTgwODg3MDMyMjQ5MTI0ODg4NGUtMyxcbiAgICAgICAgLTAuMjEwMjY0NDQxNzI0MTA0ODgzMTllLTMsXG4gICAgICAgICAwLjIxNzQzOTYxODExNTIxMjY0MzIwZS0zLFxuICAgICAgICAtMC4xNjQzMTgxMDY1MzY3NjM4OTAyMmUtMyxcbiAgICAgICAgIDAuODQ0MTgyMjM5ODM4NTI3NDMyOTNlLTQsXG4gICAgICAgIC0wLjI2MTkwODM4NDAxNTgxNDA4NjcwZS00LFxuICAgICAgICAgMC4zNjg5OTE4MjY1OTUzMTYyMjcwNGUtNVxuICAgICAgXTtcblxuXG4gICAgICBpZiAoaXNOYU4obikpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XG4gICAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID09PSAtMSB8fCBuID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgI3tyYWlzZSBEb21haW5FcnJvciwgJ051bWVyaWNhbCBhcmd1bWVudCBpcyBvdXQgb2YgZG9tYWluIC0gXCJnYW1tYVwiJ307XG4gICAgICB9XG5cbiAgICAgIGlmICgje0ludGVnZXIgPT09IG59KSB7XG4gICAgICAgIGlmIChuIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gaXNGaW5pdGUobikgPyBJbmZpbml0eSA6IE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuID4gMTcxKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgID0gbiAtIDI7XG4gICAgICAgIHJlc3VsdCA9IG4gLSAxO1xuXG4gICAgICAgIHdoaWxlICh2YWx1ZSA+IDEpIHtcbiAgICAgICAgICByZXN1bHQgKj0gdmFsdWU7XG4gICAgICAgICAgdmFsdWUtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXN1bHQgPT0gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAobiA8IDAuNSkge1xuICAgICAgICByZXR1cm4gTWF0aC5QSSAvIChNYXRoLnNpbihNYXRoLlBJICogbikgKiAje01hdGguZ2FtbWEoMSAtIG4pfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID49IDE3MS4zNSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuID4gODUuMCkge1xuICAgICAgICB0d29OICAgPSBuICogbjtcbiAgICAgICAgdGhyZWVOID0gdHdvTiAqIG47XG4gICAgICAgIGZvdXJOICA9IHRocmVlTiAqIG47XG4gICAgICAgIGZpdmVOICA9IGZvdXJOICogbjtcblxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KDIgKiBNYXRoLlBJIC8gbikgKiBNYXRoLnBvdygobiAvIE1hdGguRSksIG4pICpcbiAgICAgICAgICAoMSArIDEgLyAoMTIgKiBuKSArIDEgLyAoMjg4ICogdHdvTikgLSAxMzkgLyAoNTE4NDAgKiB0aHJlZU4pIC1cbiAgICAgICAgICA1NzEgLyAoMjQ4ODMyMCAqIGZvdXJOKSArIDE2Mzg3OSAvICgyMDkwMTg4ODAgKiBmaXZlTikgK1xuICAgICAgICAgIDUyNDY4MTkgLyAoNzUyNDY3OTY4MDAgKiBmaXZlTiAqIG4pKTtcbiAgICAgIH1cblxuICAgICAgbiAtPSAxO1xuICAgICAgeCAgPSBQWzBdO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgUC5sZW5ndGg7ICsraSkge1xuICAgICAgICB4ICs9IFBbaV0gLyAobiArIGkpO1xuICAgICAgfVxuXG4gICAgICB0ID0gbiArIEcgKyAwLjU7XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoMiAqIE1hdGguUEkpICogTWF0aC5wb3codCwgbiArIDAuNSkgKiBNYXRoLmV4cCgtdCkgKiB4O1xuICAgIH1cbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmh5cG90YClcbiAgICAleHtcbiAgICAgIE1hdGguaHlwb3QgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSlcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBoeXBvdCh4LCB5KVxuICAgIE1hdGguY2hlY2tlZCA6aHlwb3QsIE1hdGguZmxvYXQhKHgpLCBNYXRoLmZsb2F0ISh5KVxuICBlbmRcblxuICBkZWYgbGRleHAobWFudGlzc2EsIGV4cG9uZW50KVxuICAgIG1hbnRpc3NhID0gTWF0aC5mbG9hdCEobWFudGlzc2EpXG4gICAgZXhwb25lbnQgPSBNYXRoLmludGVnZXIhKGV4cG9uZW50KVxuXG4gICAgJXh7XG4gICAgICBpZiAoaXNOYU4oZXhwb25lbnQpKSB7XG4gICAgICAgICN7cmFpc2UgUmFuZ2VFcnJvciwgJ2Zsb2F0IE5hTiBvdXQgb2YgcmFuZ2Ugb2YgaW50ZWdlcid9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFudGlzc2EgKiBNYXRoLnBvdygyLCBleHBvbmVudCk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgbGdhbW1hKG4pXG4gICAgJXh7XG4gICAgICBpZiAobiA9PSAtMSkge1xuICAgICAgICByZXR1cm4gW0luZmluaXR5LCAxXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW01hdGgubG9nKE1hdGguYWJzKCN7TWF0aC5nYW1tYShuKX0pKSwgI3tNYXRoLmdhbW1hKG4pfSA8IDAgPyAtMSA6IDFdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZyh4LCBiYXNlID0gdW5kZWZpbmVkKVxuICAgIGlmIFN0cmluZyA9PT0geFxuICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKHgsICN7RmxvYXR9KWBcbiAgICBlbmRcblxuICAgIGlmIGBiYXNlID09IG51bGxgXG4gICAgICBNYXRoLmNoZWNrZWQgOmxvZywgTWF0aC5mbG9hdCEoeClcbiAgICBlbHNlXG4gICAgICBpZiBTdHJpbmcgPT09IGJhc2VcbiAgICAgICAgcmFpc2UgYCR0eXBlX2Vycm9yKGJhc2UsICN7RmxvYXR9KWBcbiAgICAgIGVuZFxuXG4gICAgICBNYXRoLmNoZWNrZWQoOmxvZywgTWF0aC5mbG9hdCEoeCkpIC8gTWF0aC5jaGVja2VkKDpsb2csIE1hdGguZmxvYXQhKGJhc2UpKVxuICAgIGVuZFxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgubG9nMTBgKVxuICAgICV4e1xuICAgICAgTWF0aC5sb2cxMCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGxvZzEwKHgpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3tGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgTWF0aC5jaGVja2VkIDpsb2cxMCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5cbiAgdW5sZXNzIGRlZmluZWQ/KGBNYXRoLmxvZzJgKVxuICAgICV4e1xuICAgICAgTWF0aC5sb2cyID0gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMjtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBsb2cyKHgpXG4gICAgaWYgU3RyaW5nID09PSB4XG4gICAgICByYWlzZSBgJHR5cGVfZXJyb3IoeCwgI3tGbG9hdH0pYFxuICAgIGVuZFxuXG4gICAgTWF0aC5jaGVja2VkIDpsb2cyLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgc2luKHgpXG4gICAgTWF0aC5jaGVja2VkIDpzaW4sIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIHVubGVzcyBkZWZpbmVkPyhgTWF0aC5zaW5oYClcbiAgICAleHtcbiAgICAgIE1hdGguc2luaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNpbmgoeClcbiAgICBNYXRoLmNoZWNrZWQgOnNpbmgsIE1hdGguZmxvYXQhKHgpXG4gIGVuZFxuXG4gIGRlZiBzcXJ0KHgpXG4gICAgTWF0aC5jaGVja2VkIDpzcXJ0LCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICBkZWYgdGFuKHgpXG4gICAgeCA9IE1hdGguZmxvYXQhKHgpXG5cbiAgICBpZiB4LmluZmluaXRlP1xuICAgICAgcmV0dXJuIEZsb2F0OjpOQU5cbiAgICBlbmRcblxuICAgIE1hdGguY2hlY2tlZCA6dGFuLCBNYXRoLmZsb2F0ISh4KVxuICBlbmRcblxuICB1bmxlc3MgZGVmaW5lZD8oYE1hdGgudGFuaGApXG4gICAgJXh7XG4gICAgICBNYXRoLnRhbmggPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeCA9PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChNYXRoLmV4cCh4KSAtIE1hdGguZXhwKC14KSkgLyAoTWF0aC5leHAoeCkgKyBNYXRoLmV4cCgteCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBlbmRcblxuICBkZWYgdGFuaCh4KVxuICAgIE1hdGguY2hlY2tlZCA6dGFuaCwgTWF0aC5mbG9hdCEoeClcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPG1vZHVsZTpNYXRoPiIsIkNsYXNzIiwibmV3IiwiU3RhbmRhcmRFcnJvciIsImNoZWNrZWQiLCJzZWxmIiwibWV0aG9kIiwicmFpc2UiLCJEb21haW5FcnJvciIsImZsb2F0ISIsInZhbHVlIiwiRmxvYXQiLCJBcmd1bWVudEVycm9yIiwiaW50ZWdlciEiLCJJbnRlZ2VyIiwibW9kdWxlX2Z1bmN0aW9uIiwiYWNvcyIsIngiLCJNYXRoIiwiYWNvc2giLCJhc2luIiwiYXNpbmgiLCJhdGFuIiwiYXRhbjIiLCJ5IiwiYXRhbmgiLCJjYnJ0IiwiY29zIiwiY29zaCIsImVyZiIsImVyZmMiLCJleHAiLCJmcmV4cCIsImdhbW1hIiwibiIsIj09PSIsIi0iLCIxIiwiaHlwb3QiLCJsZGV4cCIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJSYW5nZUVycm9yIiwibGdhbW1hIiwibG9nIiwiYmFzZSIsIlN0cmluZyIsIi8iLCJsb2cxMCIsImxvZzIiLCJzaW4iLCJzaW5oIiwic3FydCIsInRhbiIsImluZmluaXRlPyIsIkZsb2F0OjpOQU4iLCJ0YW5oIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0UsaUNBQU1BLE1BQU47SUFDQSxrQ0FBTUEsT0FBTjtJQUVBLDJDQUFjQyxxQkFBS0MsS0FBQUEsQ0FBS0MsNkJBQUxELENBQW5CO0lBRUFFLFVBQUlDLElBQUpELGNBQUFBLGtCQUFBQSxtQkFBaUJFLE1BQUQsRUFSbEIsRUFRRUY7QUFBQUEsTUFBQUE7Ozs7TUFSRjs7TUFRMkI7O0FBRTNCQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBLFFBQVVDLElBQUFFLE9BQUFBLENBQU1DLDJCQUFOLEVBQW1CLEVBQUEsR0FBQSwwQ0FBQSxHQUFBLENBQTJDRixNQUEzQyxDQUFBLEdBQUEsSUFBbkJDLENBQXlFSDtBQUNuRkE7O0FBRUFBO0FBQ0FBO0lBYkVBLENBQUFBLDhCQUFBQTtJQWdCQUssVUFBSUosSUFBSkksYUFBQUEscUJBQUFBLFNBQWdCQyxLQUFoQkQ7QUFBQUEsTUFBQUE7O01BQ0U7UUFBQUEsT0FBQUosSUFBQU0sT0FBQUEsQ0FBTUQsS0FBTkM7TUFBQTtRQUNGLHNCQUFPLENBQUFDLDZCQUFBLENBQVA7VUFBQTtZQUNFSCxPQUFBSixJQUFBRSxPQUFBQSxDQUFPRSxtQkFBcUJFLHFCQUFNRixDQUFsQ0Y7VUFERjtRQUFBLENBREU7TUFBQTtJQURGRSxDQUFBQSxnQ0FBQUE7SUFNQUksVUFBSVIsSUFBSlEsZUFBQUEsdUJBQUFBLFNBQWtCSCxLQUFsQkc7QUFBQUEsTUFBQUE7O01BQ0U7UUFBQUEsT0FBQVIsSUFBQVMsU0FBQUEsQ0FBUUosS0FBUkk7TUFBQTtRQUNGLHNCQUFPLENBQUFGLDZCQUFBLENBQVA7VUFBQTtZQUNFQyxPQUFBUixJQUFBRSxPQUFBQSxDQUFPTSxtQkFBcUJDLHVCQUFRRCxDQUFwQ047VUFERjtRQUFBLENBREU7TUFBQTtJQURGTSxDQUFBQSxrQ0FBQUE7SUFNQVIsSUFBQVUsaUJBQUFBLENBQUFBOztBQUVBQyxJQUFBQSx3QkFBQUEsZUFBQUEsZ0JBQVNDLENBQVREO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRSxvQkFBSWQsU0FBQUEsQ0FBUyxNQUFiLEVBQW9CYyxvQkFBSVQsV0FBQUEsQ0FBUVEsQ0FBUlIsQ0FBcEJMO0lBRE5ZLENBQUFBLDBCQUFBQTtJQUlBLElBQUEsUUFBTyxRQUFVaEIsVUFBVixrQkFBUCxDQUFBO0lBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEU7O0FBUUFtQixJQUFBQSx5QkFBQUEsZ0JBQUFBLGlCQUFVRixDQUFWRTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUQsb0JBQUlkLFNBQUFBLENBQVMsT0FBYixFQUFxQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQXJCTDtJQUROZSxDQUFBQSwyQkFBQUE7O0FBSUFDLElBQUFBLHdCQUFBQSxlQUFBQSxnQkFBU0gsQ0FBVEc7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFGLG9CQUFJZCxTQUFBQSxDQUFTLE1BQWIsRUFBb0JjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUFwQkw7SUFETmdCLENBQUFBLDBCQUFBQTtJQUlBLElBQUEsUUFBTyxRQUFVcEIsVUFBVixrQkFBUCxDQUFBO0lBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEU7O0FBUUFxQixJQUFBQSx5QkFBQUEsZ0JBQUFBLGlCQUFVSixDQUFWSTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUgsb0JBQUlkLFNBQUFBLENBQVMsT0FBYixFQUFxQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQXJCTDtJQUROaUIsQ0FBQUEsMkJBQUFBOztBQUlBQyxJQUFBQSx3QkFBQUEsZUFBQUEsZ0JBQVNMLENBQVRLO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBSixvQkFBSWQsU0FBQUEsQ0FBUyxNQUFiLEVBQW9CYyxvQkFBSVQsV0FBQUEsQ0FBUVEsQ0FBUlIsQ0FBcEJMO0lBRE5rQixDQUFBQSwwQkFBQUE7O0FBSUFDLElBQUFBLHlCQUFBQSxnQkFBQUEsaUJBQVVDLENBQUQsRUFBSVAsQ0FBYk07QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFMLG9CQUFJZCxTQUFBQSxDQUFTLE9BQWIsRUFBcUJjLG9CQUFJVCxXQUFBQSxDQUFRZSxDQUFSZixDQUF6QixFQUFxQ1Msb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQXJDTDtJQURObUIsQ0FBQUEsMkJBQUFBO0lBSUEsSUFBQSxRQUFPLFFBQVV2QixVQUFWLGtCQUFQLENBQUE7SUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRTs7QUFRQXlCLElBQUFBLHlCQUFBQSxpQkFBQUEsaUJBQVVSLENBQVZRO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBUCxvQkFBSWQsU0FBQUEsQ0FBUyxPQUFiLEVBQXFCYyxvQkFBSVQsV0FBQUEsQ0FBUVEsQ0FBUlIsQ0FBckJMO0lBRE5xQixDQUFBQSw0QkFBQUE7SUFJQSxJQUFBLFFBQU8sUUFBVXpCLFNBQVYsa0JBQVAsQ0FBQTtJQUFBOztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtJQTNDRTs7QUE4Q0EwQixJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFTVCxDQUFUUztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQVIsb0JBQUlkLFNBQUFBLENBQVMsTUFBYixFQUFvQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQXBCTDtJQUROc0IsQ0FBQUEsMkJBQUFBOztBQUlBQyxJQUFBQSx1QkFBQUEsZUFBQUEsZUFBUVYsQ0FBUlU7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFULG9CQUFJZCxTQUFBQSxDQUFTLEtBQWIsRUFBbUJjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUFuQkw7SUFETnVCLENBQUFBLDBCQUFBQTtJQUlBLElBQUEsUUFBTyxRQUFVM0IsU0FBVixrQkFBUCxDQUFBO0lBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEU7O0FBUUE0QixJQUFBQSx3QkFBQUEsZ0JBQUFBLGdCQUFTWCxDQUFUVztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQVYsb0JBQUlkLFNBQUFBLENBQVMsTUFBYixFQUFvQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQXBCTDtJQUROd0IsQ0FBQUEsMkJBQUFBO0lBSUEsSUFBQSxRQUFPLFFBQVU1QixRQUFWLGtCQUFQLENBQUE7SUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtJQXZCRTs7QUEwQkE2QixJQUFBQSx1QkFBQUEsZUFBQUEsZUFBUVosQ0FBUlk7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFYLG9CQUFJZCxTQUFBQSxDQUFTLEtBQWIsRUFBbUJjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUFuQkw7SUFETnlCLENBQUFBLDBCQUFBQTtJQUlBLElBQUEsUUFBTyxRQUFVN0IsU0FBVixrQkFBUCxDQUFBO0lBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBMUJFOztBQTZCQThCLElBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQVNiLENBQVRhO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBWixvQkFBSWQsU0FBQUEsQ0FBUyxNQUFiLEVBQW9CYyxvQkFBSVQsV0FBQUEsQ0FBUVEsQ0FBUlIsQ0FBcEJMO0lBRE4wQixDQUFBQSwyQkFBQUE7O0FBSUFDLElBQUFBLHVCQUFBQSxlQUFBQSxlQUFRZCxDQUFSYztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWIsb0JBQUlkLFNBQUFBLENBQVMsS0FBYixFQUFtQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQW5CTDtJQUROMkIsQ0FBQUEsMEJBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFVZixDQUFWZTtBQUFBQSxNQUFBQTs7O01BQ0VmLElBQUlDLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUjs7QUFHWnVCO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7SUFaRUEsQ0FBQUEsNEJBQUFBOztBQWVBQyxJQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFVQyxDQUFWRDtBQUFBQSxNQUFBQTs7O01BQ0VDLElBQUloQixvQkFBSVQsV0FBQUEsQ0FBUXlCLENBQVJ6Qjs7QUFHWndCOztBQUVBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7OztBQUdBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBLFFBQVU1QixJQUFBRSxPQUFBQSxDQUFNQywyQkFBTixFQUFtQnlCLGlEQUFuQjFCLENBQW1FMEI7QUFDN0VBOztBQUVBQSxVQUFZbkIsdUJBQVFxQixRQUFBQSxDQUFJRCxDQUFKQyxDQUFNRjtBQUMxQkE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUEsa0RBQW9EZixvQkFBSWUsT0FBQUEsQ0FBU0csVUFBRkMsQ0FBRUQsRUFBRUYsQ0FBRkUsQ0FBVEgsQ0FBY0E7QUFDdEVBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTtJQTdGRUEsQ0FBQUEsNEJBQUFBO0lBZ0dBLElBQUEsUUFBTyxRQUFVakMsVUFBVixrQkFBUCxDQUFBO0lBQUE7O0FBRUZBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0lBTEU7O0FBUUFzQyxJQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFVckIsQ0FBRCxFQUFJTyxDQUFiYztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQXBCLG9CQUFJZCxTQUFBQSxDQUFTLE9BQWIsRUFBcUJjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUF6QixFQUFxQ1Msb0JBQUlULFdBQUFBLENBQVFlLENBQVJmLENBQXJDTDtJQUROa0MsQ0FBQUEsNEJBQUFBOztBQUlBQyxJQUFBQSx5QkFBQUEsaUJBQUFBLGlCQUFVQyxRQUFELEVBQVdDLFFBQXBCRjtBQUFBQSxNQUFBQTs7O01BQ0VDLFdBQVd0QixvQkFBSVQsV0FBQUEsQ0FBUStCLFFBQVIvQjtNQUNmZ0MsV0FBV3ZCLG9CQUFJTCxhQUFBQSxDQUFVNEIsUUFBVjVCOztBQUduQjBCO0FBQ0FBLFFBQVVsQyxJQUFBRSxPQUFBQSxDQUFNbUMsMEJBQU4sRUFBa0JILG1DQUFsQmhDLENBQXNEZ0M7QUFDaEVBOztBQUVBQTtBQUNBQTtJQVZFQSxDQUFBQSw0QkFBQUE7O0FBYUFJLElBQUFBLDBCQUFBQSxrQkFBQUEsa0JBQVdULENBQVhTO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsa0NBQW9DekIsb0JBQUllLE9BQUFBLENBQU9DLENBQVBELENBQVVVLElBQU16QixvQkFBSWUsT0FBQUEsQ0FBT0MsQ0FBUEQsQ0FBVVU7QUFDdEVBO0FBQ0FBO0lBUkVBLENBQUFBLDZCQUFBQTs7QUFXQUMsSUFBQUEsdUJBQUFBLGVBQUFBLGVBQVEzQixDQUFELEVBQUk0QixJQUFYRDtBQUFBQSxNQUFBQTs7OztNQUNFLElBQUEsUUFBR0Usc0JBQU9YLFFBQUFBLENBQUlsQixDQUFKa0IsQ0FBVixDQUFBO1FBQ0U5QixJQUFBRSxPQUFBQSxDQUFPcUMsZUFBaUJqQyxxQkFBTWlDLENBQTlCckMsQ0FERjtNQUlBLElBQUEsUUFBSXFDLFlBQUosQ0FBQTtRQUNFQSxPQUFBMUIsb0JBQUlkLFNBQUFBLENBQVMsS0FBYixFQUFtQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQW5CTDtNQUROOztRQUdFLElBQUEsUUFBRzBDLHNCQUFPWCxRQUFBQSxDQUFJVSxJQUFKVixDQUFWLENBQUE7VUFDRTlCLElBQUFFLE9BQUFBLENBQU9xQyxrQkFBb0JqQyxxQkFBTWlDLENBQWpDckMsQ0FERjtRQUlBcUMsT0FBbUNHLFdBQW5DN0Isb0JBQUlkLFNBQUFBLENBQVMsS0FBYixFQUFtQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQW5CTCxDQUErQjJDLEVBQUU3QixvQkFBSWQsU0FBQUEsQ0FBUyxLQUFiLEVBQW1CYyxvQkFBSVQsV0FBQUEsQ0FBUW9DLElBQVJwQyxDQUFuQkwsQ0FBTjJDO01BUHJDO0lBTEZILENBQUFBLDJCQUFBQTtJQWdCQSxJQUFBLFFBQU8sUUFBVTVDLFVBQVYsa0JBQVAsQ0FBQTtJQUFBOztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFOztBQVFBZ0QsSUFBQUEseUJBQUFBLGlCQUFBQSxpQkFBVS9CLENBQVYrQjtBQUFBQSxNQUFBQTs7O01BQ0UsSUFBQSxRQUFHRixzQkFBT1gsUUFBQUEsQ0FBSWxCLENBQUprQixDQUFWLENBQUE7UUFDRTlCLElBQUFFLE9BQUFBLENBQU95QyxlQUFpQnJDLHFCQUFNcUMsQ0FBOUJ6QyxDQURGO01BSUF5QyxPQUFBOUIsb0JBQUlkLFNBQUFBLENBQVMsT0FBYixFQUFxQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQXJCTDtJQUxONEMsQ0FBQUEsNEJBQUFBO0lBUUEsSUFBQSxRQUFPLFFBQVVoRCxTQUFWLGtCQUFQLENBQUE7SUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7SUFMRTs7QUFRQWlELElBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQVNoQyxDQUFUZ0M7QUFBQUEsTUFBQUE7OztNQUNFLElBQUEsUUFBR0gsc0JBQU9YLFFBQUFBLENBQUlsQixDQUFKa0IsQ0FBVixDQUFBO1FBQ0U5QixJQUFBRSxPQUFBQSxDQUFPMEMsZUFBaUJ0QyxxQkFBTXNDLENBQTlCMUMsQ0FERjtNQUlBMEMsT0FBQS9CLG9CQUFJZCxTQUFBQSxDQUFTLE1BQWIsRUFBb0JjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUFwQkw7SUFMTjZDLENBQUFBLDJCQUFBQTs7QUFRQUMsSUFBQUEsdUJBQUFBLGVBQUFBLGVBQVFqQyxDQUFSaUM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUFoQyxvQkFBSWQsU0FBQUEsQ0FBUyxLQUFiLEVBQW1CYyxvQkFBSVQsV0FBQUEsQ0FBUVEsQ0FBUlIsQ0FBbkJMO0lBRE44QyxDQUFBQSwwQkFBQUE7SUFJQSxJQUFBLFFBQU8sUUFBVWxELFNBQVYsa0JBQVAsQ0FBQTtJQUFBOztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUxFOztBQVFBbUQsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBU2xDLENBQVRrQztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWpDLG9CQUFJZCxTQUFBQSxDQUFTLE1BQWIsRUFBb0JjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUFwQkw7SUFETitDLENBQUFBLDJCQUFBQTs7QUFJQUMsSUFBQUEsd0JBQUFBLGdCQUFBQSxnQkFBU25DLENBQVRtQztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQWxDLG9CQUFJZCxTQUFBQSxDQUFTLE1BQWIsRUFBb0JjLG9CQUFJVCxXQUFBQSxDQUFRUSxDQUFSUixDQUFwQkw7SUFETmdELENBQUFBLDJCQUFBQTs7QUFJQUMsSUFBQUEsdUJBQUFBLGVBQUFBLGVBQVFwQyxDQUFSb0M7QUFBQUEsTUFBQUE7OztNQUNFcEMsSUFBSUMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSO01BRVIsSUFBQSxRQUFHUSxDQUFDcUMsY0FBQUEsQ0FBQUEsQ0FBSixDQUFBO1FBQ0UsT0FBT0MsSUFBQTVDLHFCQUFBNEMsUUFEVDtNQUlBRixPQUFBbkMsb0JBQUlkLFNBQUFBLENBQVMsS0FBYixFQUFtQmMsb0JBQUlULFdBQUFBLENBQVFRLENBQVJSLENBQW5CTDtJQVBOaUQsQ0FBQUEsMEJBQUFBO0lBVUEsSUFBQSxRQUFPLFFBQVVyRCxTQUFWLGtCQUFQLENBQUE7SUFBQTs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFiRTtJQWdCQUEsT0FBQXdELENBQUFBLHdCQUFBQSxnQkFBQUEsZ0JBQVN2QyxDQUFUdUM7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF0QyxvQkFBSWQsU0FBQUEsQ0FBUyxNQUFiLEVBQW9CYyxvQkFBSVQsV0FBQUEsQ0FBUVEsQ0FBUlIsQ0FBcEJMO0lBRE5vRCxDQUFBQSwyQkFBQUEsQ0FBQUE7RUE5Y0Z4RCxHQUFBQSxXQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjE4NjIsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2NvbXBsZXgucmIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSAnY29yZWxpYi9udW1lcmljJ1xuXG5jbGFzcyBDb21wbGV4IDwgTnVtZXJpY1xuICBkZWYgc2VsZi5yZWN0KHJlYWwsIGltYWcgPSAwKVxuICAgIHVubGVzcyBOdW1lcmljID09PSByZWFsICYmIHJlYWwucmVhbD8gJiYgTnVtZXJpYyA9PT0gaW1hZyAmJiBpbWFnLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHJlYWwsIGltYWcpXG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyByZWN0YW5ndWxhciByZWN0XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnBvbGFyKHIsIHRoZXRhID0gMClcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gciAmJiByLnJlYWw/ICYmIE51bWVyaWMgPT09IHRoZXRhICYmIHRoZXRhLnJlYWw/XG4gICAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYSByZWFsJ1xuICAgIGVuZFxuXG4gICAgbmV3KHIgKiBNYXRoLmNvcyh0aGV0YSksIHIgKiBNYXRoLnNpbih0aGV0YSkpXG4gIGVuZFxuXG4gIGF0dHJfcmVhZGVyIDpyZWFsLCA6aW1hZ1xuXG4gIGRlZiBpbml0aWFsaXplKHJlYWwsIGltYWcgPSAwKVxuICAgIEByZWFsID0gcmVhbFxuICAgIEBpbWFnID0gaW1hZ1xuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBbb3RoZXIsIHNlbGZdXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIFtDb21wbGV4Lm5ldyhvdGhlciwgMCksIHNlbGZdXG4gICAgZWxzZVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7b3RoZXIuY2xhc3N9IGNhbid0IGJlIGNvZXJjZWQgaW50byBDb21wbGV4XCJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBAcmVhbCA9PSBvdGhlci5yZWFsICYmIEBpbWFnID09IG90aGVyLmltYWdcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQHJlYWwgPT0gb3RoZXIgJiYgQGltYWcgPT0gMFxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIC1AXG4gICAgQ29tcGxleCgtQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgaWYgQ29tcGxleCA9PT0gb3RoZXJcbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlci5yZWFsLCBAaW1hZyArIG90aGVyLmltYWcpXG4gICAgZWxzaWYgTnVtZXJpYyA9PT0gb3RoZXIgJiYgb3RoZXIucmVhbD9cbiAgICAgIENvbXBsZXgoQHJlYWwgKyBvdGhlciwgQGltYWcpXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIENvbXBsZXggPT09IG90aGVyXG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIucmVhbCwgQGltYWcgLSBvdGhlci5pbWFnKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG90aGVyICYmIG90aGVyLnJlYWw/XG4gICAgICBDb21wbGV4KEByZWFsIC0gb3RoZXIsIEBpbWFnKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLnJlYWwgLSBAaW1hZyAqIG90aGVyLmltYWcsXG4gICAgICAgIEByZWFsICogb3RoZXIuaW1hZyArIEBpbWFnICogb3RoZXIucmVhbCxcbiAgICAgIClcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbCAqIG90aGVyLCBAaW1hZyAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgaWYgKE51bWJlciA9PT0gQHJlYWwgJiYgQHJlYWwubmFuPykgfHwgKE51bWJlciA9PT0gQGltYWcgJiYgQGltYWcubmFuPykgfHxcbiAgICAgICAgIChOdW1iZXIgPT09IG90aGVyLnJlYWwgJiYgb3RoZXIucmVhbC5uYW4/KSB8fCAoTnVtYmVyID09PSBvdGhlci5pbWFnICYmIG90aGVyLmltYWcubmFuPylcbiAgICAgICAgQ29tcGxleC5uZXcoRmxvYXQ6Ok5BTiwgRmxvYXQ6Ok5BTilcbiAgICAgIGVsc2VcbiAgICAgICAgc2VsZiAqIG90aGVyLmNvbmogLyBvdGhlci5hYnMyXG4gICAgICBlbmRcbiAgICBlbHNpZiBOdW1lcmljID09PSBvdGhlciAmJiBvdGhlci5yZWFsP1xuICAgICAgQ29tcGxleChAcmVhbC5xdW8ob3RoZXIpLCBAaW1hZy5xdW8ob3RoZXIpKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgaWYgb3RoZXIgPT0gMFxuICAgICAgcmV0dXJuIENvbXBsZXgubmV3KDEsIDApXG4gICAgZW5kXG5cbiAgICBpZiBDb21wbGV4ID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuICAgICAgb3JlICAgICAgPSBvdGhlci5yZWFsXG4gICAgICBvaW0gICAgICA9IG90aGVyLmltYWdcbiAgICAgIG5yICAgICAgID0gTWF0aC5leHAob3JlICogTWF0aC5sb2cocikgLSBvaW0gKiB0aGV0YSlcbiAgICAgIG50aGV0YSAgID0gdGhldGEgKiBvcmUgKyBvaW0gKiBNYXRoLmxvZyhyKVxuXG4gICAgICBDb21wbGV4LnBvbGFyKG5yLCBudGhldGEpXG4gICAgZWxzaWYgSW50ZWdlciA9PT0gb3RoZXJcbiAgICAgIGlmIG90aGVyID4gMFxuICAgICAgICB4ID0gc2VsZlxuICAgICAgICB6ID0geFxuICAgICAgICBuID0gb3RoZXIgLSAxXG5cbiAgICAgICAgd2hpbGUgbiAhPSAwXG4gICAgICAgICAgZGl2LCBtb2QgPSBuLmRpdm1vZCgyKVxuICAgICAgICAgIHdoaWxlIG1vZCA9PSAwXG4gICAgICAgICAgICB4ID0gQ29tcGxleCh4LnJlYWwgKiB4LnJlYWwgLSB4LmltYWcgKiB4LmltYWcsIDIgKiB4LnJlYWwgKiB4LmltYWcpXG4gICAgICAgICAgICBuID0gZGl2XG4gICAgICAgICAgICBkaXYsIG1vZCA9IG4uZGl2bW9kKDIpXG4gICAgICAgICAgZW5kXG5cbiAgICAgICAgICB6ICo9IHhcbiAgICAgICAgICBuIC09IDFcbiAgICAgICAgZW5kXG5cbiAgICAgICAgelxuICAgICAgZWxzZVxuICAgICAgICAoUmF0aW9uYWwubmV3KDEsIDEpIC8gc2VsZikqKi1vdGhlclxuICAgICAgZW5kXG4gICAgZWxzaWYgRmxvYXQgPT09IG90aGVyIHx8IFJhdGlvbmFsID09PSBvdGhlclxuICAgICAgciwgdGhldGEgPSBwb2xhclxuXG4gICAgICBDb21wbGV4LnBvbGFyKHIqKm90aGVyLCB0aGV0YSAqIG90aGVyKVxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqKiwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGFic1xuICAgIE1hdGguaHlwb3QoQHJlYWwsIEBpbWFnKVxuICBlbmRcblxuICBkZWYgYWJzMlxuICAgIEByZWFsICogQHJlYWwgKyBAaW1hZyAqIEBpbWFnXG4gIGVuZFxuXG4gIGRlZiBhbmdsZVxuICAgIE1hdGguYXRhbjIoQGltYWcsIEByZWFsKVxuICBlbmRcblxuICBhbGlhcyBhcmcgYW5nbGVcblxuICBkZWYgY29ualxuICAgIENvbXBsZXgoQHJlYWwsIC1AaW1hZylcbiAgZW5kXG5cbiAgYWxpYXMgY29uanVnYXRlIGNvbmpcblxuICBkZWYgZGVub21pbmF0b3JcbiAgICBAcmVhbC5kZW5vbWluYXRvci5sY20oQGltYWcuZGVub21pbmF0b3IpXG4gIGVuZFxuXG4gIGFsaWFzIGRpdmlkZSAvXG5cbiAgZGVmIGVxbD8ob3RoZXIpXG4gICAgQ29tcGxleCA9PT0gb3RoZXIgJiYgQHJlYWwuY2xhc3MgPT0gQGltYWcuY2xhc3MgJiYgc2VsZiA9PSBvdGhlclxuICBlbmRcblxuICBkZWYgZmRpdihvdGhlcilcbiAgICB1bmxlc3MgTnVtZXJpYyA9PT0gb3RoZXJcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCIje290aGVyLmNsYXNzfSBjYW4ndCBiZSBjb2VyY2VkIGludG8gQ29tcGxleFwiXG4gICAgZW5kXG5cbiAgICBzZWxmIC8gb3RoZXJcbiAgZW5kXG5cbiAgZGVmIGZpbml0ZT9cbiAgICBAcmVhbC5maW5pdGU/ICYmIEBpbWFnLmZpbml0ZT9cbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBcIkNvbXBsZXg6I3tAcmVhbH06I3tAaW1hZ31cIlxuICBlbmRcblxuICBhbGlhcyBpbWFnaW5hcnkgaW1hZ1xuXG4gIGRlZiBpbmZpbml0ZT9cbiAgICBAcmVhbC5pbmZpbml0ZT8gfHwgQGltYWcuaW5maW5pdGU/XG4gIGVuZFxuXG4gIGRlZiBpbnNwZWN0XG4gICAgXCIoI3tzZWxmfSlcIlxuICBlbmRcblxuICBhbGlhcyBtYWduaXR1ZGUgYWJzXG5cbiAgdW5kZWYgbmVnYXRpdmU/XG5cbiAgZGVmIG51bWVyYXRvclxuICAgIGQgPSBkZW5vbWluYXRvclxuXG4gICAgQ29tcGxleChAcmVhbC5udW1lcmF0b3IgKiAoZCAvIEByZWFsLmRlbm9taW5hdG9yKSxcbiAgICAgIEBpbWFnLm51bWVyYXRvciAqIChkIC8gQGltYWcuZGVub21pbmF0b3IpLFxuICAgIClcbiAgZW5kXG5cbiAgYWxpYXMgcGhhc2UgYXJnXG5cbiAgZGVmIHBvbGFyXG4gICAgW2FicywgYXJnXVxuICBlbmRcblxuICB1bmRlZiBwb3NpdGl2ZT9cblxuICBhbGlhcyBxdW8gL1xuXG4gIGRlZiByYXRpb25hbGl6ZShlcHMgPSB1bmRlZmluZWQpXG4gICAgJXh7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKCN7YGFyZ3VtZW50cy5sZW5ndGhgfSBmb3IgMC4uMSlcIn07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgQGltYWcgIT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCcgY29udmVydCAje3NlbGZ9IGludG8gUmF0aW9uYWxcIlxuICAgIGVuZFxuXG4gICAgcmVhbC5yYXRpb25hbGl6ZShlcHMpXG4gIGVuZFxuXG4gIGRlZiByZWFsP1xuICAgIGZhbHNlXG4gIGVuZFxuXG4gIGRlZiByZWN0XG4gICAgW0ByZWFsLCBAaW1hZ11cbiAgZW5kXG5cbiAgYWxpYXMgcmVjdGFuZ3VsYXIgcmVjdFxuXG4gIHVuZGVmIHN0ZXBcblxuICBkZWYgdG9fZlxuICAgIHVubGVzcyBAaW1hZyA9PSAwXG4gICAgICByYWlzZSBSYW5nZUVycm9yLCBcImNhbid0IGNvbnZlcnQgI3tzZWxmfSBpbnRvIEZsb2F0XCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2ZcbiAgZW5kXG5cbiAgZGVmIHRvX2lcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIEByZWFsLnRvX2lcbiAgZW5kXG5cbiAgZGVmIHRvX3JcbiAgICB1bmxlc3MgQGltYWcgPT0gMFxuICAgICAgcmFpc2UgUmFuZ2VFcnJvciwgXCJjYW4ndCBjb252ZXJ0ICN7c2VsZn0gaW50byBSYXRpb25hbFwiXG4gICAgZW5kXG5cbiAgICBAcmVhbC50b19yXG4gIGVuZFxuXG4gIGRlZiB0b19zXG4gICAgcmVzdWx0ID0gQHJlYWwuaW5zcGVjdFxuXG4gICAgcmVzdWx0ICs9XG4gICAgICBpZiAoTnVtYmVyID09PSBAaW1hZyAmJiBAaW1hZy5uYW4/KSB8fCBAaW1hZy5wb3NpdGl2ZT8gfHwgQGltYWcuemVybz9cbiAgICAgICAgJysnXG4gICAgICBlbHNlXG4gICAgICAgICctJ1xuICAgICAgZW5kXG5cbiAgICByZXN1bHQgKz0gQGltYWcuYWJzLmluc3BlY3RcblxuICAgIGlmIE51bWJlciA9PT0gQGltYWcgJiYgKEBpbWFnLm5hbj8gfHwgQGltYWcuaW5maW5pdGU/KVxuICAgICAgcmVzdWx0ICs9ICcqJ1xuICAgIGVuZFxuXG4gICAgcmVzdWx0ICsgJ2knXG4gIGVuZFxuXG4gIEkgPSBuZXcoMCwgMSlcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGRlZiBDb21wbGV4KHJlYWwsIGltYWcgPSBuaWwpXG4gICAgaWYgaW1hZ1xuICAgICAgQ29tcGxleC5uZXcocmVhbCwgaW1hZylcbiAgICBlbHNlXG4gICAgICBDb21wbGV4Lm5ldyhyZWFsLCAwKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX2NcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLFxuICAgICAgICAgIHJlID0gL1srLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8oZVxcZCspPy8sXG4gICAgICAgICAgbWF0Y2ggPSBzdHIubWF0Y2gocmUpLFxuICAgICAgICAgIHJlYWwsIGltYWcsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZXMgYm90aCBmbG9hdHMgYW5kIHJhdGlvbmFsc1xuICAgICAgZnVuY3Rpb24gY3V0TnVtYmVyKCkge1xuICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgdmFyIG51bWVyYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG5cbiAgICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAgIC8vIHJhdGlvbmFsIHJlYWwgcGFydFxuICAgICAgICAgICAgc3RyID0gc3RyLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICAgIHJldHVybiAje1JhdGlvbmFsKGBudW1lcmF0b3JgLCBgZGVub21pbmF0b3JgKX07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyByZXZlcnRpbmcgJy8nXG4gICAgICAgICAgICAgIHN0ciA9ICcvJyArIHN0cjtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmxvYXQgcmVhbCBwYXJ0LCBubyBkZW5vbWluYXRvclxuICAgICAgICAgICAgcmV0dXJuIG51bWVyYXRvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVhbCA9IGN1dE51bWJlcigpO1xuXG4gICAgICBpZiAoIXJlYWwpIHtcbiAgICAgICAgaWYgKHN0clswXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gaSA9PiBDb21wbGV4KDAsIDEpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAxKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJy0nICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gLWkgPT4gQ29tcGxleCgwLCAtMSlcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KDAsIC0xKX07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0clswXSA9PT0gJysnICYmIHN0clsxXSA9PT0gJ2knKSB7XG4gICAgICAgICAgLy8gK2kgPT4gQ29tcGxleCgwLCAxKVxuICAgICAgICAgIHJldHVybiAje0NvbXBsZXgoMCwgMSl9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFueXRoaW5nID0+IENvbXBsZXgoMCwgMClcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCAwKX07XG4gICAgICB9XG5cbiAgICAgIGltYWcgPSBjdXROdW1iZXIoKTtcbiAgICAgIGlmICghaW1hZykge1xuICAgICAgICBpZiAoc3RyWzBdID09PSAnaScpIHtcbiAgICAgICAgICAvLyAzaSA9PiBDb21wbGV4KDAsIDMpXG4gICAgICAgICAgcmV0dXJuICN7Q29tcGxleCgwLCBgcmVhbGApfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAzID0+IENvbXBsZXgoMywgMClcbiAgICAgICAgICByZXR1cm4gI3tDb21wbGV4KGByZWFsYCwgMCl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAzKzJpID0+IENvbXBsZXgoMywgMilcbiAgICAgICAgcmV0dXJuICN7Q29tcGxleChgcmVhbGAsIGBpbWFnYCl9O1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6Q29tcGxleD4iLCJyZWN0IiwicmVhbCIsImltYWciLCIwIiwiJHJldF9vcl8xIiwiJHJldF9vcl8yIiwiJHJldF9vcl8zIiwiTnVtZXJpYyIsIj09PSIsInJlYWw/IiwicmFpc2UiLCJUeXBlRXJyb3IiLCJuZXciLCJwb2xhciIsInIiLCJ0aGV0YSIsIiRyZXRfb3JfNCIsIiRyZXRfb3JfNSIsIiRyZXRfb3JfNiIsIioiLCJNYXRoIiwiY29zIiwic2luIiwiYXR0cl9yZWFkZXIiLCJpbml0aWFsaXplIiwiQHJlYWwiLCJAaW1hZyIsImNvZXJjZSIsIm90aGVyIiwiQ29tcGxleCIsIiRyZXRfb3JfNyIsImNsYXNzIiwiPT0iLCIkcmV0X29yXzgiLCIkcmV0X29yXzkiLCIkcmV0X29yXzEwIiwiLUAiLCIrIiwiJHJldF9vcl8xMSIsIl9fY29lcmNlZF9fIiwiLSIsIiRyZXRfb3JfMTIiLCIkcmV0X29yXzEzIiwiLyIsIiRyZXRfb3JfMTQiLCIkcmV0X29yXzE1IiwiJHJldF9vcl8xNiIsIiRyZXRfb3JfMTciLCJOdW1iZXIiLCJuYW4/IiwiJHJldF9vcl8xOCIsIiRyZXRfb3JfMTkiLCIkcmV0X29yXzIwIiwiRmxvYXQ6Ok5BTiIsIkZsb2F0IiwiY29uaiIsImFiczIiLCIkcmV0X29yXzIxIiwicXVvIiwiKioiLCIxIiwib3JlIiwib2ltIiwibnIiLCJleHAiLCJsb2ciLCJudGhldGEiLCJJbnRlZ2VyIiwiPiIsIngiLCJ6IiwibiIsIiE9IiwiZGl2bW9kIiwiMiIsImRpdiIsIm1vZCIsIlJhdGlvbmFsIiwiJHJldF9vcl8yMiIsImFicyIsImh5cG90IiwiYW5nbGUiLCJhdGFuMiIsImRlbm9taW5hdG9yIiwibGNtIiwiZXFsPyIsIiRyZXRfb3JfMjMiLCIkcmV0X29yXzI0IiwiZmRpdiIsImZpbml0ZT8iLCIkcmV0X29yXzI1IiwiaGFzaCIsImluZmluaXRlPyIsIiRyZXRfb3JfMjYiLCJpbnNwZWN0IiwibnVtZXJhdG9yIiwiZCIsImFyZyIsInJhdGlvbmFsaXplIiwiZXBzIiwiQXJndW1lbnRFcnJvciIsIlJhbmdlRXJyb3IiLCJ0b19mIiwidG9faSIsInRvX3IiLCJ0b19zIiwicmVzdWx0IiwiJHJldF9vcl8yNyIsIiRyZXRfb3JfMjgiLCIkcmV0X29yXzI5IiwicG9zaXRpdmU/IiwiemVybz8iLCIkcmV0X29yXzMwIiwiJHJldF9vcl8zMSIsIjxtb2R1bGU6S2VybmVsPiIsIjxjbGFzczpTdHJpbmc+IiwidG9fYyIsIi0xIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixpQkFBUkU7RUFFQUM7RUFBQUE7O0lBQUFBOztBQUFBQTs7SUFDRUMsVUFBSUgsSUFBSkcsV0FBQUEsa0JBQUFBLGdCQUFjQyxJQUFELEVBQU9DLElBQXBCRjtBQUFBQSxNQUFBQTs7OztNQUFvQjtNQUFBLFNBQU9HLENBQVA7TUFBQTtNQUNsQixJQUFBLFFBQU8sYUFBQSxJQUFBLFFBSlhDLENBQUFBLFlBSVcsYUFBQSxJQUFBLFFBSlhDLENBQUFBLFlBSVcsYUFBQSxJQUFBLFFBSlhDLENBQUFBLFlBSVdDLHVCQUFRQyxRQUFBQSxDQUFJUCxJQUFKTyxDQUpuQkYsQ0FJVyxDQUFBO1FBQW9CTixPQUFBQyxJQUFJUSxVQUFBQSxDQUFBQTtNQUF4QjtRQUpYVCxPQUFBO01BSVcsQ0FBQSxrQkFKWEssQ0FJVyxDQUFBO1FBQWtDTCxPQUFBTyx1QkFBUUMsUUFBQUEsQ0FBSU4sSUFBSk07TUFBMUM7UUFKWFIsT0FBQTtNQUlXLENBQUEsa0JBSlhJLENBSVcsQ0FBQTtRQUFzREosT0FBQUUsSUFBSU8sVUFBQUEsQ0FBQUE7TUFBMUQ7UUFKWFQsT0FBQTtNQUlXLENBQUEsa0JBQVAsQ0FBQTtNQUFBO1FBQ0VILElBQUFhLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCWCxZQUFqQlU7TUFERjtNQUlBVixPQUFBSCxJQUFBZSxLQUFBQSxDQUFJWCxJQUFKLEVBQVVDLElBQVZVO0lBTEZaLENBQUFBLDhCQUFBQTtJQVFBO01BQUE7O01BQ0UsT0FBQSxhQUFNLGFBQU4sRUFBa0IsTUFBbEI7SUFERiw0QkFBU0gsSUFBVDtJQUlBZ0IsVUFBSWhCLElBQUpnQixZQUFBQSxtQkFBQUEsaUJBQWVDLENBQUQsRUFBSUMsS0FBbEJGO0FBQUFBLE1BQUFBOzs7O01BQWtCO01BQUEsVUFBUVYsQ0FBUjtNQUFBO01BQ2hCLElBQUEsUUFBTyxhQUFBLElBQUEsUUFoQlhhLENBQUFBLFlBZ0JXLGFBQUEsSUFBQSxRQWhCWEMsQ0FBQUEsWUFnQlcsYUFBQSxJQUFBLFFBaEJYQyxDQUFBQSxZQWdCV1gsdUJBQVFDLFFBQUFBLENBQUlNLENBQUpOLENBaEJuQlUsQ0FnQlcsQ0FBQTtRQUFpQkwsT0FBQUMsQ0FBQ0wsVUFBQUEsQ0FBQUE7TUFBbEI7UUFoQlhJLE9BQUE7TUFnQlcsQ0FBQSxrQkFoQlhJLENBZ0JXLENBQUE7UUFBNEJKLE9BQUFOLHVCQUFRQyxRQUFBQSxDQUFJTyxLQUFKUDtNQUFwQztRQWhCWEssT0FBQTtNQWdCVyxDQUFBLGtCQWhCWEcsQ0FnQlcsQ0FBQTtRQUFpREgsT0FBQUUsS0FBS04sVUFBQUEsQ0FBQUE7TUFBdEQ7UUFoQlhJLE9BQUE7TUFnQlcsQ0FBQSxrQkFBUCxDQUFBO01BQUE7UUFDRWhCLElBQUFhLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCRSxZQUFqQkg7TUFERjtNQUlBRyxPQUFBaEIsSUFBQWUsS0FBQUEsQ0FBTU8sVUFBRkwsQ0FBRUssRUFBRUMsb0JBQUlDLEtBQUFBLENBQUtOLEtBQUxNLENBQU5GLENBQU4sRUFBMkJBLFVBQUZMLENBQUVLLEVBQUVDLG9CQUFJRSxLQUFBQSxDQUFLUCxLQUFMTyxDQUFOSCxDQUEzQlA7SUFMRkMsQ0FBQUEsK0JBQUFBO0lBUUFoQixJQUFBMEIsYUFBQUEsQ0FBWSxNQUFaLEVBQW1CLE1BQW5CQTs7QUFFQUMsSUFBQUEsOEJBQUFBLHdCQUFBQSxzQkFBZXZCLElBQUQsRUFBT0MsSUFBckJzQjtBQUFBQSxNQUFBQTs7OztNQUFxQjtNQUFBLFNBQU9yQixDQUFQO01BQUE7TUFDbkJzQixZQUFReEI7TUFDUnVCLE9BQUFFLENBQUFBLFlBQVF4QixJQUFSd0I7SUFGRkYsQ0FBQUEsb0NBQUFBOztBQUtBRyxJQUFBQSwwQkFBQUEsb0JBQUFBLGtCQUFXQyxLQUFYRDtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdFLHVCQUFRckIsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQUFYLENBQUE7UUFDRW1CLE9BQUEsQ0FBQ0MsS0FBRCxFQUFRL0IsSUFBUjtNQURGLE9BRUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQWpDVmlDLENBQUFBLFlBaUNVdkIsdUJBQVFDLFFBQUFBLENBQUlvQixLQUFKcEIsQ0FqQ2xCc0IsQ0FpQ1UsQ0FBQTtRQUFxQkgsT0FBQUMsS0FBS25CLFVBQUFBLENBQUFBO01BQTFCO1FBakNWa0IsT0FBQTtNQWlDVSxDQUFBLGtCQUFOLENBQUE7UUFDRUEsT0FBQSxDQUFDRSx1QkFBT2pCLEtBQUFBLENBQUtnQixLQUFaLEVBQW1CekIsQ0FBWlMsQ0FBUixFQUF3QmYsSUFBeEI7TUFERjtRQUdFOEIsT0FBQTlCLElBQUFhLE9BQUFBLENBQU1DLHlCQUFOLEVBQWlCLEVBQUEsR0FBQSxDQUFHaUIsS0FBS0csT0FBQUEsQ0FBQUEsQ0FBUixDQUFBLEdBQUEsZ0NBQWpCckI7TUFIRjtJQUhGaUIsQ0FBQUEsK0JBQUFBOztBQVVBSyxJQUFBQSxzQkFBQUEsb0JBQUFBLFNBQU9KLEtBQVBJO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR0gsdUJBQVFyQixRQUFBQSxDQUFJb0IsS0FBSnBCLENBQVgsQ0FBQTtRQUNFLElBQUEsUUExQ055QixDQUFBQSxZQTBDTVIsU0FBTU8sT0FBQUEsQ0FBR0osS0FBSzNCLE1BQUFBLENBQUFBLENBQVIrQixDQTFDWkMsQ0EwQ00sQ0FBQTtVQUF1QkQsT0FBQU4sU0FBTU0sT0FBQUEsQ0FBR0osS0FBSzFCLE1BQUFBLENBQUFBLENBQVI4QjtRQUE3QjtVQTFDTkEsT0FBQTtRQTBDTTtNQURGLE9BRUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQTNDVkUsQ0FBQUEsWUEyQ1UzQix1QkFBUUMsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQTNDbEIwQixDQTJDVSxDQUFBO1FBQXFCRixPQUFBSixLQUFLbkIsVUFBQUEsQ0FBQUE7TUFBMUI7UUEzQ1Z1QixPQUFBO01BMkNVLENBQUEsa0JBQU4sQ0FBQTtRQUNFLElBQUEsUUE1Q05HLENBQUFBLGFBNENNVixTQUFNTyxPQUFBQSxDQUFHSixLQUFISSxDQTVDWkcsQ0E0Q00sQ0FBQTtVQUFrQkgsT0FBQU4sU0FBTU0sT0FBQUEsQ0FBRzdCLENBQUg2QjtRQUF4QjtVQTVDTkEsT0FBQTtRQTRDTTtNQURGO1FBR0VBLE9BQUFKLEtBQU1JLE9BQUFBLENBQUduQyxJQUFIbUM7TUFIUjtJQUhGQSxDQUFBQSwrQkFBQUE7O0FBVUFJLElBQUFBLHNCQUFBQSxxQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUF2QyxJQUFBZ0MsU0FBQUEsQ0FBU0osU0FBRFcsT0FBQUEsQ0FBQUEsQ0FBUixFQUFpQlYsU0FBRFUsT0FBQUEsQ0FBQUEsQ0FBaEJQO0lBREZPLENBQUFBLGdDQUFBQTs7QUFJQUMsSUFBQUEscUJBQUFBLG1CQUFBQSxTQUFNVCxLQUFOUztBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdSLHVCQUFRckIsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQUFYLENBQUE7UUFDRTZCLE9BQUF4QyxJQUFBZ0MsU0FBQUEsQ0FBY1EsU0FBTlosU0FBTVksRUFBRVQsS0FBSzNCLE1BQUFBLENBQUFBLENBQVBvQyxDQUFkLEVBQWtDQSxTQUFOWCxTQUFNVyxFQUFFVCxLQUFLMUIsTUFBQUEsQ0FBQUEsQ0FBUG1DLENBQWxDUjtNQURGLE9BRUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQXpEVlMsQ0FBQUEsYUF5RFUvQix1QkFBUUMsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQXpEbEI4QixDQXlEVSxDQUFBO1FBQXFCRCxPQUFBVCxLQUFLbkIsVUFBQUEsQ0FBQUE7TUFBMUI7UUF6RFY0QixPQUFBO01BeURVLENBQUEsa0JBQU4sQ0FBQTtRQUNFQSxPQUFBeEMsSUFBQWdDLFNBQUFBLENBQWNRLFNBQU5aLFNBQU1ZLEVBQUVULEtBQUZTLENBQWQsRUFBdUJYLFNBQXZCRztNQURGO1FBR0VRLE9BQUF4QyxJQUFBMEMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCWCxLQUFoQlc7TUFIRjtJQUhGRixDQUFBQSw4QkFBQUE7O0FBVUFHLElBQUFBLHFCQUFBQSxvQkFBQUEsU0FBTVosS0FBTlk7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQUFHWCx1QkFBUXJCLFFBQUFBLENBQUlvQixLQUFKcEIsQ0FBWCxDQUFBO1FBQ0VnQyxPQUFBM0MsSUFBQWdDLFNBQUFBLENBQWNXLFVBQU5mLFNBQU1lLEVBQUVaLEtBQUszQixNQUFBQSxDQUFBQSxDQUFQdUMsQ0FBZCxFQUFrQ0EsVUFBTmQsU0FBTWMsRUFBRVosS0FBSzFCLE1BQUFBLENBQUFBLENBQVBzQyxDQUFsQ1g7TUFERixPQUVBLElBQUEsUUFBTSxhQUFBLElBQUEsUUFuRVZZLENBQUFBLGFBbUVVbEMsdUJBQVFDLFFBQUFBLENBQUlvQixLQUFKcEIsQ0FuRWxCaUMsQ0FtRVUsQ0FBQTtRQUFxQkQsT0FBQVosS0FBS25CLFVBQUFBLENBQUFBO01BQTFCO1FBbkVWK0IsT0FBQTtNQW1FVSxDQUFBLGtCQUFOLENBQUE7UUFDRUEsT0FBQTNDLElBQUFnQyxTQUFBQSxDQUFjVyxVQUFOZixTQUFNZSxFQUFFWixLQUFGWSxDQUFkLEVBQXVCZCxTQUF2Qkc7TUFERjtRQUdFVyxPQUFBM0MsSUFBQTBDLGFBQUFBLENBQVksR0FBWixFQUFnQlgsS0FBaEJXO01BSEY7SUFIRkMsQ0FBQUEsK0JBQUFBOztBQVVBckIsSUFBQUEscUJBQUFBLGVBQUFBLFNBQU1TLEtBQU5UO0FBQUFBLE1BQUFBOztNQUNFLElBQUEsUUFBR1UsdUJBQVFyQixRQUFBQSxDQUFJb0IsS0FBSnBCLENBQVgsQ0FBQTtRQUNFVyxPQUFBdEIsSUFBQWdDLFNBQUFBLENBQTJCVyxVQUFickIsVUFBTk0sU0FBTU4sRUFBRVMsS0FBSzNCLE1BQUFBLENBQUFBLENBQVBrQixDQUFhcUIsRUFBUXJCLFVBQU5PLFNBQU1QLEVBQUVTLEtBQUsxQixNQUFBQSxDQUFBQSxDQUFQaUIsQ0FBUnFCLENBQTNCLEVBQ3FCSCxTQUFibEIsVUFBTk0sU0FBTU4sRUFBRVMsS0FBSzFCLE1BQUFBLENBQUFBLENBQVBpQixDQUFha0IsRUFBUWxCLFVBQU5PLFNBQU1QLEVBQUVTLEtBQUszQixNQUFBQSxDQUFBQSxDQUFQa0IsQ0FBUmtCLENBRHJCUjtNQURGLE9BSUEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQS9FVmEsQ0FBQUEsYUErRVVuQyx1QkFBUUMsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQS9FbEJrQyxDQStFVSxDQUFBO1FBQXFCdkIsT0FBQVMsS0FBS25CLFVBQUFBLENBQUFBO01BQTFCO1FBL0VWVSxPQUFBO01BK0VVLENBQUEsa0JBQU4sQ0FBQTtRQUNFQSxPQUFBdEIsSUFBQWdDLFNBQUFBLENBQWNWLFVBQU5NLFNBQU1OLEVBQUVTLEtBQUZULENBQWQsRUFBNkJBLFVBQU5PLFNBQU1QLEVBQUVTLEtBQUZULENBQTdCVTtNQURGO1FBR0VWLE9BQUF0QixJQUFBMEMsYUFBQUEsQ0FBWSxHQUFaLEVBQWdCWCxLQUFoQlc7TUFIRjtJQUxGcEIsQ0FBQUEsMEJBQUFBOztBQVlBd0IsSUFBQUEscUJBQUFBLHFCQUFBQSxTQUFNZixLQUFOZTtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBQUdkLHVCQUFRckIsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQUFYLENBQUE7UUFDRSxJQUFBLFFBQUcsYUFBQSxJQUFBLFFBeEZUb0MsQ0FBQUEsYUF3RlMsYUFBQSxJQUFBLFFBeEZUQyxDQUFBQSxhQXdGUyxhQUFBLElBQUEsUUF4RlRDLENBQUFBLGFBd0ZVLGFBQUEsSUFBQSxRQXhGVkMsQ0FBQUEsYUF3RlVDLHNCQUFPeEMsUUFBQUEsQ0FBSWlCLFNBQUpqQixDQXhGakJ1QyxDQXdGVSxDQUFBO1VBQW9CSixPQUFBbEIsU0FBS3dCLFNBQUFBLENBQUFBO1FBQXpCO1VBeEZWTixPQUFBO1FBd0ZVLENBQUEsa0JBeEZWRyxDQXdGUyxDQUFBO1VBeEZUSCxPQUFBO1FBd0ZTOztVQUFxQyxJQUFBLFFBeEY5Q08sQ0FBQUEsYUF3RjhDRixzQkFBT3hDLFFBQUFBLENBQUlrQixTQUFKbEIsQ0F4RnJEMEMsQ0F3RjhDLENBQUE7WUFBb0JQLE9BQUFqQixTQUFLdUIsU0FBQUEsQ0FBQUE7VUFBekI7WUF4RjlDTixPQUFBO1VBd0Y4QztRQUFyQyxDQUFBLGtCQXhGVEUsQ0F3RlMsQ0FBQTtVQXhGVEYsT0FBQTtRQXdGUzs7VUFDQyxJQUFBLFFBekZWUSxDQUFBQSxhQXlGVUgsc0JBQU94QyxRQUFBQSxDQUFJb0IsS0FBSzNCLE1BQUFBLENBQUFBLENBQVRPLENBekZqQjJDLENBeUZVLENBQUE7WUFBeUJSLE9BQUFmLEtBQUszQixNQUFBQSxDQUFBQSxDQUFLZ0QsU0FBQUEsQ0FBQUE7VUFBbkM7WUF6RlZOLE9BQUE7VUF5RlU7UUFERCxDQUFBLGtCQXhGVEMsQ0F3RlMsQ0FBQTtVQXhGVEQsT0FBQTtRQXdGUzs7VUFDK0MsSUFBQSxRQXpGeERTLENBQUFBLGFBeUZ3REosc0JBQU94QyxRQUFBQSxDQUFJb0IsS0FBSzFCLE1BQUFBLENBQUFBLENBQVRNLENBekYvRDRDLENBeUZ3RCxDQUFBO1lBQXlCVCxPQUFBZixLQUFLMUIsTUFBQUEsQ0FBQUEsQ0FBSytDLFNBQUFBLENBQUFBO1VBQW5DO1lBekZ4RE4sT0FBQTtVQXlGd0Q7UUFEL0MsQ0FBQSxrQkFBSCxDQUFBO1VBRUVBLE9BQUFkLHVCQUFPakIsS0FBQUEsQ0FBS3lDLElBQUFDLHFCQUFBRCxRQUFaLEVBQXdCQSxJQUFBQyxxQkFBQUQsUUFBakJ6QztRQUZUO1VBSUUrQixPQUFrQkEsV0FBYnhCLFVBQUx0QixJQUFLc0IsRUFBRVMsS0FBSzJCLE1BQUFBLENBQUFBLENBQVBwQyxDQUFhd0IsRUFBRWYsS0FBSzRCLE1BQUFBLENBQUFBLENBQVBiO1FBSnBCO01BREYsT0FPQSxJQUFBLFFBQU0sYUFBQSxJQUFBLFFBOUZWYyxDQUFBQSxhQThGVWxELHVCQUFRQyxRQUFBQSxDQUFJb0IsS0FBSnBCLENBOUZsQmlELENBOEZVLENBQUE7UUFBcUJkLE9BQUFmLEtBQUtuQixVQUFBQSxDQUFBQTtNQUExQjtRQTlGVmtDLE9BQUE7TUE4RlUsQ0FBQSxrQkFBTixDQUFBO1FBQ0VBLE9BQUE5QyxJQUFBZ0MsU0FBQUEsQ0FBUUosU0FBS2lDLEtBQUFBLENBQUs5QixLQUFMOEIsQ0FBYixFQUEwQmhDLFNBQUtnQyxLQUFBQSxDQUFLOUIsS0FBTDhCLENBQS9CN0I7TUFERjtRQUdFYyxPQUFBOUMsSUFBQTBDLGFBQUFBLENBQVksR0FBWixFQUFnQlgsS0FBaEJXO01BSEY7SUFSRkksQ0FBQUEsZ0NBQUFBOztBQWVBZ0IsSUFBQUEsc0JBQUFBLGlCQUFBQSxTQUFPL0IsS0FBUCtCO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFHL0IsS0FBTUksT0FBQUEsQ0FBRzdCLENBQUg2QixDQUFUO1FBQ0UsT0FBT0gsdUJBQU9qQixLQUFBQSxDQUFLZ0QsQ0FBWixFQUFlekQsQ0FBUlMsQ0FEaEI7TUFJQSxJQUFBLFFBQUdpQix1QkFBUXJCLFFBQUFBLENBQUlvQixLQUFKcEIsQ0FBWCxDQUFBOztRQUNFLEtBQVdYLElBQUFnQixPQUFBQSxDQUFBQSxDQUFYLHNCQUFBLEVBQUFDLENBQUFBLElBQUEsNkJBQUFBLENBQUEsRUFBR0MsQ0FBQUEsUUFBSCw2QkFBR0EsQ0FBSDtRQUNBOEMsTUFBV2pDLEtBQUszQixNQUFBQSxDQUFBQTtRQUNoQjZELE1BQVdsQyxLQUFLMUIsTUFBQUEsQ0FBQUE7UUFDaEI2RCxLQUFXM0Msb0JBQUk0QyxLQUFBQSxDQUF1QnhCLFVBQWRyQixVQUFKMEMsR0FBSTFDLEVBQUVDLG9CQUFJNkMsS0FBQUEsQ0FBS25ELENBQUxtRCxDQUFOOUMsQ0FBY3FCLEVBQU1yQixVQUFKMkMsR0FBSTNDLEVBQUVKLEtBQUZJLENBQU5xQixDQUF2QndCO1FBQ2ZFLFNBQXVCN0IsU0FBTmxCLFVBQU5KLEtBQU1JLEVBQUUwQyxHQUFGMUMsQ0FBTWtCLEVBQU1sQixVQUFKMkMsR0FBSTNDLEVBQUVDLG9CQUFJNkMsS0FBQUEsQ0FBS25ELENBQUxtRCxDQUFOOUMsQ0FBTmtCO1FBRXZCc0IsT0FBQTlCLHVCQUFPaEIsT0FBQUEsQ0FBT2tELEVBQWQsRUFBa0JHLE1BQVhyRDtNQVBULE9BUUEsSUFBQSxRQUFNc0QsdUJBQVEzRCxRQUFBQSxDQUFJb0IsS0FBSnBCLENBQWQsQ0FBQTtRQUNFLElBQUEsUUFBUzRELE9BQU54QyxLQUFNd0MsRUFBRWpFLENBQUZpRSxDQUFULENBQUE7O1VBQ0VDLElBQUl4RTtVQUNKeUUsSUFBSUQ7VUFDSkUsSUFBVS9CLFVBQU5aLEtBQU1ZLEVBQUVvQixDQUFGcEI7VUFFVixPQUFBLFFBQU0rQixDQUFFQyxPQUFBQSxDQUFHckUsQ0FBSHFFLENBQVIsQ0FBQTs7WUFDRSxLQUFXRCxDQUFDRSxRQUFBQSxDQUFRQyxDQUFSRCxDQUFaLHNCQUFBLEVBQUFFLENBQUFBLE1BQUEsNkJBQUFBLENBQUEsRUFBS0MsQ0FBQUEsTUFBTCw2QkFBS0EsQ0FBTDtZQUNBLE9BQU1BLEdBQUk1QyxPQUFBQSxDQUFHN0IsQ0FBSDZCLENBQVY7O2NBQ0VxQyxJQUFJeEUsSUFBQWdDLFNBQUFBLENBQXdCVyxVQUFUckIsVUFBUGtELENBQUNwRSxNQUFBQSxDQUFBQSxDQUFNa0IsRUFBRWtELENBQUNwRSxNQUFBQSxDQUFBQSxDQUFIa0IsQ0FBU3FCLEVBQVNyQixVQUFQa0QsQ0FBQ25FLE1BQUFBLENBQUFBLENBQU1pQixFQUFFa0QsQ0FBQ25FLE1BQUFBLENBQUFBLENBQUhpQixDQUFUcUIsQ0FBeEIsRUFBc0RyQixVQUFUQSxVQUFGdUQsQ0FBRXZELEVBQUVrRCxDQUFDcEUsTUFBQUEsQ0FBQUEsQ0FBSGtCLENBQVNBLEVBQUVrRCxDQUFDbkUsTUFBQUEsQ0FBQUEsQ0FBSGlCLENBQXREVTtjQUNKMEMsSUFBSUk7Y0FDSixLQUFXSixDQUFDRSxRQUFBQSxDQUFRQyxDQUFSRCxDQUFaLHNCQUFBLEVBQUFFLENBQUFBLE1BQUEsNkJBQUFBLENBQUEsRUFBS0MsQ0FBQUEsTUFBTCw2QkFBS0EsQ0FBTDtZQUhGO1lBTUFOLElBQUVuRCxVQUFGbUQsQ0FBRW5ELEVBQUdrRCxDQUFIbEQ7WUFDRm9ELElBQUUvQixVQUFGK0IsQ0FBRS9CLEVBQUdvQixDQUFIcEI7VUFUSjtVQVlBbUIsT0FBQVc7UUFqQkY7VUFtQkVYLE9BQW9CaEIsV0FBbkJrQyx3QkFBUWpFLEtBQUFBLENBQUtnRCxDQUFiLEVBQWdCQSxDQUFSaEQsQ0FBVytCLEVBQUU5QyxJQUFGOEMsQ0FBT2dCLE9BQUFBLENBQUcvQixLQUFEUSxPQUFBQSxDQUFBQSxDQUFGdUI7UUFuQjdCO01BREYsT0FzQkEsSUFBQSxRQUFNLGFBQUEsSUFBQSxRQXhJVm1CLENBQUFBLGFBd0lVeEIscUJBQU05QyxRQUFBQSxDQUFJb0IsS0FBSnBCLENBeEloQnNFLENBd0lVLENBQUE7UUF4SVZuQixPQUFBO01Bd0lVO1FBQW1CQSxPQUFBa0Isd0JBQVNyRSxRQUFBQSxDQUFJb0IsS0FBSnBCO01BQTVCLENBQUEsa0JBQU4sQ0FBQTs7UUFDRSxLQUFXWCxJQUFBZ0IsT0FBQUEsQ0FBQUEsQ0FBWCxzQkFBQSxFQUFBQyxDQUFBQSxJQUFBLDZCQUFBQSxDQUFBLEVBQUdDLENBQUFBLFFBQUgsNkJBQUdBLENBQUg7UUFFQTRDLE9BQUE5Qix1QkFBT2hCLE9BQUFBLENBQU9DLENBQUM2QyxPQUFBQSxDQUFFL0IsS0FBRitCLENBQWYsRUFBOEJ4QyxVQUFOSixLQUFNSSxFQUFFUyxLQUFGVCxDQUF2Qk47TUFIVDtRQUtFOEMsT0FBQTlELElBQUEwQyxhQUFBQSxDQUFZLElBQVosRUFBaUJYLEtBQWpCVztNQUxGO0lBbkNGb0IsQ0FBQUEsNEJBQUFBOztBQTRDQW9CLElBQUFBLHVCQUFBQSxrQkFBQUEsZUFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUEzRCxvQkFBSTRELE9BQUFBLENBQU92RCxTQUFYLEVBQWtCQyxTQUFkc0Q7SUFETkQsQ0FBQUEsNkJBQUFBOztBQUlBdkIsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQWNuQixTQUFSbEIsVUFBTk0sU0FBTU4sRUFBRU0sU0FBRk4sQ0FBUWtCLEVBQVFsQixVQUFOTyxTQUFNUCxFQUFFTyxTQUFGUCxDQUFSa0I7SUFEaEJtQixDQUFBQSw4QkFBQUE7O0FBSUF5QixJQUFBQSx5QkFBQUEsb0JBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTdELG9CQUFJOEQsT0FBQUEsQ0FBT3hELFNBQVgsRUFBa0JELFNBQWR5RDtJQURORCxDQUFBQSwrQkFBQUE7SUFJQSxhQUFNLEtBQU4sRUFBVSxPQUFWOztBQUVBMUIsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7O01BQ0VBLE9BQUExRCxJQUFBZ0MsU0FBQUEsQ0FBUUosU0FBUixFQUFnQkMsU0FBRFUsT0FBQUEsQ0FBQUEsQ0FBZlA7SUFERjBCLENBQUFBLDhCQUFBQTtJQUlBLGFBQU0sV0FBTixFQUFnQixNQUFoQjs7QUFFQTRCLElBQUFBLCtCQUFBQSwwQkFBQUEsdUJBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBMUQsU0FBSzBELGFBQUFBLENBQUFBLENBQVlDLEtBQUFBLENBQUsxRCxTQUFLeUQsYUFBQUEsQ0FBQUEsQ0FBVkM7SUFEbkJELENBQUFBLHFDQUFBQTtJQUlBLGFBQU0sUUFBTixFQUFhLEdBQWI7O0FBRUFFLElBQUFBLHdCQUFBQSx1QkFBQUEsU0FBU3pELEtBQVR5RDtBQUFBQSxNQUFBQTs7TUFDRSxJQUFBLFFBNUtKQyxDQUFBQSxhQTRLSSxhQUFBLElBQUEsUUE1S0pDLENBQUFBLGFBNEtJMUQsdUJBQVFyQixRQUFBQSxDQUFJb0IsS0FBSnBCLENBNUtaK0UsQ0E0S0ksQ0FBQTtRQUFxQkYsT0FBQTVELFNBQUtNLE9BQUFBLENBQUFBLENBQU9DLE9BQUFBLENBQUdOLFNBQUtLLE9BQUFBLENBQUFBLENBQVJDO01BQWpDO1FBNUtKcUQsT0FBQTtNQTRLSSxDQUFBLGtCQTVLSkMsQ0E0S0ksQ0FBQTtRQUFtREQsT0FBQXhGLElBQUttQyxPQUFBQSxDQUFHSixLQUFISTtNQUF4RDtRQTVLSnFELE9BQUE7TUE0S0k7SUFERkEsQ0FBQUEsa0NBQUFBOztBQUlBRyxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFTNUQsS0FBVDREO0FBQUFBLE1BQUFBOzs7TUFDRSxJQUFBLFFBQU9qRix1QkFBUUMsUUFBQUEsQ0FBSW9CLEtBQUpwQixDQUFmLENBQUE7TUFBQTtRQUNFWCxJQUFBYSxPQUFBQSxDQUFNQyx5QkFBTixFQUFpQixFQUFBLEdBQUEsQ0FBR2lCLEtBQUtHLE9BQUFBLENBQUFBLENBQVIsQ0FBQSxHQUFBLGdDQUFqQnJCO01BREY7TUFJQThFLE9BQUs3QyxXQUFMOUMsSUFBSzhDLEVBQUVmLEtBQUZlO0lBTFA2QyxDQUFBQSw4QkFBQUE7O0FBUUFDLElBQUFBLDJCQUFBQSwwQkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQXhMSkMsQ0FBQUEsYUF3TElqRSxTQUFLZ0UsWUFBQUEsQ0FBQUEsQ0F4TFRDLENBd0xJLENBQUE7UUFBaUJELE9BQUEvRCxTQUFLK0QsWUFBQUEsQ0FBQUE7TUFBdEI7UUF4TEpBLE9BQUE7TUF3TEk7SUFERkEsQ0FBQUEscUNBQUFBOztBQUlBRSxJQUFBQSx3QkFBQUEsbUJBQUFBLGdCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxFQUFBLEdBQUEsVUFBQSxHQUFBLENBQVdsRSxTQUFYLENBQUEsR0FBQSxHQUFBLEdBQUEsQ0FBb0JDLFNBQXBCO0lBREZpRSxDQUFBQSw4QkFBQUE7SUFJQSxhQUFNLFdBQU4sRUFBZ0IsTUFBaEI7O0FBRUFDLElBQUFBLDZCQUFBQSw0QkFBQUEsU0FBQUE7QUFBQUEsTUFBQUE7O01BQ0UsSUFBQSxRQWxNSkMsQ0FBQUEsYUFrTUlwRSxTQUFLbUUsY0FBQUEsQ0FBQUEsQ0FsTVRDLENBa01JLENBQUE7UUFsTUpELE9BQUE7TUFrTUk7UUFBbUJBLE9BQUFsRSxTQUFLa0UsY0FBQUEsQ0FBQUE7TUFBeEI7SUFERkEsQ0FBQUEsdUNBQUFBOztBQUlBRSxJQUFBQSwyQkFBQUEsc0JBQUFBLG1CQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxFQUFBLEdBQUEsR0FBQSxHQUFBLENBQUlqRyxJQUFKLENBQUEsR0FBQTtJQURGaUcsQ0FBQUEsaUNBQUFBO0lBSUEsYUFBTSxXQUFOLEVBQWdCLEtBQWhCOztJQUVBLHNCQUFNLFdBQU47O0FBRUFDLElBQUFBLDZCQUFBQSx3QkFBQUEscUJBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsSUFBSW5HLElBQUFzRixhQUFBQSxDQUFBQTtNQUVKWSxPQUFBbEcsSUFBQWdDLFNBQUFBLENBQXdCVixVQUFoQk0sU0FBS3NFLFdBQUFBLENBQUFBLENBQVc1RSxFQUFLd0IsV0FBRnFELENBQUVyRCxFQUFFbEIsU0FBSzBELGFBQUFBLENBQUFBLENBQVB4QyxDQUFMeEIsQ0FBeEIsRUFDa0JBLFVBQWhCTyxTQUFLcUUsV0FBQUEsQ0FBQUEsQ0FBVzVFLEVBQUt3QixXQUFGcUQsQ0FBRXJELEVBQUVqQixTQUFLeUQsYUFBQUEsQ0FBQUEsQ0FBUHhDLENBQUx4QixDQURsQlU7SUFIRmtFLENBQUFBLG1DQUFBQTtJQVFBLGFBQU0sT0FBTixFQUFZLEtBQVo7O0FBRUFsRixJQUFBQSx5QkFBQUEsb0JBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQSxDQUFDaEIsSUFBQWtGLEtBQUFBLENBQUFBLENBQUQsRUFBTWxGLElBQUFvRyxLQUFBQSxDQUFBQSxDQUFOO0lBREZwRixDQUFBQSwrQkFBQUE7O0lBSUEsc0JBQU0sV0FBTjtJQUVBLGFBQU0sS0FBTixFQUFVLEdBQVY7O0FBRUFxRixJQUFBQSwrQkFBQUEsMEJBQUFBLHVCQUFnQkMsR0FBaEJEO0FBQUFBLE1BQUFBOzs7OztBQUVGQTtBQUNBQSxRQUFVckcsSUFBQWEsT0FBQUEsQ0FBTTBGLDZCQUFOLEVBQXFCLEVBQUEsR0FBQSw2QkFBQSxHQUFBLENBQStCRixnQkFBL0IsQ0FBQSxHQUFBLFlBQXJCeEYsQ0FBa0Z3RjtBQUM1RkE7QUFDQUE7TUFFSSxJQUFBLFFBQUd4RSxTQUFNOEMsT0FBQUEsQ0FBR3JFLENBQUhxRSxDQUFULENBQUE7UUFDRTNFLElBQUFhLE9BQUFBLENBQU0yRiwwQkFBTixFQUFrQixFQUFBLEdBQUEsaUJBQUEsR0FBQSxDQUFrQnhHLElBQWxCLENBQUEsR0FBQSxnQkFBbEJhLENBREY7TUFJQXdGLE9BQUFyRyxJQUFBSSxNQUFBQSxDQUFBQSxDQUFJaUcsYUFBQUEsQ0FBYUMsR0FBYkQ7SUFYTkEsQ0FBQUEsc0NBQUFBOztBQWNBekYsSUFBQUEseUJBQUFBLHdCQUFBQSxTQUFBQTtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQTtJQURGQSxDQUFBQSxtQ0FBQUE7O0FBSUFULElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBLENBQUN5QixTQUFELEVBQVFDLFNBQVI7SUFERjFCLENBQUFBLDhCQUFBQTtJQUlBLGFBQU0sYUFBTixFQUFrQixNQUFsQjs7SUFFQSxzQkFBTSxNQUFOOztBQUVBc0csSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFLElBQU81RSxTQUFNTSxPQUFBQSxDQUFHN0IsQ0FBSDZCLENBQWI7TUFBQTtRQUNFbkMsSUFBQWEsT0FBQUEsQ0FBTTJGLDBCQUFOLEVBQWtCLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCeEcsSUFBakIsQ0FBQSxHQUFBLGFBQWxCYTtNQURGO01BSUE0RixPQUFBN0UsU0FBSzZFLE1BQUFBLENBQUFBO0lBTFBBLENBQUFBLDhCQUFBQTs7QUFRQUMsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFLElBQU83RSxTQUFNTSxPQUFBQSxDQUFHN0IsQ0FBSDZCLENBQWI7TUFBQTtRQUNFbkMsSUFBQWEsT0FBQUEsQ0FBTTJGLDBCQUFOLEVBQWtCLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCeEcsSUFBakIsQ0FBQSxHQUFBLGVBQWxCYTtNQURGO01BSUE2RixPQUFBOUUsU0FBSzhFLE1BQUFBLENBQUFBO0lBTFBBLENBQUFBLDhCQUFBQTs7QUFRQUMsSUFBQUEsd0JBQUFBLG1CQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztNQUNFLElBQU85RSxTQUFNTSxPQUFBQSxDQUFHN0IsQ0FBSDZCLENBQWI7TUFBQTtRQUNFbkMsSUFBQWEsT0FBQUEsQ0FBTTJGLDBCQUFOLEVBQWtCLEVBQUEsR0FBQSxnQkFBQSxHQUFBLENBQWlCeEcsSUFBakIsQ0FBQSxHQUFBLGdCQUFsQmE7TUFERjtNQUlBOEYsT0FBQS9FLFNBQUsrRSxNQUFBQSxDQUFBQTtJQUxQQSxDQUFBQSw4QkFBQUE7O0FBUUFDLElBQUFBLHdCQUFBQSxtQkFBQUEsZ0JBQUFBO0FBQUFBLE1BQUFBOzs7TUFDRUMsU0FBU2pGLFNBQUtxRSxTQUFBQSxDQUFBQTtNQUVkWSxTQUFPckUsU0FBUHFFLE1BQU9yRSxFQUNMLGFBQUEsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQXJSVHNFLENBQUFBLGFBcVJTLGFBQUEsSUFBQSxRQXJSVEMsQ0FBQUEsYUFxUlUsYUFBQSxJQUFBLFFBclJWQyxDQUFBQSxhQXFSVTdELHNCQUFPeEMsUUFBQUEsQ0FBSWtCLFNBQUpsQixDQXJSakJxRyxDQXFSVSxDQUFBO1FBQW9CSixPQUFBL0UsU0FBS3VCLFNBQUFBLENBQUFBO01BQXpCO1FBclJWd0QsT0FBQTtNQXFSVSxDQUFBLGtCQXJSVkcsQ0FxUlMsQ0FBQTtRQXJSVEgsT0FBQTtNQXFSUztRQUFvQ0EsT0FBQS9FLFNBQUtvRixjQUFBQSxDQUFBQTtNQUF6QyxDQUFBLGtCQXJSVEgsQ0FxUlMsQ0FBQTtRQXJSVEYsT0FBQTtNQXFSUztRQUF1REEsT0FBQS9FLFNBQUtxRixVQUFBQSxDQUFBQTtNQUE1RCxDQUFBLGtCQUFILENBQUE7UUFDRU4sT0FBQUE7TUFERjtRQUdFQSxPQUFBQTtNQUhGLENBQUEsa0JBREtwRTtNQU9QcUUsU0FBT3JFLFNBQVBxRSxNQUFPckUsRUFBR1gsU0FBS3FELEtBQUFBLENBQUFBLENBQUllLFNBQUFBLENBQUFBLENBQVp6RDtNQUVQLElBQUEsUUFBRyxhQUFBLElBQUEsUUE3UlAyRSxDQUFBQSxhQTZST2hFLHNCQUFPeEMsUUFBQUEsQ0FBSWtCLFNBQUpsQixDQTdSZHdHLENBNlJPLENBQUE7O1FBQXFCLElBQUEsUUE3UjVCQyxDQUFBQSxhQTZSNEJ2RixTQUFLdUIsU0FBQUEsQ0FBQUEsQ0E3UmpDZ0UsQ0E2UjRCLENBQUE7VUE3UjVCUixPQUFBO1FBNlI0QjtVQUFjQSxPQUFBL0UsU0FBS2tFLGNBQUFBLENBQUFBO1FBQW5CO01BQXJCO1FBN1JQYSxPQUFBO01BNlJPLENBQUEsa0JBQUgsQ0FBQTtRQUNFQyxTQUFPckUsU0FBUHFFLE1BQU9yRSxFQUFHb0UsR0FBSHBFLENBRFQ7TUFJQW9FLE9BQU9wRSxTQUFQcUUsTUFBT3JFLEVBQUVvRSxHQUFGcEU7SUFoQlRvRSxDQUFBQSw4QkFBQUE7SUFtQkExRyxPQUFBLGlDQUFJRixJQUFBZSxLQUFBQSxDQUFJVCxDQUFKLEVBQU95RCxDQUFQaEQsQ0FBSjtFQWxTRmIsR0FBQUEsV0FBQUEsRUFBZ0JRLHVCQUFoQlI7RUFxU0FtSDtFQUFBQTs7SUFBQUE7O0lBQ0VBLE9BQUFyRixDQUFBQSwyQkFBQUEscUJBQUFBLG1CQUFZNUIsSUFBRCxFQUFPQyxJQUFsQjJCO0FBQUFBLE1BQUFBOzs7O01BQWtCO01BQUEsU0FBTyxHQUFQO01BQUE7TUFDaEIsSUFBQSxRQUFHM0IsSUFBSCxDQUFBO1FBQ0UyQixPQUFBQSx1QkFBT2pCLEtBQUFBLENBQUtYLElBQVosRUFBa0JDLElBQVhVO01BRFQ7UUFHRWlCLE9BQUFBLHVCQUFPakIsS0FBQUEsQ0FBS1gsSUFBWixFQUFrQkUsQ0FBWFM7TUFIVDtJQURGaUIsQ0FBQUEsaUNBQUFBLENBQUFBO0VBREZxRixHQUFBQSxXQUFBQTtFQVVBdEgsT0FBQXVIO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsQ0FBQUEsd0JBQUFBLGtCQUFBQSxnQkFBQUE7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBLHFCQUF1QnZILElBQUFnRixVQUFBQSxDQUFVdUMsU0FBVixFQUF1QkEsV0FBdkJ2QyxDQUFxQ3VDO0FBQzVEQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQnZILElBQUFnQyxTQUFBQSxDQUFRMUIsQ0FBUixFQUFXeUQsQ0FBWC9CLENBQWN1RjtBQUNqQ0E7QUFDQUE7QUFDQUE7QUFDQUEsaUJBQW1CdkgsSUFBQWdDLFNBQUFBLENBQVExQixDQUFSLEVBQVdrSCxFQUFYeEYsQ0FBZXVGO0FBQ2xDQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJ2SCxJQUFBZ0MsU0FBQUEsQ0FBUTFCLENBQVIsRUFBV3lELENBQVgvQixDQUFjdUY7QUFDakNBO0FBQ0FBO0FBQ0FBLGVBQWlCdkgsSUFBQWdDLFNBQUFBLENBQVExQixDQUFSLEVBQVdBLENBQVgwQixDQUFjdUY7QUFDL0JBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQSxpQkFBbUJ2SCxJQUFBZ0MsU0FBQUEsQ0FBUTFCLENBQVIsRUFBWWlILElBQVp2RixDQUFtQnVGO0FBQ3RDQTtBQUNBQTtBQUNBQSxpQkFBbUJ2SCxJQUFBZ0MsU0FBQUEsQ0FBU3VGLElBQVQsRUFBZ0JqSCxDQUFoQjBCLENBQW1CdUY7QUFDdENBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGVBQWlCdkgsSUFBQWdDLFNBQUFBLENBQVN1RixJQUFULEVBQWlCQSxJQUFqQnZGLENBQXdCdUY7QUFDekNBO0FBQ0FBO0lBNUVFQSxDQUFBQSw2QkFBQUEsQ0FBQUE7RUFERkQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUFqVEF2SDsifX0seyJvZmZzZXQiOnsibGluZSI6MjI0NzcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhdGlvbmFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvbnVtZXJpYydcblxuY2xhc3MgUmF0aW9uYWwgPCBOdW1lcmljXG4gIGRlZiBzZWxmLnJlZHVjZShudW0sIGRlbilcbiAgICBudW0gPSBudW0udG9faVxuICAgIGRlbiA9IGRlbi50b19pXG5cbiAgICBpZiBkZW4gPT0gMFxuICAgICAgcmFpc2UgWmVyb0RpdmlzaW9uRXJyb3IsICdkaXZpZGVkIGJ5IDAnXG4gICAgZWxzaWYgZGVuIDwgMFxuICAgICAgbnVtID0gLW51bVxuICAgICAgZGVuID0gLWRlblxuICAgIGVsc2lmIGRlbiA9PSAxXG4gICAgICByZXR1cm4gbmV3KG51bSwgZGVuKVxuICAgIGVuZFxuXG4gICAgZ2NkID0gbnVtLmdjZChkZW4pXG5cbiAgICBuZXcobnVtIC8gZ2NkLCBkZW4gLyBnY2QpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNvbnZlcnQobnVtLCBkZW4pXG4gICAgaWYgbnVtLm5pbD8gfHwgZGVuLm5pbD9cbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgJ2Nhbm5vdCBjb252ZXJ0IG5pbCBpbnRvIFJhdGlvbmFsJ1xuICAgIGVuZFxuXG4gICAgaWYgSW50ZWdlciA9PT0gbnVtICYmIEludGVnZXIgPT09IGRlblxuICAgICAgcmV0dXJuIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcblxuICAgIGlmIEZsb2F0ID09PSBudW0gfHwgU3RyaW5nID09PSBudW0gfHwgQ29tcGxleCA9PT0gbnVtXG4gICAgICBudW0gPSBudW0udG9fclxuICAgIGVuZFxuXG4gICAgaWYgRmxvYXQgPT09IGRlbiB8fCBTdHJpbmcgPT09IGRlbiB8fCBDb21wbGV4ID09PSBkZW5cbiAgICAgIGRlbiA9IGRlbi50b19yXG4gICAgZW5kXG5cbiAgICBpZiBkZW4uZXF1YWw/KDEpICYmICEoSW50ZWdlciA9PT0gbnVtKVxuICAgICAgT3BhbC5jb2VyY2VfdG8hKG51bSwgUmF0aW9uYWwsIDp0b19yKVxuICAgIGVsc2lmIE51bWVyaWMgPT09IG51bSAmJiBOdW1lcmljID09PSBkZW5cbiAgICAgIG51bSAvIGRlblxuICAgIGVsc2VcbiAgICAgIHJlZHVjZShudW0sIGRlbilcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUobnVtLCBkZW4pXG4gICAgQG51bSA9IG51bVxuICAgIEBkZW4gPSBkZW5cbiAgZW5kXG5cbiAgZGVmIG51bWVyYXRvclxuICAgIEBudW1cbiAgZW5kXG5cbiAgZGVmIGRlbm9taW5hdG9yXG4gICAgQGRlblxuICBlbmRcblxuICBkZWYgY29lcmNlKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBbb3RoZXIsIHNlbGZdXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFtvdGhlci50b19yLCBzZWxmXVxuXG4gICAgd2hlbiBGbG9hdFxuICAgICAgW290aGVyLCB0b19mXVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIEBudW0gPT0gb3RoZXIubnVtZXJhdG9yICYmIEBkZW4gPT0gb3RoZXIuZGVub21pbmF0b3JcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgQG51bSA9PSBvdGhlciAmJiBAZGVuID09IDFcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgPT0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIG90aGVyID09IHNlbGZcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIDw9PihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgQG51bSAqIG90aGVyLmRlbm9taW5hdG9yIC0gQGRlbiAqIG90aGVyLm51bWVyYXRvciA8PT4gMFxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBAbnVtIC0gQGRlbiAqIG90aGVyIDw9PiAwXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mIDw9PiBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOjw9Piwgb3RoZXJcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmICsob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gUmF0aW9uYWxcbiAgICAgIG51bSA9IEBudW0gKiBvdGhlci5kZW5vbWluYXRvciArIEBkZW4gKiBvdGhlci5udW1lcmF0b3JcbiAgICAgIGRlbiA9IEBkZW4gKiBvdGhlci5kZW5vbWluYXRvclxuXG4gICAgICBSYXRpb25hbChudW0sIGRlbilcblxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgUmF0aW9uYWwoQG51bSArIG90aGVyICogQGRlbiwgQGRlbilcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YgKyBvdGhlclxuXG4gICAgZWxzZVxuICAgICAgX19jb2VyY2VkX18gOissIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGNhc2Ugb3RoZXJcbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBudW0gPSBAbnVtICogb3RoZXIuZGVub21pbmF0b3IgLSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIuZGVub21pbmF0b3JcblxuICAgICAgUmF0aW9uYWwobnVtLCBkZW4pXG5cbiAgICB3aGVuIEludGVnZXJcbiAgICAgIFJhdGlvbmFsKEBudW0gLSBvdGhlciAqIEBkZW4sIEBkZW4pXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mIC0gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDotLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKihvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLm51bWVyYXRvclxuICAgICAgZGVuID0gQGRlbiAqIG90aGVyLmRlbm9taW5hdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBSYXRpb25hbChAbnVtICogb3RoZXIsIEBkZW4pXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mICogb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDoqLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgLyhvdGhlcilcbiAgICBjYXNlIG90aGVyXG4gICAgd2hlbiBSYXRpb25hbFxuICAgICAgbnVtID0gQG51bSAqIG90aGVyLmRlbm9taW5hdG9yXG4gICAgICBkZW4gPSBAZGVuICogb3RoZXIubnVtZXJhdG9yXG5cbiAgICAgIFJhdGlvbmFsKG51bSwgZGVuKVxuXG4gICAgd2hlbiBJbnRlZ2VyXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIHRvX2YgLyAwLjBcbiAgICAgIGVsc2VcbiAgICAgICAgUmF0aW9uYWwoQG51bSwgQGRlbiAqIG90aGVyKVxuICAgICAgZW5kXG5cbiAgICB3aGVuIEZsb2F0XG4gICAgICB0b19mIC8gb3RoZXJcblxuICAgIGVsc2VcbiAgICAgIF9fY29lcmNlZF9fIDovLCBvdGhlclxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgKioob3RoZXIpXG4gICAgY2FzZSBvdGhlclxuICAgIHdoZW4gSW50ZWdlclxuICAgICAgaWYgc2VsZiA9PSAwICYmIG90aGVyIDwgMFxuICAgICAgICBGbG9hdDo6SU5GSU5JVFlcbiAgICAgIGVsc2lmIG90aGVyID4gMFxuICAgICAgICBSYXRpb25hbChAbnVtKipvdGhlciwgQGRlbioqb3RoZXIpXG4gICAgICBlbHNpZiBvdGhlciA8IDBcbiAgICAgICAgUmF0aW9uYWwoQGRlbioqLW90aGVyLCBAbnVtKiotb3RoZXIpXG4gICAgICBlbHNlXG4gICAgICAgIFJhdGlvbmFsKDEsIDEpXG4gICAgICBlbmRcblxuICAgIHdoZW4gRmxvYXRcbiAgICAgIHRvX2YqKm90aGVyXG5cbiAgICB3aGVuIFJhdGlvbmFsXG4gICAgICBpZiBvdGhlciA9PSAwXG4gICAgICAgIFJhdGlvbmFsKDEsIDEpXG4gICAgICBlbHNpZiBvdGhlci5kZW5vbWluYXRvciA9PSAxXG4gICAgICAgIGlmIG90aGVyIDwgMFxuICAgICAgICAgIFJhdGlvbmFsKEBkZW4qKm90aGVyLm51bWVyYXRvci5hYnMsIEBudW0qKm90aGVyLm51bWVyYXRvci5hYnMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBSYXRpb25hbChAbnVtKipvdGhlci5udW1lcmF0b3IsIEBkZW4qKm90aGVyLm51bWVyYXRvcilcbiAgICAgICAgZW5kXG4gICAgICBlbHNpZiBzZWxmID09IDAgJiYgb3RoZXIgPCAwXG4gICAgICAgIHJhaXNlIFplcm9EaXZpc2lvbkVycm9yLCAnZGl2aWRlZCBieSAwJ1xuICAgICAgZWxzZVxuICAgICAgICB0b19mKipvdGhlclxuICAgICAgZW5kXG5cbiAgICBlbHNlXG4gICAgICBfX2NvZXJjZWRfXyA6KiosIG90aGVyXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBhYnNcbiAgICBSYXRpb25hbChAbnVtLmFicywgQGRlbi5hYnMpXG4gIGVuZFxuXG4gIGRlZiBjZWlsKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgICgtKC1AbnVtIC8gQGRlbikpLmNlaWxcbiAgICBlbHNlXG4gICAgICB3aXRoX3ByZWNpc2lvbig6Y2VpbCwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBhbGlhcyBkaXZpZGUgL1xuXG4gIGRlZiBmbG9vcihwcmVjaXNpb24gPSAwKVxuICAgIGlmIHByZWNpc2lvbiA9PSAwXG4gICAgICAoLSgtQG51bSAvIEBkZW4pKS5mbG9vclxuICAgIGVsc2VcbiAgICAgIHdpdGhfcHJlY2lzaW9uKDpmbG9vciwgcHJlY2lzaW9uKVxuICAgIGVuZFxuICBlbmRcblxuICBkZWYgaGFzaFxuICAgIFwiUmF0aW9uYWw6I3tAbnVtfToje0BkZW59XCJcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBcIigje3NlbGZ9KVwiXG4gIGVuZFxuXG4gIGFsaWFzIHF1byAvXG5cbiAgZGVmIHJhdGlvbmFsaXplKGVwcyA9IHVuZGVmaW5lZClcbiAgICAleHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyAoI3tgYXJndW1lbnRzLmxlbmd0aGB9IGZvciAwLi4xKVwifTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVwcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZSA9ICN7ZXBzLmFic30sXG4gICAgICAgICAgYSA9ICN7c2VsZiAtIGBlYH0sXG4gICAgICAgICAgYiA9ICN7c2VsZiArIGBlYH07XG5cbiAgICAgIHZhciBwMCA9IDAsXG4gICAgICAgICAgcDEgPSAxLFxuICAgICAgICAgIHEwID0gMSxcbiAgICAgICAgICBxMSA9IDAsXG4gICAgICAgICAgcDIsIHEyO1xuXG4gICAgICB2YXIgYywgaywgdDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgYyA9ICN7YGFgLmNlaWx9O1xuXG4gICAgICAgIGlmICgje2BjYCA8PSBgYmB9KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBrICA9IGMgLSAxO1xuICAgICAgICBwMiA9IGsgKiBwMSArIHAwO1xuICAgICAgICBxMiA9IGsgKiBxMSArIHEwO1xuICAgICAgICB0ICA9ICN7MSAvIChgYmAgLSBga2ApfTtcbiAgICAgICAgYiAgPSAjezEgLyAoYGFgIC0gYGtgKX07XG4gICAgICAgIGEgID0gdDtcblxuICAgICAgICBwMCA9IHAxO1xuICAgICAgICBxMCA9IHExO1xuICAgICAgICBwMSA9IHAyO1xuICAgICAgICBxMSA9IHEyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gI3tSYXRpb25hbChgYyAqIHAxICsgcDBgLCBgYyAqIHExICsgcTBgKX07XG4gICAgfVxuICBlbmRcblxuICBkZWYgcm91bmQocHJlY2lzaW9uID0gMClcbiAgICByZXR1cm4gd2l0aF9wcmVjaXNpb24oOnJvdW5kLCBwcmVjaXNpb24pIHVubGVzcyBwcmVjaXNpb24gPT0gMFxuICAgIHJldHVybiAwIGlmIEBudW0gPT0gMFxuICAgIHJldHVybiBAbnVtIGlmIEBkZW4gPT0gMVxuXG4gICAgbnVtID0gQG51bS5hYnMgKiAyICsgQGRlblxuICAgIGRlbiA9IEBkZW4gKiAyXG5cbiAgICBhcHByb3ggPSAobnVtIC8gZGVuKS50cnVuY2F0ZVxuXG4gICAgaWYgQG51bSA8IDBcbiAgICAgIC1hcHByb3hcbiAgICBlbHNlXG4gICAgICBhcHByb3hcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHRvX2ZcbiAgICBAbnVtIC8gQGRlblxuICBlbmRcblxuICBkZWYgdG9faVxuICAgIHRydW5jYXRlXG4gIGVuZFxuXG4gIGRlZiB0b19yXG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgdG9fc1xuICAgIFwiI3tAbnVtfS8je0BkZW59XCJcbiAgZW5kXG5cbiAgZGVmIHRydW5jYXRlKHByZWNpc2lvbiA9IDApXG4gICAgaWYgcHJlY2lzaW9uID09IDBcbiAgICAgIEBudW0gPCAwID8gY2VpbCA6IGZsb29yXG4gICAgZWxzZVxuICAgICAgd2l0aF9wcmVjaXNpb24oOnRydW5jYXRlLCBwcmVjaXNpb24pXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiB3aXRoX3ByZWNpc2lvbihtZXRob2QsIHByZWNpc2lvbilcbiAgICByYWlzZSBUeXBlRXJyb3IsICdub3QgYW4gSW50ZWdlcicgdW5sZXNzIEludGVnZXIgPT09IHByZWNpc2lvblxuXG4gICAgcCA9IDEwKipwcmVjaXNpb25cbiAgICBzID0gc2VsZiAqIHBcblxuICAgIGlmIHByZWNpc2lvbiA8IDFcbiAgICAgIChzLnNlbmQobWV0aG9kKSAvIHApLnRvX2lcbiAgICBlbHNlXG4gICAgICBSYXRpb25hbChzLnNlbmQobWV0aG9kKSwgcClcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgUmF0aW9uYWwobnVtZXJhdG9yLCBkZW5vbWluYXRvciA9IDEpXG4gICAgUmF0aW9uYWwuY29udmVydChudW1lcmF0b3IsIGRlbm9taW5hdG9yKVxuICBlbmRcbmVuZFxuXG5jbGFzcyBTdHJpbmdcbiAgZGVmIHRvX3JcbiAgICAleHtcbiAgICAgIHZhciBzdHIgPSBzZWxmLnRyaW1MZWZ0KCksXG4gICAgICAgICAgcmUgPSAvXlsrLV0/W1xcZF9dKyhcXC5bXFxkX10rKT8vLFxuICAgICAgICAgIG1hdGNoID0gc3RyLm1hdGNoKHJlKSxcbiAgICAgICAgICBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuXG4gICAgICBmdW5jdGlvbiBpc0Zsb2F0KCkge1xuICAgICAgICByZXR1cm4gcmUudGVzdChzdHIpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjdXRGbG9hdCgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJlKTtcbiAgICAgICAgdmFyIG51bWJlciA9IG1hdGNoWzBdO1xuICAgICAgICBzdHIgPSBzdHIuc2xpY2UobnVtYmVyLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBudW1iZXIucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0Zsb2F0KCkpIHtcbiAgICAgICAgbnVtZXJhdG9yID0gcGFyc2VGbG9hdChjdXRGbG9hdCgpKTtcblxuICAgICAgICBpZiAoc3RyWzBdID09PSAnLycpIHtcbiAgICAgICAgICAvLyByYXRpb25hbCByZWFsIHBhcnRcbiAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMSk7XG5cbiAgICAgICAgICBpZiAoaXNGbG9hdCgpKSB7XG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHBhcnNlRmxvYXQoY3V0RmxvYXQoKSk7XG4gICAgICAgICAgICByZXR1cm4gI3tSYXRpb25hbChgbnVtZXJhdG9yYCwgYGRlbm9taW5hdG9yYCl9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gI3tSYXRpb25hbChgbnVtZXJhdG9yYCwgMSl9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gI3tSYXRpb25hbChgbnVtZXJhdG9yYCwgMSl9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gI3tSYXRpb25hbCgwLCAxKX07XG4gICAgICB9XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSIsIjxjbGFzczpSYXRpb25hbD4iLCJyZWR1Y2UiLCJudW0iLCJkZW4iLCJ0b19pIiwiPT0iLCIwIiwicmFpc2UiLCJaZXJvRGl2aXNpb25FcnJvciIsIjwiLCItQCIsIjEiLCJuZXciLCJnY2QiLCIvIiwiY29udmVydCIsIiRyZXRfb3JfMSIsIm5pbD8iLCJUeXBlRXJyb3IiLCIkcmV0X29yXzIiLCJJbnRlZ2VyIiwiPT09IiwiJHJldF9vcl8zIiwiJHJldF9vcl80IiwiRmxvYXQiLCJTdHJpbmciLCJDb21wbGV4IiwidG9fciIsIiRyZXRfb3JfNSIsIiRyZXRfb3JfNiIsIiRyZXRfb3JfNyIsImVxdWFsPyIsIiEiLCJPcGFsIiwiY29lcmNlX3RvISIsIlJhdGlvbmFsIiwiJHJldF9vcl84IiwiTnVtZXJpYyIsImluaXRpYWxpemUiLCJAbnVtIiwiQGRlbiIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29lcmNlIiwib3RoZXIiLCJ0b19mIiwiJHJldF9vcl85IiwiJHJldF9vcl8xMCIsIjw9PiIsIi0iLCIqIiwiX19jb2VyY2VkX18iLCIrIiwiKioiLCIkcmV0X29yXzExIiwiRmxvYXQ6OklORklOSVRZIiwiPiIsImFicyIsIiRyZXRfb3JfMTIiLCJjZWlsIiwicHJlY2lzaW9uIiwid2l0aF9wcmVjaXNpb24iLCJmbG9vciIsImhhc2giLCJpbnNwZWN0IiwicmF0aW9uYWxpemUiLCJlcHMiLCJBcmd1bWVudEVycm9yIiwiPD0iLCJyb3VuZCIsIjIiLCJhcHByb3giLCJ0cnVuY2F0ZSIsInRvX3MiLCJtZXRob2QiLCJwIiwi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QlI7QUFDNUNBO0FBQ0FBO0FBQ0FBLGVBQWlCN0IsSUFBQXFDLFVBQUFBLENBQVM3QixDQUFULEVBQVlLLENBQVp3QixDQUFlUjtBQUNoQ0E7QUFDQUE7SUFyQ0VBLENBQUFBLDZCQUFBQSxDQUFBQTtFQURGcUQsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7QUF4V0FuRjsifX0seyJvZmZzZXQiOnsibGluZSI6MjI5ODQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3RpbWUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBzbGljZVxuXG5yZXF1aXJlICdjb3JlbGliL2NvbXBhcmFibGUnXG5cbmNsYXNzIFRpbWUgPCBgRGF0ZWBcbiAgaW5jbHVkZSBDb21wYXJhYmxlXG5cbiAgJXh7XG4gICAgdmFyIGRheXNfb2Zfd2VlayA9ICN7JXdbU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXkgU3VuZGF5XX0sXG4gICAgICAgIHNob3J0X2RheXMgICA9ICN7JXdbU3VuIE1vbiBUdWUgV2VkIFRodSBGcmkgU2F0XX0sXG4gICAgICAgIHNob3J0X21vbnRocyA9ICN7JXdbSmFuIEZlYiBNYXIgQXByIE1heSBKdW4gSnVsIEF1ZyBTZXAgT2N0IE5vdiBEZWNdfSxcbiAgICAgICAgbG9uZ19tb250aHMgID0gI3sld1tKYW51YXJ5IEZlYnJ1YXJ5IE1hcmNoIEFwcmlsIE1heSBKdW5lIEp1bHkgQXVndXN0IFNlcHRlbWJlciBPY3RvYmVyIE5vdmVtYmVyIERlY2VtYmVyXX07XG4gIH1cblxuICBkZWYgc2VsZi5hdChzZWNvbmRzLCBmcmFjID0gdW5kZWZpbmVkKVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgaWYgKCN7VGltZSA9PT0gc2Vjb25kc30pIHtcbiAgICAgICAgaWYgKGZyYWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcImNhbid0IGNvbnZlcnQgVGltZSBpbnRvIGFuIGV4YWN0IG51bWJlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHNlY29uZHMuZ2V0VGltZSgpKTtcbiAgICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlY29uZHMuaXNfdXRjO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlY29uZHMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgc2Vjb25kcyA9ICN7T3BhbC5jb2VyY2VfdG8hKHNlY29uZHMsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoc2Vjb25kcyAqIDEwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZyYWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgZnJhYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGZyYWMsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEYXRlKHNlY29uZHMgKiAxMDAwICsgKGZyYWMgLyAxMDAwKSk7XG4gICAgfVxuICBlbmRcblxuICAleHtcbiAgICBmdW5jdGlvbiB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYykge1xuICAgICAgaWYgKHllYXIuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgeWVhciA9IHBhcnNlSW50KHllYXIsIDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHllYXIgPSAje09wYWwuY29lcmNlX3RvIShgeWVhcmAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vbnRoID09PSBuaWwpIHtcbiAgICAgICAgbW9udGggPSAxO1xuICAgICAgfSBlbHNlIGlmICghbW9udGguJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKCN7YG1vbnRoYC5yZXNwb25kX3RvPyg6dG9fc3RyKX0pIHtcbiAgICAgICAgICBtb250aCA9ICN7YG1vbnRoYC50b19zdHJ9O1xuICAgICAgICAgIHN3aXRjaCAobW9udGgudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ2phbic6IG1vbnRoID0gIDE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZlYic6IG1vbnRoID0gIDI7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21hcic6IG1vbnRoID0gIDM7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Fwcic6IG1vbnRoID0gIDQ7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ21heSc6IG1vbnRoID0gIDU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bic6IG1vbnRoID0gIDY7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2p1bCc6IG1vbnRoID0gIDc7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2F1Zyc6IG1vbnRoID0gIDg7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NlcCc6IG1vbnRoID0gIDk7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ29jdCc6IG1vbnRoID0gMTA7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ25vdic6IG1vbnRoID0gMTE7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2RlYyc6IG1vbnRoID0gMTI7IGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IG1vbnRoID0gI3tgbW9udGhgLnRvX2l9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb250aCA9ICN7T3BhbC5jb2VyY2VfdG8hKGBtb250aGAsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGggPCAxIHx8IG1vbnRoID4gMTIpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcIm1vbnRoIG91dCBvZiByYW5nZTogI3tgbW9udGhgfVwifVxuICAgICAgfVxuICAgICAgbW9udGggPSBtb250aCAtIDE7XG5cbiAgICAgIGlmIChkYXkgPT09IG5pbCkge1xuICAgICAgICBkYXkgPSAxO1xuICAgICAgfSBlbHNlIGlmIChkYXkuJCRpc19zdHJpbmcpIHtcbiAgICAgICAgZGF5ID0gcGFyc2VJbnQoZGF5LCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXkgPSAje09wYWwuY29lcmNlX3RvIShgZGF5YCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF5IDwgMSB8fCBkYXkgPiAzMSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwiZGF5IG91dCBvZiByYW5nZTogI3tgZGF5YH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKGhvdXIgPT09IG5pbCkge1xuICAgICAgICBob3VyID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoaG91ci4kJGlzX3N0cmluZykge1xuICAgICAgICBob3VyID0gcGFyc2VJbnQoaG91ciwgMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG91ciA9ICN7T3BhbC5jb2VyY2VfdG8hKGBob3VyYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAoaG91ciA8IDAgfHwgaG91ciA+IDI0KSB7XG4gICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJob3VyIG91dCBvZiByYW5nZTogI3tgaG91cmB9XCJ9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW4gPT09IG5pbCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfSBlbHNlIGlmIChtaW4uJCRpc19zdHJpbmcpIHtcbiAgICAgICAgbWluID0gcGFyc2VJbnQobWluLCAxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW4gPSAje09wYWwuY29lcmNlX3RvIShgbWluYCwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuXG4gICAgICBpZiAobWluIDwgMCB8fCBtaW4gPiA1OSkge1xuICAgICAgICAje3JhaXNlIEFyZ3VtZW50RXJyb3IsIFwibWluIG91dCBvZiByYW5nZTogI3tgbWluYH1cIn1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA9PT0gbmlsKSB7XG4gICAgICAgIHNlYyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKCFzZWMuJCRpc19udW1iZXIpIHtcbiAgICAgICAgaWYgKHNlYy4kJGlzX3N0cmluZykge1xuICAgICAgICAgIHNlYyA9IHBhcnNlSW50KHNlYywgMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYyA9ICN7T3BhbC5jb2VyY2VfdG8hKGBzZWNgLCBJbnRlZ2VyLCA6dG9faW50KX07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlYyA8IDAgfHwgc2VjID4gNjApIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCBcInNlYyBvdXQgb2YgcmFuZ2U6ICN7YHNlY2B9XCJ9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWNdO1xuICAgIH1cbiAgfVxuXG4gIGRlZiBzZWxmLm5ldyh5ZWFyID0gdW5kZWZpbmVkLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgdXRjX29mZnNldCA9IG5pbClcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGNfb2Zmc2V0ICE9PSBuaWwpIHtcbiAgICAgICAgI3tyYWlzZSBBcmd1bWVudEVycm9yLCAnT3BhbCBkb2VzIG5vdCBzdXBwb3J0IGV4cGxpY2l0bHkgc3BlY2lmeWluZyBVVEMgb2Zmc2V0IGZvciBUaW1lJ31cbiAgICAgIH1cblxuICAgICAgYXJncyAgPSB0aW1lX3BhcmFtcyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIHNlYyk7XG4gICAgICB5ZWFyICA9IGFyZ3NbMF07XG4gICAgICBtb250aCA9IGFyZ3NbMV07XG4gICAgICBkYXkgICA9IGFyZ3NbMl07XG4gICAgICBob3VyICA9IGFyZ3NbM107XG4gICAgICBtaW4gICA9IGFyZ3NbNF07XG4gICAgICBzZWMgICA9IGFyZ3NbNV07XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgMCwgc2VjICogMTAwMCk7XG4gICAgICBpZiAoeWVhciA8IDEwMCkge1xuICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIoeWVhcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHNlbGYubG9jYWwoeWVhciwgbW9udGggPSBuaWwsIGRheSA9IG5pbCwgaG91ciA9IG5pbCwgbWluID0gbmlsLCBzZWMgPSBuaWwsIG1pbGxpc2Vjb25kID0gbmlsLCBfZHVtbXkxID0gbmlsLCBfZHVtbXkyID0gbmlsLCBfZHVtbXkzID0gbmlsKVxuICAgICMgVGhlIF9kdW1teSBhcmdzIGFyZSB0aGVyZSBvbmx5IGJlY2F1c2UgdGhlIE1SSSB2ZXJzaW9uIGFjY2VwdHMgdXAgdG8gMTAgYXJndW1lbnRzXG4gICAgJXh7XG4gICAgICB2YXIgYXJncywgcmVzdWx0O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgICAgYXJncyAgPSAkc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB5ZWFyICA9IGFyZ3NbNV07XG4gICAgICAgIG1vbnRoID0gYXJnc1s0XTtcbiAgICAgICAgZGF5ICAgPSBhcmdzWzNdO1xuICAgICAgICBob3VyICA9IGFyZ3NbMl07XG4gICAgICAgIG1pbiAgID0gYXJnc1sxXTtcbiAgICAgICAgc2VjICAgPSBhcmdzWzBdO1xuICAgICAgfVxuXG4gICAgICBhcmdzICA9IHRpbWVfcGFyYW1zKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbiwgc2VjKTtcbiAgICAgIHllYXIgID0gYXJnc1swXTtcbiAgICAgIG1vbnRoID0gYXJnc1sxXTtcbiAgICAgIGRheSAgID0gYXJnc1syXTtcbiAgICAgIGhvdXIgID0gYXJnc1szXTtcbiAgICAgIG1pbiAgID0gYXJnc1s0XTtcbiAgICAgIHNlYyAgID0gYXJnc1s1XTtcblxuICAgICAgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCAwLCBzZWMgKiAxMDAwKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5nbSh5ZWFyLCBtb250aCA9IG5pbCwgZGF5ID0gbmlsLCBob3VyID0gbmlsLCBtaW4gPSBuaWwsIHNlYyA9IG5pbCwgbWlsbGlzZWNvbmQgPSBuaWwsIF9kdW1teTEgPSBuaWwsIF9kdW1teTIgPSBuaWwsIF9kdW1teTMgPSBuaWwpXG4gICAgIyBUaGUgX2R1bW15IGFyZ3MgYXJlIHRoZXJlIG9ubHkgYmVjYXVzZSB0aGUgTVJJIHZlcnNpb24gYWNjZXB0cyB1cCB0byAxMCBhcmd1bWVudHNcbiAgICAleHtcbiAgICAgIHZhciBhcmdzLCByZXN1bHQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxMCkge1xuICAgICAgICBhcmdzICA9ICRzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHllYXIgID0gYXJnc1s1XTtcbiAgICAgICAgbW9udGggPSBhcmdzWzRdO1xuICAgICAgICBkYXkgICA9IGFyZ3NbM107XG4gICAgICAgIGhvdXIgID0gYXJnc1syXTtcbiAgICAgICAgbWluICAgPSBhcmdzWzFdO1xuICAgICAgICBzZWMgICA9IGFyZ3NbMF07XG4gICAgICB9XG5cbiAgICAgIGFyZ3MgID0gdGltZV9wYXJhbXMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWluLCBzZWMpO1xuICAgICAgeWVhciAgPSBhcmdzWzBdO1xuICAgICAgbW9udGggPSBhcmdzWzFdO1xuICAgICAgZGF5ICAgPSBhcmdzWzJdO1xuICAgICAgaG91ciAgPSBhcmdzWzNdO1xuICAgICAgbWluICAgPSBhcmdzWzRdO1xuICAgICAgc2VjICAgPSBhcmdzWzVdO1xuXG4gICAgICByZXN1bHQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW4sIDAsIHNlYyAqIDEwMDApKTtcbiAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG4gICAgICAgIHJlc3VsdC5zZXRVVENGdWxsWWVhcih5ZWFyKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBhbGlhcyBta3RpbWUgbG9jYWxcbiAgICBhbGlhcyB1dGMgZ21cbiAgZW5kXG5cbiAgZGVmIHNlbGYubm93XG4gICAgbmV3XG4gIGVuZFxuXG4gIGRlZiArKG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICByYWlzZSBUeXBlRXJyb3IsICd0aW1lICsgdGltZT8nXG4gICAgZW5kXG5cbiAgICAleHtcbiAgICAgIGlmICghb3RoZXIuJCRpc19udW1iZXIpIHtcbiAgICAgICAgb3RoZXIgPSAje09wYWwuY29lcmNlX3RvIShvdGhlciwgSW50ZWdlciwgOnRvX2ludCl9O1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpICsgKG90aGVyICogMTAwMCkpO1xuICAgICAgcmVzdWx0LmlzX3V0YyA9IHNlbGYuaXNfdXRjO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiAtKG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICByZXR1cm4gYChzZWxmLmdldFRpbWUoKSAtIG90aGVyLmdldFRpbWUoKSkgLyAxMDAwYFxuICAgIGVuZFxuXG4gICAgJXh7XG4gICAgICBpZiAoIW90aGVyLiQkaXNfbnVtYmVyKSB7XG4gICAgICAgIG90aGVyID0gI3tPcGFsLmNvZXJjZV90byEob3RoZXIsIEludGVnZXIsIDp0b19pbnQpfTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSAtIChvdGhlciAqIDEwMDApKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgPD0+KG90aGVyKVxuICAgIGlmIFRpbWUgPT09IG90aGVyXG4gICAgICB0b19mIDw9PiBvdGhlci50b19mXG4gICAgZWxzZVxuICAgICAgciA9IG90aGVyIDw9PiBzZWxmXG4gICAgICBpZiByLm5pbD9cbiAgICAgICAgbmlsXG4gICAgICBlbHNpZiByID4gMFxuICAgICAgICAtMVxuICAgICAgZWxzaWYgciA8IDBcbiAgICAgICAgMVxuICAgICAgZWxzZVxuICAgICAgICAwXG4gICAgICBlbmRcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmID09KG90aGVyKVxuICAgIFRpbWUgPT09IG90aGVyICYmIGAje3RvX2Z9ID09PSAje290aGVyLnRvX2Z9YFxuICBlbmRcblxuICBkZWYgYXNjdGltZVxuICAgIHN0cmZ0aW1lICclYSAlYiAlZSAlSDolTTolUyAlWSdcbiAgZW5kXG5cbiAgYWxpYXMgY3RpbWUgYXNjdGltZVxuXG4gIGRlZiBkYXlcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0RhdGUoKSA6IHNlbGYuZ2V0RGF0ZSgpYFxuICBlbmRcblxuICBkZWYgeWRheVxuICAgICMgaHR0cDovL2phdmFzY3JpcHQuYWJvdXQuY29tL2xpYnJhcnkvYmxkYXl5ZWFyLmh0bVxuICAgICMgYWxzbyBzZWUgbW9tZW50LmpzIGltcGxlbWVudGF0aW9uOiBodHRwOi8vZ2l0LmlvL3ZDS05FXG5cbiAgICBzdGFydF9vZl95ZWFyID0gVGltZS5uZXcoeWVhcikudG9faVxuICAgIHN0YXJ0X29mX2RheSAgPSBUaW1lLm5ldyh5ZWFyLCBtb250aCwgZGF5KS50b19pXG4gICAgb25lX2RheSAgICAgICA9IDg2XzQwMFxuXG4gICAgKChzdGFydF9vZl9kYXkgLSBzdGFydF9vZl95ZWFyKSAvIG9uZV9kYXkpLnJvdW5kICsgMVxuICBlbmRcblxuICBkZWYgaXNkc3RcbiAgICAleHtcbiAgICAgIHZhciBqYW4gPSBuZXcgRGF0ZShzZWxmLmdldEZ1bGxZZWFyKCksIDAsIDEpLFxuICAgICAgICAgIGp1bCA9IG5ldyBEYXRlKHNlbGYuZ2V0RnVsbFllYXIoKSwgNiwgMSk7XG4gICAgICByZXR1cm4gc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpIDwgTWF0aC5tYXgoamFuLmdldFRpbWV6b25lT2Zmc2V0KCksIGp1bC5nZXRUaW1lem9uZU9mZnNldCgpKTtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGRzdD8gaXNkc3RcblxuICBkZWYgZHVwXG4gICAgY29weSA9IGBuZXcgRGF0ZShzZWxmLmdldFRpbWUoKSlgXG5cbiAgICBjb3B5LmNvcHlfaW5zdGFuY2VfdmFyaWFibGVzKHNlbGYpXG4gICAgY29weS5pbml0aWFsaXplX2R1cChzZWxmKVxuXG4gICAgY29weVxuICBlbmRcblxuICBkZWYgZXFsPyhvdGhlcilcbiAgICBvdGhlci5pc19hPyhUaW1lKSAmJiAoc2VsZiA8PT4gb3RoZXIpLnplcm8/XG4gIGVuZFxuXG4gIGRlZiBmcmlkYXk/XG4gICAgYCN7d2RheX0gPT0gNWBcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBgJ1RpbWU6JyArIHNlbGYuZ2V0VGltZSgpYFxuICBlbmRcblxuICBkZWYgaG91clxuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDSG91cnMoKSA6IHNlbGYuZ2V0SG91cnMoKWBcbiAgZW5kXG5cbiAgZGVmIGluc3BlY3RcbiAgICBpZiB1dGM/XG4gICAgICBzdHJmdGltZSAnJVktJW0tJWQgJUg6JU06JVMgVVRDJ1xuICAgIGVsc2VcbiAgICAgIHN0cmZ0aW1lICclWS0lbS0lZCAlSDolTTolUyAleidcbiAgICBlbmRcbiAgZW5kXG5cbiAgYWxpYXMgbWRheSBkYXlcblxuICBkZWYgbWluXG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENNaW51dGVzKCkgOiBzZWxmLmdldE1pbnV0ZXMoKWBcbiAgZW5kXG5cbiAgZGVmIG1vblxuICAgIGAoc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ01vbnRoKCkgOiBzZWxmLmdldE1vbnRoKCkpICsgMWBcbiAgZW5kXG5cbiAgZGVmIG1vbmRheT9cbiAgICBgI3t3ZGF5fSA9PSAxYFxuICBlbmRcblxuICBhbGlhcyBtb250aCBtb25cblxuICBkZWYgc2F0dXJkYXk/XG4gICAgYCN7d2RheX0gPT0gNmBcbiAgZW5kXG5cbiAgZGVmIHNlY1xuICAgIGBzZWxmLmlzX3V0YyA/IHNlbGYuZ2V0VVRDU2Vjb25kcygpIDogc2VsZi5nZXRTZWNvbmRzKClgXG4gIGVuZFxuXG4gIGRlZiBzdWNjXG4gICAgJXh7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoc2VsZi5nZXRUaW1lKCkgKyAxMDAwKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSBzZWxmLmlzX3V0YztcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICBlbmRcblxuICBkZWYgdXNlY1xuICAgIGBzZWxmLmdldE1pbGxpc2Vjb25kcygpICogMTAwMGBcbiAgZW5kXG5cbiAgZGVmIHpvbmVcbiAgICAleHtcbiAgICAgIHZhciBzdHJpbmcgPSBzZWxmLnRvU3RyaW5nKCksXG4gICAgICAgICAgcmVzdWx0O1xuXG4gICAgICBpZiAoc3RyaW5nLmluZGV4T2YoJygnKSA9PSAtMSkge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1tBLVpdezMsNH0vKVswXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBzdHJpbmcubWF0Y2goL1xcKCguKylcXCkoPzpcXHN8JCkvKVsxXVxuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09IFwiR01UXCIgJiYgLyhHTVRcXFcqXFxkezR9KS8udGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBSZWdFeHAuJDE7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBnZXRnbVxuICAgICV4e1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKHNlbGYuZ2V0VGltZSgpKTtcbiAgICAgIHJlc3VsdC5pc191dGMgPSB0cnVlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIGVuZFxuXG4gIGFsaWFzIGdldHV0YyBnZXRnbVxuXG4gIGRlZiBnbXRpbWVcbiAgICAleHtcbiAgICAgIHNlbGYuaXNfdXRjID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgZW5kXG5cbiAgYWxpYXMgdXRjIGdtdGltZVxuXG4gIGRlZiBnbXQ/XG4gICAgYHNlbGYuaXNfdXRjID09PSB0cnVlYFxuICBlbmRcblxuICBkZWYgZ210X29mZnNldFxuICAgIGBzZWxmLmlzX3V0YyA/IDAgOiAtc2VsZi5nZXRUaW1lem9uZU9mZnNldCgpICogNjBgXG4gIGVuZFxuXG4gIGRlZiBzdHJmdGltZShmb3JtYXQpXG4gICAgJXh7XG4gICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoLyUoW1xcLV8jXjBdKjp7MCwyfSkoXFxkKyk/KFtFT10qKSguKS9nLCBmdW5jdGlvbihmdWxsLCBmbGFncywgd2lkdGgsIF8sIGNvbnYpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICAgICAgICB6ZXJvICAgPSBmbGFncy5pbmRleE9mKCcwJykgIT09IC0xLFxuICAgICAgICAgICAgcGFkICAgID0gZmxhZ3MuaW5kZXhPZignLScpID09PSAtMSxcbiAgICAgICAgICAgIGJsYW5rICA9IGZsYWdzLmluZGV4T2YoJ18nKSAhPT0gLTEsXG4gICAgICAgICAgICB1cGNhc2UgPSBmbGFncy5pbmRleE9mKCdeJykgIT09IC0xLFxuICAgICAgICAgICAgaW52ZXJ0ID0gZmxhZ3MuaW5kZXhPZignIycpICE9PSAtMSxcbiAgICAgICAgICAgIGNvbG9ucyA9IChmbGFncy5tYXRjaCgnOicpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICAgICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCwgMTApO1xuXG4gICAgICAgIGlmICh6ZXJvICYmIGJsYW5rKSB7XG4gICAgICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJzAnKSA8IGZsYWdzLmluZGV4T2YoJ18nKSkge1xuICAgICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsYW5rID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChjb252KSB7XG4gICAgICAgICAgY2FzZSAnWSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZWFyfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGgucm91bmQoI3t5ZWFyfSAvIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t5ZWFyfSAlIDEwMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAje21vbn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGxvbmdfbW9udGhzWyN7bW9ufSAtIDFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGJsYW5rICAgPSAhemVybztcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9tb250aHNbI3ttb259IC0gMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFua1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm9cbiAgICAgICAgICAgIHJlc3VsdCArPSAje2RheX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2onOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t5ZGF5fTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB6ZXJvICAgID0gIWJsYW5rO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgYmxhbmsgICA9ICF6ZXJvO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7aG91cn07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0knOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3tob3VyfSAlIDEyIHx8IDEyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICBibGFuayAgID0gIXplcm87XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gJSAxMiB8fCAxMik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1AnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICgje2hvdXJ9ID49IDEyID8gXCJwbVwiIDogXCJhbVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICByZXN1bHQgKz0gKCN7aG91cn0gPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3ttaW59O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIHplcm8gICAgPSAhYmxhbms7XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzZWN9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgemVybyAgICA9ICFibGFuaztcbiAgICAgICAgICAgIHdpZHRoICAgPSBpc05hTih3aWR0aCkgPyAzIDogd2lkdGg7XG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICB3aWR0aCAgID0gaXNOYU4od2lkdGgpID8gOSA6IHdpZHRoO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICN7YHNlbGYuZ2V0TWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKWAucmp1c3QoMywgJzAnKX07XG4gICAgICAgICAgICByZXN1bHQgID0gI3tgcmVzdWx0YC5sanVzdChgd2lkdGhgLCAnMCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ICA9IHNlbGYuZ2V0VGltZXpvbmVPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBob3VycyAgID0gTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyhvZmZzZXQpICUgNjA7XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBvZmZzZXQgPCAwID8gXCIrXCIgOiBcIi1cIjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBob3VycyA8IDEwID8gXCIwXCIgOiBcIlwiO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGhvdXJzO1xuXG4gICAgICAgICAgICBpZiAoY29sb25zID4gMCkge1xuICAgICAgICAgICAgICByZXN1bHQgKz0gXCI6XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCArPSBtaW51dGVzIDwgMTAgPyBcIjBcIiA6IFwiXCI7XG4gICAgICAgICAgICByZXN1bHQgKz0gbWludXRlcztcblxuICAgICAgICAgICAgaWYgKGNvbG9ucyA+IDEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOjAwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3t6b25lfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXN1bHQgKz0gZGF5c19vZl93ZWVrWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBzaG9ydF9kYXlzWyN7d2RheX1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAoI3t3ZGF5fSArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd3JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3dkYXl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzBdLnRvX3Mucmp1c3QoMiwgJzAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0cnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7Y3dlZWtfY3llYXJbMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje2N3ZWVrX2N5ZWFyWzFdWy0yLi4tMV19O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3RvX2l9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcdFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWEgJWIgJWUgJVQgJVknKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVtLyVkLyV5Jyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclWS0lbS0lZCcpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJWUtJV5iLSU0WScpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICByZXN1bHQgKz0gI3tzdHJmdGltZSgnJUk6JU06JVMgJXAnKX07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ1InOlxuICAgICAgICAgICAgcmVzdWx0ICs9ICN7c3RyZnRpbWUoJyVIOiVNJyl9O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHJlc3VsdCArPSAje3N0cmZ0aW1lKCclSDolTTolUycpfTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmdWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwY2FzZSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9bQS1aXS8sIGZ1bmN0aW9uKGMpIHsgYy50b0xvd2VyQ2FzZSgpIH0pLlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC9bYS16XS8sIGZ1bmN0aW9uKGMpIHsgYy50b1VwcGVyQ2FzZSgpIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhZCAmJiAoemVybyB8fCBibGFuaykpIHtcbiAgICAgICAgICByZXN1bHQgPSAje2ByZXN1bHRgLnJqdXN0KGBpc05hTih3aWR0aCkgPyAyIDogd2lkdGhgLCBgYmxhbmsgPyBcIiBcIiA6IFwiMFwiYCl9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIHN1bmRheT9cbiAgICBgI3t3ZGF5fSA9PSAwYFxuICBlbmRcblxuICBkZWYgdGh1cnNkYXk/XG4gICAgYCN7d2RheX0gPT0gNGBcbiAgZW5kXG5cbiAgZGVmIHRvX2FcbiAgICBbc2VjLCBtaW4sIGhvdXIsIGRheSwgbW9udGgsIHllYXIsIHdkYXksIHlkYXksIGlzZHN0LCB6b25lXVxuICBlbmRcblxuICBkZWYgdG9fZlxuICAgIGBzZWxmLmdldFRpbWUoKSAvIDEwMDBgXG4gIGVuZFxuXG4gIGRlZiB0b19pXG4gICAgYHBhcnNlSW50KHNlbGYuZ2V0VGltZSgpIC8gMTAwMCwgMTApYFxuICBlbmRcblxuICBhbGlhcyB0b19zIGluc3BlY3RcblxuICBkZWYgdHVlc2RheT9cbiAgICBgI3t3ZGF5fSA9PSAyYFxuICBlbmRcblxuICBhbGlhcyB0dl9zZWMgdG9faVxuXG4gIGFsaWFzIHR2X3VzZWMgdXNlY1xuXG4gIGFsaWFzIHV0Yz8gZ210P1xuXG4gIGFsaWFzIGdtdG9mZiBnbXRfb2Zmc2V0XG4gIGFsaWFzIHV0Y19vZmZzZXQgZ210X29mZnNldFxuXG4gIGRlZiB3ZGF5XG4gICAgYHNlbGYuaXNfdXRjID8gc2VsZi5nZXRVVENEYXkoKSA6IHNlbGYuZ2V0RGF5KClgXG4gIGVuZFxuXG4gIGRlZiB3ZWRuZXNkYXk/XG4gICAgYCN7d2RheX0gPT0gM2BcbiAgZW5kXG5cbiAgZGVmIHllYXJcbiAgICBgc2VsZi5pc191dGMgPyBzZWxmLmdldFVUQ0Z1bGxZZWFyKCkgOiBzZWxmLmdldEZ1bGxZZWFyKClgXG4gIGVuZFxuXG4gIGRlZiBjd2Vla19jeWVhclxuICAgIGphbjAxID0gVGltZS5uZXcoeWVhciwgMSwgMSlcbiAgICBqYW4wMV93ZGF5ID0gamFuMDEud2RheVxuICAgIGZpcnN0X21vbmRheSA9IDBcbiAgICB5ZWFyID0gc2VsZi55ZWFyXG4gICAgaWYgamFuMDFfd2RheSA8PSA0ICYmIGphbjAxX3dkYXkgIT0gMFxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXJcbiAgICAgIG9mZnNldCA9IGphbjAxX3dkYXkgLSAxXG4gICAgZWxzZVxuICAgICAgIyBKYW4gMDEgaXMgaW4gdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgb2Zmc2V0ID0gamFuMDFfd2RheSAtIDcgLSAxXG4gICAgICBvZmZzZXQgPSAtMSBpZiBvZmZzZXQgPT0gLTggIyBBZGp1c3QgaWYgSmFuIDAxIGlzIGEgU3VuZGF5XG4gICAgZW5kXG5cbiAgICB3ZWVrID0gKCh5ZGF5ICsgb2Zmc2V0KSAvIDcuMDApLmNlaWxcblxuICAgIGlmIHdlZWsgPD0gMFxuICAgICAgIyBHZXQgdGhlIGxhc3Qgd2VlayBvZiB0aGUgcHJldmlvdXMgeWVhclxuICAgICAgcmV0dXJuIFRpbWUubmV3KHNlbGYueWVhciAtIDEsIDEyLCAzMSkuY3dlZWtfY3llYXJcbiAgICBlbHNpZiB3ZWVrID09IDUzXG4gICAgICAjIEZpbmQgb3V0IHdoZXRoZXIgdGhpcyBpcyBhY3R1YWxseSB3ZWVrIDUzIG9yIGFscmVhZHkgd2VlayAwMSBvZiB0aGUgZm9sbG93aW5nIHllYXJcbiAgICAgIGRlYzMxID0gVGltZS5uZXcoc2VsZi55ZWFyLCAxMiwgMzEpXG4gICAgICBkZWMzMV93ZGF5ID0gZGVjMzEud2RheVxuICAgICAgaWYgZGVjMzFfd2RheSA8PSAzICYmIGRlYzMxX3dkYXkgIT0gMFxuICAgICAgICB3ZWVrID0gMVxuICAgICAgICB5ZWFyICs9IDFcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgW3dlZWssIHllYXJdXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsInNlbGYiLCJyZXF1aXJlIiwiPGNsYXNzOlRpbWU+IiwiaW5jbHVkZSIsIkNvbXBhcmFibGUiLCJhdCIsInNlY29uZHMiLCJmcmFjIiwiVGltZSIsIj09PSIsInJhaXNlIiwiVHlwZUVycm9yIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwicmVzcG9uZF90bz8iLCJ0b19zdHIiLCJ0b19pIiwiQXJndW1lbnRFcnJvciIsIm5ldyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW4iLCJzZWMiLCJ1dGNfb2Zmc2V0IiwibG9jYWwiLCJtaWxsaXNlY29uZCIsIl9kdW1teTEiLCJfZHVtbXkyIiwiX2R1bW15MyIsImdtIiwibm93IiwiKyIsIm90aGVyIiwiLSIsIjw9PiIsInRvX2YiLCJyIiwibmlsPyIsIj4iLCIwIiwiLTEiLCI8IiwiMSIsIj09IiwiJHJldF9vcl8xIiwiYXNjdGltZSIsInN0cmZ0aW1lIiwieWRheSIsInN0YXJ0X29mX3llYXIiLCJzdGFydF9vZl9kYXkiLCJvbmVfZGF5IiwiODY0MDAiLCIvIiwicm91bmQiLCJpc2RzdCIsImR1cCIsImNvcHkiLCJjb3B5X2luc3RhbmNlX3ZhcmlhYmxlcyIsImluaXRpYWxpemVfZHVwIiwiZXFsPyIsIiRyZXRfb3JfMiIsImlzX2E/IiwiemVybz8iLCJmcmlkYXk/Iiwid2RheSIsImhhc2giLCJpbnNwZWN0IiwidXRjPyIsIm1vbiIsIm1vbmRheT8iLCJzYXR1cmRheT8iLCJzdWNjIiwidXNlYyIsInpvbmUiLCJnZXRnbSIsImdtdGltZSIsImdtdD8iLCJnbXRfb2Zmc2V0IiwiZm9ybWF0Iiwicmp1c3QiLCIzIiwibGp1c3QiLCJjd2Vla19jeWVhciIsIltdIiwidG9fcyIsIjIiLCItMiIsInN1bmRheT8iLCJ0aHVyc2RheT8iLCJ0b19hIiwidHVlc2RheT8iLCJ3ZWRuZXNkYXk/IiwiamFuMDEiLCJqYW4wMV93ZGF5IiwiZmlyc3RfbW9uZGF5IiwiJHJldF9vcl8zIiwiPD0iLCI0IiwiIT0iLCJvZmZzZXQiLCI3IiwiLTgiLCJ3ZWVrIiwiY2VpbCIsIjEyIiwiMzEiLCI1MyIsImRlYzMxIiwiZGVjMzFfd2RheSIsIiRyZXRfb3JfNCJdLCJtYXBwaW5ncyI6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QVIsQ0FBQTtRQUVFLE9BQU8zRixvQkFBSVcsS0FBQUEsQ0FBZWlCLFVBQVZwQyxJQUFJb0IsTUFBQUEsQ0FBQUEsQ0FBTWdCLEVBQUVTLENBQUZULENBQW5CLEVBQXdCdUUsRUFBeEIsRUFBNEJDLEVBQXhCekYsQ0FBMkJrRSxhQUFBQSxDQUFBQTtNQUZ4QyxPQUdBLElBQU1vQixJQUFLM0QsT0FBQUEsQ0FBRytELEVBQUgvRCxDQUFYOztRQUVFZ0UsUUFBUXRHLG9CQUFJVyxLQUFBQSxDQUFLbkIsSUFBSW9CLE1BQUFBLENBQUFBLENBQWIsRUFBb0J1RixFQUFwQixFQUF3QkMsRUFBcEJ6RjtRQUNaNEYsYUFBYUQsS0FBSzNDLE1BQUFBLENBQUFBO1FBQ2xCLElBQUEsUUFBRyxhQUFBLElBQUEsUUF4dUJUNkMsQ0FBQUEsWUF3dUJvQmIsT0FBWFksVUFBV1osRUFBR2hCLENBQUhnQixDQXh1QnBCYSxDQXd1QlMsQ0FBQTtVQUFtQjNCLE9BQUEwQixVQUFXVixPQUFBQSxDQUFHM0QsQ0FBSDJEO1FBQTlCO1VBeHVCVGhCLE9BQUE7UUF3dUJTLENBQUEsa0JBQUgsQ0FBQTs7VUFDRW9CLE9BQU81RDtVQUNQekIsT0FBS2MsU0FBTGQsSUFBS2MsRUFBR1csQ0FBSFgsRUFGUCxFQUpGO01BVUFtRCxPQUFBLENBQUNvQixJQUFELEVBQU9yRixJQUFQO0lBN0JGaUUsQ0FBQUEsa0NBQUFBLENBQUFBO0VBN3NCRm5GLEdBQUFBLFdBQUFBLEVBQWNILElBQWRHO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyMzkzOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvc3RydWN0LnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ2NvcmVsaWIvZW51bWVyYWJsZSdcblxuY2xhc3MgU3RydWN0XG4gIGluY2x1ZGUgRW51bWVyYWJsZVxuXG4gIGRlZiBzZWxmLm5ldyhjb25zdF9uYW1lLCAqYXJncywga2V5d29yZF9pbml0OiBmYWxzZSwgJmJsb2NrKVxuICAgIGlmIGNvbnN0X25hbWVcbiAgICAgIGlmIGNvbnN0X25hbWUuY2xhc3MgPT0gU3RyaW5nICYmIGNvbnN0X25hbWVbMF0udXBjYXNlICE9IGNvbnN0X25hbWVbMF1cbiAgICAgICAgIyBGYXN0IHRyYWNrIHNvIHRoYXQgd2Ugc2tpcCBuZWVkbGVzc2x5IGdvaW5nIHRocnUgZXhjZXB0aW9uc1xuICAgICAgICAjIGluIG1vc3QgY2FzZXMuXG4gICAgICAgIGFyZ3MudW5zaGlmdChjb25zdF9uYW1lKVxuICAgICAgICBjb25zdF9uYW1lID0gbmlsXG4gICAgICBlbHNlXG4gICAgICAgIGJlZ2luXG4gICAgICAgICAgY29uc3RfbmFtZSA9IE9wYWwuY29uc3RfbmFtZSEoY29uc3RfbmFtZSlcbiAgICAgICAgcmVzY3VlIFR5cGVFcnJvciwgTmFtZUVycm9yXG4gICAgICAgICAgYXJncy51bnNoaWZ0KGNvbnN0X25hbWUpXG4gICAgICAgICAgY29uc3RfbmFtZSA9IG5pbFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgYXJncy5tYXAgZG8gfGFyZ3xcbiAgICAgIE9wYWwuY29lcmNlX3RvIShhcmcsIFN0cmluZywgOnRvX3N0cilcbiAgICBlbmRcblxuICAgIGtsYXNzID0gQ2xhc3MubmV3KHNlbGYpIGRvXG4gICAgICBhcmdzLmVhY2ggeyB8YXJnfCBkZWZpbmVfc3RydWN0X2F0dHJpYnV0ZShhcmcpIH1cblxuICAgICAgY2xhc3MgPDwgc2VsZlxuICAgICAgICBkZWYgbmV3KCphcmdzKVxuICAgICAgICAgIGluc3RhbmNlID0gYWxsb2NhdGVcbiAgICAgICAgICBgI3tpbnN0YW5jZX0uJCRkYXRhID0ge31gXG4gICAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZSgqYXJncylcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICBlbmRcblxuICAgICAgICBhbGlhc19tZXRob2QgOltdLCA6bmV3XG4gICAgICBlbmRcbiAgICBlbmRcblxuICAgIGtsYXNzLm1vZHVsZV9ldmFsKCZibG9jaykgaWYgYmxvY2tcbiAgICBga2xhc3MuJCRrZXl3b3JkX2luaXQgPSBrZXl3b3JkX2luaXRgXG5cbiAgICBpZiBjb25zdF9uYW1lXG4gICAgICBTdHJ1Y3QuY29uc3Rfc2V0KGNvbnN0X25hbWUsIGtsYXNzKVxuICAgIGVuZFxuXG4gICAga2xhc3NcbiAgZW5kXG5cbiAgZGVmIHNlbGYuZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUobmFtZSlcbiAgICBpZiBzZWxmID09IFN0cnVjdFxuICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3lvdSBjYW5ub3QgZGVmaW5lIGF0dHJpYnV0ZXMgdG8gdGhlIFN0cnVjdCBjbGFzcydcbiAgICBlbmRcblxuICAgIG1lbWJlcnMgPDwgbmFtZVxuXG4gICAgZGVmaW5lX21ldGhvZCBuYW1lIGRvXG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gICAgZW5kXG5cbiAgICBkZWZpbmVfbWV0aG9kIFwiI3tuYW1lfT1cIiBkbyB8dmFsdWV8XG4gICAgICBgc2VsZi4kJGRhdGFbbmFtZV0gPSB2YWx1ZWBcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIHNlbGYubWVtYmVyc1xuICAgIGlmIHNlbGYgPT0gU3RydWN0XG4gICAgICByYWlzZSBBcmd1bWVudEVycm9yLCAndGhlIFN0cnVjdCBjbGFzcyBoYXMgbm8gbWVtYmVycydcbiAgICBlbmRcblxuICAgIEBtZW1iZXJzIHx8PSBbXVxuICBlbmRcblxuICBkZWYgc2VsZi5pbmhlcml0ZWQoa2xhc3MpXG4gICAgbWVtYmVycyA9IEBtZW1iZXJzXG5cbiAgICBrbGFzcy5pbnN0YW5jZV9ldmFsIGRvXG4gICAgICBAbWVtYmVycyA9IG1lbWJlcnNcbiAgICBlbmRcbiAgZW5kXG5cbiAgZGVmIGluaXRpYWxpemUoKmFyZ3MpXG4gICAgaWYgYCN7c2VsZi5jbGFzc30uJCRrZXl3b3JkX2luaXRgXG4gICAgICBrd2FyZ3MgPSBhcmdzLmxhc3QgfHwge31cblxuICAgICAgaWYgYXJncy5sZW5ndGggPiAxIHx8IGAoYXJncy5sZW5ndGggPT09IDEgJiYgIWt3YXJncy4kJGlzX2hhc2gpYFxuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcIndyb25nIG51bWJlciBvZiBhcmd1bWVudHMgKGdpdmVuICN7YXJncy5sZW5ndGh9LCBleHBlY3RlZCAwKVwiXG4gICAgICBlbmRcblxuICAgICAgZXh0cmEgPSBrd2FyZ3Mua2V5cyAtIHNlbGYuY2xhc3MubWVtYmVyc1xuICAgICAgaWYgZXh0cmEuYW55P1xuICAgICAgICByYWlzZSBBcmd1bWVudEVycm9yLCBcInVua25vd24ga2V5d29yZHM6ICN7ZXh0cmEuam9pbignLCAnKX1cIlxuICAgICAgZW5kXG5cbiAgICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIGRvIHxuYW1lfFxuICAgICAgICBzZWxmW25hbWVdID0ga3dhcmdzW25hbWVdXG4gICAgICBlbmRcbiAgICBlbHNlXG4gICAgICBpZiBhcmdzLmxlbmd0aCA+IHNlbGYuY2xhc3MubWVtYmVycy5sZW5ndGhcbiAgICAgICAgcmFpc2UgQXJndW1lbnRFcnJvciwgJ3N0cnVjdCBzaXplIGRpZmZlcnMnXG4gICAgICBlbmRcblxuICAgICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2hfd2l0aF9pbmRleCBkbyB8bmFtZSwgaW5kZXh8XG4gICAgICAgIHNlbGZbbmFtZV0gPSBhcmdzW2luZGV4XVxuICAgICAgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplX2NvcHkoZnJvbSlcbiAgICAleHtcbiAgICAgIHNlbGYuJCRkYXRhID0ge31cbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbS4kJGRhdGEpLCBpLCBtYXgsIG5hbWU7XG4gICAgICBmb3IgKGkgPSAwLCBtYXggPSBrZXlzLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBzZWxmLiQkZGF0YVtuYW1lXSA9IGZyb20uJCRkYXRhW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgZW5kXG5cbiAgZGVmIG1lbWJlcnNcbiAgICBzZWxmLmNsYXNzLm1lbWJlcnNcbiAgZW5kXG5cbiAgZGVmIGhhc2hcbiAgICBIYXNoLm5ldyhgc2VsZi4kJGRhdGFgKS5oYXNoXG4gIGVuZFxuXG4gIGRlZiBbXShuYW1lKVxuICAgIGlmIEludGVnZXIgPT09IG5hbWVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIHNtYWxsIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lIDwgLXNlbGYuY2xhc3MubWVtYmVycy5zaXplXG4gICAgICByYWlzZSBJbmRleEVycm9yLCBcIm9mZnNldCAje25hbWV9IHRvbyBsYXJnZSBmb3Igc3RydWN0KHNpemU6I3tzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZX0pXCIgaWYgbmFtZSA+PSBzZWxmLmNsYXNzLm1lbWJlcnMuc2l6ZVxuXG4gICAgICBuYW1lID0gc2VsZi5jbGFzcy5tZW1iZXJzW25hbWVdXG4gICAgZWxzaWYgU3RyaW5nID09PSBuYW1lXG4gICAgICAleHtcbiAgICAgICAgaWYoIXNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgI3tyYWlzZSBOYW1lRXJyb3IubmV3KFwibm8gbWVtYmVyICcje25hbWV9JyBpbiBzdHJ1Y3RcIiwgbmFtZSl9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICByYWlzZSBUeXBlRXJyb3IsIFwibm8gaW1wbGljaXQgY29udmVyc2lvbiBvZiAje25hbWUuY2xhc3N9IGludG8gSW50ZWdlclwiXG4gICAgZW5kXG5cbiAgICBuYW1lID0gT3BhbC5jb2VyY2VfdG8hKG5hbWUsIFN0cmluZywgOnRvX3N0cilcbiAgICBgc2VsZi4kJGRhdGFbbmFtZV1gXG4gIGVuZFxuXG4gIGRlZiBbXT0obmFtZSwgdmFsdWUpXG4gICAgaWYgSW50ZWdlciA9PT0gbmFtZVxuICAgICAgcmFpc2UgSW5kZXhFcnJvciwgXCJvZmZzZXQgI3tuYW1lfSB0b28gc21hbGwgZm9yIHN0cnVjdChzaXplOiN7c2VsZi5jbGFzcy5tZW1iZXJzLnNpemV9KVwiIGlmIG5hbWUgPCAtc2VsZi5jbGFzcy5tZW1iZXJzLnNpemVcbiAgICAgIHJhaXNlIEluZGV4RXJyb3IsIFwib2Zmc2V0ICN7bmFtZX0gdG9vIGxhcmdlIGZvciBzdHJ1Y3Qoc2l6ZToje3NlbGYuY2xhc3MubWVtYmVycy5zaXplfSlcIiBpZiBuYW1lID49IHNlbGYuY2xhc3MubWVtYmVycy5zaXplXG5cbiAgICAgIG5hbWUgPSBzZWxmLmNsYXNzLm1lbWJlcnNbbmFtZV1cbiAgICBlbHNpZiBTdHJpbmcgPT09IG5hbWVcbiAgICAgIHJhaXNlIE5hbWVFcnJvci5uZXcoXCJubyBtZW1iZXIgJyN7bmFtZX0nIGluIHN0cnVjdFwiLCBuYW1lKSB1bmxlc3Mgc2VsZi5jbGFzcy5tZW1iZXJzLmluY2x1ZGU/KG5hbWUudG9fc3ltKVxuICAgIGVsc2VcbiAgICAgIHJhaXNlIFR5cGVFcnJvciwgXCJubyBpbXBsaWNpdCBjb252ZXJzaW9uIG9mICN7bmFtZS5jbGFzc30gaW50byBJbnRlZ2VyXCJcbiAgICBlbmRcblxuICAgIG5hbWUgPSBPcGFsLmNvZXJjZV90byEobmFtZSwgU3RyaW5nLCA6dG9fc3RyKVxuICAgIGBzZWxmLiQkZGF0YVtuYW1lXSA9IHZhbHVlYFxuICBlbmRcblxuICBkZWYgPT0ob3RoZXIpXG4gICAgcmV0dXJuIGZhbHNlIHVubGVzcyBvdGhlci5pbnN0YW5jZV9vZj8oc2VsZi5jbGFzcylcblxuICAgICV4e1xuICAgICAgdmFyIHJlY3Vyc2VkMSA9IHt9LCByZWN1cnNlZDIgPSB7fTtcblxuICAgICAgZnVuY3Rpb24gX2VxZXEoc3RydWN0LCBvdGhlcikge1xuICAgICAgICB2YXIga2V5LCBhLCBiO1xuXG4gICAgICAgIHJlY3Vyc2VkMVsje2BzdHJ1Y3RgLl9faWRfX31dID0gdHJ1ZTtcbiAgICAgICAgcmVjdXJzZWQyWyN7YG90aGVyYC5fX2lkX199XSA9IHRydWU7XG5cbiAgICAgICAgZm9yIChrZXkgaW4gc3RydWN0LiQkZGF0YSkge1xuICAgICAgICAgIGEgPSBzdHJ1Y3QuJCRkYXRhW2tleV07XG4gICAgICAgICAgYiA9IG90aGVyLiQkZGF0YVtrZXldO1xuXG4gICAgICAgICAgaWYgKCN7U3RydWN0ID09PSBgYWB9KSB7XG4gICAgICAgICAgICBpZiAoIXJlY3Vyc2VkMS5oYXNPd25Qcm9wZXJ0eSgje2BhYC5fX2lkX199KSB8fCAhcmVjdXJzZWQyLmhhc093blByb3BlcnR5KCN7YGJgLl9faWRfX30pKSB7XG4gICAgICAgICAgICAgIGlmICghX2VxZXEoYSwgYikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEje2BhYCA9PSBgYmB9KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9lcWVxKHNlbGYsIG90aGVyKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBlcWw/KG90aGVyKVxuICAgIHJldHVybiBmYWxzZSB1bmxlc3Mgb3RoZXIuaW5zdGFuY2Vfb2Y/KHNlbGYuY2xhc3MpXG5cbiAgICAleHtcbiAgICAgIHZhciByZWN1cnNlZDEgPSB7fSwgcmVjdXJzZWQyID0ge307XG5cbiAgICAgIGZ1bmN0aW9uIF9lcWVxKHN0cnVjdCwgb3RoZXIpIHtcbiAgICAgICAgdmFyIGtleSwgYSwgYjtcblxuICAgICAgICByZWN1cnNlZDFbI3tgc3RydWN0YC5fX2lkX199XSA9IHRydWU7XG4gICAgICAgIHJlY3Vyc2VkMlsje2BvdGhlcmAuX19pZF9ffV0gPSB0cnVlO1xuXG4gICAgICAgIGZvciAoa2V5IGluIHN0cnVjdC4kJGRhdGEpIHtcbiAgICAgICAgICBhID0gc3RydWN0LiQkZGF0YVtrZXldO1xuICAgICAgICAgIGIgPSBvdGhlci4kJGRhdGFba2V5XTtcblxuICAgICAgICAgIGlmICgje1N0cnVjdCA9PT0gYGFgfSkge1xuICAgICAgICAgICAgaWYgKCFyZWN1cnNlZDEuaGFzT3duUHJvcGVydHkoI3tgYWAuX19pZF9ffSkgfHwgIXJlY3Vyc2VkMi5oYXNPd25Qcm9wZXJ0eSgje2BiYC5fX2lkX199KSkge1xuICAgICAgICAgICAgICBpZiAoIV9lcWVxKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghI3tgYWAuZXFsPyhgYmApfSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZXFlcShzZWxmLCBvdGhlcik7XG4gICAgfVxuICBlbmRcblxuICBkZWYgZWFjaFxuICAgIHJldHVybiBlbnVtX2Zvcig6ZWFjaCkgeyBzaXplIH0gdW5sZXNzIGJsb2NrX2dpdmVuP1xuXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmVhY2ggeyB8bmFtZXwgeWllbGQgc2VsZltuYW1lXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgZWFjaF9wYWlyXG4gICAgcmV0dXJuIGVudW1fZm9yKDplYWNoX3BhaXIpIHsgc2l6ZSB9IHVubGVzcyBibG9ja19naXZlbj9cblxuICAgIHNlbGYuY2xhc3MubWVtYmVycy5lYWNoIHsgfG5hbWV8IHlpZWxkIFtuYW1lLCBzZWxmW25hbWVdXSB9XG4gICAgc2VsZlxuICBlbmRcblxuICBkZWYgbGVuZ3RoXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLmxlbmd0aFxuICBlbmRcblxuICBhbGlhcyBzaXplIGxlbmd0aFxuXG4gIGRlZiB0b19hXG4gICAgc2VsZi5jbGFzcy5tZW1iZXJzLm1hcCB7IHxuYW1lfCBzZWxmW25hbWVdIH1cbiAgZW5kXG5cbiAgYWxpYXMgdmFsdWVzIHRvX2FcblxuICBkZWYgaW5zcGVjdFxuICAgIHJlc3VsdCA9ICcjPHN0cnVjdCAnXG5cbiAgICBpZiBTdHJ1Y3QgPT09IHNlbGYgJiYgc2VsZi5jbGFzcy5uYW1lXG4gICAgICByZXN1bHQgKz0gXCIje3NlbGYuY2xhc3N9IFwiXG4gICAgZW5kXG5cbiAgICByZXN1bHQgKz0gZWFjaF9wYWlyLm1hcCBkbyB8bmFtZSwgdmFsdWV8XG4gICAgICBcIiN7bmFtZX09I3t2YWx1ZS5pbnNwZWN0fVwiXG4gICAgZW5kLmpvaW4gJywgJ1xuXG4gICAgcmVzdWx0ICs9ICc+J1xuXG4gICAgcmVzdWx0XG4gIGVuZFxuXG4gIGFsaWFzIHRvX3MgaW5zcGVjdFxuXG4gIGRlZiB0b19oKCZibG9jaylcbiAgICByZXR1cm4gbWFwKCZibG9jaykudG9faCgqYXJncykgaWYgYmxvY2tfZ2l2ZW4/XG5cbiAgICBzZWxmLmNsYXNzLm1lbWJlcnMuZWFjaF93aXRoX29iamVjdCh7fSkgeyB8bmFtZSwgaHwgaFtuYW1lXSA9IHNlbGZbbmFtZV0gfVxuICBlbmRcblxuICBkZWYgdmFsdWVzX2F0KCphcmdzKVxuICAgIGFyZ3MgPSBhcmdzLm1hcCB7IHxhcmd8IGBhcmcuJCRpc19yYW5nZSA/ICN7YXJnLnRvX2F9IDogYXJnYCB9LmZsYXR0ZW5cbiAgICAleHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYXJnc1tpXS4kJGlzX251bWJlcikge1xuICAgICAgICAgICN7cmFpc2UgVHlwZUVycm9yLCBcIm5vIGltcGxpY2l0IGNvbnZlcnNpb24gb2YgI3tgYXJnc1tpXWAuY2xhc3N9IGludG8gSW50ZWdlclwifVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKCN7c2VsZltgYXJnc1tpXWBdfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgZW5kXG5cbiAgZGVmIGRpZyhrZXksICprZXlzKVxuICAgIGl0ZW0gPSBpZiBga2V5LiQkaXNfc3RyaW5nICYmIHNlbGYuJCRkYXRhLmhhc093blByb3BlcnR5KGtleSlgXG4gICAgICAgICAgICAgYHNlbGYuJCRkYXRhW2tleV0gfHwgbmlsYFxuICAgICAgICAgICBlbmRcblxuICAgICV4e1xuICAgICAgaWYgKGl0ZW0gPT09IG5pbCB8fCBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmxlc3MgaXRlbS5yZXNwb25kX3RvPyg6ZGlnKVxuICAgICAgcmFpc2UgVHlwZUVycm9yLCBcIiN7aXRlbS5jbGFzc30gZG9lcyBub3QgaGF2ZSAjZGlnIG1ldGhvZFwiXG4gICAgZW5kXG5cbiAgICBpdGVtLmRpZygqa2V5cylcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCI8Y2xhc3M6U3RydWN0PiIsImluY2x1ZGUiLCJFbnVtZXJhYmxlIiwibmV3IiwiY29uc3RfbmFtZSIsIiRyZXRfb3JfMSIsImNsYXNzIiwiPT0iLCJTdHJpbmciLCJbXSIsIjAiLCJ1cGNhc2UiLCIhPSIsImFyZ3MiLCJ1bnNoaWZ0IiwiT3BhbCIsImNvbnN0X25hbWUhIiwiVHlwZUVycm9yIiwiTmFtZUVycm9yIiwibWFwIiwiYmxvY2sgaW4gbmV3IiwiYXJnIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBuZXciLCJjb2VyY2VfdG8hIiwia2xhc3MiLCJDbGFzcyIsImVhY2giLCJibG9jayAoMyBsZXZlbHMpIGluIG5ldyIsImRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwiaW5zdGFuY2UiLCJhbGxvY2F0ZSIsImluaXRpYWxpemUiLCJhbGlhc19tZXRob2QiLCJibG9jayIsIm1vZHVsZV9ldmFsIiwidG9fcHJvYyIsIlN0cnVjdCIsImNvbnN0X3NldCIsIm5hbWUiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJtZW1iZXJzIiwiPDwiLCJkZWZpbmVfbWV0aG9kIiwiYmxvY2sgaW4gZGVmaW5lX3N0cnVjdF9hdHRyaWJ1dGUiLCJibG9jayAoMiBsZXZlbHMpIGluIGRlZmluZV9zdHJ1Y3RfYXR0cmlidXRlIiwidmFsdWUiLCJAbWVtYmVycyIsIiRyZXRfb3JfMiIsImluaGVyaXRlZCIsImluc3RhbmNlX2V2YWwiLCJibG9jayBpbiBpbmhlcml0ZWQiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaGVyaXRlZCIsImt3YXJncyIsIiRyZXRfb3JfMyIsImxhc3QiLCIkcmV0X29yXzQiLCI+IiwibGVuZ3RoIiwiMSIsImV4dHJhIiwiLSIsImtleXMiLCJhbnk/Iiwiam9pbiIsImJsb2NrIGluIGluaXRpYWxpemUiLCJibG9jayAoMiBsZXZlbHMpIGluIGluaXRpYWxpemUiLCIkd3JpdGVyIiwiW109IiwiZWFjaF93aXRoX2luZGV4IiwiaW5kZXgiLCJpbml0aWFsaXplX2NvcHkiLCJmcm9tIiwiaGFzaCIsIkhhc2giLCJJbnRlZ2VyIiwiPT09IiwiPCIsInNpemUiLCItQCIsIkluZGV4RXJyb3IiLCI+PSIsImluY2x1ZGU/IiwidG9fc3ltIiwib3RoZXIiLCJpbnN0YW5jZV9vZj8iLCJfX2lkX18iLCJlcWw/IiwiYmxvY2tfZ2l2ZW4/IiwiZW51bV9mb3IiLCJibG9jayBpbiBlYWNoIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoIiwiZWFjaF9wYWlyIiwiYmxvY2sgaW4gZWFjaF9wYWlyIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBlYWNoX3BhaXIiLCJ0b19hIiwiYmxvY2sgaW4gdG9fYSIsImJsb2NrICgyIGxldmVscykgaW4gdG9fYSIsImluc3BlY3QiLCJyZXN1bHQiLCIkcmV0X29yXzUiLCIrIiwiYmxvY2sgaW4gaW5zcGVjdCIsImJsb2NrICgyIGxldmVscykgaW4gaW5zcGVjdCIsInRvX2giLCJlYWNoX3dpdGhfb2JqZWN0IiwiYmxvY2sgaW4gdG9faCIsImgiLCJibG9jayAoMiBsZXZlbHMpIGluIHRvX2giLCJ2YWx1ZXNfYXQiLCJibG9jayBpbiB2YWx1ZXNfYXQiLCJibG9jayAoMiBsZXZlbHMpIGluIHZhbHVlc19hdCIsImZsYXR0ZW4iLCJkaWciLCJrZXkiLCJpdGVtIiwicmVzcG9uZF90bz8iXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLG9CQUFSRTtFQUVBRixPQUFBRztFQUFBQTs7SUFBQUE7OztJQUNFRixJQUFBRyxTQUFBQSxDQUFRQywwQkFBUkQ7SUFFQUUsVUFBSUwsSUFBSkssVUFBQUEsZ0JBQUFBLFNBQWFDLFVBQUQsRUFMZCxFQUtjLEVBTGQsRUFLRUQ7QUFBQUEsTUFBQUE7O01BQUFBOzs7TUFBcUQ7O01BTHZEOztNQUFBOztNQUFBO01BQUE7TUFBQTtNQUFBO01BQUE7O01BSzJCOztNQUFPO01BQUE7TUFBQSxpQkFBYztNQUFkO01BQzlCLElBQUEsUUFBR0MsVUFBSCxDQUFBO1FBQ0UsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQVBUQyxDQUFBQSxZQU9TRCxVQUFVRSxPQUFBQSxDQUFBQSxDQUFPQyxPQUFBQSxDQUFHQyxzQkFBSEQsQ0FQMUJGLENBT1MsQ0FBQTtVQUE4QkYsT0FBQUMsVUFBVUssT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBR0UsUUFBQUEsQ0FBQUEsQ0FBUUMsT0FBQUEsQ0FBR1IsVUFBVUssT0FBQUEsQ0FBQ0MsQ0FBREQsQ0FBYkc7UUFBbkQ7VUFQVFQsT0FBQTtRQU9TLENBQUEsa0JBQUgsQ0FBQTs7VUFHRVUsSUFBSUMsU0FBQUEsQ0FBU1YsVUFBVFU7VUFDSlYsYUFBYTtRQUpm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RmpILEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDQ4NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvbWFpbi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJkZWYgc2VsZi50b19zXG4gICdtYWluJ1xuZW5kXG5cbmRlZiBzZWxmLmluY2x1ZGUobW9kKVxuICBPYmplY3QuaW5jbHVkZSBtb2RcbmVuZFxuXG4jIENvbXBpbGVyIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxuZGVmIHNlbGYudXNpbmcobW9kKVxuICByYWlzZSAnbWFpbi51c2luZyBpcyBwZXJtaXR0ZWQgb25seSBhdCB0b3BsZXZlbCdcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJ0b19zIiwic2VsZiIsImluY2x1ZGUiLCJtb2QiLCJPYmplY3QiLCJ1c2luZyIsInJhaXNlIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxVQUFJQyxJQUFKRCxXQUFBQSxVQUFBQSxnQkFBQUE7QUFBQUEsSUFBQUE7O0lBQ0VBLE9BQUFBO0VBREZBLENBQUFBLHFCQUFBQTtFQUlBRSxVQUFJRCxJQUFKQyxjQUFBQSxhQUFBQSxtQkFBaUJDLEdBQWpCRDtBQUFBQSxJQUFBQTs7SUFDRUEsT0FBQUUsc0JBQU1GLFNBQUFBLENBQVNDLEdBQVREO0VBRFJBLENBQUFBLHdCQUFBQTtFQUtBSCxPQUFBTSxDQUFBQSxVQUFJSixJQUFKSSxZQUFBQSxXQUFBQSxpQkFBZUYsR0FBZkU7QUFBQUEsSUFBQUE7O0lBQ0VBLE9BQUFKLElBQUFLLE9BQUFBLENBQU1ELDBDQUFOQztFQURGRCxDQUFBQSxzQkFBQUEsQ0FBQUE7QUFUQU47In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0NTA4LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9kaXIucmIiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgRGlyXG4gIGNsYXNzIDw8IHNlbGZcbiAgICBkZWYgY2hkaXIoZGlyKVxuICAgICAgcHJldl9jd2QgPSBgT3BhbC5jdXJyZW50X2RpcmBcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3tkaXJ9YFxuICAgICAgeWllbGRcbiAgICBlbnN1cmVcbiAgICAgIGBPcGFsLmN1cnJlbnRfZGlyID0gI3twcmV2X2N3ZH1gXG4gICAgZW5kXG5cbiAgICBkZWYgcHdkXG4gICAgICBgT3BhbC5jdXJyZW50X2RpciB8fCAnLidgXG4gICAgZW5kXG4gICAgYWxpYXMgZ2V0d2QgcHdkXG5cbiAgICBkZWYgaG9tZVxuICAgICAgRU5WWydIT01FJ10gfHwgJy4nXG4gICAgZW5kXG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpEaXI+IiwiY2hkaXIiLCJkaXIiLCJwcmV2X2N3ZCIsInB3ZCIsImhvbWUiLCIkcmV0X29yXzEiLCJFTlYiLCJbXSIsInNlbGYiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7RUFBQUEsT0FBQUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBO01BQUE7Ozs7QUFDRUMsTUFBQUEseUJBQUFBLFdBQUFBLGlCQUFVQyxHQUFWRDtBQUFBQSxRQUFBQTs7UUFBQUE7UUFDRUEsT0FBQSxjQUFBOztRQUFBRSxXQUFZRjtRQUNYQSxtQkFBcUJDO1FBQ3RCLE9BQUEscUJBQUEsRUFBQTtRQUZBO1VBSUNELG1CQUFxQkU7UUFKdEIsQ0FBQTtNQURGRixDQUFBQSxzQkFBQUE7O0FBUUFHLE1BQUFBLHVCQUFBQSxTQUFBQSxlQUFBQTtBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQ0EsdUJBQURBO01BREZBLENBQUFBLG9CQUFBQTtNQUdBLGFBQU0sT0FBTixFQUFZLEtBQVo7TUFFQSxPQUFBQyxDQUFBQSx3QkFBQUEsVUFBQUEsZ0JBQUFBO0FBQUFBLFFBQUFBOztRQUNFLElBQUEsUUFoQk5DLENBQUFBLFlBZ0JNQyxtQkFBR0MsT0FBQUEsQ0FBQ0gsTUFBREcsQ0FoQlRGLENBZ0JNLENBQUE7VUFoQk5ELE9BQUE7UUFnQk07VUFBZUEsT0FBQUE7UUFBZjtNQURGQSxDQUFBQSxxQkFBQUEsQ0FBQUE7SUFkRiw0QkFBU0ksSUFBVDtFQURGVCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUFBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjQ1NTYsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiB0cnV0aHlcblxuY2xhc3MgRmlsZSA8IElPXG4gIFNlcGFyYXRvciA9IFNFUEFSQVRPUiA9ICcvJ1xuICBBTFRfU0VQQVJBVE9SID0gbmlsXG4gIFBBVEhfU0VQQVJBVE9SID0gJzonXG4gICMgQXNzdW1pbmcgY2FzZSBpbnNlbnN0aXZlIGZpbGVzeXN0ZW1cbiAgRk5NX1NZU0NBU0UgPSAwXG4gIHdpbmRvd3Nfcm9vdF9yeCA9ICVye15bYS16QS1aXTooPzpcXFxcfFxcLyl9XG5cbiAgY2xhc3MgPDwgc2VsZlxuICAgIGRlZiBhYnNvbHV0ZV9wYXRoKHBhdGgsIGJhc2VkaXIgPSBuaWwpXG4gICAgICBzZXAgPSBTRVBBUkFUT1JcbiAgICAgIHNlcF9jaGFycyA9IGAkc2VwX2NoYXJzKClgXG4gICAgICBuZXdfcGFydHMgPSBbXVxuXG4gICAgICBwYXRoID0gcGF0aC5yZXNwb25kX3RvPyg6dG9fcGF0aCkgPyBwYXRoLnRvX3BhdGggOiBwYXRoXG4gICAgICBiYXNlZGlyIHx8PSBEaXIucHdkXG4gICAgICBwYXRoX2FicyAgICA9IGBwYXRoLnN1YnN0cigwLCBzZXAubGVuZ3RoKSA9PT0gc2VwIHx8IHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpYFxuICAgICAgYmFzZWRpcl9hYnMgPSBgYmFzZWRpci5zdWJzdHIoMCwgc2VwLmxlbmd0aCkgPT09IHNlcCB8fCB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKWBcblxuICAgICAgaWYgcGF0aF9hYnNcbiAgICAgICAgcGFydHMgICAgICAgPSBwYXRoLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pXG4gICAgICAgIGxlYWRpbmdfc2VwID0gYHdpbmRvd3Nfcm9vdF9yeC50ZXN0KHBhdGgpID8gJycgOiAje3BhdGguc3ViKC9eKFsje3NlcF9jaGFyc31dKykuKiQvLCAnXFwxJyl9YFxuICAgICAgICBhYnMgICAgICAgICA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMgICAgICAgPSBiYXNlZGlyLnNwbGl0KC9bI3tzZXBfY2hhcnN9XS8pICsgcGF0aC5zcGxpdCgvWyN7c2VwX2NoYXJzfV0vKVxuICAgICAgICBsZWFkaW5nX3NlcCA9IGB3aW5kb3dzX3Jvb3RfcngudGVzdChiYXNlZGlyKSA/ICcnIDogI3tiYXNlZGlyLnN1YigvXihbI3tzZXBfY2hhcnN9XSspLiokLywgJ1xcMScpfWBcbiAgICAgICAgYWJzICAgICAgICAgPSBiYXNlZGlyX2Fic1xuICAgICAgZW5kXG5cbiAgICAgICV4e1xuICAgICAgICB2YXIgcGFydDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChwYXJ0ID09PSBuaWwpIHx8XG4gICAgICAgICAgICAocGFydCA9PT0gJycgICYmICgobmV3X3BhcnRzLmxlbmd0aCA9PT0gMCkgfHwgYWJzKSkgfHxcbiAgICAgICAgICAgIChwYXJ0ID09PSAnLicgJiYgKChuZXdfcGFydHMubGVuZ3RoID09PSAwKSB8fCBhYnMpKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICBuZXdfcGFydHMucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld19wYXJ0cy5wdXNoKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYWJzICYmIHBhcnRzWzBdICE9PSAnLicpIHtcbiAgICAgICAgICAje25ld19wYXJ0cy51bnNoaWZ0ICcuJ31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXdfcGF0aCA9IG5ld19wYXJ0cy5qb2luKHNlcClcbiAgICAgIG5ld19wYXRoID0gbGVhZGluZ19zZXAgKyBuZXdfcGF0aCBpZiBhYnNcbiAgICAgIG5ld19wYXRoXG4gICAgZW5kXG5cbiAgICBkZWYgZXhwYW5kX3BhdGgocGF0aCwgYmFzZWRpciA9IG5pbClcbiAgICAgIHNlcCA9IFNFUEFSQVRPUlxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIGlmIGBwYXRoWzBdID09PSAnficgfHwgKGJhc2VkaXIgJiYgYmFzZWRpclswXSA9PT0gJ34nKWBcbiAgICAgICAgaG9tZSA9IERpci5ob21lXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsIFwiY291bGRuJ3QgZmluZCBIT01FIGVudmlyb25tZW50IC0tIGV4cGFuZGluZyBgfidcIikgdW5sZXNzIGhvbWVcbiAgICAgICAgbGVhZGluZ19zZXAgPSBgd2luZG93c19yb290X3J4LnRlc3QoaG9tZSkgPyAnJyA6ICN7aG9tZS5zdWIoL14oWyN7c2VwX2NoYXJzfV0rKS4qJC8sICdcXDEnKX1gXG4gICAgICAgIHJhaXNlKEFyZ3VtZW50RXJyb3IsICdub24tYWJzb2x1dGUgaG9tZScpIHVubGVzcyBob21lLnN0YXJ0X3dpdGg/KGxlYWRpbmdfc2VwKVxuXG4gICAgICAgIGhvbWUgICAgICAgICAgICArPSBzZXBcbiAgICAgICAgaG9tZV9wYXRoX3JlZ2V4cCA9IC9eXFx+KD86I3tzZXB9fCQpL1xuICAgICAgICBwYXRoICAgICAgICAgICAgID0gcGF0aC5zdWIoaG9tZV9wYXRoX3JlZ2V4cCwgaG9tZSlcbiAgICAgICAgYmFzZWRpciAgICAgICAgICA9IGJhc2VkaXIuc3ViKGhvbWVfcGF0aF9yZWdleHAsIGhvbWUpIGlmIGJhc2VkaXJcbiAgICAgIGVuZFxuICAgICAgYWJzb2x1dGVfcGF0aChwYXRoLCBiYXNlZGlyKVxuICAgIGVuZFxuICAgIGFsaWFzIHJlYWxwYXRoIGV4cGFuZF9wYXRoXG5cbiAgICAleHtcbiAgICAgIC8vIENvZXJjZSBhIGdpdmVuIHBhdGggdG8gYSBwYXRoIHN0cmluZyB1c2luZyAjdG9fcGF0aCBhbmQgI3RvX3N0clxuICAgICAgZnVuY3Rpb24gJGNvZXJjZV90b19wYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKCR0cnV0aHkoI3tgcGF0aGAucmVzcG9uZF90bz8oOnRvX3BhdGgpfSkpIHtcbiAgICAgICAgICBwYXRoID0gcGF0aC4kdG9fcGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aCA9ICN7T3BhbC5jb2VyY2VfdG8hKGBwYXRoYCwgU3RyaW5nLCA6dG9fc3RyKX07XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIFJlZ0V4cCBjb21wYXRpYmxlIGNoYXIgY2xhc3NcbiAgICAgIGZ1bmN0aW9uICRzZXBfY2hhcnMoKSB7XG4gICAgICAgIGlmICgje0FMVF9TRVBBUkFUT1J9ID09PSBuaWwpIHtcbiAgICAgICAgICByZXR1cm4gT3BhbC5lc2NhcGVfcmVnZXhwKCN7U0VQQVJBVE9SfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIE9wYWwuZXNjYXBlX3JlZ2V4cCgje1NFUEFSQVRPUiArIEFMVF9TRVBBUkFUT1J9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZiBkaXJuYW1lKHBhdGgpXG4gICAgICBzZXBfY2hhcnMgPSBgJHNlcF9jaGFycygpYFxuICAgICAgcGF0aCA9IGAkY29lcmNlX3RvX3BhdGgocGF0aClgXG4gICAgICAleHtcbiAgICAgICAgdmFyIGFic29sdXRlID0gcGF0aC5tYXRjaChuZXcgUmVnRXhwKCN7XCJeWyN7c2VwX2NoYXJzfV1cIn0pKTtcblxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3JzXG4gICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiW14je3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBiYXNlbmFtZVxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIlsje3NlcF9jaGFyc31dKyRcIn0pLCAnJyk7IC8vIHJlbW92ZSBmaW5hbCB0cmFpbGluZyBzZXBhcmF0b3JzXG5cbiAgICAgICAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIGFic29sdXRlID8gJy8nIDogJy4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZW5hbWUobmFtZSwgc3VmZml4ID0gbmlsKVxuICAgICAgc2VwX2NoYXJzID0gYCRzZXBfY2hhcnMoKWBcbiAgICAgIG5hbWUgPSBgJGNvZXJjZV90b19wYXRoKG5hbWUpYFxuICAgICAgJXh7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VmZml4ICE9PSBuaWwpIHtcbiAgICAgICAgICBzdWZmaXggPSAje09wYWwuY29lcmNlX3RvIShzdWZmaXgsIFN0cmluZywgOnRvX3N0cil9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VmZml4ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgje1wiKC4pWyN7c2VwX2NoYXJzfV0qJFwifSksICckMScpO1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIl4oPzouKlsje3NlcF9jaGFyc31dKT8oW14je3NlcF9jaGFyc31dKykkXCJ9KSwgJyQxJyk7XG5cbiAgICAgICAgaWYgKHN1ZmZpeCA9PT0gXCIuKlwiKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFwuW15cXC5dKyQvLCAnJyk7XG4gICAgICAgIH0gZWxzZSBpZihzdWZmaXggIT09IG51bGwpIHtcbiAgICAgICAgICBzdWZmaXggPSBPcGFsLmVzY2FwZV9yZWdleHAoc3VmZml4KTtcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoI3tcIiN7c3VmZml4fSRcIn0pLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICBlbmRcblxuICAgIGRlZiBleHRuYW1lKHBhdGgpXG4gICAgICBgcGF0aCA9ICRjb2VyY2VfdG9fcGF0aChwYXRoKWBcbiAgICAgIGZpbGVuYW1lID0gYmFzZW5hbWUocGF0aClcbiAgICAgIHJldHVybiAnJyBpZiBmaWxlbmFtZS5lbXB0eT9cbiAgICAgIGxhc3RfZG90X2lkeCA9IGZpbGVuYW1lWzEuLi0xXS5yaW5kZXgoJy4nKVxuICAgICAgIyBleHRlbnNpb24gbmFtZSBtdXN0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgLihzb21ldGhpbmcpXG4gICAgICBsYXN0X2RvdF9pZHgubmlsPyB8fCBsYXN0X2RvdF9pZHggKyAxID09IGZpbGVuYW1lLmxlbmd0aCAtIDEgPyAnJyA6IGZpbGVuYW1lWyhsYXN0X2RvdF9pZHggKyAxKS4uLTFdXG4gICAgZW5kXG5cbiAgICBkZWYgZXhpc3Q/KHBhdGgpXG4gICAgICBgT3BhbC5tb2R1bGVzWyN7cGF0aH1dICE9IG51bGxgXG4gICAgZW5kXG4gICAgYWxpYXMgZXhpc3RzPyBleGlzdD9cblxuICAgIGRlZiBkaXJlY3Rvcnk/KHBhdGgpXG4gICAgICBmaWxlcyA9IFtdXG4gICAgICAleHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIE9wYWwubW9kdWxlcykge1xuICAgICAgICAgICN7ZmlsZXN9LnB1c2goa2V5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRoID0gcGF0aC5nc3ViKC8oXi4je1NFUEFSQVRPUn0rfCN7U0VQQVJBVE9SfSskKS8pXG4gICAgICBmaWxlID0gZmlsZXMuZmluZCB7IHxmfCBmID1+IC9eI3twYXRofS8gfVxuICAgICAgZmlsZVxuICAgIGVuZFxuXG4gICAgZGVmIGpvaW4oKnBhdGhzKVxuICAgICAgaWYgcGF0aHMuZW1wdHk/XG4gICAgICAgIHJldHVybiAnJ1xuICAgICAgZW5kXG4gICAgICByZXN1bHQgPSAnJ1xuICAgICAgcGF0aHMgPSBwYXRocy5mbGF0dGVuLmVhY2hfd2l0aF9pbmRleC5tYXAgZG8gfGl0ZW0sIGluZGV4fFxuICAgICAgICBpZiBpbmRleCA9PSAwICYmIGl0ZW0uZW1wdHk/XG4gICAgICAgICAgU0VQQVJBVE9SXG4gICAgICAgIGVsc2lmIHBhdGhzLmxlbmd0aCA9PSBpbmRleCArIDEgJiYgaXRlbS5lbXB0eT9cbiAgICAgICAgICBTRVBBUkFUT1JcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGl0ZW1cbiAgICAgICAgZW5kXG4gICAgICBlbmRcbiAgICAgIHBhdGhzID0gcGF0aHMucmVqZWN0KCY6ZW1wdHk/KVxuICAgICAgcGF0aHMuZWFjaF93aXRoX2luZGV4IGRvIHxpdGVtLCBpbmRleHxcbiAgICAgICAgbmV4dF9pdGVtID0gcGF0aHNbaW5kZXggKyAxXVxuICAgICAgICBpZiBuZXh0X2l0ZW0ubmlsP1xuICAgICAgICAgIHJlc3VsdCA9IFwiI3tyZXN1bHR9I3tpdGVtfVwiXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpZiBpdGVtLmVuZF93aXRoPyhTRVBBUkFUT1IpICYmIG5leHRfaXRlbS5zdGFydF93aXRoPyhTRVBBUkFUT1IpXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5zdWIoLyN7U0VQQVJBVE9SfSskLywgJycpXG4gICAgICAgICAgZW5kXG4gICAgICAgICAgcmVzdWx0ID0gaWYgaXRlbS5lbmRfd2l0aD8oU0VQQVJBVE9SKSB8fCBuZXh0X2l0ZW0uc3RhcnRfd2l0aD8oU0VQQVJBVE9SKVxuICAgICAgICAgICAgICAgICAgICAgXCIje3Jlc3VsdH0je2l0ZW19XCJcbiAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICBcIiN7cmVzdWx0fSN7aXRlbX0je1NFUEFSQVRPUn1cIlxuICAgICAgICAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIGVuZFxuICAgICAgcmVzdWx0XG4gICAgZW5kXG5cbiAgICBkZWYgc3BsaXQocGF0aClcbiAgICAgIHBhdGguc3BsaXQoU0VQQVJBVE9SKVxuICAgIGVuZFxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RmlsZT4iLCIwIiwid2luZG93c19yb290X3J4IiwiYWJzb2x1dGVfcGF0aCIsInBhdGgiLCJiYXNlZGlyIiwic2VwIiwiU0VQQVJBVE9SIiwic2VwX2NoYXJzIiwibmV3X3BhcnRzIiwicmVzcG9uZF90bz8iLCJ0b19wYXRoIiwiJHJldF9vcl8xIiwiRGlyIiwicHdkIiwicGF0aF9hYnMiLCJiYXNlZGlyX2FicyIsInBhcnRzIiwic3BsaXQiLCJsZWFkaW5nX3NlcCIsInN1YiIsImFicyIsIisiLCJ1bnNoaWZ0IiwibmV3X3BhdGgiLCJqb2luIiwiZXhwYW5kX3BhdGgiLCJob21lIiwic2VsZiIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsInN0YXJ0X3dpdGg/IiwiaG9tZV9wYXRoX3JlZ2V4cCIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiU3RyaW5nIiwiQUxUX1NFUEFSQVRPUiIsImRpcm5hbWUiLCJiYXNlbmFtZSIsIm5hbWUiLCJzdWZmaXgiLCJleHRuYW1lIiwiZmlsZW5hbWUiLCJlbXB0eT8iLCJsYXN0X2RvdF9pZHgiLCJbXSIsIjEiLCItMSIsInJpbmRleCIsIiRyZXRfb3JfMiIsIm5pbD8iLCI9PSIsIi0iLCJsZW5ndGgiLCJleGlzdD8iLCJkaXJlY3Rvcnk/IiwiZmlsZXMiLCJnc3ViIiwiZmlsZSIsImZpbmQiLCJibG9jayBpbiBkaXJlY3Rvcnk/IiwiZiIsImJsb2NrICgyIGxldmVscykgaW4gZGlyZWN0b3J5PyIsIj1+IiwicGF0aHMiLCJyZXN1bHQiLCJtYXAiLCJmbGF0dGVuIiwiZWFjaF93aXRoX2luZGV4IiwiYmxvY2sgaW4gam9pbiIsIml0ZW0iLCJpbmRleCIsImJsb2NrICgyIGxldmVscykgaW4gam9pbiIsIiRyZXRfb3JfMyIsIiRyZXRfb3JfNCIsInJlamVjdCIsInRvX3Byb2MiLCJuZXh0X2l0ZW0iLCIkcmV0X29yXzUiLCJlbmRfd2l0aD8iLCIkcmV0X29yXzYiLCJJTyJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTtFQUVBQSxPQUFBQztFQUFBQTs7SUFBQUE7OztJQUNFLHlDQUFZLHlDQUFZQSxHQUFaLENBQVo7SUFDQSw2Q0FBZ0IsR0FBaEI7SUFDQSw4Q0FBaUJBLEdBQWpCO0lBRUEsMkNBQWNDLENBQWQ7SUFDQUMsa0JBQWtCO0lBRWxCRixPQUFBO01BQUE7Ozs7QUFDRUcsTUFBQUEsaUNBQUFBLG1CQUFBQSx5QkFBa0JDLElBQUQsRUFBT0MsT0FBeEJGO0FBQUFBLFFBQUFBOzs7O1FBQXdCO1FBQUEsWUFBVSxHQUFWO1FBQUE7UUFDdEJHLE1BQU1DO1FBQ05DLFlBQWFMO1FBQ2JNLFlBQVk7UUFFWkwsT0FBTyxhQUFBLElBQUEsUUFBQUEsSUFBSU0sZ0JBQUFBLENBQWEsU0FBYkEsQ0FBSixDQUFBO1VBQTZCUCxPQUFBQyxJQUFJTyxTQUFBQSxDQUFBQTtRQUFqQztVQUE0Q1IsT0FBQUM7UUFBNUMsQ0FBQTtRQUNQQyxVQWpCTixhQUFBLElBQUEsUUFBQU8sQ0FB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QUFILEVBQWFpRSxJQUFiLENBQUEsQ0FBVCxFQUEyQkEsRUFBdkJwRCxDQURiO1lBR0FvRCxPQUFBUCxDQUFBQSxTQUFTLGFBQUEsSUFBQSxRQUFHLGFBQUEsSUFBQSxRQW5NdEJlLENBQUFBLFlBbU1zQlYsSUFBSVMsY0FBQUEsQ0FBV3hFLHlCQUFYd0UsQ0FuTTFCQyxDQW1Nc0IsQ0FBQTtjQW5NdEJSLE9BQUE7WUFtTXNCO2NBQTZCQSxPQUFBSyxTQUFTOUMsZ0JBQUFBLENBQWF4Qix5QkFBYndCO1lBQXRDLENBQUEsa0JBQUgsQ0FBQTtjQUNFeUMsT0FBQSxFQUFBLEdBQUEsQ0FBR1AsTUFBSCxDQUFBLEdBQUEsQ0FBWUssSUFBWjtZQURGO2NBR0VFLE9BQUEsRUFBQSxHQUFBLENBQUdQLE1BQUgsQ0FBQSxHQUFBLENBQVlLLElBQVosQ0FBQSxHQUFBLENBQW1CL0QseUJBQW5CO1lBSEYsQ0FBQSxrQkFBVDBEO1VBTkYsRUFGb0JJLG1CQUFBQSxrQkFBQUEsTUFBakJEO1FBZUwzQyxPQUFBd0M7TUE5QkZ4QyxDQUFBQSxzQkFBQUE7TUFpQ0EsT0FBQVAsQ0FBQUEseUJBQUFBLFlBQUFBLGlCQUFVZCxJQUFWYztBQUFBQSxRQUFBQTs7UUFDRUEsT0FBQWQsSUFBSWMsT0FBQUEsQ0FBT1gseUJBQVBXO01BRE5BLENBQUFBLHVCQUFBQSxDQUFBQTtJQW5NRiw0QkFBU1UsSUFBVDtFQVJGNUIsR0FBQUEsV0FBQUEsRUFBYWlGLGtCQUFiakY7QUFGQUQ7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI0ODg0LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9wcm9jZXNzLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFByb2Nlc3NcbiAgQF9fY2xvY2tzX18gPSBbXVxuICBkZWYgc2VsZi5fX3JlZ2lzdGVyX2Nsb2NrX18obmFtZSwgZnVuYylcbiAgICBjb25zdF9zZXQgbmFtZSwgQF9fY2xvY2tzX18uc2l6ZVxuICAgIEBfX2Nsb2Nrc19fIDw8IGZ1bmNcbiAgZW5kXG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fIDpDTE9DS19SRUFMVElNRSwgYGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKSB9YFxuXG4gIG1vbm90b25pYyA9IGZhbHNlXG5cbiAgJXh7XG4gICAgaWYgKE9wYWwuZ2xvYmFsLnBlcmZvcm1hbmNlKSB7XG4gICAgICBtb25vdG9uaWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChPcGFsLmdsb2JhbC5wcm9jZXNzICYmIHByb2Nlc3MuaHJ0aW1lKSB7XG4gICAgICAvLyBsZXQgbm93IGJlIHRoZSBiYXNlIHRvIGdldCBzbWFsbGVyIG51bWJlcnNcbiAgICAgIHZhciBocnRpbWVfYmFzZSA9IHByb2Nlc3MuaHJ0aW1lKCk7XG5cbiAgICAgIG1vbm90b25pYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWUoaHJ0aW1lX2Jhc2UpO1xuICAgICAgICB2YXIgdXMgPSAoaHJ0aW1lWzFdIC8gMTAwMCkgfCAwOyAvLyBjdXQgYmVsb3cgbWljcm9zZWNzO1xuICAgICAgICByZXR1cm4gKChocnRpbWVbMF0gKiAxMDAwKSArICh1cyAvIDEwMDApKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgX19yZWdpc3Rlcl9jbG9ja19fKDpDTE9DS19NT05PVE9OSUMsIG1vbm90b25pYykgaWYgbW9ub3RvbmljXG5cbiAgZGVmIHNlbGYucGlkXG4gICAgMFxuICBlbmRcblxuICBkZWYgc2VsZi50aW1lc1xuICAgIHQgPSBUaW1lLm5vdy50b19mXG4gICAgQmVuY2htYXJrOjpUbXMubmV3KHQsIHQsIHQsIHQsIHQpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmNsb2NrX2dldHRpbWUoY2xvY2tfaWQsIHVuaXQgPSA6ZmxvYXRfc2Vjb25kKVxuICAgIChjbG9jayA9IEBfX2Nsb2Nrc19fW2Nsb2NrX2lkXSkgfHwgcmFpc2UoRXJybm86OkVJTlZBTCwgXCJjbG9ja19nZXR0aW1lKCN7Y2xvY2tfaWR9KSAje0BfX2Nsb2Nrc19fW2Nsb2NrX2lkXX1cIilcbiAgICAleHtcbiAgICAgIHZhciBtcyA9IGNsb2NrKCk7XG4gICAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgICAgY2FzZSAnZmxvYXRfc2Vjb25kJzogICAgICByZXR1cm4gIChtcyAvIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBzZWNvbmRzIGFzIGEgZmxvYXQgKGRlZmF1bHQpXG4gICAgICAgIGNhc2UgJ2Zsb2F0X21pbGxpc2Vjb25kJzogcmV0dXJuICAobXMgLyAxKTsgICAgICAgICAgICAvLyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGFzIGEgZmxvYXRcbiAgICAgICAgY2FzZSAnZmxvYXRfbWljcm9zZWNvbmQnOiByZXR1cm4gIChtcyAqIDEwMDApOyAgICAgICAgIC8vIG51bWJlciBvZiBtaWNyb3NlY29uZHMgYXMgYSBmbG9hdFxuICAgICAgICBjYXNlICdzZWNvbmQnOiAgICAgICAgICAgIHJldHVybiAoKG1zIC8gMTAwMCkgICAgfCAwKTsgLy8gbnVtYmVyIG9mIHNlY29uZHMgYXMgYW4gaW50ZWdlclxuICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6ICAgICAgIHJldHVybiAoKG1zIC8gMSkgICAgICAgfCAwKTsgLy8gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGNhc2UgJ21pY3Jvc2Vjb25kJzogICAgICAgcmV0dXJuICgobXMgKiAxMDAwKSAgICB8IDApOyAvLyBudW1iZXIgb2YgbWljcm9zZWNvbmRzIGFzIGFuIGludGVnZXJcbiAgICAgICAgY2FzZSAnbmFub3NlY29uZCc6ICAgICAgICByZXR1cm4gKChtcyAqIDEwMDAwMDApIHwgMCk7IC8vIG51bWJlciBvZiBuYW5vc2Vjb25kcyBhcyBhbiBpbnRlZ2VyXG4gICAgICAgIGRlZmF1bHQ6ICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJ1bmV4cGVjdGVkIHVuaXQ6ICN7dW5pdH1cIn1cbiAgICAgIH1cbiAgICB9XG4gIGVuZFxuZW5kXG5cbmNsYXNzIFNpZ25hbFxuICBkZWYgc2VsZi50cmFwKCopXG4gIGVuZFxuZW5kXG5cbmNsYXNzIEdDXG4gIGRlZiBzZWxmLnN0YXJ0XG4gIGVuZFxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpQcm9jZXNzPiIsIkBfX2Nsb2Nrc19fIiwiX19yZWdpc3Rlcl9jbG9ja19fIiwic2VsZiIsIm5hbWUiLCJmdW5jIiwiY29uc3Rfc2V0Iiwic2l6ZSIsIjw8IiwibW9ub3RvbmljIiwicGlkIiwiMCIsInRpbWVzIiwidCIsIlRpbWUiLCJub3ciLCJ0b19mIiwiQmVuY2htYXJrOjpUbXMiLCJCZW5jaG1hcmsiLCJuZXciLCJjbG9ja19nZXR0aW1lIiwiY2xvY2tfaWQiLCJ1bml0IiwiJHJldF9vcl8xIiwiY2xvY2siLCJbXSIsInJhaXNlIiwiRXJybm86OkVJTlZBTCIsIkVycm5vIiwiQXJndW1lbnRFcnJvciIsIjxjbGFzczpTaWduYWw+IiwidHJhcCIsIjxjbGFzczpHQz4iLCJzdGFydCJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsa0JBQWM7SUFDZEMsVUFBSUMsSUFBSkQseUJBQUFBLGdDQUFBQSw4QkFBNEJFLElBQUQsRUFBT0MsSUFBbENIO0FBQUFBLE1BQUFBO0FBQUFBOzs7TUFDRUMsSUFBQUcsV0FBQUEsQ0FBVUYsSUFBVixFQUFnQkgsZUFBV00sTUFBQUEsQ0FBQUEsQ0FBM0JEO01BQ0FKLE9BQUFELGVBQVlPLE9BQUFBLENBQUdILElBQUhHO0lBRmROLENBQUFBLDJDQUFBQTtJQUtBQyxJQUFBRCxvQkFBQUEsQ0FBbUIsZ0JBQW5CLEVBQXFDRixnQ0FBckNFO0lBRUFPLFlBQVk7O0FBR2RUO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtJQUVFLElBQUEsUUFBbURTLFNBQW5ELENBQUE7TUFBQU4sSUFBQUQsb0JBQUFBLENBQW1CLGlCQUFuQixFQUFxQ08sU0FBckNQLENBQUE7SUFFQVEsVUFBSVAsSUFBSk8sVUFBQUEsaUJBQUFBLGVBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBQztJQURGRCxDQUFBQSw0QkFBQUE7SUFJQUUsVUFBSVQsSUFBSlMsWUFBQUEsbUJBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7O01BQ0VDLElBQUlDLG9CQUFJQyxLQUFBQSxDQUFBQSxDQUFJQyxNQUFBQSxDQUFBQTtNQUNaSixPQUFBSyxJQUFBQyx5QkFBQUQsUUFBY0UsS0FBQUEsQ0FBS04sQ0FBbkIsRUFBc0JBLENBQXRCLEVBQXlCQSxDQUF6QixFQUE0QkEsQ0FBNUIsRUFBK0JBLENBQWpCTTtJQUZoQlAsQ0FBQUEsOEJBQUFBO0lBS0FaLE9BQUFvQixDQUFBQSxVQUFJakIsSUFBSmlCLG9CQUFBQSwyQkFBQUEseUJBQXVCQyxRQUFELEVBQVdDLElBQWpDRjtBQUFBQSxNQUFBQTtBQUFBQTs7OztNQUFpQztNQUFBLFNBQU8sY0FBUDtNQUFBO01BQy9CLElBQUEsUUF6Q0pHLENBQUFBLFlBeUNLQyxDQUFBQSxRQUFRdkIsZUFBV3dCLE9BQUFBLENBQUNKLFFBQURJLENBQW5CRCxDQXpDTEQsQ0F5Q0ksQ0FBQTtRQXpDSjtNQXlDSTtRQUFtQ3BCLElBQUF1QixPQUFBQSxDQUFNQyxJQUFBQyxxQkFBQUQsV0FBTixFQUFxQixFQUFBLEdBQUEsZ0JBQUEsR0FBQSxDQUFpQk4sUUFBakIsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUE4QnBCLGVBQVd3QixPQUFBQSxDQUFDSixRQUFESSxDQUF6QyxDQUFyQkM7TUFBbkM7O0FBRUpOO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBLGlCQUFtQmpCLElBQUF1QixPQUFBQSxDQUFNRyw2QkFBTixFQUFxQixFQUFBLEdBQUEsbUJBQUEsR0FBQSxDQUFvQlAsSUFBcEIsQ0FBckJJO0FBQ25CTjtBQUNBQTtJQWRFQSxDQUFBQSx1Q0FBQUEsQ0FBQUE7RUF4Q0ZwQixHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtFQTBEQThCO0VBQUFBOztJQUFBQTs7SUFDRUEsT0FBQUMsQ0FBQUEsVUFBSTVCLElBQUo0QixXQUFBQSxpQkFBQUEsZ0JBM0RGLEVBMkRFQTtBQUFBQSxNQUFBQTs7OztNQTNERjs7TUFBQUEsT0FBQTtJQTJERUEsQ0FBQUEsNkJBQUFBLENBQUFBO0VBREZELEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0VBS0EvQixPQUFBaUM7RUFBQUE7O0lBQUFBOztJQUNFQSxPQUFBQyxDQUFBQSxVQUFJOUIsSUFBSjhCLFlBQUFBLGNBQUFBLGlCQUFBQTtBQUFBQSxNQUFBQTs7TUFoRUZBLE9BQUE7SUFnRUVBLENBQUFBLHlCQUFBQSxDQUFBQTtFQURGRCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQS9EQWpDOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyNDk5NSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvcmVsaWIvcmFuZG9tL2Zvcm1hdHRlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBSYW5kb21cbiAgbW9kdWxlIEZvcm1hdHRlclxuICAgIGRlZiBoZXgoY291bnQgPSBuaWwpXG4gICAgICBjb3VudCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGNvdW50KVxuICAgICAgJXh7XG4gICAgICAgIHZhciBieXRlcyA9ICN7Ynl0ZXMoY291bnQpfTtcbiAgICAgICAgdmFyIG91dCA9IFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgI3tjb3VudH07IGkrKykge1xuICAgICAgICAgIG91dCArPSBieXRlcy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAje2BvdXRgLmVuY29kZSgnVVMtQVNDSUknKX07XG4gICAgICB9XG4gICAgZW5kXG5cbiAgICBkZWYgcmFuZG9tX2J5dGVzKGNvdW50ID0gbmlsKVxuICAgICAgYnl0ZXMoY291bnQpXG4gICAgZW5kXG5cbiAgICBkZWYgYmFzZTY0KGNvdW50ID0gbmlsKVxuICAgICAgQmFzZTY0LnN0cmljdF9lbmNvZGU2NChyYW5kb21fYnl0ZXMoY291bnQpKS5lbmNvZGUoJ1VTLUFTQ0lJJylcbiAgICBlbmRcblxuICAgIGRlZiB1cmxzYWZlX2Jhc2U2NChjb3VudCA9IG5pbCwgcGFkZGluZyA9IGZhbHNlKVxuICAgICAgQmFzZTY0LnVybHNhZmVfZW5jb2RlNjQocmFuZG9tX2J5dGVzKGNvdW50KSwgcGFkZGluZykuZW5jb2RlKCdVUy1BU0NJSScpXG4gICAgZW5kXG5cbiAgICBkZWYgdXVpZFxuICAgICAgc3RyID0gaGV4KDE2KS5zcGxpdCgnJylcbiAgICAgIHN0clsxMl0gPSAnNCdcbiAgICAgIHN0clsxNl0gPSBgKHBhcnNlSW50KCN7c3RyWzE2XX0sIDE2KSAmIDMgfCA4KS50b1N0cmluZygxNilgXG4gICAgICBzdHIgPSBbc3RyWzAuLi44XSwgc3RyWzguLi4xMl0sIHN0clsxMi4uLjE2XSwgc3RyWzE2Li4uMjBdLCBzdHJbMjAuLi4zMl1dXG4gICAgICBzdHIgPSBzdHIubWFwKCY6am9pbilcbiAgICAgIHN0ci5qb2luKCctJylcbiAgICBlbmRcblxuICAgICMgSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgYCNieXRlc2AgZm9yIFNlY3VyZVJhbmRvbSwgYnV0IFJhbmRvbSBvdmVycmlkZXMgdGhpc1xuICAgICMgbWV0aG9kIHRvIGltcGxlbWVudCBgI2J5dGVzYCBpbiB0ZXJtcyBvZiBgI3JhbmRvbV9mbG9hdGAuIE5vdCBwYXJ0IG9mIHN0YW5kYXJkXG4gICAgIyBSdWJ5IGludGVyZmFjZSAtIHVzZSByYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eS5cbiAgICBkZWYgcmFuZG9tX2Zsb2F0XG4gICAgICBicyA9IGJ5dGVzKDQpXG4gICAgICBudW0gPSAwXG4gICAgICA0LnRpbWVzIGRvIHxpfFxuICAgICAgICBudW0gPDw9IDhcbiAgICAgICAgbnVtIHw9IGJzW2ldLm9yZFxuICAgICAgZW5kXG4gICAgICBudW0uYWJzIC8gMHg3ZmZmZmZmZlxuICAgIGVuZFxuXG4gICAgZGVmIHJhbmRvbV9udW1iZXIobGltaXQgPSB1bmRlZmluZWQpXG4gICAgICAleHtcbiAgICAgICAgZnVuY3Rpb24gcmFuZG9tRmxvYXQoKSB7XG4gICAgICAgICAgcmV0dXJuICN7cmFuZG9tX2Zsb2F0fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbUludChtYXgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyYW5kb21GbG9hdCgpICogbWF4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbVJhbmdlKCkge1xuICAgICAgICAgIHZhciBtaW4gPSBsaW1pdC5iZWdpbixcbiAgICAgICAgICAgICAgbWF4ID0gbGltaXQuZW5kO1xuXG4gICAgICAgICAgaWYgKG1pbiA9PT0gbmlsIHx8IG1heCA9PT0gbmlsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmlsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsZW5ndGggPSBtYXggLSBtaW47XG5cbiAgICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5pbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXggJSAxID09PSAwICYmIG1pbiAlIDEgPT09IDAgJiYgIWxpbWl0LmV4Y2wpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5kb21JbnQobGVuZ3RoKSArIG1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGltaXQuJCRpc19yYW5nZSkge1xuICAgICAgICAgIHJldHVybiByYW5kb21SYW5nZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbWl0LiQkaXNfbnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpbnRlZ2VyXG4gICAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmRvbUZsb2F0KCkgKiBsaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGltaXQgPSAje09wYWwuY29lcmNlX3RvIShsaW1pdCwgSW50ZWdlciwgOnRvX2ludCl9O1xuXG4gICAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgICN7cmFpc2UgQXJndW1lbnRFcnJvciwgXCJpbnZhbGlkIGFyZ3VtZW50IC0gI3tsaW1pdH1cIn1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmFuZG9tSW50KGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGVuZFxuXG4gICAgZGVmIGFscGhhbnVtZXJpYyhjb3VudCA9IG5pbClcbiAgICAgIGNvdW50ID0gUmFuZG9tLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgICBtYXAgPSBbJzAnLi4nOScsICdhJy4uJ3onLCAnQScuLidaJ10ubWFwKCY6dG9fYSkuZmxhdHRlblxuICAgICAgQXJyYXkubmV3KGNvdW50KSBkbyB8aXxcbiAgICAgICAgbWFwW3JhbmRvbV9udW1iZXIobWFwLmxlbmd0aCldXG4gICAgICBlbmQuam9pblxuICAgIGVuZFxuICBlbmRcblxuICBpbmNsdWRlIFJhbmRvbTo6Rm9ybWF0dGVyXG4gIGV4dGVuZCBSYW5kb206OkZvcm1hdHRlclxuZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpSYW5kb20+IiwiPG1vZHVsZTpGb3JtYXR0ZXI+IiwiaGV4IiwiY291bnQiLCJSYW5kb20iLCJfdmVyaWZ5X2NvdW50Iiwic2VsZiIsImJ5dGVzIiwiZW5jb2RlIiwicmFuZG9tX2J5dGVzIiwiYmFzZTY0IiwiQmFzZTY0Iiwic3RyaWN0X2VuY29kZTY0IiwidXJsc2FmZV9iYXNlNjQiLCJwYWRkaW5nIiwidXJsc2FmZV9lbmNvZGU2NCIsInV1aWQiLCJzdHIiLCIxNiIsInNwbGl0IiwiJHdyaXRlciIsIjEyIiwiW109IiwiLSIsIjEiLCJbXSIsIjAiLCI4IiwiMjAiLCIzMiIsIm1hcCIsInRvX3Byb2MiLCJqb2luIiwicmFuZG9tX2Zsb2F0IiwiYnMiLCI0IiwibnVtIiwidGltZXMiLCJibG9jayBpbiByYW5kb21fZmxvYXQiLCJpIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiByYW5kb21fZmxvYXQiLCI8PCIsInwiLCJvcmQiLCIvIiwiYWJzIiwiMjE0NzQ4MzY0NyIsInJhbmRvbV9udW1iZXIiLCJsaW1pdCIsInJhaXNlIiwiQXJndW1lbnRFcnJvciIsIk9wYWwiLCJjb2VyY2VfdG8hIiwiSW50ZWdlciIsImFscGhhbnVtZXJpYyIsImZsYXR0ZW4iLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGFscGhhbnVtZXJpYyIsImJsb2NrICgyIGxldmVscykgaW4gYWxwaGFudW1lcmljIiwibGVuZ3RoIiwiaW5jbHVkZSIsIlJhbmRvbTo6Rm9ybWF0dGVyIiwiZXh0ZW5kIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7RUFBQUE7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LHsib2Zmc2V0Ijp7ImxpbmUiOjI1MjAxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi9yYW5kb20ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiIyBoZWxwZXJzOiBmYWxzeVxuXG5jbGFzcyBSYW5kb21cbiAgYXR0cl9yZWFkZXIgOnNlZWQsIDpzdGF0ZVxuXG4gIGRlZiBzZWxmLl92ZXJpZnlfY291bnQoY291bnQpXG4gICAgJXh7XG4gICAgICBpZiAoJGZhbHN5KGNvdW50KSkgY291bnQgPSAxNjtcbiAgICAgIGlmICh0eXBlb2YgY291bnQgIT09IFwibnVtYmVyXCIpIGNvdW50ID0gI3tgY291bnRgLnRvX2ludH07XG4gICAgICBpZiAoY291bnQgPCAwKSAje3JhaXNlIEFyZ3VtZW50RXJyb3IsICduZWdhdGl2ZSBzdHJpbmcgc2l6ZSAob3Igc2l6ZSB0b28gYmlnKSd9O1xuICAgICAgY291bnQgPSBNYXRoLmZsb29yKGNvdW50KTtcbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBpbml0aWFsaXplKHNlZWQgPSBSYW5kb20ubmV3X3NlZWQpXG4gICAgc2VlZCA9IE9wYWwuY29lcmNlX3RvIShzZWVkLCBJbnRlZ2VyLCA6dG9faW50KVxuICAgIEBzdGF0ZSA9IHNlZWRcbiAgICByZXNlZWQoc2VlZClcbiAgZW5kXG5cbiAgZGVmIHJlc2VlZChzZWVkKVxuICAgIEBzZWVkID0gc2VlZFxuICAgIGBzZWxmLiRybmcgPSBPcGFsLiQkcmFuZC5yZXNlZWQoc2VlZClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLm5ld19zZWVkXG4gICAgYE9wYWwuJCRyYW5kLm5ld19zZWVkKClgXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJhbmQobGltaXQgPSB1bmRlZmluZWQpXG4gICAgREVGQVVMVC5yYW5kKGxpbWl0KVxuICBlbmRcblxuICBkZWYgc2VsZi5zcmFuZChuID0gUmFuZG9tLm5ld19zZWVkKVxuICAgIG4gPSBPcGFsLmNvZXJjZV90byEobiwgSW50ZWdlciwgOnRvX2ludClcblxuICAgIHByZXZpb3VzX3NlZWQgPSBERUZBVUxULnNlZWRcbiAgICBERUZBVUxULnJlc2VlZChuKVxuICAgIHByZXZpb3VzX3NlZWRcbiAgZW5kXG5cbiAgZGVmIHNlbGYudXJhbmRvbShzaXplKVxuICAgIDo6U2VjdXJlUmFuZG9tLmJ5dGVzKHNpemUpXG4gIGVuZFxuXG4gIGRlZiA9PShvdGhlcilcbiAgICByZXR1cm4gZmFsc2UgdW5sZXNzIFJhbmRvbSA9PT0gb3RoZXJcblxuICAgIHNlZWQgPT0gb3RoZXIuc2VlZCAmJiBzdGF0ZSA9PSBvdGhlci5zdGF0ZVxuICBlbmRcblxuICBkZWYgYnl0ZXMobGVuZ3RoKVxuICAgIGxlbmd0aCA9IFJhbmRvbS5fdmVyaWZ5X2NvdW50KGxlbmd0aClcblxuICAgIEFycmF5Lm5ldyhsZW5ndGgpIHsgcmFuZCgyNTUpLmNociB9LmpvaW4uZW5jb2RlKCdBU0NJSS04QklUJylcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYnl0ZXMobGVuZ3RoKVxuICAgIERFRkFVTFQuYnl0ZXMobGVuZ3RoKVxuICBlbmRcblxuICBkZWYgcmFuZChsaW1pdCA9IHVuZGVmaW5lZClcbiAgICByYW5kb21fbnVtYmVyKGxpbWl0KVxuICBlbmRcblxuICAjIE5vdCBwYXJ0IG9mIHRoZSBSdWJ5IGludGVyZmFjZSAodXNlICNyYW5kb21fbnVtYmVyIGZvciBwb3J0YWJpbGl0eSksIGJ1dFxuICAjIHVzZWQgYnkgUmFuZG9tOjpGb3JtYXR0ZXIgYXMgYSBzaG9ydGN1dCwgYXMgZm9yIFJhbmRvbSBpbnRlcmZhY2UgdGhlIGZsb2F0XG4gICMgUk5HIGlzIHByaW1hcnkuXG4gIGRlZiByYW5kb21fZmxvYXRcbiAgICAleHtcbiAgICAgIHNlbGYuc3RhdGUrKztcbiAgICAgIHJldHVybiBPcGFsLiQkcmFuZC5yYW5kKHNlbGYuJHJuZyk7XG4gICAgfVxuICBlbmRcblxuICBkZWYgc2VsZi5yYW5kb21fZmxvYXRcbiAgICBERUZBVUxULnJhbmRvbV9mbG9hdFxuICBlbmRcblxuICBkZWYgc2VsZi5nZW5lcmF0b3I9KGdlbmVyYXRvcilcbiAgICBgT3BhbC4kJHJhbmQgPSAje2dlbmVyYXRvcn1gXG5cbiAgICBpZiBjb25zdF9kZWZpbmVkPyA6REVGQVVMVFxuICAgICAgREVGQVVMVC5yZXNlZWRcbiAgICBlbHNlXG4gICAgICBjb25zdF9zZXQgOkRFRkFVTFQsIG5ldyhuZXdfc2VlZClcbiAgICBlbmRcbiAgZW5kXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwiPGNsYXNzOlJhbmRvbT4iLCJzZWxmIiwiYXR0cl9yZWFkZXIiLCJfdmVyaWZ5X2NvdW50IiwiY291bnQiLCJ0b19pbnQiLCJyYWlzZSIsIkFyZ3VtZW50RXJyb3IiLCJpbml0aWFsaXplIiwic2VlZCIsIlJhbmRvbSIsIm5ld19zZWVkIiwiT3BhbCIsImNvZXJjZV90byEiLCJJbnRlZ2VyIiwiQHN0YXRlIiwicmVzZWVkIiwiQHNlZWQiLCJyYW5kIiwibGltaXQiLCJERUZBVUxUIiwic3JhbmQiLCJuIiwicHJldmlvdXNfc2VlZCIsInVyYW5kb20iLCJzaXplIiwiU2VjdXJlUmFuZG9tIiwiYnl0ZXMiLCI9PSIsIm90aGVyIiwiPT09IiwiJHJldF9vcl8xIiwic3RhdGUiLCJsZW5ndGgiLCJuZXciLCJBcnJheSIsImJsb2NrIGluIGJ5dGVzIiwiYmxvY2sgKDIgbGV2ZWxzKSBpbiBieXRlcyIsIjI1NSIsImNociIsImpvaW4iLCJlbmNvZGUiLCJyYW5kb21fbnVtYmVyIiwicmFuZG9tX2Zsb2F0IiwiZ2VuZXJhdG9yPSIsImdlbmVyYXRvciIsImNvbnN0X2RlZmluZWQ/IiwiY29uc3Rfc2V0Il0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBO0VBRUFBLE9BQUFDO0VBQUFBOztJQUFBQTs7O0lBQ0VDLElBQUFDLGFBQUFBLENBQVksTUFBWixFQUFtQixPQUFuQkE7SUFFQUMsVUFBSUYsSUFBSkUsb0JBQUFBLDBCQUFBQSx5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LFVBQUkxQixJQUFKMEIsWUFBQUEsbUJBQUFBLGlCQUFlTSxNQUFmTjtBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQVAsdUJBQU9PLE9BQUFBLENBQU9NLE1BQVBOO0lBRFRBLENBQUFBLDhCQUFBQTs7QUFJQVQsSUFBQUEsd0JBQUFBLGtCQUFBQSxnQkFBU0MsS0FBVEQ7QUFBQUEsTUFBQUE7Ozs7TUFDRUEsT0FBQWpCLElBQUF5QyxlQUFBQSxDQUFjdkIsS0FBZHVCO0lBREZ4QixDQUFBQSw4QkFBQUE7O0FBT0F5QixJQUFBQSxnQ0FBQUEsMEJBQUFBLHdCQUFBQTtBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0lBSkVBLENBQUFBLHFDQUFBQTtJQU9BQSxVQUFJMUMsSUFBSjBDLG1CQUFBQSwwQkFBQUEsd0JBQUFBO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBdkIsdUJBQU91QixjQUFBQSxDQUFBQTtJQURUQSxDQUFBQSxxQ0FBQUE7SUFJQTNDLE9BQUE0QyxDQUFBQSxVQUFJM0MsSUFBSjJDLGlCQUFBQSwwQkFBQUEsU0FBb0JDLFNBQXBCRDtBQUFBQSxNQUFBQTs7O01BQ0dBLGNBQWdCQztNQUVqQixJQUFBLFFBQUc1QyxJQUFBNkMsbUJBQUFBLENBQWUsU0FBZkEsQ0FBSCxDQUFBO1FBQ0VGLE9BQUF4Qix1QkFBT0osUUFBQUEsQ0FBQUE7TUFEVDtRQUdFNEIsT0FBQTNDLElBQUE4QyxXQUFBQSxDQUFVLFNBQVYsRUFBb0I5QyxJQUFBaUMsS0FBQUEsQ0FBSWpDLElBQUFVLFVBQUFBLENBQUFBLENBQUp1QixDQUFwQmE7TUFIRjtJQUhGSCxDQUFBQSxxQ0FBQUEsQ0FBQUE7RUE5RUY1QyxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQUZBRDsifX0seyJvZmZzZXQiOnsibGluZSI6MjUzNDEsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb3JlbGliL3JhbmRvbS9tZXJzZW5uZV90d2lzdGVyLnJiIl0sInNvdXJjZXNDb250ZW50IjpbIiMgVGhpcyBpcyBiYXNlZCBvbiBhbiBhZGFwdGF0aW9uIG9mIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlXG4jIGRvbmUgYnkgU2VhbiBNY0N1bGxvdWdoIDxiYW5rc2VhbkBnbWFpbC5jb20+IGFuZCBEYXZlIEhlaXR6bWFuXG4jIDxkYXZlaGVpdHptYW5AeWFob28uY29tPiwgc3Vic2VxdWVudGx5IHJlYWRhcHRlZCBmcm9tIGFuIHVwZGF0ZWQgdmVyc2lvbiBvZlxuIyBydWJ5J3MgcmFuZG9tLmMgKHJldiBjMzhhMTgzMDMyYTc4MjZkZjFhZGFiZDhhYTA3MjVjNzEzZDUzZTFjKS5cbiNcbiMgVGhlIG9yaWdpbmFsIGNvcHlyaWdodCBub3RpY2UgZnJvbSByYW5kb20uYyBmb2xsb3dzLlxuI1xuIyAgIFRoaXMgaXMgYmFzZWQgb24gdHJpbW1lZCB2ZXJzaW9uIG9mIE1UMTk5MzcuICBUbyBnZXQgdGhlIG9yaWdpbmFsIHZlcnNpb24sXG4jICAgY29udGFjdCA8aHR0cDovL3d3dy5tYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcC9+bS1tYXQvTVQvZW10Lmh0bWw+LlxuI1xuIyAgIFRoZSBvcmlnaW5hbCBjb3B5cmlnaHQgbm90aWNlIGZvbGxvd3MuXG4jXG4jICAgICAgQSBDLXByb2dyYW0gZm9yIE1UMTk5MzcsIHdpdGggaW5pdGlhbGl6YXRpb24gaW1wcm92ZWQgMjAwMi8yLzEwLlxuIyAgICAgIENvZGVkIGJ5IFRha3VqaSBOaXNoaW11cmEgYW5kIE1ha290byBNYXRzdW1vdG8uXG4jICAgICAgVGhpcyBpcyBhIGZhc3RlciB2ZXJzaW9uIGJ5IHRha2luZyBTaGF3biBDb2t1cydzIG9wdGltaXphdGlvbixcbiMgICAgICBNYXR0aGUgQmVsbGV3J3Mgc2ltcGxpZmljYXRpb24sIElzYWt1IFdhZGEncyByZWFsIHZlcnNpb24uXG4jXG4jICAgICAgQmVmb3JlIHVzaW5nLCBpbml0aWFsaXplIHRoZSBzdGF0ZSBieSB1c2luZyBpbml0X2dlbnJhbmQobXQsIHNlZWQpXG4jICAgICAgb3IgaW5pdF9ieV9hcnJheShtdCwgaW5pdF9rZXksIGtleV9sZW5ndGgpLlxuI1xuIyAgICAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4jICAgICAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiNcbiMgICAgICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiMgICAgICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiMgICAgICBhcmUgbWV0OlxuI1xuIyAgICAgICAgMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiMgICAgICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiNcbiMgICAgICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4jICAgICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4jICAgICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuI1xuIyAgICAgICAgMy4gVGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IG5vdCBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZVxuIyAgICAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4jICAgICAgICAgICBwZXJtaXNzaW9uLlxuI1xuIyAgICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiMgICAgICBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4jICAgICAgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4jICAgICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4jICAgICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4jICAgICAgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLFxuIyAgICAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuIyAgICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbiMgICAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuIyAgICAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuIyAgICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuI1xuI1xuIyAgICAgIEFueSBmZWVkYmFjayBpcyB2ZXJ5IHdlbGNvbWUuXG4jICAgICAgaHR0cDovL3d3dy5tYXRoLmtlaW8uYWMuanAvbWF0dW1vdG8vZW10Lmh0bWxcbiMgICAgICBlbWFpbDogbWF0dW1vdG9AbWF0aC5rZWlvLmFjLmpwXG5tZXJzZW5uZV90d2lzdGVyID0gJXh7KGZ1bmN0aW9uKCkge1xuICAvKiBQZXJpb2QgcGFyYW1ldGVycyAqL1xuICB2YXIgTiA9IDYyNDtcbiAgdmFyIE0gPSAzOTc7XG4gIHZhciBNQVRSSVhfQSA9IDB4OTkwOGIwZGY7ICAgICAgLyogY29uc3RhbnQgdmVjdG9yIGEgKi9cbiAgdmFyIFVNQVNLID0gMHg4MDAwMDAwMDsgICAgICAgICAvKiBtb3N0IHNpZ25pZmljYW50IHctciBiaXRzICovXG4gIHZhciBMTUFTSyA9IDB4N2ZmZmZmZmY7ICAgICAgICAgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG4gIHZhciBNSVhCSVRTID0gZnVuY3Rpb24odSx2KSB7IHJldHVybiAoICgodSkgJiBVTUFTSykgfCAoKHYpICYgTE1BU0spICk7IH07XG4gIHZhciBUV0lTVCA9IGZ1bmN0aW9uKHUsdikgeyByZXR1cm4gKE1JWEJJVFMoKHUpLCh2KSkgPj4+IDEpIF4gKCh2ICYgMHgxKSA/IE1BVFJJWF9BIDogMHgwKTsgfTtcblxuICBmdW5jdGlvbiBpbml0KHMpIHtcbiAgICB2YXIgbXQgPSB7bGVmdDogMCwgbmV4dDogTiwgc3RhdGU6IG5ldyBBcnJheShOKX07XG4gICAgaW5pdF9nZW5yYW5kKG10LCBzKTtcbiAgICByZXR1cm4gbXQ7XG4gIH1cblxuICAvKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuICBmdW5jdGlvbiBpbml0X2dlbnJhbmQobXQsIHMpIHtcbiAgICB2YXIgaiwgaTtcbiAgICBtdC5zdGF0ZVswXSA9IHMgPj4+IDA7XG4gICAgZm9yIChqPTE7IGo8TjsgaisrKSB7XG4gICAgICBtdC5zdGF0ZVtqXSA9ICgxODEyNDMzMjUzICogKChtdC5zdGF0ZVtqLTFdIF4gKG10LnN0YXRlW2otMV0gPj4gMzApID4+PiAwKSkgKyBqKTtcbiAgICAgIC8qIFNlZSBLbnV0aCBUQU9DUCBWb2wyLiAzcmQgRWQuIFAuMTA2IGZvciBtdWx0aXBsaWVyLiAqL1xuICAgICAgLyogSW4gdGhlIHByZXZpb3VzIHZlcnNpb25zLCBNU0JzIG9mIHRoZSBzZWVkIGFmZmVjdCAgICovXG4gICAgICAvKiBvbmx5IE1TQnMgb2YgdGhlIGFycmF5IHN0YXRlW10uICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgIC8qIDIwMDIvMDEvMDkgbW9kaWZpZWQgYnkgTWFrb3RvIE1hdHN1bW90byAgICAgICAgICAgICAqL1xuICAgICAgbXQuc3RhdGVbal0gJj0gMHhmZmZmZmZmZjsgIC8qIGZvciA+MzIgYml0IG1hY2hpbmVzICovXG4gICAgfVxuICAgIG10LmxlZnQgPSAxO1xuICAgIG10Lm5leHQgPSBOO1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgTiB3b3JkcyBhdCBvbmUgdGltZSAqL1xuICBmdW5jdGlvbiBuZXh0X3N0YXRlKG10KSB7XG4gICAgdmFyIHAgPSAwLCBfcCA9IG10LnN0YXRlO1xuICAgIHZhciBqO1xuXG4gICAgbXQubGVmdCA9IE47XG4gICAgbXQubmV4dCA9IDA7XG5cbiAgICBmb3IgKGo9Ti1NKzE7IC0tajsgcCsrKVxuICAgICAgX3BbcF0gPSBfcFtwKyhNKV0gXiBUV0lTVChfcFtwKygwKV0sIF9wW3ArKDEpXSk7XG5cbiAgICBmb3IgKGo9TTsgLS1qOyBwKyspXG4gICAgICBfcFtwXSA9IF9wW3ArKE0tTildIF4gVFdJU1QoX3BbcCsoMCldLCBfcFtwKygxKV0pO1xuXG4gICAgX3BbcF0gPSBfcFtwKyhNLU4pXSBeIFRXSVNUKF9wW3ArKDApXSwgX3BbMF0pO1xuICB9XG5cbiAgLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwweGZmZmZmZmZmXS1pbnRlcnZhbCAqL1xuICBmdW5jdGlvbiBnZW5yYW5kX2ludDMyKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciB5O1xuXG4gICAgaWYgKC0tbXQubGVmdCA8PSAwKSBuZXh0X3N0YXRlKG10KTtcbiAgICB5ID0gbXQuc3RhdGVbbXQubmV4dCsrXTtcblxuICAgIC8qIFRlbXBlcmluZyAqL1xuICAgIHkgXj0gKHkgPj4+IDExKTtcbiAgICB5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcbiAgICB5IF49ICh5IDw8IDE1KSAmIDB4ZWZjNjAwMDA7XG4gICAgeSBePSAoeSA+Pj4gMTgpO1xuXG4gICAgcmV0dXJuIHkgPj4+IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpbnRfcGFpcl90b19yZWFsX2V4Y2x1c2l2ZShhLCBiKSB7XG4gICAgYSA+Pj49IDU7XG4gICAgYiA+Pj49IDY7XG4gICAgcmV0dXJuKGEqNjcxMDg4NjQuMCtiKSooMS4wLzkwMDcxOTkyNTQ3NDA5OTIuMCk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb25cbiAgZnVuY3Rpb24gZ2VucmFuZF9yZWFsKG10KSB7XG4gICAgLyogbXQgbXVzdCBiZSBpbml0aWFsaXplZCAqL1xuICAgIHZhciBhID0gZ2VucmFuZF9pbnQzMihtdCksIGIgPSBnZW5yYW5kX2ludDMyKG10KTtcbiAgICByZXR1cm4gaW50X3BhaXJfdG9fcmVhbF9leGNsdXNpdmUoYSwgYik7XG4gIH1cblxuICByZXR1cm4geyBnZW5yYW5kX3JlYWw6IGdlbnJhbmRfcmVhbCwgaW5pdDogaW5pdCB9O1xufSkoKX1cblxuY2xhc3MgUmFuZG9tXG4gIGB2YXIgTUFYX0lOVCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IE1hdGgucG93KDIsIDUzKSAtIDFgXG5cbiAgTUVSU0VOTkVfVFdJU1RFUl9HRU5FUkFUT1IgPSBge1xuICAgIG5ld19zZWVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIE1BWF9JTlQpOyB9LFxuICAgIHJlc2VlZDogZnVuY3Rpb24oc2VlZCkgeyByZXR1cm4gbWVyc2VubmVfdHdpc3Rlci5pbml0KHNlZWQpOyB9LFxuICAgIHJhbmQ6IGZ1bmN0aW9uKG10KSB7IHJldHVybiBtZXJzZW5uZV90d2lzdGVyLmdlbnJhbmRfcmVhbChtdCk7IH1cbiAgfWBcblxuICBzZWxmLmdlbmVyYXRvciA9IE1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+IiwibWVyc2VubmVfdHdpc3RlciIsIjxjbGFzczpSYW5kb20+IiwiJHdyaXRlciIsIk1FUlNFTk5FX1RXSVNURVJfR0VORVJBVE9SIiwiZ2VuZXJhdG9yPSIsInNlbGYiLCItIiwiMSJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7RUFzREFDLG1CQUFzQkQ7QUFDdEJBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7RUFFQUEsT0FBQUU7RUFBQUE7O0lBQUFBOzs7SUFDR0E7SUFFRCwwREFBOEJBO0FBQ2hDQTtBQUNBQTtBQUNBQTtBQUNBQSxHQUpFOztJQTNJRkMsVUFBQSxDQWlKbUJDLDBDQWpKbkI7SUFpSk1DLE1BQUpDLElBQUlELGNBQUFBLEVBakpOLFVBQUFGLE9BQUEsQ0FpSk1FO0lBakpOSCxPQUFBQyxPQUFBLENBQUFJLFVBQUFKLE9BQUEsQ0FBQUQsUUFBQSxDQUFBSyxFQUFBQyxDQUFBRCxDQUFBO0VBd0lBTCxHQUFBQSxXQUFBQSxFQUFBQSxJQUFBQTtBQXhJQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1NDUwLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29yZWxpYi91bnN1cHBvcnRlZC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgdmFyIHdhcm5pbmdzID0ge307XG5cbiAgZnVuY3Rpb24gaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUobWVzc2FnZSkge1xuICAgIHN3aXRjaCAoT3BhbC5jb25maWcudW5zdXBwb3J0ZWRfZmVhdHVyZXNfc2V2ZXJpdHkpIHtcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICAje0tlcm5lbC5yYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgbWVzc2FnZWB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgIHdhcm4obWVzc2FnZSlcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6IC8vIGlnbm9yZVxuICAgICAgLy8gbm9vcFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oc3RyaW5nKSB7XG4gICAgaWYgKHdhcm5pbmdzW3N0cmluZ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuaW5nc1tzdHJpbmddID0gdHJ1ZTtcbiAgICAje3dhcm4oYHN0cmluZ2ApfTtcbiAgfVxufVxuXG5jbGFzcyBTdHJpbmdcbiAgYHZhciBFUlJPUiA9IFwiU3RyaW5nIyVzIG5vdCBzdXBwb3J0ZWQuIE11dGFibGUgU3RyaW5nIG1ldGhvZHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gT3BhbC5cImBcblxuICBkZWYgPDwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJzw8J1xuICBlbmRcblxuICBkZWYgY2FwaXRhbGl6ZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NhcGl0YWxpemUhJ1xuICBlbmRcblxuICBkZWYgY2hvbXAhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdjaG9tcCEnXG4gIGVuZFxuXG4gIGRlZiBjaG9wISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnY2hvcCEnXG4gIGVuZFxuXG4gIGRlZiBkb3duY2FzZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2Rvd25jYXNlISdcbiAgZW5kXG5cbiAgZGVmIGdzdWIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdnc3ViISdcbiAgZW5kXG5cbiAgZGVmIGxzdHJpcCEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2xzdHJpcCEnXG4gIGVuZFxuXG4gIGRlZiBuZXh0ISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnbmV4dCEnXG4gIGVuZFxuXG4gIGRlZiByZXZlcnNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncmV2ZXJzZSEnXG4gIGVuZFxuXG4gIGRlZiBzbGljZSEoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ3NsaWNlISdcbiAgZW5kXG5cbiAgZGVmIHNxdWVlemUhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzcXVlZXplISdcbiAgZW5kXG5cbiAgZGVmIHN0cmlwISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3RyaXAhJ1xuICBlbmRcblxuICBkZWYgc3ViISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3ViISdcbiAgZW5kXG5cbiAgZGVmIHN1Y2MhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICdzdWNjISdcbiAgZW5kXG5cbiAgZGVmIHN3YXBjYXNlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnc3dhcGNhc2UhJ1xuICBlbmRcblxuICBkZWYgdHIhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd0ciEnXG4gIGVuZFxuXG4gIGRlZiB0cl9zISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndHJfcyEnXG4gIGVuZFxuXG4gIGRlZiB1cGNhc2UhKCopXG4gICAgcmFpc2UgTm90SW1wbGVtZW50ZWRFcnJvciwgYEVSUk9SYCAlICd1cGNhc2UhJ1xuICBlbmRcblxuICBkZWYgcHJlcGVuZCgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAncHJlcGVuZCdcbiAgZW5kXG5cbiAgZGVmIFtdPSgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnW109J1xuICBlbmRcblxuICBkZWYgY2xlYXIoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBgRVJST1JgICUgJ2NsZWFyJ1xuICBlbmRcblxuICBkZWYgZW5jb2RlISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAnZW5jb2RlISdcbiAgZW5kXG5cbiAgZGVmIHVuaWNvZGVfbm9ybWFsaXplISgqKVxuICAgIHJhaXNlIE5vdEltcGxlbWVudGVkRXJyb3IsIGBFUlJPUmAgJSAndW5pY29kZV9ub3JtYWxpemUhJ1xuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCBmcmVlemluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgZnJlZXplXG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBzZWxmXG4gIGVuZFxuXG4gIGRlZiBmcm96ZW4/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgS2VybmVsXG4gIGB2YXIgRVJST1IgPSBcIk9iamVjdCB0YWludGluZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IE9wYWxcImBcblxuICBkZWYgdGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHVudGFpbnRcbiAgICBgaGFuZGxlX3Vuc3VwcG9ydGVkX2ZlYXR1cmUoRVJST1IpYFxuICAgIHNlbGZcbiAgZW5kXG5cbiAgZGVmIHRhaW50ZWQ/XG4gICAgYGhhbmRsZV91bnN1cHBvcnRlZF9mZWF0dXJlKEVSUk9SKWBcbiAgICBmYWxzZVxuICBlbmRcbmVuZFxuXG5jbGFzcyBNb2R1bGVcbiAgZGVmIHB1YmxpYygqbWV0aG9kcylcbiAgICAleHtcbiAgICAgIGlmIChtZXRob2RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZWxmLiQkbW9kdWxlX2Z1bmN0aW9uID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuaWw7XG4gICAgfVxuICBlbmRcblxuICBhbGlhcyBwcml2YXRlIHB1YmxpY1xuXG4gIGFsaWFzIHByb3RlY3RlZCBwdWJsaWNcblxuICBhbGlhcyBuZXN0aW5nIHB1YmxpY1xuXG4gIGRlZiBwcml2YXRlX2NsYXNzX21ldGhvZCgqKVxuICAgIHNlbGZcbiAgZW5kXG5cbiAgYWxpYXMgcHVibGljX2NsYXNzX21ldGhvZCBwcml2YXRlX2NsYXNzX21ldGhvZFxuXG4gIGRlZiBwcml2YXRlX21ldGhvZF9kZWZpbmVkPyhvYmopXG4gICAgZmFsc2VcbiAgZW5kXG5cbiAgZGVmIHByaXZhdGVfY29uc3RhbnQoKilcbiAgZW5kXG5cbiAgYWxpYXMgcHJvdGVjdGVkX21ldGhvZF9kZWZpbmVkPyBwcml2YXRlX21ldGhvZF9kZWZpbmVkP1xuXG4gIGFsaWFzIHB1YmxpY19pbnN0YW5jZV9tZXRob2RzIGluc3RhbmNlX21ldGhvZHNcblxuICBhbGlhcyBwdWJsaWNfaW5zdGFuY2VfbWV0aG9kIGluc3RhbmNlX21ldGhvZFxuXG4gIGFsaWFzIHB1YmxpY19tZXRob2RfZGVmaW5lZD8gbWV0aG9kX2RlZmluZWQ/XG5lbmRcblxubW9kdWxlIEtlcm5lbFxuICBkZWYgcHJpdmF0ZV9tZXRob2RzKCopXG4gICAgW11cbiAgZW5kXG5cbiAgYWxpYXMgcHJpdmF0ZV9pbnN0YW5jZV9tZXRob2RzIHByaXZhdGVfbWV0aG9kc1xuZW5kXG5cbm1vZHVsZSBLZXJuZWxcbiAgZGVmIGV2YWwoKilcbiAgICByYWlzZSBOb3RJbXBsZW1lbnRlZEVycm9yLCBcIlRvIHVzZSBLZXJuZWwjZXZhbCwgeW91IG11c3QgZmlyc3QgcmVxdWlyZSAnb3BhbC1wYXJzZXInLiBcIlxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly9naXRodWIuY29tL29wYWwvb3BhbC9ibG9iLyN7UlVCWV9FTkdJTkVfVkVSU0lPTn0vZG9jcy9vcGFsX3BhcnNlci5tZCBmb3IgZGV0YWlscy5cIlxuICBlbmRcbmVuZFxuXG5kZWYgc2VsZi5wdWJsaWMoKilcbiAgIyBzdHViXG5lbmRcblxuZGVmIHNlbGYucHJpdmF0ZSgqKVxuICAjIHN0dWJcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJLZXJuZWwiLCJyYWlzZSIsIk5vdEltcGxlbWVudGVkRXJyb3IiLCJzZWxmIiwid2FybiIsIjxjbGFzczpTdHJpbmc+IiwiPDwiLCIlIiwiY2FwaXRhbGl6ZSEiLCJjaG9tcCEiLCJjaG9wISIsImRvd25jYXNlISIsImdzdWIhIiwibHN0cmlwISIsIm5leHQhIiwicmV2ZXJzZSEiLCJzbGljZSEiLCJzcXVlZXplISIsInN0cmlwISIsInN1YiEiLCJzdWNjISIsInN3YXBjYXNlISIsInRyISIsInRyX3MhIiwidXBjYXNlISIsInByZXBlbmQiLCJbXT0iLCJjbGVhciIsImVuY29kZSEiLCJ1bmljb2RlX25vcm1hbGl6ZSEiLCI8bW9kdWxlOktlcm5lbD4iLCJmcmVlemUiLCJmcm96ZW4/IiwidGFpbnQiLCJ1bnRhaW50IiwidGFpbnRlZD8iLCI8Y2xhc3M6TW9kdWxlPiIsInB1YmxpYyIsInByaXZhdGVfY2xhc3NfbWV0aG9kIiwicHJpdmF0ZV9tZXRob2RfZGVmaW5lZD8iLCJvYmoiLCJwcml2YXRlX2NvbnN0YW50IiwicHJpdmF0ZV9tZXRob2RzIiwiZXZhbCIsIlJVQllfRU5HSU5FX1ZFUlNJT04iLCJwcml2YXRlIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOzs7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBLE1BQVFDLHNCQUFNQyxPQUFBQSxDQUFPQyxtQ0FBYixFQUFtQ0gsT0FBN0JFO0FBQ2RGO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUEsSUFBTUksSUFBQUMsTUFBQUEsQ0FBTUwsTUFBTkssQ0FBZUw7QUFDckJBOztFQUdBTTtFQUFBQTs7SUFBQUE7OztJQUNHQTs7QUFFREMsSUFBQUEsc0JBQUFBLG1CQUFBQSxTQTdCRixFQTZCRUE7QUFBQUEsTUFBQUE7Ozs7TUE3QkY7O01BOEJJQSxPQUFBSCxJQUFBRixPQUFBQSxDQUFNQyxtQ0FBTixFQUEyQkksQ0FBQ0EsS0FBREEsQ0FBUUMsTUFBQUEsQ0FBRUQsSUFBRkMsQ0FBbkNOO0lBREZLLENBQUFBLCtCQUFBQTs7QUFJQUUsSUFBQUEsK0JBQUFBLDRCQUFBQSxTQWpDRixFQWlDRUE7QUFBQUEsTUFBQUE7Ozs7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QUlsQyxJQUFKa0MsYUFBQUEsYUFBQUEsU0FqTkEsRUFpTkFBO0FBQUFBLElBQUFBOzs7O0lBak5BOztJQUFBQSxPQUFBO0VBaU5BQSxDQUFBQSx5QkFBQUE7RUFJQXRDLE9BQUE4QyxDQUFBQSxVQUFJMUMsSUFBSjBDLGNBQUFBLGNBQUFBLFNBck5BLEVBcU5BQTtBQUFBQSxJQUFBQTs7OztJQXJOQTs7SUFBQUEsT0FBQTtFQXFOQUEsQ0FBQUEsMEJBQUFBLENBQUFBO0FBck5BOUM7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1ODgzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi9vcGFsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUgJ29wYWwvYmFzZSdcbnJlcXVpcmUgJ29wYWwvbWluaSdcblxucmVxdWlyZSAnY29yZWxpYi9rZXJuZWwvZm9ybWF0J1xucmVxdWlyZSAnY29yZWxpYi9zdHJpbmcvZW5jb2RpbmcnXG5yZXF1aXJlICdjb3JlbGliL21hdGgnXG5yZXF1aXJlICdjb3JlbGliL2NvbXBsZXgnXG5yZXF1aXJlICdjb3JlbGliL3JhdGlvbmFsJ1xucmVxdWlyZSAnY29yZWxpYi90aW1lJ1xucmVxdWlyZSAnY29yZWxpYi9zdHJ1Y3QnXG5yZXF1aXJlICdjb3JlbGliL2lvJ1xucmVxdWlyZSAnY29yZWxpYi9tYWluJ1xucmVxdWlyZSAnY29yZWxpYi9kaXInXG5yZXF1aXJlICdjb3JlbGliL2ZpbGUnXG5yZXF1aXJlICdjb3JlbGliL3Byb2Nlc3MnXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbS9mb3JtYXR0ZXInXG5yZXF1aXJlICdjb3JlbGliL3JhbmRvbSdcbnJlcXVpcmUgJ2NvcmVsaWIvcmFuZG9tL21lcnNlbm5lX3R3aXN0ZXInXG5cbnJlcXVpcmUgJ2NvcmVsaWIvdW5zdXBwb3J0ZWQnXG4iXSwibmFtZXMiOlsiPG1haW4+Iiwic2VsZiIsInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUFDLElBQUFDLFNBQUFBLENBQVFGLFdBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLFdBQVJFO0VBRUFELElBQUFDLFNBQUFBLENBQVFGLHVCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRix5QkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLGtCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixjQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsWUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsYUFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsY0FBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUJBQVJFO0VBQ0FELElBQUFDLFNBQUFBLENBQVFGLDBCQUFSRTtFQUNBRCxJQUFBQyxTQUFBQSxDQUFRRixnQkFBUkU7RUFDQUQsSUFBQUMsU0FBQUEsQ0FBUUYsaUNBQVJFO0VBRUFGLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLHFCQUFSRTtBQW5CQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI1OTA5LCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9jbGlfcnVubmVycy9zb3VyY2UtbWFwLXN1cHBvcnQtbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5zb3VyY2VNYXBTdXBwb3J0ID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbnZhciBpc01vZGVybiA9IChcbiAgdHlwZW9mIEJ1ZmZlci5hbGxvYyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgQnVmZmVyLmFsbG9jVW5zYWZlID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBCdWZmZXIuZnJvbSA9PT0gJ2Z1bmN0aW9uJ1xuKVxuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyIChpbnB1dCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpbnB1dCkuc2xpY2UoOCwgLTEpID09PSAnQXJyYXlCdWZmZXInXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAob2JqLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYnl0ZU9mZnNldCA+Pj49IDBcblxuICB2YXIgbWF4TGVuZ3RoID0gb2JqLmJ5dGVMZW5ndGggLSBieXRlT2Zmc2V0XG5cbiAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidvZmZzZXQnIGlzIG91dCBvZiBib3VuZHNcIilcbiAgfVxuXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IG1heExlbmd0aFxuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA+Pj49IDBcblxuICAgIGlmIChsZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2xlbmd0aCcgaXMgb3V0IG9mIGJvdW5kc1wiKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20ob2JqLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBsZW5ndGgpKVxuICAgIDogbmV3IEJ1ZmZlcihuZXcgVWludDhBcnJheShvYmouc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGxlbmd0aCkpKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHJldHVybiBpc01vZGVyblxuICAgID8gQnVmZmVyLmZyb20oc3RyaW5nLCBlbmNvZGluZylcbiAgICA6IG5ldyBCdWZmZXIoc3RyaW5nLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYnVmZmVyRnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGlzTW9kZXJuXG4gICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICA6IG5ldyBCdWZmZXIodmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVmZmVyRnJvbVxuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIGhhc05hdGl2ZU1hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCI7XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB3aGljaCBpcyBhIGNvbWJpbmF0aW9uIG9mIGFuIGFycmF5IGFuZCBhIHNldC4gQWRkaW5nIGEgbmV3XG4gKiBtZW1iZXIgaXMgTygxKSwgdGVzdGluZyBmb3IgbWVtYmVyc2hpcCBpcyBPKDEpLCBhbmQgZmluZGluZyB0aGUgaW5kZXggb2YgYW5cbiAqIGVsZW1lbnQgaXMgTygxKS4gUmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgc2V0IGlzIG5vdCBzdXBwb3J0ZWQuIE9ubHlcbiAqIHN0cmluZ3MgYXJlIHN1cHBvcnRlZCBmb3IgbWVtYmVyc2hpcC5cbiAqL1xuZnVuY3Rpb24gQXJyYXlTZXQoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NldCA9IGhhc05hdGl2ZU1hcCA/IG5ldyBNYXAoKSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbi8qKlxuICogU3RhdGljIG1ldGhvZCBmb3IgY3JlYXRpbmcgQXJyYXlTZXQgaW5zdGFuY2VzIGZyb20gYW4gZXhpc3RpbmcgYXJyYXkuXG4gKi9cbkFycmF5U2V0LmZyb21BcnJheSA9IGZ1bmN0aW9uIEFycmF5U2V0X2Zyb21BcnJheShhQXJyYXksIGFBbGxvd0R1cGxpY2F0ZXMpIHtcbiAgdmFyIHNldCA9IG5ldyBBcnJheVNldCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2V0LmFkZChhQXJyYXlbaV0sIGFBbGxvd0R1cGxpY2F0ZXMpO1xuICB9XG4gIHJldHVybiBzZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBob3cgbWFueSB1bmlxdWUgaXRlbXMgYXJlIGluIHRoaXMgQXJyYXlTZXQuIElmIGR1cGxpY2F0ZXMgaGF2ZSBiZWVuXG4gKiBhZGRlZCwgdGhhbiB0aG9zZSBkbyBub3QgY291bnQgdG93YXJkcyB0aGUgc2l6ZS5cbiAqXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBBcnJheVNldF9zaXplKCkge1xuICByZXR1cm4gaGFzTmF0aXZlTWFwID8gdGhpcy5fc2V0LnNpemUgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9zZXQpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBzdHJpbmcgdG8gdGhpcyBzZXQuXG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBBcnJheVNldF9hZGQoYVN0ciwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc1N0ciA9IGhhc05hdGl2ZU1hcCA/IGFTdHIgOiB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICB2YXIgaXNEdXBsaWNhdGUgPSBoYXNOYXRpdmVNYXAgPyB0aGlzLmhhcyhhU3RyKSA6IGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cik7XG4gIHZhciBpZHggPSB0aGlzLl9hcnJheS5sZW5ndGg7XG4gIGlmICghaXNEdXBsaWNhdGUgfHwgYUFsbG93RHVwbGljYXRlcykge1xuICAgIHRoaXMuX2FycmF5LnB1c2goYVN0cik7XG4gIH1cbiAgaWYgKCFpc0R1cGxpY2F0ZSkge1xuICAgIGlmIChoYXNOYXRpdmVNYXApIHtcbiAgICAgIHRoaXMuX3NldC5zZXQoYVN0ciwgaWR4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2V0W3NTdHJdID0gaWR4O1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJcyB0aGUgZ2l2ZW4gc3RyaW5nIGEgbWVtYmVyIG9mIHRoaXMgc2V0P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gQXJyYXlTZXRfaGFzKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHJldHVybiB0aGlzLl9zZXQuaGFzKGFTdHIpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICByZXR1cm4gaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBhcnJheT9cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBBcnJheVNldF9pbmRleE9mKGFTdHIpIHtcbiAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgIHZhciBpZHggPSB0aGlzLl9zZXQuZ2V0KGFTdHIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc1N0ciA9IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gICAgaWYgKGhhcy5jYWxsKHRoaXMuX3NldCwgc1N0cikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRbc1N0cl07XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhU3RyICsgJ1wiIGlzIG5vdCBpbiB0aGUgc2V0LicpO1xufTtcblxuLyoqXG4gKiBXaGF0IGlzIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleD9cbiAqXG4gKiBAcGFyYW0gTnVtYmVyIGFJZHhcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gQXJyYXlTZXRfYXQoYUlkeCkge1xuICBpZiAoYUlkeCA+PSAwICYmIGFJZHggPCB0aGlzLl9hcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyYXlbYUlkeF07XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBlbGVtZW50IGluZGV4ZWQgYnkgJyArIGFJZHgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNldCAod2hpY2ggaGFzIHRoZSBwcm9wZXIgaW5kaWNlc1xuICogaW5kaWNhdGVkIGJ5IGluZGV4T2YpLiBOb3RlIHRoYXQgdGhpcyBpcyBhIGNvcHkgb2YgdGhlIGludGVybmFsIGFycmF5IHVzZWRcbiAqIGZvciBzdG9yaW5nIHRoZSBtZW1iZXJzIHNvIHRoYXQgbm8gb25lIGNhbiBtZXNzIHdpdGggaW50ZXJuYWwgc3RhdGUuXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2FycmF5LnNsaWNlKCk7XG59O1xuXG5leHBvcnRzLkFycmF5U2V0ID0gQXJyYXlTZXQ7XG5cbn0se1wiLi91dGlsXCI6MTF9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKlxuICogQmFzZWQgb24gdGhlIEJhc2UgNjQgVkxRIGltcGxlbWVudGF0aW9uIGluIENsb3N1cmUgQ29tcGlsZXI6XG4gKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nsb3N1cmUtY29tcGlsZXIvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9kZWJ1Z2dpbmcvc291cmNlbWFwL0Jhc2U2NFZMUS5qYXZhXG4gKlxuICogQ29weXJpZ2h0IDIwMTEgVGhlIENsb3N1cmUgQ29tcGlsZXIgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZVxuICogbWV0OlxuICpcbiAqICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4gKiAgICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZ1xuICogICAgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkXG4gKiAgICB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIEdvb2dsZSBJbmMuIG5vciB0aGUgbmFtZXMgb2YgaXRzXG4gKiAgICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWRcbiAqICAgIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTXG4gKiBcIkFTIElTXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1JcbiAqIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUXG4gKiBPV05FUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCxcbiAqIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1RcbiAqIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLFxuICogREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZXG4gKiBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbi8vIEEgc2luZ2xlIGJhc2UgNjQgZGlnaXQgY2FuIGNvbnRhaW4gNiBiaXRzIG9mIGRhdGEuIEZvciB0aGUgYmFzZSA2NCB2YXJpYWJsZVxuLy8gbGVuZ3RoIHF1YW50aXRpZXMgd2UgdXNlIGluIHRoZSBzb3VyY2UgbWFwIHNwZWMsIHRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ24sXG4vLyB0aGUgbmV4dCBmb3VyIGJpdHMgYXJlIHRoZSBhY3R1YWwgdmFsdWUsIGFuZCB0aGUgNnRoIGJpdCBpcyB0aGVcbi8vIGNvbnRpbnVhdGlvbiBiaXQuIFRoZSBjb250aW51YXRpb24gYml0IHRlbGxzIHVzIHdoZXRoZXIgdGhlcmUgYXJlIG1vcmVcbi8vIGRpZ2l0cyBpbiB0aGlzIHZhbHVlIGZvbGxvd2luZyB0aGlzIGRpZ2l0LlxuLy9cbi8vICAgQ29udGludWF0aW9uXG4vLyAgIHwgICAgU2lnblxuLy8gICB8ICAgIHxcbi8vICAgViAgICBWXG4vLyAgIDEwMTAxMVxuXG52YXIgVkxRX0JBU0VfU0hJRlQgPSA1O1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9CQVNFID0gMSA8PCBWTFFfQkFTRV9TSElGVDtcblxuLy8gYmluYXJ5OiAwMTExMTFcbnZhciBWTFFfQkFTRV9NQVNLID0gVkxRX0JBU0UgLSAxO1xuXG4vLyBiaW5hcnk6IDEwMDAwMFxudmFyIFZMUV9DT05USU5VQVRJT05fQklUID0gVkxRX0JBU0U7XG5cbi8qKlxuICogQ29udmVydHMgZnJvbSBhIHR3by1jb21wbGVtZW50IHZhbHVlIHRvIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMSBiZWNvbWVzIDIgKDEwIGJpbmFyeSksIC0xIGJlY29tZXMgMyAoMTEgYmluYXJ5KVxuICogICAyIGJlY29tZXMgNCAoMTAwIGJpbmFyeSksIC0yIGJlY29tZXMgNSAoMTAxIGJpbmFyeSlcbiAqL1xuZnVuY3Rpb24gdG9WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHJldHVybiBhVmFsdWUgPCAwXG4gICAgPyAoKC1hVmFsdWUpIDw8IDEpICsgMVxuICAgIDogKGFWYWx1ZSA8PCAxKSArIDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgdG8gYSB0d28tY29tcGxlbWVudCB2YWx1ZSBmcm9tIGEgdmFsdWUgd2hlcmUgdGhlIHNpZ24gYml0IGlzXG4gKiBwbGFjZWQgaW4gdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdC4gIEZvciBleGFtcGxlLCBhcyBkZWNpbWFsczpcbiAqICAgMiAoMTAgYmluYXJ5KSBiZWNvbWVzIDEsIDMgKDExIGJpbmFyeSkgYmVjb21lcyAtMVxuICogICA0ICgxMDAgYmluYXJ5KSBiZWNvbWVzIDIsIDUgKDEwMSBiaW5hcnkpIGJlY29tZXMgLTJcbiAqL1xuZnVuY3Rpb24gZnJvbVZMUVNpZ25lZChhVmFsdWUpIHtcbiAgdmFyIGlzTmVnYXRpdmUgPSAoYVZhbHVlICYgMSkgPT09IDE7XG4gIHZhciBzaGlmdGVkID0gYVZhbHVlID4+IDE7XG4gIHJldHVybiBpc05lZ2F0aXZlXG4gICAgPyAtc2hpZnRlZFxuICAgIDogc2hpZnRlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlIDY0IFZMUSBlbmNvZGVkIHZhbHVlLlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGJhc2U2NFZMUV9lbmNvZGUoYVZhbHVlKSB7XG4gIHZhciBlbmNvZGVkID0gXCJcIjtcbiAgdmFyIGRpZ2l0O1xuXG4gIHZhciB2bHEgPSB0b1ZMUVNpZ25lZChhVmFsdWUpO1xuXG4gIGRvIHtcbiAgICBkaWdpdCA9IHZscSAmIFZMUV9CQVNFX01BU0s7XG4gICAgdmxxID4+Pj0gVkxRX0JBU0VfU0hJRlQ7XG4gICAgaWYgKHZscSA+IDApIHtcbiAgICAgIC8vIFRoZXJlIGFyZSBzdGlsbCBtb3JlIGRpZ2l0cyBpbiB0aGlzIHZhbHVlLCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZSB0aGVcbiAgICAgIC8vIGNvbnRpbnVhdGlvbiBiaXQgaXMgbWFya2VkLlxuICAgICAgZGlnaXQgfD0gVkxRX0NPTlRJTlVBVElPTl9CSVQ7XG4gICAgfVxuICAgIGVuY29kZWQgKz0gYmFzZTY0LmVuY29kZShkaWdpdCk7XG4gIH0gd2hpbGUgKHZscSA+IDApO1xuXG4gIHJldHVybiBlbmNvZGVkO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIHRoZSBuZXh0IGJhc2UgNjQgVkxRIHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZyBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGFuZCB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nIHZpYSB0aGUgb3V0IHBhcmFtZXRlci5cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZGVjb2RlKGFTdHIsIGFJbmRleCwgYU91dFBhcmFtKSB7XG4gIHZhciBzdHJMZW4gPSBhU3RyLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IDA7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBjb250aW51YXRpb24sIGRpZ2l0O1xuXG4gIGRvIHtcbiAgICBpZiAoYUluZGV4ID49IHN0ckxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbW9yZSBkaWdpdHMgaW4gYmFzZSA2NCBWTFEgdmFsdWUuXCIpO1xuICAgIH1cblxuICAgIGRpZ2l0ID0gYmFzZTY0LmRlY29kZShhU3RyLmNoYXJDb2RlQXQoYUluZGV4KyspKTtcbiAgICBpZiAoZGlnaXQgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBkaWdpdDogXCIgKyBhU3RyLmNoYXJBdChhSW5kZXggLSAxKSk7XG4gICAgfVxuXG4gICAgY29udGludWF0aW9uID0gISEoZGlnaXQgJiBWTFFfQ09OVElOVUFUSU9OX0JJVCk7XG4gICAgZGlnaXQgJj0gVkxRX0JBU0VfTUFTSztcbiAgICByZXN1bHQgPSByZXN1bHQgKyAoZGlnaXQgPDwgc2hpZnQpO1xuICAgIHNoaWZ0ICs9IFZMUV9CQVNFX1NISUZUO1xuICB9IHdoaWxlIChjb250aW51YXRpb24pO1xuXG4gIGFPdXRQYXJhbS52YWx1ZSA9IGZyb21WTFFTaWduZWQocmVzdWx0KTtcbiAgYU91dFBhcmFtLnJlc3QgPSBhSW5kZXg7XG59O1xuXG59LHtcIi4vYmFzZTY0XCI6NH1dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNCBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBtYXBwaW5nQiBpcyBhZnRlciBtYXBwaW5nQSB3aXRoIHJlc3BlY3QgdG8gZ2VuZXJhdGVkXG4gKiBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb25BZnRlcihtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgLy8gT3B0aW1pemVkIGZvciBtb3N0IGNvbW1vbiBjYXNlXG4gIHZhciBsaW5lQSA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmU7XG4gIHZhciBsaW5lQiA9IG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIHZhciBjb2x1bW5BID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uO1xuICB2YXIgY29sdW1uQiA9IG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgcmV0dXJuIGxpbmVCID4gbGluZUEgfHwgbGluZUIgPT0gbGluZUEgJiYgY29sdW1uQiA+PSBjb2x1bW5BIHx8XG4gICAgICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikgPD0gMDtcbn1cblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHRvIHByb3ZpZGUgYSBzb3J0ZWQgdmlldyBvZiBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiBhXG4gKiBwZXJmb3JtYW5jZSBjb25zY2lvdXMgbWFubmVyLiBJdCB0cmFkZXMgYSBuZWdsaWJhYmxlIG92ZXJoZWFkIGluIGdlbmVyYWxcbiAqIGNhc2UgZm9yIGEgbGFyZ2Ugc3BlZWR1cCBpbiBjYXNlIG9mIG1hcHBpbmdzIGJlaW5nIGFkZGVkIGluIG9yZGVyLlxuICovXG5mdW5jdGlvbiBNYXBwaW5nTGlzdCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgLy8gU2VydmVzIGFzIGluZmltdW1cbiAgdGhpcy5fbGFzdCA9IHtnZW5lcmF0ZWRMaW5lOiAtMSwgZ2VuZXJhdGVkQ29sdW1uOiAwfTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIHRocm91Z2ggaW50ZXJuYWwgaXRlbXMuIFRoaXMgbWV0aG9kIHRha2VzIHRoZSBzYW1lIGFyZ3VtZW50cyB0aGF0XG4gKiBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIHRha2VzLlxuICpcbiAqIE5PVEU6IFRoZSBvcmRlciBvZiB0aGUgbWFwcGluZ3MgaXMgTk9UIGd1YXJhbnRlZWQuXG4gKi9cbk1hcHBpbmdMaXN0LnByb3RvdHlwZS51bnNvcnRlZEZvckVhY2ggPVxuICBmdW5jdGlvbiBNYXBwaW5nTGlzdF9mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpIHtcbiAgICB0aGlzLl9hcnJheS5mb3JFYWNoKGFDYWxsYmFjaywgYVRoaXNBcmcpO1xuICB9O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gc291cmNlIG1hcHBpbmcuXG4gKlxuICogQHBhcmFtIE9iamVjdCBhTWFwcGluZ1xuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gTWFwcGluZ0xpc3RfYWRkKGFNYXBwaW5nKSB7XG4gIGlmIChnZW5lcmF0ZWRQb3NpdGlvbkFmdGVyKHRoaXMuX2xhc3QsIGFNYXBwaW5nKSkge1xuICAgIHRoaXMuX2xhc3QgPSBhTWFwcGluZztcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hcnJheS5wdXNoKGFNYXBwaW5nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmbGF0LCBzb3J0ZWQgYXJyYXkgb2YgbWFwcGluZ3MuIFRoZSBtYXBwaW5ncyBhcmUgc29ydGVkIGJ5XG4gKiBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKlxuICogV0FSTklORzogVGhpcyBtZXRob2QgcmV0dXJucyBpbnRlcm5hbCBkYXRhIHdpdGhvdXQgY29weWluZywgZm9yXG4gKiBwZXJmb3JtYW5jZS4gVGhlIHJldHVybiB2YWx1ZSBtdXN0IE5PVCBiZSBtdXRhdGVkLCBhbmQgc2hvdWxkIGJlIHRyZWF0ZWQgYXNcbiAqIGFuIGltbXV0YWJsZSBib3Jyb3cuIElmIHlvdSB3YW50IHRvIHRha2Ugb3duZXJzaGlwLCB5b3UgbXVzdCBtYWtlIHlvdXIgb3duXG4gKiBjb3B5LlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X3RvQXJyYXkoKSB7XG4gIGlmICghdGhpcy5fc29ydGVkKSB7XG4gICAgdGhpcy5fYXJyYXkuc29ydCh1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKTtcbiAgICB0aGlzLl9zb3J0ZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheTtcbn07XG5cbmV4cG9ydHMuTWFwcGluZ0xpc3QgPSBNYXBwaW5nTGlzdDtcblxufSx7XCIuL3V0aWxcIjoxMX1dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vLyBJdCB0dXJucyBvdXQgdGhhdCBzb21lIChtb3N0PykgSmF2YVNjcmlwdCBlbmdpbmVzIGRvbid0IHNlbGYtaG9zdFxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YC4gVGhpcyBtYWtlcyBzZW5zZSBiZWNhdXNlIEMrKyB3aWxsIGxpa2VseSByZW1haW5cbi8vIGZhc3RlciB0aGFuIEpTIHdoZW4gZG9pbmcgcmF3IENQVS1pbnRlbnNpdmUgc29ydGluZy4gSG93ZXZlciwgd2hlbiB1c2luZyBhXG4vLyBjdXN0b20gY29tcGFyYXRvciBmdW5jdGlvbiwgY2FsbGluZyBiYWNrIGFuZCBmb3J0aCBiZXR3ZWVuIHRoZSBWTSdzIEMrKyBhbmRcbi8vIEpJVCdkIEpTIGlzIHJhdGhlciBzbG93ICphbmQqIGxvc2VzIEpJVCB0eXBlIGluZm9ybWF0aW9uLCByZXN1bHRpbmcgaW5cbi8vIHdvcnNlIGdlbmVyYXRlZCBjb2RlIGZvciB0aGUgY29tcGFyYXRvciBmdW5jdGlvbiB0aGFuIHdvdWxkIGJlIG9wdGltYWwuIEluXG4vLyBmYWN0LCB3aGVuIHNvcnRpbmcgd2l0aCBhIGNvbXBhcmF0b3IsIHRoZXNlIGNvc3RzIG91dHdlaWdoIHRoZSBiZW5lZml0cyBvZlxuLy8gc29ydGluZyBpbiBDKysuIEJ5IHVzaW5nIG91ciBvd24gSlMtaW1wbGVtZW50ZWQgUXVpY2sgU29ydCAoYmVsb3cpLCB3ZSBnZXRcbi8vIGEgfjM1MDBtcyBtZWFuIHNwZWVkLXVwIGluIGBiZW5jaC9iZW5jaC5odG1sYC5cblxuLyoqXG4gKiBTd2FwIHRoZSBlbGVtZW50cyBpbmRleGVkIGJ5IGB4YCBhbmQgYHlgIGluIHRoZSBhcnJheSBgYXJ5YC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBUaGUgYXJyYXkuXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogICAgICAgIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBzZWNvbmQgaXRlbS5cbiAqL1xuZnVuY3Rpb24gc3dhcChhcnksIHgsIHkpIHtcbiAgdmFyIHRlbXAgPSBhcnlbeF07XG4gIGFyeVt4XSA9IGFyeVt5XTtcbiAgYXJ5W3ldID0gdGVtcDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGludGVnZXIgd2l0aGluIHRoZSByYW5nZSBgbG93IC4uIGhpZ2hgIGluY2x1c2l2ZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbG93XG4gKiAgICAgICAgVGhlIGxvd2VyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBoaWdoXG4gKiAgICAgICAgVGhlIHVwcGVyIGJvdW5kIG9uIHRoZSByYW5nZS5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tSW50SW5SYW5nZShsb3csIGhpZ2gpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQobG93ICsgKE1hdGgucmFuZG9tKCkgKiAoaGlnaCAtIGxvdykpKTtcbn1cblxuLyoqXG4gKiBUaGUgUXVpY2sgU29ydCBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJ5XG4gKiAgICAgICAgQW4gYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNvbXBhcmF0b3JcbiAqICAgICAgICBGdW5jdGlvbiB0byB1c2UgdG8gY29tcGFyZSB0d28gaXRlbXMuXG4gKiBAcGFyYW0ge051bWJlcn0gcFxuICogICAgICAgIFN0YXJ0IGluZGV4IG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IHJcbiAqICAgICAgICBFbmQgaW5kZXggb2YgdGhlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcikge1xuICAvLyBJZiBvdXIgbG93ZXIgYm91bmQgaXMgbGVzcyB0aGFuIG91ciB1cHBlciBib3VuZCwgd2UgKDEpIHBhcnRpdGlvbiB0aGVcbiAgLy8gYXJyYXkgaW50byB0d28gcGllY2VzIGFuZCAoMikgcmVjdXJzZSBvbiBlYWNoIGhhbGYuIElmIGl0IGlzIG5vdCwgdGhpcyBpc1xuICAvLyB0aGUgZW1wdHkgYXJyYXkgYW5kIG91ciBiYXNlIGNhc2UuXG5cbiAgaWYgKHAgPCByKSB7XG4gICAgLy8gKDEpIFBhcnRpdGlvbmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSBwYXJ0aXRpb25pbmcgY2hvb3NlcyBhIHBpdm90IGJldHdlZW4gYHBgIGFuZCBgcmAgYW5kIG1vdmVzIGFsbFxuICAgIC8vIGVsZW1lbnRzIHRoYXQgYXJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QgdG8gdGhlIGJlZm9yZSBpdCwgYW5kXG4gICAgLy8gYWxsIHRoZSBlbGVtZW50cyB0aGF0IGFyZSBncmVhdGVyIHRoYW4gaXQgYWZ0ZXIgaXQuIFRoZSBlZmZlY3QgaXMgdGhhdFxuICAgIC8vIG9uY2UgcGFydGl0aW9uIGlzIGRvbmUsIHRoZSBwaXZvdCBpcyBpbiB0aGUgZXhhY3QgcGxhY2UgaXQgd2lsbCBiZSB3aGVuXG4gICAgLy8gdGhlIGFycmF5IGlzIHB1dCBpbiBzb3J0ZWQgb3JkZXIsIGFuZCBpdCB3aWxsIG5vdCBuZWVkIHRvIGJlIG1vdmVkXG4gICAgLy8gYWdhaW4uIFRoaXMgcnVucyBpbiBPKG4pIHRpbWUuXG5cbiAgICAvLyBBbHdheXMgY2hvb3NlIGEgcmFuZG9tIHBpdm90IHNvIHRoYXQgYW4gaW5wdXQgYXJyYXkgd2hpY2ggaXMgcmV2ZXJzZVxuICAgIC8vIHNvcnRlZCBkb2VzIG5vdCBjYXVzZSBPKG5eMikgcnVubmluZyB0aW1lLlxuICAgIHZhciBwaXZvdEluZGV4ID0gcmFuZG9tSW50SW5SYW5nZShwLCByKTtcbiAgICB2YXIgaSA9IHAgLSAxO1xuXG4gICAgc3dhcChhcnksIHBpdm90SW5kZXgsIHIpO1xuICAgIHZhciBwaXZvdCA9IGFyeVtyXTtcblxuICAgIC8vIEltbWVkaWF0ZWx5IGFmdGVyIGBqYCBpcyBpbmNyZW1lbnRlZCBpbiB0aGlzIGxvb3AsIHRoZSBmb2xsb3dpbmcgaG9sZFxuICAgIC8vIHRydWU6XG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W3AgLi4gaV1gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcGl2b3QuXG4gICAgLy9cbiAgICAvLyAgICogRXZlcnkgZWxlbWVudCBpbiBgYXJ5W2krMSAuLiBqLTFdYCBpcyBncmVhdGVyIHRoYW4gdGhlIHBpdm90LlxuICAgIGZvciAodmFyIGogPSBwOyBqIDwgcjsgaisrKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcihhcnlbal0sIHBpdm90KSA8PSAwKSB7XG4gICAgICAgIGkgKz0gMTtcbiAgICAgICAgc3dhcChhcnksIGksIGopO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3YXAoYXJ5LCBpICsgMSwgaik7XG4gICAgdmFyIHEgPSBpICsgMTtcblxuICAgIC8vICgyKSBSZWN1cnNlIG9uIGVhY2ggaGFsZi5cblxuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcCwgcSAtIDEpO1xuICAgIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgcSArIDEsIHIpO1xuICB9XG59XG5cbi8qKlxuICogU29ydCB0aGUgZ2l2ZW4gYXJyYXkgaW4tcGxhY2Ugd2l0aCB0aGUgZ2l2ZW4gY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqL1xuZXhwb3J0cy5xdWlja1NvcnQgPSBmdW5jdGlvbiAoYXJ5LCBjb21wYXJhdG9yKSB7XG4gIGRvUXVpY2tTb3J0KGFyeSwgY29tcGFyYXRvciwgMCwgYXJ5Lmxlbmd0aCAtIDEpO1xufTtcblxufSx7fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluYXJ5U2VhcmNoID0gcmVxdWlyZSgnLi9iaW5hcnktc2VhcmNoJyk7XG52YXIgQXJyYXlTZXQgPSByZXF1aXJlKCcuL2FycmF5LXNldCcpLkFycmF5U2V0O1xudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHF1aWNrU29ydCA9IHJlcXVpcmUoJy4vcXVpY2stc29ydCcpLnF1aWNrU29ydDtcblxuZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2VNYXAuc2VjdGlvbnMgIT0gbnVsbFxuICAgID8gbmV3IEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpXG4gICAgOiBuZXcgQmFzaWNTb3VyY2VNYXBDb25zdW1lcihzb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG5Tb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwID0gZnVuY3Rpb24oYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICByZXR1cm4gQmFzaWNTb3VyY2VNYXBDb25zdW1lci5mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpO1xufVxuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLy8gYF9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZCBgX19vcmlnaW5hbE1hcHBpbmdzYCBhcmUgYXJyYXlzIHRoYXQgaG9sZCB0aGVcbi8vIHBhcnNlZCBtYXBwaW5nIGNvb3JkaW5hdGVzIGZyb20gdGhlIHNvdXJjZSBtYXAncyBcIm1hcHBpbmdzXCIgYXR0cmlidXRlLiBUaGV5XG4vLyBhcmUgbGF6aWx5IGluc3RhbnRpYXRlZCwgYWNjZXNzZWQgdmlhIHRoZSBgX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgZ2V0dGVycyByZXNwZWN0aXZlbHksIGFuZCB3ZSBvbmx5IHBhcnNlIHRoZSBtYXBwaW5nc1xuLy8gYW5kIGNyZWF0ZSB0aGVzZSBhcnJheXMgb25jZSBxdWVyaWVkIGZvciBhIHNvdXJjZSBsb2NhdGlvbi4gV2UganVtcCB0aHJvdWdoXG4vLyB0aGVzZSBob29wcyBiZWNhdXNlIHRoZXJlIGNhbiBiZSBtYW55IHRob3VzYW5kcyBvZiBtYXBwaW5ncywgYW5kIHBhcnNpbmdcbi8vIHRoZW0gaXMgZXhwZW5zaXZlLCBzbyB3ZSBvbmx5IHdhbnQgdG8gZG8gaXQgaWYgd2UgbXVzdC5cbi8vXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlzIGlzIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICB7XG4vLyAgICAgICBnZW5lcmF0ZWRMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBzb3VyY2U6IFRoZSBwYXRoIHRvIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSB0aGF0IGdlbmVyYXRlZCB0aGlzXG4vLyAgICAgICAgICAgICAgIGNodW5rIG9mIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbExpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG9yaWdpbmFsQ29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlIHRoYXRcbi8vICAgICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kcyB0byB0aGlzIGNodW5rIG9mIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgbmFtZTogVGhlIG5hbWUgb2YgdGhlIG9yaWdpbmFsIHN5bWJvbCB3aGljaCBnZW5lcmF0ZWQgdGhpcyBjaHVuayBvZlxuLy8gICAgICAgICAgICAgY29kZS5cbi8vICAgICB9XG4vL1xuLy8gQWxsIHByb3BlcnRpZXMgZXhjZXB0IGZvciBgZ2VuZXJhdGVkTGluZWAgYW5kIGBnZW5lcmF0ZWRDb2x1bW5gIGNhbiBiZVxuLy8gYG51bGxgLlxuLy9cbi8vIGBfZ2VuZXJhdGVkTWFwcGluZ3NgIGlzIG9yZGVyZWQgYnkgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMuXG4vL1xuLy8gYF9vcmlnaW5hbE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMuXG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX2dlbmVyYXRlZE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfZ2VuZXJhdGVkTWFwcGluZ3MnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fX29yaWdpbmFsTWFwcGluZ3MgPSBudWxsO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ19vcmlnaW5hbE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MpIHtcbiAgICAgIHRoaXMuX3BhcnNlTWFwcGluZ3ModGhpcy5fbWFwcGluZ3MsIHRoaXMuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzO1xuICB9XG59KTtcblxuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY2hhcklzTWFwcGluZ1NlcGFyYXRvcihhU3RyLCBpbmRleCkge1xuICAgIHZhciBjID0gYVN0ci5jaGFyQXQoaW5kZXgpO1xuICAgIHJldHVybiBjID09PSBcIjtcIiB8fCBjID09PSBcIixcIjtcbiAgfTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgbWFwcGluZ3MgaW4gYSBzdHJpbmcgaW4gdG8gYSBkYXRhIHN0cnVjdHVyZSB3aGljaCB3ZSBjYW4gZWFzaWx5XG4gKiBxdWVyeSAodGhlIG9yZGVyZWQgYXJyYXlzIGluIHRoZSBgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmRcbiAqIGB0aGlzLl9fb3JpZ2luYWxNYXBwaW5nc2AgcHJvcGVydGllcykuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50IF9wYXJzZU1hcHBpbmdzXCIpO1xuICB9O1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVIgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVIgPSAyO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5Tb3VyY2VNYXBDb25zdW1lci5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGVhY2ggbWFwcGluZyBiZXR3ZWVuIGFuIG9yaWdpbmFsIHNvdXJjZS9saW5lL2NvbHVtbiBhbmQgYVxuICogZ2VuZXJhdGVkIGxpbmUvY29sdW1uIGluIHRoaXMgc291cmNlIG1hcC5cbiAqXG4gKiBAcGFyYW0gRnVuY3Rpb24gYUNhbGxiYWNrXG4gKiAgICAgICAgVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggZWFjaCBtYXBwaW5nLlxuICogQHBhcmFtIE9iamVjdCBhQ29udGV4dFxuICogICAgICAgIE9wdGlvbmFsLiBJZiBzcGVjaWZpZWQsIHRoaXMgb2JqZWN0IHdpbGwgYmUgdGhlIHZhbHVlIG9mIGB0aGlzYCBldmVyeVxuICogICAgICAgIHRpbWUgdGhhdCBgYUNhbGxiYWNrYCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0gYU9yZGVyXG4gKiAgICAgICAgRWl0aGVyIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgIG9yXG4gKiAgICAgICAgYFNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSYC4gU3BlY2lmaWVzIHdoZXRoZXIgeW91IHdhbnQgdG9cbiAqICAgICAgICBpdGVyYXRlIG92ZXIgdGhlIG1hcHBpbmdzIHNvcnRlZCBieSB0aGUgZ2VuZXJhdGVkIGZpbGUncyBsaW5lL2NvbHVtblxuICogICAgICAgIG9yZGVyIG9yIHRoZSBvcmlnaW5hbCdzIHNvdXJjZS9saW5lL2NvbHVtbiBvcmRlciwgcmVzcGVjdGl2ZWx5LiBEZWZhdWx0cyB0b1xuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVJgLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuZWFjaE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9lYWNoTWFwcGluZyhhQ2FsbGJhY2ssIGFDb250ZXh0LCBhT3JkZXIpIHtcbiAgICB2YXIgY29udGV4dCA9IGFDb250ZXh0IHx8IG51bGw7XG4gICAgdmFyIG9yZGVyID0gYU9yZGVyIHx8IFNvdXJjZU1hcENvbnN1bWVyLkdFTkVSQVRFRF9PUkRFUjtcblxuICAgIHZhciBtYXBwaW5ncztcbiAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUjpcbiAgICAgIG1hcHBpbmdzID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9yZGVyIG9mIGl0ZXJhdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVJvb3QgPSB0aGlzLnNvdXJjZVJvb3Q7XG4gICAgbWFwcGluZ3MubWFwKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICB2YXIgc291cmNlID0gbWFwcGluZy5zb3VyY2UgPT09IG51bGwgPyBudWxsIDogdGhpcy5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgc291cmNlLCB0aGlzLl9zb3VyY2VNYXBVUkwpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbixcbiAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgb3JpZ2luYWxDb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgIG5hbWU6IG1hcHBpbmcubmFtZSA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpXG4gICAgICB9O1xuICAgIH0sIHRoaXMpLmZvckVhY2goYUNhbGxiYWNrLCBjb250ZXh0KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgb3JpZ2luYWwgc291cmNlLFxuICogbGluZSwgYW5kIGNvbHVtbiBwcm92aWRlZC4gSWYgbm8gY29sdW1uIGlzIHByb3ZpZGVkLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byBhIGVpdGhlciB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvciBvciB0aGUgbmV4dFxuICogY2xvc2VzdCBsaW5lIHRoYXQgaGFzIGFueSBtYXBwaW5ncy4gT3RoZXJ3aXNlLCByZXR1cm5zIGFsbCBtYXBwaW5nc1xuICogY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGluZSBhbmQgZWl0aGVyIHRoZSBjb2x1bW4gd2UgYXJlIHNlYXJjaGluZyBmb3JcbiAqIG9yIHRoZSBuZXh0IGNsb3Nlc3QgY29sdW1uIHRoYXQgaGFzIGFueSBvZmZzZXRzLlxuICpcbiAqIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogT3B0aW9uYWwuIHRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBhcnJheSBvZiBvYmplY3RzIGlzIHJldHVybmVkLCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IoYUFyZ3MpIHtcbiAgICB2YXIgbGluZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBubyBleGFjdCBtYXRjaCwgQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRNYXBwaW5nXG4gICAgLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3Nlc3QgbWFwcGluZyBsZXNzIHRoYW4gdGhlIG5lZWRsZS4gQnlcbiAgICAvLyBzZXR0aW5nIG5lZWRsZS5vcmlnaW5hbENvbHVtbiB0byAwLCB3ZSB0aHVzIGZpbmQgdGhlIGxhc3QgbWFwcGluZyBmb3JcbiAgICAvLyB0aGUgZ2l2ZW4gbGluZSwgcHJvdmlkZWQgc3VjaCBhIG1hcHBpbmcgZXhpc3RzLlxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyksXG4gICAgICBvcmlnaW5hbExpbmU6IGxpbmUsXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nLCAwKVxuICAgIH07XG5cbiAgICBuZWVkbGUuc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KG5lZWRsZS5zb3VyY2UpO1xuICAgIGlmIChuZWVkbGUuc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcobmVlZGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9yaWdpbmFsQ29sdW1uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAoYUFyZ3MuY29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2UgZm91bmQuIFNpbmNlXG4gICAgICAgIC8vIG1hcHBpbmdzIGFyZSBzb3J0ZWQsIHRoaXMgaXMgZ3VhcmFudGVlZCB0byBmaW5kIGFsbCBtYXBwaW5ncyBmb3JcbiAgICAgICAgLy8gdGhlIGxpbmUgd2UgZm91bmQuXG4gICAgICAgIHdoaWxlIChtYXBwaW5nICYmIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBvcmlnaW5hbExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3JpZ2luYWxDb2x1bW4gPSBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgdW50aWwgZWl0aGVyIHdlIHJ1biBvdXQgb2YgbWFwcGluZ3MsIG9yIHdlIHJ1biBpbnRvXG4gICAgICAgIC8vIGEgbWFwcGluZyBmb3IgYSBkaWZmZXJlbnQgbGluZSB0aGFuIHRoZSBvbmUgd2Ugd2VyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICAvLyBTaW5jZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJlxuICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09IGxpbmUgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPT0gb3JpZ2luYWxDb2x1bW4pIHtcbiAgICAgICAgICBtYXBwaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICAgIGxhc3RDb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdsYXN0R2VuZXJhdGVkQ29sdW1uJywgbnVsbClcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzWysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBpbmdzO1xuICB9O1xuXG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaCB3ZSBjYW5cbiAqIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3JpZ2luYWwgZmlsZSBwb3NpdGlvbnMgYnkgZ2l2aW5nIGl0IGEgZmlsZVxuICogcG9zaXRpb24gaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvclxuICogYWxyZWFkeSBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjLCBzb3VyY2UgbWFwcyBoYXZlIHRoZVxuICogZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gc291cmNlczogQW4gYXJyYXkgb2YgVVJMcyB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGVzLlxuICogICAtIG5hbWVzOiBBbiBhcnJheSBvZiBpZGVudGlmaWVycyB3aGljaCBjYW4gYmUgcmVmZXJyZW5jZWQgYnkgaW5kaXZpZHVhbCBtYXBwaW5ncy5cbiAqICAgLSBzb3VyY2VSb290OiBPcHRpb25hbC4gVGhlIFVSTCByb290IGZyb20gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIHJlbGF0aXZlLlxuICogICAtIHNvdXJjZXNDb250ZW50OiBPcHRpb25hbC4gQW4gYXJyYXkgb2YgY29udGVudHMgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBtYXBwaW5nczogQSBzdHJpbmcgb2YgYmFzZTY0IFZMUXMgd2hpY2ggY29udGFpbiB0aGUgYWN0dWFsIG1hcHBpbmdzLlxuICogICAtIGZpbGU6IE9wdGlvbmFsLiBUaGUgZ2VuZXJhdGVkIGZpbGUgdGhpcyBzb3VyY2UgbWFwIGlzIGFzc29jaWF0ZWQgd2l0aC5cbiAqXG4gKiBIZXJlIGlzIGFuIGV4YW1wbGUgc291cmNlIG1hcCwgdGFrZW4gZnJvbSB0aGUgc291cmNlIG1hcCBzcGVjWzBdOlxuICpcbiAqICAgICB7XG4gKiAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgIGZpbGU6IFwib3V0LmpzXCIsXG4gKiAgICAgICBzb3VyY2VSb290IDogXCJcIixcbiAqICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgIG5hbWVzOiBbXCJzcmNcIiwgXCJtYXBzXCIsIFwiYXJlXCIsIFwiZnVuXCJdLFxuICogICAgICAgbWFwcGluZ3M6IFwiQUEsQUI7O0FCQ0RFO1wiXG4gKiAgICAgfVxuICpcbiAqIFRoZSBzZWNvbmQgcGFyYW1ldGVyLCBpZiBnaXZlbiwgaXMgYSBzdHJpbmcgd2hvc2UgdmFsdWUgaXMgdGhlIFVSTFxuICogYXQgd2hpY2ggdGhlIHNvdXJjZSBtYXAgd2FzIGZvdW5kLiAgVGhpcyBVUkwgaXMgdXNlZCB0byBjb21wdXRlIHRoZVxuICogc291cmNlcyBhcnJheS5cbiAqXG4gKiBbMF06IGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMVUxUkdBZWhRd1J5cFVUb3ZGMUtSbHBpT0Z6ZTBiLV8yZ2M2ZkFIMEtZMGsvZWRpdD9wbGk9MSNcbiAqL1xuZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcihhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKSB7XG4gIHZhciBzb3VyY2VNYXAgPSBhU291cmNlTWFwO1xuICBpZiAodHlwZW9mIGFTb3VyY2VNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlTWFwID0gdXRpbC5wYXJzZVNvdXJjZU1hcElucHV0KGFTb3VyY2VNYXApO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICd2ZXJzaW9uJyk7XG4gIHZhciBzb3VyY2VzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlcycpO1xuICAvLyBTYXNzIDMuMyBsZWF2ZXMgb3V0IHRoZSAnbmFtZXMnIGFycmF5LCBzbyB3ZSBkZXZpYXRlIGZyb20gdGhlIHNwZWMgKHdoaWNoXG4gIC8vIHJlcXVpcmVzIHRoZSBhcnJheSkgdG8gcGxheSBuaWNlIGhlcmUuXG4gIHZhciBuYW1lcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ25hbWVzJywgW10pO1xuICB2YXIgc291cmNlUm9vdCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdmFyIHNvdXJjZXNDb250ZW50ID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc291cmNlc0NvbnRlbnQnLCBudWxsKTtcbiAgdmFyIG1hcHBpbmdzID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnbWFwcGluZ3MnKTtcbiAgdmFyIGZpbGUgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdmaWxlJywgbnVsbCk7XG5cbiAgLy8gT25jZSBhZ2FpbiwgU2FzcyBkZXZpYXRlcyBmcm9tIHRoZSBzcGVjIGFuZCBzdXBwbGllcyB0aGUgdmVyc2lvbiBhcyBhXG4gIC8vIHN0cmluZyByYXRoZXIgdGhhbiBhIG51bWJlciwgc28gd2UgdXNlIGxvb3NlIGVxdWFsaXR5IGNoZWNraW5nIGhlcmUuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VSb290KSB7XG4gICAgc291cmNlUm9vdCA9IHV0aWwubm9ybWFsaXplKHNvdXJjZVJvb3QpO1xuICB9XG5cbiAgc291cmNlcyA9IHNvdXJjZXNcbiAgICAubWFwKFN0cmluZylcbiAgICAvLyBTb21lIHNvdXJjZSBtYXBzIHByb2R1Y2UgcmVsYXRpdmUgc291cmNlIHBhdGhzIGxpa2UgXCIuL2Zvby5qc1wiIGluc3RlYWQgb2ZcbiAgICAvLyBcImZvby5qc1wiLiAgTm9ybWFsaXplIHRoZXNlIGZpcnN0IHNvIHRoYXQgZnV0dXJlIGNvbXBhcmlzb25zIHdpbGwgc3VjY2VlZC5cbiAgICAvLyBTZWUgYnVnemlsLmxhLzEwOTA3NjguXG4gICAgLm1hcCh1dGlsLm5vcm1hbGl6ZSlcbiAgICAvLyBBbHdheXMgZW5zdXJlIHRoYXQgYWJzb2x1dGUgc291cmNlcyBhcmUgaW50ZXJuYWxseSBzdG9yZWQgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgc291cmNlIHJvb3QsIGlmIHRoZSBzb3VyY2Ugcm9vdCBpcyBhYnNvbHV0ZS4gTm90IGRvaW5nIHRoaXMgd291bGRcbiAgICAvLyBiZSBwYXJ0aWN1bGFybHkgcHJvYmxlbWF0aWMgd2hlbiB0aGUgc291cmNlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlXG4gICAgLy8gc291cmNlICh2YWxpZCwgYnV0IHdoeT8/KS4gU2VlIGdpdGh1YiBpc3N1ZSAjMTk5IGFuZCBidWd6aWwubGEvMTE4ODk4Mi5cbiAgICAubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2VSb290ICYmIHV0aWwuaXNBYnNvbHV0ZShzb3VyY2VSb290KSAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlKVxuICAgICAgICA/IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlKVxuICAgICAgICA6IHNvdXJjZTtcbiAgICB9KTtcblxuICAvLyBQYXNzIGB0cnVlYCBiZWxvdyB0byBhbGxvdyBkdXBsaWNhdGUgbmFtZXMgYW5kIHNvdXJjZXMuIFdoaWxlIHNvdXJjZSBtYXBzXG4gIC8vIGFyZSBpbnRlbmRlZCB0byBiZSBjb21wcmVzc2VkIGFuZCBkZWR1cGxpY2F0ZWQsIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4gIC8vIHNvbWV0aW1lcyBnZW5lcmF0ZXMgc291cmNlIG1hcHMgd2l0aCBkdXBsaWNhdGVzIGluIHRoZW0uIFNlZSBHaXRodWIgaXNzdWVcbiAgLy8gIzcyIGFuZCBidWd6aWwubGEvODg5NDkyLlxuICB0aGlzLl9uYW1lcyA9IEFycmF5U2V0LmZyb21BcnJheShuYW1lcy5tYXAoU3RyaW5nKSwgdHJ1ZSk7XG4gIHRoaXMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoc291cmNlcywgdHJ1ZSk7XG5cbiAgdGhpcy5fYWJzb2x1dGVTb3VyY2VzID0gdGhpcy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgfSk7XG5cbiAgdGhpcy5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgdGhpcy5zb3VyY2VzQ29udGVudCA9IHNvdXJjZXNDb250ZW50O1xuICB0aGlzLl9tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICB0aGlzLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICB0aGlzLmZpbGUgPSBmaWxlO1xufVxuXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN1bWVyID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB0byBmaW5kIHRoZSBpbmRleCBvZiBhIHNvdXJjZS4gIFJldHVybnMgLTEgaWYgbm90XG4gKiBmb3VuZC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX2ZpbmRTb3VyY2VJbmRleCA9IGZ1bmN0aW9uKGFTb3VyY2UpIHtcbiAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgcmVsYXRpdmVTb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuc291cmNlUm9vdCwgcmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NvdXJjZXMuaGFzKHJlbGF0aXZlU291cmNlKSkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2VzLmluZGV4T2YocmVsYXRpdmVTb3VyY2UpO1xuICB9XG5cbiAgLy8gTWF5YmUgYVNvdXJjZSBpcyBhbiBhYnNvbHV0ZSBVUkwgYXMgcmV0dXJuZWQgYnkgfHNvdXJjZXN8LiAgSW5cbiAgLy8gdGhpcyBjYXNlIHdlIGNhbid0IHNpbXBseSB1bmRvIHRoZSB0cmFuc2Zvcm0uXG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fYWJzb2x1dGVTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHRoaXMuX2Fic29sdXRlU291cmNlc1tpXSA9PSBhU291cmNlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgZnJvbSBhIFNvdXJjZU1hcEdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gU291cmNlTWFwR2VuZXJhdG9yIGFTb3VyY2VNYXBcbiAqICAgICAgICBUaGUgc291cmNlIG1hcCB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG4gKiBAcGFyYW0gU3RyaW5nIGFTb3VyY2VNYXBVUkxcbiAqICAgICAgICBUaGUgVVJMIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIGNhbiBiZSBmb3VuZCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBCYXNpY1NvdXJjZU1hcENvbnN1bWVyXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBzbWMgPSBPYmplY3QuY3JlYXRlKEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlKTtcblxuICAgIHZhciBuYW1lcyA9IHNtYy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fbmFtZXMudG9BcnJheSgpLCB0cnVlKTtcbiAgICB2YXIgc291cmNlcyA9IHNtYy5fc291cmNlcyA9IEFycmF5U2V0LmZyb21BcnJheShhU291cmNlTWFwLl9zb3VyY2VzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgc21jLnNvdXJjZVJvb3QgPSBhU291cmNlTWFwLl9zb3VyY2VSb290O1xuICAgIHNtYy5zb3VyY2VzQ29udGVudCA9IGFTb3VyY2VNYXAuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQoc21jLl9zb3VyY2VzLnRvQXJyYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNtYy5zb3VyY2VSb290KTtcbiAgICBzbWMuZmlsZSA9IGFTb3VyY2VNYXAuX2ZpbGU7XG4gICAgc21jLl9zb3VyY2VNYXBVUkwgPSBhU291cmNlTWFwVVJMO1xuICAgIHNtYy5fYWJzb2x1dGVTb3VyY2VzID0gc21jLl9zb3VyY2VzLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc21jLnNvdXJjZVJvb3QsIHMsIGFTb3VyY2VNYXBVUkwpO1xuICAgIH0pO1xuXG4gICAgLy8gQmVjYXVzZSB3ZSBhcmUgbW9kaWZ5aW5nIHRoZSBlbnRyaWVzIChieSBjb252ZXJ0aW5nIHN0cmluZyBzb3VyY2VzIGFuZFxuICAgIC8vIG5hbWVzIHRvIGluZGljZXMgaW50byB0aGUgc291cmNlcyBhbmQgbmFtZXMgQXJyYXlTZXRzKSwgd2UgaGF2ZSB0byBtYWtlXG4gICAgLy8gYSBjb3B5IG9mIHRoZSBlbnRyeSBvciBlbHNlIGJhZCB0aGluZ3MgaGFwcGVuLiBTaGFyZWQgbXV0YWJsZSBzdGF0ZVxuICAgIC8vIHN0cmlrZXMgYWdhaW4hIFNlZSBnaXRodWIgaXNzdWUgIzE5MS5cblxuICAgIHZhciBnZW5lcmF0ZWRNYXBwaW5ncyA9IGFTb3VyY2VNYXAuX21hcHBpbmdzLnRvQXJyYXkoKS5zbGljZSgpO1xuICAgIHZhciBkZXN0R2VuZXJhdGVkTWFwcGluZ3MgPSBzbWMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IFtdO1xuICAgIHZhciBkZXN0T3JpZ2luYWxNYXBwaW5ncyA9IHNtYy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNyY01hcHBpbmcgPSBnZW5lcmF0ZWRNYXBwaW5nc1tpXTtcbiAgICAgIHZhciBkZXN0TWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgICAgZGVzdE1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkTGluZTtcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHNyY01hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICBpZiAoc3JjTWFwcGluZy5zb3VyY2UpIHtcbiAgICAgICAgZGVzdE1hcHBpbmcuc291cmNlID0gc291cmNlcy5pbmRleE9mKHNyY01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgZGVzdE1hcHBpbmcub3JpZ2luYWxMaW5lID0gc3JjTWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gc3JjTWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAoc3JjTWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgZGVzdE1hcHBpbmcubmFtZSA9IG5hbWVzLmluZGV4T2Yoc3JjTWFwcGluZy5uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlc3RPcmlnaW5hbE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgICAgfVxuXG4gICAgICBkZXN0R2VuZXJhdGVkTWFwcGluZ3MucHVzaChkZXN0TWFwcGluZyk7XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHNtYy5fX29yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuXG4gICAgcmV0dXJuIHNtYztcbiAgfTtcblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWJzb2x1dGVTb3VyY2VzLnNsaWNlKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIEpJVCB3aXRoIGEgbmljZSBzaGFwZSAvIGhpZGRlbiBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZygpIHtcbiAgdGhpcy5nZW5lcmF0ZWRMaW5lID0gMDtcbiAgdGhpcy5nZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICB0aGlzLnNvdXJjZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdGhpcy5vcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHRoaXMubmFtZSA9IG51bGw7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB2YXIgZ2VuZXJhdGVkTGluZSA9IDE7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbExpbmUgPSAwO1xuICAgIHZhciBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciBwcmV2aW91c05hbWUgPSAwO1xuICAgIHZhciBsZW5ndGggPSBhU3RyLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjYWNoZWRTZWdtZW50cyA9IHt9O1xuICAgIHZhciB0ZW1wID0ge307XG4gICAgdmFyIG9yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgbWFwcGluZywgc3RyLCBzZWdtZW50LCBlbmQsIHZhbHVlO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnOycpIHtcbiAgICAgICAgZ2VuZXJhdGVkTGluZSsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChhU3RyLmNoYXJBdChpbmRleCkgPT09ICcsJykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG1hcHBpbmcgPSBuZXcgTWFwcGluZygpO1xuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBnZW5lcmF0ZWRMaW5lO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZWFjaCBvZmZzZXQgaXMgZW5jb2RlZCByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLFxuICAgICAgICAvLyBtYW55IHNlZ21lbnRzIG9mdGVuIGhhdmUgdGhlIHNhbWUgZW5jb2RpbmcuIFdlIGNhbiBleHBsb2l0IHRoaXNcbiAgICAgICAgLy8gZmFjdCBieSBjYWNoaW5nIHRoZSBwYXJzZWQgdmFyaWFibGUgbGVuZ3RoIGZpZWxkcyBvZiBlYWNoIHNlZ21lbnQsXG4gICAgICAgIC8vIGFsbG93aW5nIHVzIHRvIGF2b2lkIGEgc2Vjb25kIHBhcnNlIGlmIHdlIGVuY291bnRlciB0aGUgc2FtZVxuICAgICAgICAvLyBzZWdtZW50IGFnYWluLlxuICAgICAgICBmb3IgKGVuZCA9IGluZGV4OyBlbmQgPCBsZW5ndGg7IGVuZCsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgZW5kKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0ciA9IGFTdHIuc2xpY2UoaW5kZXgsIGVuZCk7XG5cbiAgICAgICAgc2VnbWVudCA9IGNhY2hlZFNlZ21lbnRzW3N0cl07XG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ID0gW107XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgZW5kKSB7XG4gICAgICAgICAgICBiYXNlNjRWTFEuZGVjb2RlKGFTdHIsIGluZGV4LCB0ZW1wKTtcbiAgICAgICAgICAgIHZhbHVlID0gdGVtcC52YWx1ZTtcbiAgICAgICAgICAgIGluZGV4ID0gdGVtcC5yZXN0O1xuICAgICAgICAgICAgc2VnbWVudC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UsIGJ1dCBubyBsaW5lIGFuZCBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgYSBzb3VyY2UgYW5kIGxpbmUsIGJ1dCBubyBjb2x1bW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWNoZWRTZWdtZW50c1tzdHJdID0gc2VnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlZCBjb2x1bW4uXG4gICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uID0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gKyBzZWdtZW50WzBdO1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAvLyBPcmlnaW5hbCBzb3VyY2UuXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBwcmV2aW91c1NvdXJjZSArIHNlZ21lbnRbMV07XG4gICAgICAgICAgcHJldmlvdXNTb3VyY2UgKz0gc2VnbWVudFsxXTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGxpbmUuXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBwcmV2aW91c09yaWdpbmFsTGluZSArIHNlZ21lbnRbMl07XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcbiAgICAgICAgICAvLyBMaW5lcyBhcmUgc3RvcmVkIDAtYmFzZWRcbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsTGluZSArPSAxO1xuXG4gICAgICAgICAgLy8gT3JpZ2luYWwgY29sdW1uLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBwcmV2aW91c09yaWdpbmFsQ29sdW1uICsgc2VnbWVudFszXTtcbiAgICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgICBtYXBwaW5nLm5hbWUgPSBwcmV2aW91c05hbWUgKyBzZWdtZW50WzRdO1xuICAgICAgICAgICAgcHJldmlvdXNOYW1lICs9IHNlZ21lbnRbNF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChtYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBvcmlnaW5hbE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWlja1NvcnQoZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IGdlbmVyYXRlZE1hcHBpbmdzO1xuXG4gICAgcXVpY2tTb3J0KG9yaWdpbmFsTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzID0gb3JpZ2luYWxNYXBwaW5ncztcbiAgfTtcblxuLyoqXG4gKiBGaW5kIHRoZSBtYXBwaW5nIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBoeXBvdGhldGljYWwgXCJuZWVkbGVcIiBtYXBwaW5nIHRoYXRcbiAqIHdlIGFyZSBzZWFyY2hpbmcgZm9yIGluIHRoZSBnaXZlbiBcImhheXN0YWNrXCIgb2YgbWFwcGluZ3MuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2ZpbmRNYXBwaW5nKGFOZWVkbGUsIGFNYXBwaW5ncywgYUxpbmVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ29sdW1uTmFtZSwgYUNvbXBhcmF0b3IsIGFCaWFzKSB7XG4gICAgLy8gVG8gcmV0dXJuIHRoZSBwb3NpdGlvbiB3ZSBhcmUgc2VhcmNoaW5nIGZvciwgd2UgbXVzdCBmaXJzdCBmaW5kIHRoZVxuICAgIC8vIG1hcHBpbmcgZm9yIHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgdGhlbiByZXR1cm4gdGhlIG9wcG9zaXRlIHBvc2l0aW9uIGl0XG4gICAgLy8gcG9pbnRzIHRvLiBCZWNhdXNlIHRoZSBtYXBwaW5ncyBhcmUgc29ydGVkLCB3ZSBjYW4gdXNlIGJpbmFyeSBzZWFyY2ggdG9cbiAgICAvLyBmaW5kIHRoZSBiZXN0IG1hcHBpbmcuXG5cbiAgICBpZiAoYU5lZWRsZVthTGluZU5hbWVdIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpbmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMSwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FMaW5lTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoYU5lZWRsZVthQ29sdW1uTmFtZV0gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb2x1bW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCwgZ290ICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBhTmVlZGxlW2FDb2x1bW5OYW1lXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaC5zZWFyY2goYU5lZWRsZSwgYU1hcHBpbmdzLCBhQ29tcGFyYXRvciwgYUJpYXMpO1xuICB9O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxhc3QgY29sdW1uIGZvciBlYWNoIGdlbmVyYXRlZCBtYXBwaW5nLiBUaGUgbGFzdCBjb2x1bW4gaXNcbiAqIGluY2x1c2l2ZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuY29tcHV0ZUNvbHVtblNwYW5zID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfY29tcHV0ZUNvbHVtblNwYW5zKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICAvLyBNYXBwaW5ncyBkbyBub3QgY29udGFpbiBhIGZpZWxkIGZvciB0aGUgbGFzdCBnZW5lcmF0ZWQgY29sdW1udC4gV2VcbiAgICAgIC8vIGNhbiBjb21lIHVwIHdpdGggYW4gb3B0aW1pc3RpYyBlc3RpbWF0ZSwgaG93ZXZlciwgYnkgYXNzdW1pbmcgdGhhdFxuICAgICAgLy8gbWFwcGluZ3MgYXJlIGNvbnRpZ3VvdXMgKGkuZS4gZ2l2ZW4gdHdvIGNvbnNlY3V0aXZlIG1hcHBpbmdzLCB0aGVcbiAgICAgIC8vIGZpcnN0IG1hcHBpbmcgZW5kcyB3aGVyZSB0aGUgc2Vjb25kIG9uZSBzdGFydHMpLlxuICAgICAgaWYgKGluZGV4ICsgMSA8IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV4dE1hcHBpbmcgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5nc1tpbmRleCArIDFdO1xuXG4gICAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgPT09IG5leHRNYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBsYXN0IG1hcHBpbmcgZm9yIGVhY2ggbGluZSBzcGFucyB0aGUgZW50aXJlIGxpbmUuXG4gICAgICBtYXBwaW5nLmxhc3RHZW5lcmF0ZWRDb2x1bW4gPSBJbmZpbml0eTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlLCBsaW5lLCBhbmQgY29sdW1uIGluZm9ybWF0aW9uIGZvciB0aGUgZ2VuZXJhdGVkXG4gKiBzb3VyY2UncyBsaW5lIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXJcbiAqICAgICBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUsIG9yIG51bGwuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqICAgLSBuYW1lOiBUaGUgb3JpZ2luYWwgaWRlbnRpZmllciwgb3IgbnVsbC5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX29yaWdpbmFsUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgZ2VuZXJhdGVkTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncyxcbiAgICAgIFwiZ2VuZXJhdGVkTGluZVwiLFxuICAgICAgXCJnZW5lcmF0ZWRDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXhdO1xuXG4gICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcobWFwcGluZywgJ3NvdXJjZScsIG51bGwpO1xuICAgICAgICBpZiAoc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5hdChzb3VyY2UpO1xuICAgICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTCh0aGlzLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICduYW1lJywgbnVsbCk7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgbmFtZSA9IHRoaXMuX25hbWVzLmF0KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsTGluZScsIG51bGwpLFxuICAgICAgICAgIGNvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ29yaWdpbmFsQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgaGF2ZSB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGV2ZXJ5IHNvdXJjZSBpbiB0aGUgc291cmNlXG4gKiBtYXAsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBCYXNpY1NvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudC5sZW5ndGggPj0gdGhpcy5fc291cmNlcy5zaXplKCkgJiZcbiAgICAgICF0aGlzLnNvdXJjZXNDb250ZW50LnNvbWUoZnVuY3Rpb24gKHNjKSB7IHJldHVybiBzYyA9PSBudWxsOyB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGlmICghdGhpcy5zb3VyY2VzQ29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KGFTb3VyY2UpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5zb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuXG4gICAgdmFyIHJlbGF0aXZlU291cmNlID0gYVNvdXJjZTtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgdXJsO1xuICAgIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbFxuICAgICAgICAmJiAodXJsID0gdXRpbC51cmxQYXJzZSh0aGlzLnNvdXJjZVJvb3QpKSkge1xuICAgICAgLy8gWFhYOiBmaWxlOi8vIFVSSXMgYW5kIGFic29sdXRlIHBhdGhzIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvciBmb3JcbiAgICAgIC8vIG1hbnkgdXNlcnMuIFdlIGNhbiBoZWxwIHRoZW0gb3V0IHdoZW4gdGhleSBleHBlY3QgZmlsZTovLyBVUklzIHRvXG4gICAgICAvLyBiZWhhdmUgbGlrZSBpdCB3b3VsZCBpZiB0aGV5IHdlcmUgcnVubmluZyBhIGxvY2FsIEhUVFAgc2VydmVyLiBTZWVcbiAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4NTU5Ny5cbiAgICAgIHZhciBmaWxlVXJpQWJzUGF0aCA9IHJlbGF0aXZlU291cmNlLnJlcGxhY2UoL15maWxlOlxcL1xcLy8sIFwiXCIpO1xuICAgICAgaWYgKHVybC5zY2hlbWUgPT0gXCJmaWxlXCJcbiAgICAgICAgICAmJiB0aGlzLl9zb3VyY2VzLmhhcyhmaWxlVXJpQWJzUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKGZpbGVVcmlBYnNQYXRoKV1cbiAgICAgIH1cblxuICAgICAgaWYgKCghdXJsLnBhdGggfHwgdXJsLnBhdGggPT0gXCIvXCIpXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoXCIvXCIgKyByZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbdGhpcy5fc291cmNlcy5pbmRleE9mKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgZnJvbVxuICAgIC8vIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuc291cmNlQ29udGVudEZvci4gSW4gdGhhdCBjYXNlLCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gdGhyb3cgaWYgd2UgY2FuJ3QgZmluZCB0aGUgc291cmNlIC0gd2UganVzdCB3YW50IHRvXG4gICAgLy8gcmV0dXJuIG51bGwsIHNvIHdlIHByb3ZpZGUgYSBmbGFnIHRvIGV4aXQgZ3JhY2VmdWxseS5cbiAgICBpZiAobnVsbE9uTWlzc2luZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyByZWxhdGl2ZVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gYmlhczogRWl0aGVyICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICogICAgIERlZmF1bHRzIHRvICdTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORCcuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLlxuICogICAgIFRoZSBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZ2VuZXJhdGVkUG9zaXRpb25Gb3IoYUFyZ3MpIHtcbiAgICB2YXIgc291cmNlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKTtcbiAgICBzb3VyY2UgPSB0aGlzLl9maW5kU291cmNlSW5kZXgoc291cmNlKTtcbiAgICBpZiAoc291cmNlIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbnVsbCxcbiAgICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIG9yaWdpbmFsTGluZTogdXRpbC5nZXRBcmcoYUFyZ3MsICdsaW5lJyksXG4gICAgICBvcmlnaW5hbENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kTWFwcGluZyhcbiAgICAgIG5lZWRsZSxcbiAgICAgIHRoaXMuX29yaWdpbmFsTWFwcGluZ3MsXG4gICAgICBcIm9yaWdpbmFsTGluZVwiLFxuICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyxcbiAgICAgIHV0aWwuZ2V0QXJnKGFBcmdzLCAnYmlhcycsIFNvdXJjZU1hcENvbnN1bWVyLkdSRUFURVNUX0xPV0VSX0JPVU5EKVxuICAgICk7XG5cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlID09PSBuZWVkbGUuc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZTogdXRpbC5nZXRBcmcobWFwcGluZywgJ2dlbmVyYXRlZExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRDb2x1bW4nLCBudWxsKSxcbiAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGwsXG4gICAgICBsYXN0Q29sdW1uOiBudWxsXG4gICAgfTtcbiAgfTtcblxuZXhwb3J0cy5CYXNpY1NvdXJjZU1hcENvbnN1bWVyID0gQmFzaWNTb3VyY2VNYXBDb25zdW1lcjtcblxuLyoqXG4gKiBBbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBhcnNlZCBzb3VyY2UgbWFwIHdoaWNoXG4gKiB3ZSBjYW4gcXVlcnkgZm9yIGluZm9ybWF0aW9uLiBJdCBkaWZmZXJzIGZyb20gQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpblxuICogdGhhdCBpdCB0YWtlcyBcImluZGV4ZWRcIiBzb3VyY2UgbWFwcyAoaS5lLiBvbmVzIHdpdGggYSBcInNlY3Rpb25zXCIgZmllbGQpIGFzXG4gKiBpbnB1dC5cbiAqXG4gKiBUaGUgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmF3IHNvdXJjZSBtYXAgKGVpdGhlciBhcyBhIEpTT04gc3RyaW5nLCBvciBhbHJlYWR5XG4gKiBwYXJzZWQgdG8gYW4gb2JqZWN0KS4gQWNjb3JkaW5nIHRvIHRoZSBzcGVjIGZvciBpbmRleGVkIHNvdXJjZSBtYXBzLCB0aGV5XG4gKiBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlczpcbiAqXG4gKiAgIC0gdmVyc2lvbjogV2hpY2ggdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcCBzcGVjIHRoaXMgbWFwIGlzIGZvbGxvd2luZy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKiAgIC0gc2VjdGlvbnM6IEEgbGlzdCBvZiBzZWN0aW9uIGRlZmluaXRpb25zLlxuICpcbiAqIEVhY2ggdmFsdWUgdW5kZXIgdGhlIFwic2VjdGlvbnNcIiBmaWVsZCBoYXMgdHdvIGZpZWxkczpcbiAqICAgLSBvZmZzZXQ6IFRoZSBvZmZzZXQgaW50byB0aGUgb3JpZ2luYWwgc3BlY2lmaWVkIGF0IHdoaWNoIHRoaXMgc2VjdGlvblxuICogICAgICAgYmVnaW5zIHRvIGFwcGx5LCBkZWZpbmVkIGFzIGFuIG9iamVjdCB3aXRoIGEgXCJsaW5lXCIgYW5kIFwiY29sdW1uXCJcbiAqICAgICAgIGZpZWxkLlxuICogICAtIG1hcDogQSBzb3VyY2UgbWFwIGRlZmluaXRpb24uIFRoaXMgc291cmNlIG1hcCBjb3VsZCBhbHNvIGJlIGluZGV4ZWQsXG4gKiAgICAgICBidXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuICpcbiAqIEluc3RlYWQgb2YgdGhlIFwibWFwXCIgZmllbGQsIGl0J3MgYWxzbyBwb3NzaWJsZSB0byBoYXZlIGEgXCJ1cmxcIiBmaWVsZFxuICogc3BlY2lmeWluZyBhIFVSTCB0byByZXRyaWV2ZSBhIHNvdXJjZSBtYXAgZnJvbSwgYnV0IHRoYXQncyBjdXJyZW50bHlcbiAqIHVuc3VwcG9ydGVkLlxuICpcbiAqIEhlcmUncyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXSwgYnV0XG4gKiBtb2RpZmllZCB0byBvbWl0IGEgc2VjdGlvbiB3aGljaCB1c2VzIHRoZSBcInVybFwiIGZpZWxkLlxuICpcbiAqICB7XG4gKiAgICB2ZXJzaW9uIDogMyxcbiAqICAgIGZpbGU6IFwiYXBwLmpzXCIsXG4gKiAgICBzZWN0aW9uczogW3tcbiAqICAgICAgb2Zmc2V0OiB7bGluZToxMDAsIGNvbHVtbjoxMH0sXG4gKiAgICAgIG1hcDoge1xuICogICAgICAgIHZlcnNpb24gOiAzLFxuICogICAgICAgIGZpbGU6IFwic2VjdGlvbi5qc1wiLFxuICogICAgICAgIHNvdXJjZXM6IFtcImZvby5qc1wiLCBcImJhci5qc1wiXSxcbiAqICAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgICBtYXBwaW5nczogXCJBQUFBLEU7O0FCQ0RFO1wiXG4gKiAgICAgIH1cbiAqICAgIH1dLFxuICogIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQjaGVhZGluZz1oLjUzNWVzM3hlcHJndFxuICovXG5mdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc2VjdGlvbnMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzZWN0aW9ucycpO1xuXG4gIGlmICh2ZXJzaW9uICE9IHRoaXMuX3ZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIHRoaXMuX3NvdXJjZXMgPSBuZXcgQXJyYXlTZXQoKTtcbiAgdGhpcy5fbmFtZXMgPSBuZXcgQXJyYXlTZXQoKTtcblxuICB2YXIgbGFzdE9mZnNldCA9IHtcbiAgICBsaW5lOiAtMSxcbiAgICBjb2x1bW46IDBcbiAgfTtcbiAgdGhpcy5fc2VjdGlvbnMgPSBzZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICBpZiAocy51cmwpIHtcbiAgICAgIC8vIFRoZSB1cmwgZmllbGQgd2lsbCByZXF1aXJlIHN1cHBvcnQgZm9yIGFzeW5jaHJvbmljaXR5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3NvdXJjZS1tYXAvaXNzdWVzLzE2XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgZm9yIHVybCBmaWVsZCBpbiBzZWN0aW9ucyBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSB1dGlsLmdldEFyZyhzLCAnb2Zmc2V0Jyk7XG4gICAgdmFyIG9mZnNldExpbmUgPSB1dGlsLmdldEFyZyhvZmZzZXQsICdsaW5lJyk7XG4gICAgdmFyIG9mZnNldENvbHVtbiA9IHV0aWwuZ2V0QXJnKG9mZnNldCwgJ2NvbHVtbicpO1xuXG4gICAgaWYgKG9mZnNldExpbmUgPCBsYXN0T2Zmc2V0LmxpbmUgfHxcbiAgICAgICAgKG9mZnNldExpbmUgPT09IGxhc3RPZmZzZXQubGluZSAmJiBvZmZzZXRDb2x1bW4gPCBsYXN0T2Zmc2V0LmNvbHVtbikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdGlvbiBvZmZzZXRzIG11c3QgYmUgb3JkZXJlZCBhbmQgbm9uLW92ZXJsYXBwaW5nLicpO1xuICAgIH1cbiAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdlbmVyYXRlZE9mZnNldDoge1xuICAgICAgICAvLyBUaGUgb2Zmc2V0IGZpZWxkcyBhcmUgMC1iYXNlZCwgYnV0IHdlIHVzZSAxLWJhc2VkIGluZGljZXMgd2hlblxuICAgICAgICAvLyBlbmNvZGluZy9kZWNvZGluZyBmcm9tIFZMUS5cbiAgICAgICAgZ2VuZXJhdGVkTGluZTogb2Zmc2V0TGluZSArIDEsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogb2Zmc2V0Q29sdW1uICsgMVxuICAgICAgfSxcbiAgICAgIGNvbnN1bWVyOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXRpbC5nZXRBcmcocywgJ21hcCcpLCBhU291cmNlTWFwVVJMKVxuICAgIH1cbiAgfSk7XG59XG5cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl92ZXJzaW9uID0gMztcblxuLyoqXG4gKiBUaGUgbGlzdCBvZiBvcmlnaW5hbCBzb3VyY2VzLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSwgJ3NvdXJjZXMnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaCh0aGlzLl9zZWN0aW9uc1tpXS5jb25zdW1lci5zb3VyY2VzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZXM7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUub3JpZ2luYWxQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIC8vIEZpbmQgdGhlIHNlY3Rpb24gY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9uIHdlJ3JlIHRyeWluZyB0byBtYXBcbiAgICAvLyB0byBhbiBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICB2YXIgc2VjdGlvbkluZGV4ID0gYmluYXJ5U2VhcmNoLnNlYXJjaChuZWVkbGUsIHRoaXMuX3NlY3Rpb25zLFxuICAgICAgZnVuY3Rpb24obmVlZGxlLCBzZWN0aW9uKSB7XG4gICAgICAgIHZhciBjbXAgPSBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtIHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmU7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChuZWVkbGUuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgfSk7XG4gICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tzZWN0aW9uSW5kZXhdO1xuXG4gICAgaWYgKCFzZWN0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2U6IG51bGwsXG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbmFtZTogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VjdGlvbi5jb25zdW1lci5vcmlnaW5hbFBvc2l0aW9uRm9yKHtcbiAgICAgIGxpbmU6IG5lZWRsZS5nZW5lcmF0ZWRMaW5lIC1cbiAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgIGNvbHVtbjogbmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBuZWVkbGUuZ2VuZXJhdGVkTGluZVxuICAgICAgICAgPyBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRDb2x1bW4gLSAxXG4gICAgICAgICA6IDApLFxuICAgICAgYmlhczogYUFyZ3MuYmlhc1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gcy5jb25zdW1lci5oYXNDb250ZW50c09mQWxsU291cmNlcygpO1xuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50LiBUaGUgb25seSBhcmd1bWVudCBpcyB0aGUgdXJsIG9mIHRoZVxuICogb3JpZ2luYWwgc291cmNlIGZpbGUuIFJldHVybnMgbnVsbCBpZiBubyBvcmlnaW5hbCBzb3VyY2UgY29udGVudCBpc1xuICogYXZhaWxhYmxlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfc291cmNlQ29udGVudEZvcihhU291cmNlLCBudWxsT25NaXNzaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgdmFyIGNvbnRlbnQgPSBzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgdHJ1ZSk7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYVNvdXJjZSArICdcIiBpcyBub3QgaW4gdGhlIFNvdXJjZU1hcC4nKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcG9zaXRpb25zIHByb3ZpZGVkLiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aFxuICogdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBmaWxlbmFtZSBvZiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgY29sdW1uXG4gKiAgICAgbnVtYmVyIGlzIDAtYmFzZWQuXG4gKlxuICogYW5kIGFuIG9iamVjdCBpcyByZXR1cm5lZCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC4gXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmdlbmVyYXRlZFBvc2l0aW9uRm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9zZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlY3Rpb24gPSB0aGlzLl9zZWN0aW9uc1tpXTtcblxuICAgICAgLy8gT25seSBjb25zaWRlciB0aGlzIHNlY3Rpb24gaWYgdGhlIHJlcXVlc3RlZCBzb3VyY2UgaXMgaW4gdGhlIGxpc3Qgb2ZcbiAgICAgIC8vIHNvdXJjZXMgb2YgdGhlIGNvbnN1bWVyLlxuICAgICAgaWYgKHNlY3Rpb24uY29uc3VtZXIuX2ZpbmRTb3VyY2VJbmRleCh1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpKSA9PT0gLTEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZ2VuZXJhdGVkUG9zaXRpb24gPSBzZWN0aW9uLmNvbnN1bWVyLmdlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKTtcbiAgICAgIGlmIChnZW5lcmF0ZWRQb3NpdGlvbikge1xuICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZFBvc2l0aW9uLmNvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gZ2VuZXJhdGVkUG9zaXRpb24ubGluZVxuICAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgIDogMClcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9wYXJzZU1hcHBpbmdzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3BhcnNlTWFwcGluZ3MoYVN0ciwgYVNvdXJjZVJvb3QpIHtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG4gICAgICB2YXIgc2VjdGlvbk1hcHBpbmdzID0gc2VjdGlvbi5jb25zdW1lci5fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlY3Rpb25NYXBwaW5ncy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IHNlY3Rpb25NYXBwaW5nc1tqXTtcblxuICAgICAgICB2YXIgc291cmNlID0gc2VjdGlvbi5jb25zdW1lci5fc291cmNlcy5hdChtYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHV0aWwuY29tcHV0ZVNvdXJjZVVSTChzZWN0aW9uLmNvbnN1bWVyLnNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgICAgdGhpcy5fc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgICAgc291cmNlID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAobWFwcGluZy5uYW1lKSB7XG4gICAgICAgICAgbmFtZSA9IHNlY3Rpb24uY29uc3VtZXIuX25hbWVzLmF0KG1hcHBpbmcubmFtZSk7XG4gICAgICAgICAgdGhpcy5fbmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG1hcHBpbmdzIGNvbWluZyBmcm9tIHRoZSBjb25zdW1lciBmb3IgdGhlIHNlY3Rpb24gaGF2ZVxuICAgICAgICAvLyBnZW5lcmF0ZWQgcG9zaXRpb25zIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiwgc28gd2VcbiAgICAgICAgLy8gbmVlZCB0byBvZmZzZXQgdGhlbSB0byBiZSByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIGNvbmNhdGVuYXRlZFxuICAgICAgICAvLyBnZW5lcmF0ZWQgZmlsZS5cbiAgICAgICAgdmFyIGFkanVzdGVkTWFwcGluZyA9IHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUgK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgLSAxKSxcbiAgICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lID09PSBtYXBwaW5nLmdlbmVyYXRlZExpbmVcbiAgICAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgICAgOiAwKSxcbiAgICAgICAgICBvcmlnaW5hbExpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICBpZiAodHlwZW9mIGFkanVzdGVkTWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MucHVzaChhZGp1c3RlZE1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZCk7XG4gICAgcXVpY2tTb3J0KHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgfTtcblxuZXhwb3J0cy5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIgPSBJbmRleGVkU291cmNlTWFwQ29uc3VtZXI7XG5cbn0se1wiLi9hcnJheS1zZXRcIjoyLFwiLi9iYXNlNjQtdmxxXCI6MyxcIi4vYmluYXJ5LXNlYXJjaFwiOjUsXCIuL3F1aWNrLXNvcnRcIjo3LFwiLi91dGlsXCI6MTF9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cbn0se1wiLi9hcnJheS1zZXRcIjoyLFwiLi9iYXNlNjQtdmxxXCI6MyxcIi4vbWFwcGluZy1saXN0XCI6NixcIi4vdXRpbFwiOjExfV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9zb3VyY2UtbWFwLWdlbmVyYXRvcicpLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYSBXaW5kb3dzLXN0eWxlIGBcXHJcXG5gIG5ld2xpbmUgb3IgYSBgXFxuYCBuZXdsaW5lIHVzZWQgYnkgYWxsIG90aGVyXG4vLyBvcGVyYXRpbmcgc3lzdGVtcyB0aGVzZSBkYXlzIChjYXB0dXJpbmcgdGhlIHJlc3VsdCkuXG52YXIgUkVHRVhfTkVXTElORSA9IC8oXFxyP1xcbikvO1xuXG4vLyBOZXdsaW5lIGNoYXJhY3RlciBjb2RlIGZvciBjaGFyQ29kZUF0KCkgY29tcGFyaXNvbnNcbnZhciBORVdMSU5FX0NPREUgPSAxMDtcblxuLy8gUHJpdmF0ZSBzeW1ib2wgZm9yIGlkZW50aWZ5aW5nIGBTb3VyY2VOb2RlYHMgd2hlbiBtdWx0aXBsZSB2ZXJzaW9ucyBvZlxuLy8gdGhlIHNvdXJjZS1tYXAgbGlicmFyeSBhcmUgbG9hZGVkLiBUaGlzIE1VU1QgTk9UIENIQU5HRSBhY3Jvc3Ncbi8vIHZlcnNpb25zIVxudmFyIGlzU291cmNlTm9kZSA9IFwiJCQkaXNTb3VyY2VOb2RlJCQkXCI7XG5cbi8qKlxuICogU291cmNlTm9kZXMgcHJvdmlkZSBhIHdheSB0byBhYnN0cmFjdCBvdmVyIGludGVycG9sYXRpbmcvY29uY2F0ZW5hdGluZ1xuICogc25pcHBldHMgb2YgZ2VuZXJhdGVkIEphdmFTY3JpcHQgc291cmNlIGNvZGUgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIGxpbmUgYW5kXG4gKiBjb2x1bW4gaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcGFyYW0gYUxpbmUgVGhlIG9yaWdpbmFsIGxpbmUgbnVtYmVyLlxuICogQHBhcmFtIGFDb2x1bW4gVGhlIG9yaWdpbmFsIGNvbHVtbiBudW1iZXIuXG4gKiBAcGFyYW0gYVNvdXJjZSBUaGUgb3JpZ2luYWwgc291cmNlJ3MgZmlsZW5hbWUuXG4gKiBAcGFyYW0gYUNodW5rcyBPcHRpb25hbC4gQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aGljaCBhcmUgc25pcHBldHMgb2ZcbiAqICAgICAgICBnZW5lcmF0ZWQgSlMsIG9yIG90aGVyIFNvdXJjZU5vZGVzLlxuICogQHBhcmFtIGFOYW1lIFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLlxuICovXG5mdW5jdGlvbiBTb3VyY2VOb2RlKGFMaW5lLCBhQ29sdW1uLCBhU291cmNlLCBhQ2h1bmtzLCBhTmFtZSkge1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMuc291cmNlQ29udGVudHMgPSB7fTtcbiAgdGhpcy5saW5lID0gYUxpbmUgPT0gbnVsbCA/IG51bGwgOiBhTGluZTtcbiAgdGhpcy5jb2x1bW4gPSBhQ29sdW1uID09IG51bGwgPyBudWxsIDogYUNvbHVtbjtcbiAgdGhpcy5zb3VyY2UgPSBhU291cmNlID09IG51bGwgPyBudWxsIDogYVNvdXJjZTtcbiAgdGhpcy5uYW1lID0gYU5hbWUgPT0gbnVsbCA/IG51bGwgOiBhTmFtZTtcbiAgdGhpc1tpc1NvdXJjZU5vZGVdID0gdHJ1ZTtcbiAgaWYgKGFDaHVua3MgIT0gbnVsbCkgdGhpcy5hZGQoYUNodW5rcyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNvdXJjZU5vZGUgZnJvbSBnZW5lcmF0ZWQgY29kZSBhbmQgYSBTb3VyY2VNYXBDb25zdW1lci5cbiAqXG4gKiBAcGFyYW0gYUdlbmVyYXRlZENvZGUgVGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAgZm9yIHRoZSBnZW5lcmF0ZWQgY29kZVxuICogQHBhcmFtIGFSZWxhdGl2ZVBhdGggT3B0aW9uYWwuIFRoZSBwYXRoIHRoYXQgcmVsYXRpdmUgc291cmNlcyBpbiB0aGVcbiAqICAgICAgICBTb3VyY2VNYXBDb25zdW1lciBzaG91bGQgYmUgcmVsYXRpdmUgdG8uXG4gKi9cblNvdXJjZU5vZGUuZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VOb2RlX2Zyb21TdHJpbmdXaXRoU291cmNlTWFwKGFHZW5lcmF0ZWRDb2RlLCBhU291cmNlTWFwQ29uc3VtZXIsIGFSZWxhdGl2ZVBhdGgpIHtcbiAgICAvLyBUaGUgU291cmNlTm9kZSB3ZSB3YW50IHRvIGZpbGwgd2l0aCB0aGUgZ2VuZXJhdGVkIGNvZGVcbiAgICAvLyBhbmQgdGhlIFNvdXJjZU1hcFxuICAgIHZhciBub2RlID0gbmV3IFNvdXJjZU5vZGUoKTtcblxuICAgIC8vIEFsbCBldmVuIGluZGljZXMgb2YgdGhpcyBhcnJheSBhcmUgb25lIGxpbmUgb2YgdGhlIGdlbmVyYXRlZCBjb2RlLFxuICAgIC8vIHdoaWxlIGFsbCBvZGQgaW5kaWNlcyBhcmUgdGhlIG5ld2xpbmVzIGJldHdlZW4gdHdvIGFkamFjZW50IGxpbmVzXG4gICAgLy8gKHNpbmNlIGBSRUdFWF9ORVdMSU5FYCBjYXB0dXJlcyBpdHMgbWF0Y2gpLlxuICAgIC8vIFByb2Nlc3NlZCBmcmFnbWVudHMgYXJlIGFjY2Vzc2VkIGJ5IGNhbGxpbmcgYHNoaWZ0TmV4dExpbmVgLlxuICAgIHZhciByZW1haW5pbmdMaW5lcyA9IGFHZW5lcmF0ZWRDb2RlLnNwbGl0KFJFR0VYX05FV0xJTkUpO1xuICAgIHZhciByZW1haW5pbmdMaW5lc0luZGV4ID0gMDtcbiAgICB2YXIgc2hpZnROZXh0TGluZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmVDb250ZW50cyA9IGdldE5leHRMaW5lKCk7XG4gICAgICAvLyBUaGUgbGFzdCBsaW5lIG9mIGEgZmlsZSBtaWdodCBub3QgaGF2ZSBhIG5ld2xpbmUuXG4gICAgICB2YXIgbmV3TGluZSA9IGdldE5leHRMaW5lKCkgfHwgXCJcIjtcbiAgICAgIHJldHVybiBsaW5lQ29udGVudHMgKyBuZXdMaW5lO1xuXG4gICAgICBmdW5jdGlvbiBnZXROZXh0TGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0xpbmVzSW5kZXggPCByZW1haW5pbmdMaW5lcy5sZW5ndGggP1xuICAgICAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleCsrXSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gV2UgbmVlZCB0byByZW1lbWJlciB0aGUgcG9zaXRpb24gb2YgXCJyZW1haW5pbmdMaW5lc1wiXG4gICAgdmFyIGxhc3RHZW5lcmF0ZWRMaW5lID0gMSwgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG5cbiAgICAvLyBUaGUgZ2VuZXJhdGUgU291cmNlTm9kZXMgd2UgbmVlZCBhIGNvZGUgcmFuZ2UuXG4gICAgLy8gVG8gZXh0cmFjdCBpdCBjdXJyZW50IGFuZCBsYXN0IG1hcHBpbmcgaXMgdXNlZC5cbiAgICAvLyBIZXJlIHdlIHN0b3JlIHRoZSBsYXN0IG1hcHBpbmcuXG4gICAgdmFyIGxhc3RNYXBwaW5nID0gbnVsbDtcblxuICAgIGFTb3VyY2VNYXBDb25zdW1lci5lYWNoTWFwcGluZyhmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFdlIGFkZCB0aGUgY29kZSBmcm9tIFwibGFzdE1hcHBpbmdcIiB0byBcIm1hcHBpbmdcIjpcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlcmUgaXMgYSBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICBpZiAobGFzdEdlbmVyYXRlZExpbmUgPCBtYXBwaW5nLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgICAvLyBBc3NvY2lhdGUgZmlyc3QgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgY29kZSBpcyBhZGRlZCB3aXRob3V0IG1hcHBpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZXcgbGluZSBpbiBiZXR3ZWVuLlxuICAgICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgY29kZSBiZXR3ZWVuIFwibGFzdEdlbmVyYXRlZENvbHVtblwiIGFuZFxuICAgICAgICAgIC8vIFwibWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cIiB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICAgIHZhciBjb2RlID0gbmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSA9IG5leHRMaW5lLnN1YnN0cihtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbik7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgY29kZSk7XG4gICAgICAgICAgLy8gTm8gbW9yZSByZW1haW5pbmcgY29kZSwgY29udGludWVcbiAgICAgICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBXZSBhZGQgdGhlIGdlbmVyYXRlZCBjb2RlIHVudGlsIHRoZSBmaXJzdCBtYXBwaW5nXG4gICAgICAvLyB0byB0aGUgU291cmNlTm9kZSB3aXRob3V0IGFueSBtYXBwaW5nLlxuICAgICAgLy8gRWFjaCBsaW5lIGlzIGFkZGVkIGFzIHNlcGFyYXRlIHN0cmluZy5cbiAgICAgIHdoaWxlIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICBub2RlLmFkZChzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICBsYXN0R2VuZXJhdGVkTGluZSsrO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3RHZW5lcmF0ZWRDb2x1bW4gPCBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbikge1xuICAgICAgICB2YXIgbmV4dExpbmUgPSByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4XSB8fCAnJztcbiAgICAgICAgbm9kZS5hZGQobmV4dExpbmUuc3Vic3RyKDAsIG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSk7XG4gICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uO1xuICAgICAgfVxuICAgICAgbGFzdE1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIH0sIHRoaXMpO1xuICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBtYXBwaW5ncy5cbiAgICBpZiAocmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCkge1xuICAgICAgaWYgKGxhc3RNYXBwaW5nKSB7XG4gICAgICAgIC8vIEFzc29jaWF0ZSB0aGUgcmVtYWluaW5nIGNvZGUgaW4gdGhlIGN1cnJlbnQgbGluZSB3aXRoIFwibGFzdE1hcHBpbmdcIlxuICAgICAgICBhZGRNYXBwaW5nV2l0aENvZGUobGFzdE1hcHBpbmcsIHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICB9XG4gICAgICAvLyBhbmQgYWRkIHRoZSByZW1haW5pbmcgbGluZXMgd2l0aG91dCBhbnkgbWFwcGluZ1xuICAgICAgbm9kZS5hZGQocmVtYWluaW5nTGluZXMuc3BsaWNlKHJlbWFpbmluZ0xpbmVzSW5kZXgpLmpvaW4oXCJcIikpO1xuICAgIH1cblxuICAgIC8vIENvcHkgc291cmNlc0NvbnRlbnQgaW50byBTb3VyY2VOb2RlXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlRmlsZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlQ29udGVudEZvcihzb3VyY2VGaWxlKTtcbiAgICAgIGlmIChjb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGFSZWxhdGl2ZVBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgc291cmNlRmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG5cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nV2l0aENvZGUobWFwcGluZywgY29kZSkge1xuICAgICAgaWYgKG1hcHBpbmcgPT09IG51bGwgfHwgbWFwcGluZy5zb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmFkZChjb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhUmVsYXRpdmVQYXRoXG4gICAgICAgICAgPyB1dGlsLmpvaW4oYVJlbGF0aXZlUGF0aCwgbWFwcGluZy5zb3VyY2UpXG4gICAgICAgICAgOiBtYXBwaW5nLnNvdXJjZTtcbiAgICAgICAgbm9kZS5hZGQobmV3IFNvdXJjZU5vZGUobWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5uYW1lKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGlzIHNvdXJjZSBub2RlLlxuICpcbiAqIEBwYXJhbSBhQ2h1bmsgQSBzdHJpbmcgc25pcHBldCBvZiBnZW5lcmF0ZWQgSlMgY29kZSwgYW5vdGhlciBpbnN0YW5jZSBvZlxuICogICAgICAgIFNvdXJjZU5vZGUsIG9yIGFuIGFycmF5IHdoZXJlIGVhY2ggbWVtYmVyIGlzIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfYWRkKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgYUNodW5rLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICB0aGlzLmFkZChjaHVuayk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChhQ2h1bmspIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChhQ2h1bmspO1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJFeHBlY3RlZCBhIFNvdXJjZU5vZGUsIHN0cmluZywgb3IgYW4gYXJyYXkgb2YgU291cmNlTm9kZXMgYW5kIHN0cmluZ3MuIEdvdCBcIiArIGFDaHVua1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZCBhIGNodW5rIG9mIGdlbmVyYXRlZCBKUyB0byB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcHJlcGVuZChhQ2h1bmspIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYUNodW5rKSkge1xuICAgIGZvciAodmFyIGkgPSBhQ2h1bmsubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLnByZXBlbmQoYUNodW5rW2ldKTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoYUNodW5rW2lzU291cmNlTm9kZV0gfHwgdHlwZW9mIGFDaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRoaXMuY2hpbGRyZW4udW5zaGlmdChhQ2h1bmspO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIEpTIHNuaXBwZXRzIGluIHRoaXMgbm9kZSBhbmQgaXRzIGNoaWxkcmVuLiBUaGVcbiAqIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggc25pcHBldCBvZiBKUyBhbmQgaXMgcGFzc2VkIHRoYXRcbiAqIHNuaXBwZXQgYW5kIHRoZSBpdHMgb3JpZ2luYWwgYXNzb2NpYXRlZCBzb3VyY2UncyBsaW5lL2NvbHVtbiBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3dhbGsoYUZuKSB7XG4gIHZhciBjaHVuaztcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHVuayA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgaWYgKGNodW5rW2lzU291cmNlTm9kZV0pIHtcbiAgICAgIGNodW5rLndhbGsoYUZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoY2h1bmsgIT09ICcnKSB7XG4gICAgICAgIGFGbihjaHVuaywgeyBzb3VyY2U6IHRoaXMuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lLFxuICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTGlrZSBgU3RyaW5nLnByb3RvdHlwZS5qb2luYCBleGNlcHQgZm9yIFNvdXJjZU5vZGVzLiBJbnNlcnRzIGBhU3RyYCBiZXR3ZWVuXG4gKiBlYWNoIG9mIGB0aGlzLmNoaWxkcmVuYC5cbiAqXG4gKiBAcGFyYW0gYVNlcCBUaGUgc2VwYXJhdG9yLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gU291cmNlTm9kZV9qb2luKGFTZXApIHtcbiAgdmFyIG5ld0NoaWxkcmVuO1xuICB2YXIgaTtcbiAgdmFyIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAobGVuID4gMCkge1xuICAgIG5ld0NoaWxkcmVuID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbi0xOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgICBuZXdDaGlsZHJlbi5wdXNoKGFTZXApO1xuICAgIH1cbiAgICBuZXdDaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5baV0pO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2Ugb24gdGhlIHZlcnkgcmlnaHQtbW9zdCBzb3VyY2Ugc25pcHBldC4gVXNlZnVsXG4gKiBmb3IgdHJpbW1pbmcgd2hpdGVzcGFjZSBmcm9tIHRoZSBlbmQgb2YgYSBzb3VyY2Ugbm9kZSwgZXRjLlxuICpcbiAqIEBwYXJhbSBhUGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICogQHBhcmFtIGFSZXBsYWNlbWVudCBUaGUgdGhpbmcgdG8gcmVwbGFjZSB0aGUgcGF0dGVybiB3aXRoLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5yZXBsYWNlUmlnaHQgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3JlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KSB7XG4gIHZhciBsYXN0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIGlmIChsYXN0Q2hpbGRbaXNTb3VyY2VOb2RlXSkge1xuICAgIGxhc3RDaGlsZC5yZXBsYWNlUmlnaHQoYVBhdHRlcm4sIGFSZXBsYWNlbWVudCk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGxhc3RDaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPSBsYXN0Q2hpbGQucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goJycucmVwbGFjZShhUGF0dGVybiwgYVJlcGxhY2VtZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgU291cmNlTWFwR2VuZXJhdG9yXG4gKiBpbiB0aGUgc291cmNlc0NvbnRlbnQgZmllbGQuXG4gKlxuICogQHBhcmFtIGFTb3VyY2VGaWxlIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGVcbiAqIEBwYXJhbSBhU291cmNlQ29udGVudCBUaGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGVcbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfc2V0U291cmNlQ29udGVudChhU291cmNlRmlsZSwgYVNvdXJjZUNvbnRlbnQpIHtcbiAgICB0aGlzLnNvdXJjZUNvbnRlbnRzW3V0aWwudG9TZXRTdHJpbmcoYVNvdXJjZUZpbGUpXSA9IGFTb3VyY2VDb250ZW50O1xuICB9O1xuXG4vKipcbiAqIFdhbGsgb3ZlciB0aGUgdHJlZSBvZiBTb3VyY2VOb2Rlcy4gVGhlIHdhbGtpbmcgZnVuY3Rpb24gaXMgY2FsbGVkIGZvciBlYWNoXG4gKiBzb3VyY2UgZmlsZSBjb250ZW50IGFuZCBpcyBwYXNzZWQgdGhlIGZpbGVuYW1lIGFuZCBzb3VyY2UgY29udGVudC5cbiAqXG4gKiBAcGFyYW0gYUZuIFRoZSB0cmF2ZXJzYWwgZnVuY3Rpb24uXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLndhbGtTb3VyY2VDb250ZW50cyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2Fsa1NvdXJjZUNvbnRlbnRzKGFGbikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbltpXVtpc1NvdXJjZU5vZGVdKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baV0ud2Fsa1NvdXJjZUNvbnRlbnRzKGFGbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZXMgPSBPYmplY3Qua2V5cyh0aGlzLnNvdXJjZUNvbnRlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYUZuKHV0aWwuZnJvbVNldFN0cmluZyhzb3VyY2VzW2ldKSwgdGhpcy5zb3VyY2VDb250ZW50c1tzb3VyY2VzW2ldXSk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybiB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc291cmNlIG5vZGUuIFdhbGtzIG92ZXIgdGhlIHRyZWVcbiAqIGFuZCBjb25jYXRlbmF0ZXMgYWxsIHRoZSB2YXJpb3VzIHNuaXBwZXRzIHRvZ2V0aGVyIHRvIG9uZSBzdHJpbmcuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZygpIHtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBzdHIgKz0gY2h1bms7XG4gIH0pO1xuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZSBhbG9uZyB3aXRoIGEgc291cmNlXG4gKiBtYXAuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nV2l0aFNvdXJjZU1hcCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfdG9TdHJpbmdXaXRoU291cmNlTWFwKGFBcmdzKSB7XG4gIHZhciBnZW5lcmF0ZWQgPSB7XG4gICAgY29kZTogXCJcIixcbiAgICBsaW5lOiAxLFxuICAgIGNvbHVtbjogMFxuICB9O1xuICB2YXIgbWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncyk7XG4gIHZhciBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gIHZhciBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB2YXIgbGFzdE9yaWdpbmFsTmFtZSA9IG51bGw7XG4gIHRoaXMud2FsayhmdW5jdGlvbiAoY2h1bmssIG9yaWdpbmFsKSB7XG4gICAgZ2VuZXJhdGVkLmNvZGUgKz0gY2h1bms7XG4gICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPT0gbnVsbFxuICAgICAgICAmJiBvcmlnaW5hbC5saW5lICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmNvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgaWYobGFzdE9yaWdpbmFsU291cmNlICE9PSBvcmlnaW5hbC5zb3VyY2VcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbExpbmUgIT09IG9yaWdpbmFsLmxpbmVcbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbENvbHVtbiAhPT0gb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICB8fCBsYXN0T3JpZ2luYWxOYW1lICE9PSBvcmlnaW5hbC5uYW1lKSB7XG4gICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IG9yaWdpbmFsLnNvdXJjZSxcbiAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luYWwuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYW1lOiBvcmlnaW5hbC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gb3JpZ2luYWwuc291cmNlO1xuICAgICAgbGFzdE9yaWdpbmFsTGluZSA9IG9yaWdpbmFsLmxpbmU7XG4gICAgICBsYXN0T3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICBsYXN0T3JpZ2luYWxOYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSBjaHVuay5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGlmIChjaHVuay5jaGFyQ29kZUF0KGlkeCkgPT09IE5FV0xJTkVfQ09ERSkge1xuICAgICAgICBnZW5lcmF0ZWQubGluZSsrO1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uID0gMDtcbiAgICAgICAgLy8gTWFwcGluZ3MgZW5kIGF0IGVvbFxuICAgICAgICBpZiAoaWR4ICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgbGFzdE9yaWdpbmFsU291cmNlID0gbnVsbDtcbiAgICAgICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlTWFwcGluZ0FjdGl2ZSkge1xuICAgICAgICAgIG1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgbGluZTogb3JpZ2luYWwubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuZXJhdGVkLmNvbHVtbisrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHRoaXMud2Fsa1NvdXJjZUNvbnRlbnRzKGZ1bmN0aW9uIChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KSB7XG4gICAgbWFwLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgc291cmNlQ29udGVudCk7XG4gIH0pO1xuXG4gIHJldHVybiB7IGNvZGU6IGdlbmVyYXRlZC5jb2RlLCBtYXA6IG1hcCB9O1xufTtcblxuZXhwb3J0cy5Tb3VyY2VOb2RlID0gU291cmNlTm9kZTtcblxufSx7XCIuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yXCI6OSxcIi4vdXRpbFwiOjExfV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gZm9yIGdldHRpbmcgdmFsdWVzIGZyb20gcGFyYW1ldGVyL29wdGlvbnNcbiAqIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgVGhlIG9iamVjdCB3ZSBhcmUgZXh0cmFjdGluZyB2YWx1ZXMgZnJvbVxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHdlIGFyZSBnZXR0aW5nLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBbiBvcHRpb25hbCB2YWx1ZSB0byByZXR1cm4gaWYgdGhlIHByb3BlcnR5IGlzIG1pc3NpbmdcbiAqIGZyb20gdGhlIG9iamVjdC4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIGFuZCB0aGUgcHJvcGVydHkgaXMgbWlzc2luZywgYW5cbiAqIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICovXG5mdW5jdGlvbiBnZXRBcmcoYUFyZ3MsIGFOYW1lLCBhRGVmYXVsdFZhbHVlKSB7XG4gIGlmIChhTmFtZSBpbiBhQXJncykge1xuICAgIHJldHVybiBhQXJnc1thTmFtZV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBhRGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignXCInICsgYU5hbWUgKyAnXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudC4nKTtcbiAgfVxufVxuZXhwb3J0cy5nZXRBcmcgPSBnZXRBcmc7XG5cbnZhciB1cmxSZWdleHAgPSAvXig/OihbXFx3K1xcLS5dKyk6KT9cXC9cXC8oPzooXFx3KzpcXHcrKUApPyhbXFx3Li1dKikoPzo6KFxcZCspKT8oLiopJC87XG52YXIgZGF0YVVybFJlZ2V4cCA9IC9eZGF0YTouK1xcLC4rJC87XG5cbmZ1bmN0aW9uIHVybFBhcnNlKGFVcmwpIHtcbiAgdmFyIG1hdGNoID0gYVVybC5tYXRjaCh1cmxSZWdleHApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWU6IG1hdGNoWzFdLFxuICAgIGF1dGg6IG1hdGNoWzJdLFxuICAgIGhvc3Q6IG1hdGNoWzNdLFxuICAgIHBvcnQ6IG1hdGNoWzRdLFxuICAgIHBhdGg6IG1hdGNoWzVdXG4gIH07XG59XG5leHBvcnRzLnVybFBhcnNlID0gdXJsUGFyc2U7XG5cbmZ1bmN0aW9uIHVybEdlbmVyYXRlKGFQYXJzZWRVcmwpIHtcbiAgdmFyIHVybCA9ICcnO1xuICBpZiAoYVBhcnNlZFVybC5zY2hlbWUpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5zY2hlbWUgKyAnOic7XG4gIH1cbiAgdXJsICs9ICcvLyc7XG4gIGlmIChhUGFyc2VkVXJsLmF1dGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5hdXRoICsgJ0AnO1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLmhvc3QpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5ob3N0O1xuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBvcnQpIHtcbiAgICB1cmwgKz0gXCI6XCIgKyBhUGFyc2VkVXJsLnBvcnRcbiAgfVxuICBpZiAoYVBhcnNlZFVybC5wYXRoKSB7XG4gICAgdXJsICs9IGFQYXJzZWRVcmwucGF0aDtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy51cmxHZW5lcmF0ZSA9IHVybEdlbmVyYXRlO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBwYXRoLCBvciB0aGUgcGF0aCBwb3J0aW9uIG9mIGEgVVJMOlxuICpcbiAqIC0gUmVwbGFjZXMgY29uc2VjdXRpdmUgc2xhc2hlcyB3aXRoIG9uZSBzbGFzaC5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnLicgcGFydHMuXG4gKiAtIFJlbW92ZXMgdW5uZWNlc3NhcnkgJzxkaXI+Ly4uJyBwYXJ0cy5cbiAqXG4gKiBCYXNlZCBvbiBjb2RlIGluIHRoZSBOb2RlLmpzICdwYXRoJyBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gYVBhdGggVGhlIHBhdGggb3IgdXJsIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGFQYXRoKSB7XG4gIHZhciBwYXRoID0gYVBhdGg7XG4gIHZhciB1cmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIGlmICh1cmwpIHtcbiAgICBpZiAoIXVybC5wYXRoKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuICAgIHBhdGggPSB1cmwucGF0aDtcbiAgfVxuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKTtcblxuICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KC9cXC8rLyk7XG4gIGZvciAodmFyIHBhcnQsIHVwID0gMCwgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgcGFydCA9IHBhcnRzW2ldO1xuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCA+IDApIHtcbiAgICAgIGlmIChwYXJ0ID09PSAnJykge1xuICAgICAgICAvLyBUaGUgZmlyc3QgcGFydCBpcyBibGFuayBpZiB0aGUgcGF0aCBpcyBhYnNvbHV0ZS4gVHJ5aW5nIHRvIGdvXG4gICAgICAgIC8vIGFib3ZlIHRoZSByb290IGlzIGEgbm8tb3AuIFRoZXJlZm9yZSB3ZSBjYW4gcmVtb3ZlIGFsbCAnLi4nIHBhcnRzXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIHRoZSByb290LlxuICAgICAgICBwYXJ0cy5zcGxpY2UoaSArIDEsIHVwKTtcbiAgICAgICAgdXAgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDIpO1xuICAgICAgICB1cC0tO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoID0gcGFydHMuam9pbignLycpO1xuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHBhdGggPSBpc0Fic29sdXRlID8gJy8nIDogJy4nO1xuICB9XG5cbiAgaWYgKHVybCkge1xuICAgIHVybC5wYXRoID0gcGF0aDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUodXJsKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuXG4vKipcbiAqIEpvaW5zIHR3byBwYXRocy9VUkxzLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgam9pbmVkIHdpdGggdGhlIHJvb3QuXG4gKlxuICogLSBJZiBhUGF0aCBpcyBhIFVSTCBvciBhIGRhdGEgVVJJLCBhUGF0aCBpcyByZXR1cm5lZCwgdW5sZXNzIGFQYXRoIGlzIGFcbiAqICAgc2NoZW1lLXJlbGF0aXZlIFVSTDogVGhlbiB0aGUgc2NoZW1lIG9mIGFSb290LCBpZiBhbnksIGlzIHByZXBlbmRlZFxuICogICBmaXJzdC5cbiAqIC0gT3RoZXJ3aXNlIGFQYXRoIGlzIGEgcGF0aC4gSWYgYVJvb3QgaXMgYSBVUkwsIHRoZW4gaXRzIHBhdGggcG9ydGlvblxuICogICBpcyB1cGRhdGVkIHdpdGggdGhlIHJlc3VsdCBhbmQgYVJvb3QgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSB0aGUgcmVzdWx0XG4gKiAgIGlzIHJldHVybmVkLlxuICogICAtIElmIGFQYXRoIGlzIGFic29sdXRlLCB0aGUgcmVzdWx0IGlzIGFQYXRoLlxuICogICAtIE90aGVyd2lzZSB0aGUgdHdvIHBhdGhzIGFyZSBqb2luZWQgd2l0aCBhIHNsYXNoLlxuICogLSBKb2luaW5nIGZvciBleGFtcGxlICdodHRwOi8vJyBhbmQgJ3d3dy5leGFtcGxlLmNvbScgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cbiAgaWYgKGFQYXRoID09PSBcIlwiKSB7XG4gICAgYVBhdGggPSBcIi5cIjtcbiAgfVxuICB2YXIgYVBhdGhVcmwgPSB1cmxQYXJzZShhUGF0aCk7XG4gIHZhciBhUm9vdFVybCA9IHVybFBhcnNlKGFSb290KTtcbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3QgPSBhUm9vdFVybC5wYXRoIHx8ICcvJztcbiAgfVxuXG4gIC8vIGBqb2luKGZvbywgJy8vd3d3LmV4YW1wbGUub3JnJylgXG4gIGlmIChhUGF0aFVybCAmJiAhYVBhdGhVcmwuc2NoZW1lKSB7XG4gICAgaWYgKGFSb290VXJsKSB7XG4gICAgICBhUGF0aFVybC5zY2hlbWUgPSBhUm9vdFVybC5zY2hlbWU7XG4gICAgfVxuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUGF0aFVybCk7XG4gIH1cblxuICBpZiAoYVBhdGhVcmwgfHwgYVBhdGgubWF0Y2goZGF0YVVybFJlZ2V4cCkpIHtcbiAgICByZXR1cm4gYVBhdGg7XG4gIH1cblxuICAvLyBgam9pbignaHR0cDovLycsICd3d3cuZXhhbXBsZS5jb20nKWBcbiAgaWYgKGFSb290VXJsICYmICFhUm9vdFVybC5ob3N0ICYmICFhUm9vdFVybC5wYXRoKSB7XG4gICAgYVJvb3RVcmwuaG9zdCA9IGFQYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cblxuICB2YXIgam9pbmVkID0gYVBhdGguY2hhckF0KDApID09PSAnLydcbiAgICA/IGFQYXRoXG4gICAgOiBub3JtYWxpemUoYVJvb3QucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyBhUGF0aCk7XG5cbiAgaWYgKGFSb290VXJsKSB7XG4gICAgYVJvb3RVcmwucGF0aCA9IGpvaW5lZDtcbiAgICByZXR1cm4gdXJsR2VuZXJhdGUoYVJvb3RVcmwpO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5leHBvcnRzLmpvaW4gPSBqb2luO1xuXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbiAoYVBhdGgpIHtcbiAgcmV0dXJuIGFQYXRoLmNoYXJBdCgwKSA9PT0gJy8nIHx8IHVybFJlZ2V4cC50ZXN0KGFQYXRoKTtcbn07XG5cbi8qKlxuICogTWFrZSBhIHBhdGggcmVsYXRpdmUgdG8gYSBVUkwgb3IgYW5vdGhlciBwYXRoLlxuICpcbiAqIEBwYXJhbSBhUm9vdCBUaGUgcm9vdCBwYXRoIG9yIFVSTC5cbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciBVUkwgdG8gYmUgbWFkZSByZWxhdGl2ZSB0byBhUm9vdC5cbiAqL1xuZnVuY3Rpb24gcmVsYXRpdmUoYVJvb3QsIGFQYXRoKSB7XG4gIGlmIChhUm9vdCA9PT0gXCJcIikge1xuICAgIGFSb290ID0gXCIuXCI7XG4gIH1cblxuICBhUm9vdCA9IGFSb290LnJlcGxhY2UoL1xcLyQvLCAnJyk7XG5cbiAgLy8gSXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYXRoIHRvIGJlIGFib3ZlIHRoZSByb290LiBJbiB0aGlzIGNhc2UsIHNpbXBseVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHRoZSByb290IGlzIGEgcHJlZml4IG9mIHRoZSBwYXRoIHdvbid0IHdvcmsuIEluc3RlYWQsIHdlXG4gIC8vIG5lZWQgdG8gcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGUgcm9vdCBvbmUgYnkgb25lLCB1bnRpbCBlaXRoZXIgd2UgZmluZFxuICAvLyBhIHByZWZpeCB0aGF0IGZpdHMsIG9yIHdlIHJ1biBvdXQgb2YgY29tcG9uZW50cyB0byByZW1vdmUuXG4gIHZhciBsZXZlbCA9IDA7XG4gIHdoaWxlIChhUGF0aC5pbmRleE9mKGFSb290ICsgJy8nKSAhPT0gMCkge1xuICAgIHZhciBpbmRleCA9IGFSb290Lmxhc3RJbmRleE9mKFwiL1wiKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG9ubHkgcGFydCBvZiB0aGUgcm9vdCB0aGF0IGlzIGxlZnQgaXMgdGhlIHNjaGVtZSAoaS5lLiBodHRwOi8vLFxuICAgIC8vIGZpbGU6Ly8vLCBldGMuKSwgb25lIG9yIG1vcmUgc2xhc2hlcyAoLyksIG9yIHNpbXBseSBub3RoaW5nIGF0IGFsbCwgd2VcbiAgICAvLyBoYXZlIGV4aGF1c3RlZCBhbGwgY29tcG9uZW50cywgc28gdGhlIHBhdGggaXMgbm90IHJlbGF0aXZlIHRvIHRoZSByb290LlxuICAgIGFSb290ID0gYVJvb3Quc2xpY2UoMCwgaW5kZXgpO1xuICAgIGlmIChhUm9vdC5tYXRjaCgvXihbXlxcL10rOlxcLyk/XFwvKiQvKSkge1xuICAgICAgcmV0dXJuIGFQYXRoO1xuICAgIH1cblxuICAgICsrbGV2ZWw7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgYWRkIGEgXCIuLi9cIiBmb3IgZWFjaCBjb21wb25lbnQgd2UgcmVtb3ZlZCBmcm9tIHRoZSByb290LlxuICByZXR1cm4gQXJyYXkobGV2ZWwgKyAxKS5qb2luKFwiLi4vXCIpICsgYVBhdGguc3Vic3RyKGFSb290Lmxlbmd0aCArIDEpO1xufVxuZXhwb3J0cy5yZWxhdGl2ZSA9IHJlbGF0aXZlO1xuXG52YXIgc3VwcG9ydHNOdWxsUHJvdG8gPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuICEoJ19fcHJvdG9fXycgaW4gb2JqKTtcbn0oKSk7XG5cbmZ1bmN0aW9uIGlkZW50aXR5IChzKSB7XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIEJlY2F1c2UgYmVoYXZpb3IgZ29lcyB3YWNreSB3aGVuIHlvdSBzZXQgYF9fcHJvdG9fX2Agb24gb2JqZWN0cywgd2VcbiAqIGhhdmUgdG8gcHJlZml4IGFsbCB0aGUgc3RyaW5ncyBpbiBvdXIgc2V0IHdpdGggYW4gYXJiaXRyYXJ5IGNoYXJhY3Rlci5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9wdWxsLzMxIGFuZFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9pc3N1ZXMvMzBcbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuZnVuY3Rpb24gdG9TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiAnJCcgKyBhU3RyO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLnRvU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IHRvU2V0U3RyaW5nO1xuXG5mdW5jdGlvbiBmcm9tU2V0U3RyaW5nKGFTdHIpIHtcbiAgaWYgKGlzUHJvdG9TdHJpbmcoYVN0cikpIHtcbiAgICByZXR1cm4gYVN0ci5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBhU3RyO1xufVxuZXhwb3J0cy5mcm9tU2V0U3RyaW5nID0gc3VwcG9ydHNOdWxsUHJvdG8gPyBpZGVudGl0eSA6IGZyb21TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzUHJvdG9TdHJpbmcocykge1xuICBpZiAoIXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA8IDkgLyogXCJfX3Byb3RvX19cIi5sZW5ndGggKi8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocy5jaGFyQ29kZUF0KGxlbmd0aCAtIDEpICE9PSA5NSAgLyogJ18nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMikgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAzKSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDQpICE9PSAxMTYgLyogJ3QnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNSkgIT09IDExMSAvKiAnbycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA2KSAhPT0gMTE0IC8qICdyJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDcpICE9PSAxMTIgLyogJ3AnICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gOCkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA5KSAhPT0gOTUgIC8qICdfJyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSBsZW5ndGggLSAxMDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocy5jaGFyQ29kZUF0KGkpICE9PSAzNiAvKiAnJCcgKi8pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb21wYXJhdG9yIGJldHdlZW4gdHdvIG1hcHBpbmdzIHdoZXJlIHRoZSBvcmlnaW5hbCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgb3JpZ2luYWwgc291cmNlL2xpbmUvY29sdW1uLCBidXQgZGlmZmVyZW50IGdlbmVyYXRlZFxuICogbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGEgbWFwcGluZyB3aXRoIGFcbiAqIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVPcmlnaW5hbCkge1xuICB2YXIgY21wID0gc3RyY21wKG1hcHBpbmdBLnNvdXJjZSwgbWFwcGluZ0Iuc291cmNlKTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbExpbmUgLSBtYXBwaW5nQi5vcmlnaW5hbExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxDb2x1bW4gLSBtYXBwaW5nQi5vcmlnaW5hbENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lIC0gbWFwcGluZ0IuZ2VuZXJhdGVkTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICByZXR1cm4gc3RyY21wKG1hcHBpbmdBLm5hbWUsIG1hcHBpbmdCLm5hbWUpO1xufVxuZXhwb3J0cy5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyA9IGNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zO1xuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBkZWZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgaW5kaWNlcyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICpcbiAqIE9wdGlvbmFsbHkgcGFzcyBpbiBgdHJ1ZWAgYXMgYG9ubHlDb21wYXJlR2VuZXJhdGVkYCB0byBjb25zaWRlciB0d29cbiAqIG1hcHBpbmdzIHdpdGggdGhlIHNhbWUgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiwgYnV0IGRpZmZlcmVudFxuICogc291cmNlL25hbWUvb3JpZ2luYWwgbGluZSBhbmQgY29sdW1uIHRoZSBzYW1lLiBVc2VmdWwgd2hlbiBzZWFyY2hpbmcgZm9yIGFcbiAqIG1hcHBpbmcgd2l0aCBhIHN0dWJiZWQgb3V0IG1hcHBpbmcuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQiwgb25seUNvbXBhcmVHZW5lcmF0ZWQpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCB8fCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQ7XG5cbmZ1bmN0aW9uIHN0cmNtcChhU3RyMSwgYVN0cjIpIHtcbiAgaWYgKGFTdHIxID09PSBhU3RyMikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGFTdHIxID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7IC8vIGFTdHIyICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7IC8vIGFTdHIxICE9PSBudWxsXG4gIH1cblxuICBpZiAoYVN0cjEgPiBhU3RyMikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2l0aCBpbmZsYXRlZCBzb3VyY2UgYW5kIG5hbWUgc3RyaW5ncyB3aGVyZVxuICogdGhlIGdlbmVyYXRlZCBwb3NpdGlvbnMgYXJlIGNvbXBhcmVkLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIHtcbiAgdmFyIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbiAtIG1hcHBpbmdCLmdlbmVyYXRlZENvbHVtbjtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkID0gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQ7XG5cbi8qKlxuICogU3RyaXAgYW55IEpTT04gWFNTSSBhdm9pZGFuY2UgcHJlZml4IGZyb20gdGhlIHN0cmluZyAoYXMgZG9jdW1lbnRlZFxuICogaW4gdGhlIHNvdXJjZSBtYXBzIHNwZWNpZmljYXRpb24pLCBhbmQgdGhlbiBwYXJzZSB0aGUgc3RyaW5nIGFzXG4gKiBKU09OLlxuICovXG5mdW5jdGlvbiBwYXJzZVNvdXJjZU1hcElucHV0KHN0cikge1xuICByZXR1cm4gSlNPTi5wYXJzZShzdHIucmVwbGFjZSgvXlxcKV19J1teXFxuXSpcXG4vLCAnJykpO1xufVxuZXhwb3J0cy5wYXJzZVNvdXJjZU1hcElucHV0ID0gcGFyc2VTb3VyY2VNYXBJbnB1dDtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBVUkwgb2YgYSBzb3VyY2UgZ2l2ZW4gdGhlIHRoZSBzb3VyY2Ugcm9vdCwgdGhlIHNvdXJjZSdzXG4gKiBVUkwsIGFuZCB0aGUgc291cmNlIG1hcCdzIFVSTC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVNvdXJjZVVSTChzb3VyY2VSb290LCBzb3VyY2VVUkwsIHNvdXJjZU1hcFVSTCkge1xuICBzb3VyY2VVUkwgPSBzb3VyY2VVUkwgfHwgJyc7XG5cbiAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAvLyBUaGlzIGZvbGxvd3Mgd2hhdCBDaHJvbWUgZG9lcy5cbiAgICBpZiAoc291cmNlUm9vdFtzb3VyY2VSb290Lmxlbmd0aCAtIDFdICE9PSAnLycgJiYgc291cmNlVVJMWzBdICE9PSAnLycpIHtcbiAgICAgIHNvdXJjZVJvb3QgKz0gJy8nO1xuICAgIH1cbiAgICAvLyBUaGUgc3BlYyBzYXlzOlxuICAgIC8vICAgTGluZSA0OiBBbiBvcHRpb25hbCBzb3VyY2Ugcm9vdCwgdXNlZnVsIGZvciByZWxvY2F0aW5nIHNvdXJjZVxuICAgIC8vICAgZmlsZXMgb24gYSBzZXJ2ZXIgb3IgcmVtb3ZpbmcgcmVwZWF0ZWQgdmFsdWVzIGluIHRoZVxuICAgIC8vICAg4oCcc291cmNlc+KAnSBlbnRyeS4gIFRoaXMgdmFsdWUgaXMgcHJlcGVuZGVkIHRvIHRoZSBpbmRpdmlkdWFsXG4gICAgLy8gICBlbnRyaWVzIGluIHRoZSDigJxzb3VyY2XigJ0gZmllbGQuXG4gICAgc291cmNlVVJMID0gc291cmNlUm9vdCArIHNvdXJjZVVSTDtcbiAgfVxuXG4gIC8vIEhpc3RvcmljYWxseSwgU291cmNlTWFwQ29uc3VtZXIgZGlkIG5vdCB0YWtlIHRoZSBzb3VyY2VNYXBVUkwgYXNcbiAgLy8gYSBwYXJhbWV0ZXIuICBUaGlzIG1vZGUgaXMgc3RpbGwgc29tZXdoYXQgc3VwcG9ydGVkLCB3aGljaCBpcyB3aHlcbiAgLy8gdGhpcyBjb2RlIGJsb2NrIGlzIGNvbmRpdGlvbmFsLiAgSG93ZXZlciwgaXQncyBwcmVmZXJhYmxlIHRvIHBhc3NcbiAgLy8gdGhlIHNvdXJjZSBtYXAgVVJMIHRvIFNvdXJjZU1hcENvbnN1bWVyLCBzbyB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgLy8gY2FuIGltcGxlbWVudCB0aGUgc291cmNlIFVSTCByZXNvbHV0aW9uIGFsZ29yaXRobSBhcyBvdXRsaW5lZCBpblxuICAvLyB0aGUgc3BlYy4gIFRoaXMgYmxvY2sgaXMgYmFzaWNhbGx5IHRoZSBlcXVpdmFsZW50IG9mOlxuICAvLyAgICBuZXcgVVJMKHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKS50b1N0cmluZygpXG4gIC8vIC4uLiBleGNlcHQgaXQgYXZvaWRzIHVzaW5nIFVSTCwgd2hpY2ggd2Fzbid0IGF2YWlsYWJsZSBpbiB0aGVcbiAgLy8gb2xkZXIgcmVsZWFzZXMgb2Ygbm9kZSBzdGlsbCBzdXBwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxuICAvL1xuICAvLyBUaGUgc3BlYyBzYXlzOlxuICAvLyAgIElmIHRoZSBzb3VyY2VzIGFyZSBub3QgYWJzb2x1dGUgVVJMcyBhZnRlciBwcmVwZW5kaW5nIG9mIHRoZVxuICAvLyAgIOKAnHNvdXJjZVJvb3TigJ0sIHRoZSBzb3VyY2VzIGFyZSByZXNvbHZlZCByZWxhdGl2ZSB0byB0aGVcbiAgLy8gICBTb3VyY2VNYXAgKGxpa2UgcmVzb2x2aW5nIHNjcmlwdCBzcmMgaW4gYSBodG1sIGRvY3VtZW50KS5cbiAgaWYgKHNvdXJjZU1hcFVSTCkge1xuICAgIHZhciBwYXJzZWQgPSB1cmxQYXJzZShzb3VyY2VNYXBVUkwpO1xuICAgIGlmICghcGFyc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzb3VyY2VNYXBVUkwgY291bGQgbm90IGJlIHBhcnNlZFwiKTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAvLyBTdHJpcCB0aGUgbGFzdCBwYXRoIGNvbXBvbmVudCwgYnV0IGtlZXAgdGhlIFwiL1wiLlxuICAgICAgdmFyIGluZGV4ID0gcGFyc2VkLnBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gcGFyc2VkLnBhdGguc3Vic3RyaW5nKDAsIGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZVVSTCA9IGpvaW4odXJsR2VuZXJhdGUocGFyc2VkKSwgc291cmNlVVJMKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemUoc291cmNlVVJMKTtcbn1cbmV4cG9ydHMuY29tcHV0ZVNvdXJjZVVSTCA9IGNvbXB1dGVTb3VyY2VVUkw7XG5cbn0se31dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuXG59LHtcIi4vbGliL3NvdXJjZS1tYXAtY29uc3VtZXJcIjo4LFwiLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3JcIjo5LFwiLi9saWIvc291cmNlLW5vZGVcIjoxMH1dLFwiL2xpYi9vcGFsL2NsaV9ydW5uZXJzL3NvdXJjZS1tYXAtc3VwcG9ydC5qc1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIElNUE9SVEFOVCBOT1RJQ0U6XG4vLyBSZW1lbWJlciB0byB1cGRhdGUgdGhlIGJyb3dzZXIgdmVyc2lvbiB3aGVuZXZlciB0aGlzIGZpbGUgaXMgY2hhbmdlZCxcbi8vIHRvIGRvIHNvLCBgcnVuIGJpbi9idWlsZC1icm93c2VyLXNvdXJjZS1tYXAtc3VwcG9ydGBcblxuLy8gVGhlIGZvbGxvd2luZyBpcyB0YWtlbiBhbmQgYWRhcHRlZCBmcm9tIHRoZSB3b3JrIG9mIEV2YW4gV2FsbGFjZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0IHYwLjUuMTlcblxuLy8gVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0IEV2YW4gV2FsbGFjZVxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbi8vIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5cbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUoJ3NvdXJjZS1tYXAnKS5Tb3VyY2VNYXBDb25zdW1lcjtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG52YXIgZnM7XG50cnkge1xuICBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIGlmICghZnMuZXhpc3RzU3luYyB8fCAhZnMucmVhZEZpbGVTeW5jKSB7XG4gICAgLy8gZnMgZG9lc24ndCBoYXZlIGFsbCBtZXRob2RzIHdlIG5lZWRcbiAgICBmcyA9IG51bGw7XG4gIH1cbn0gY2F0Y2ggKGVycikge1xuICAvKiBub3AgKi9cbn1cblxudmFyIGJ1ZmZlckZyb20gPSByZXF1aXJlKCdidWZmZXItZnJvbScpO1xuXG4vKipcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIHdoaWNoIGlzIHByb3RlY3RlZCBhZ2FpbnN0IGJ1bmRsZXIgbWluaWZpY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB7Tm9kZU1vZHVsZX0gbW9kXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdFxuICovXG5mdW5jdGlvbiBkeW5hbWljUmVxdWlyZShtb2QsIHJlcXVlc3QpIHtcbiAgcmV0dXJuIG1vZC5yZXF1aXJlKHJlcXVlc3QpO1xufSAgXG5cbi8vIE9ubHkgaW5zdGFsbCBvbmNlIGlmIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xudmFyIGVycm9yRm9ybWF0dGVySW5zdGFsbGVkID0gZmFsc2U7XG52YXIgdW5jYXVnaHRTaGltSW5zdGFsbGVkID0gZmFsc2U7XG5cbi8vIElmIHRydWUsIHRoZSBjYWNoZXMgYXJlIHJlc2V0IGJlZm9yZSBhIHN0YWNrIHRyYWNlIGZvcm1hdHRpbmcgb3BlcmF0aW9uXG52YXIgZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zID0gZmFsc2U7XG5cbi8vIFN1cHBvcnRzIHticm93c2VyLCBub2RlLCBhdXRvfVxudmFyIGVudmlyb25tZW50ID0gXCJhdXRvXCI7XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZmlsZSBjb250ZW50c1xudmFyIGZpbGVDb250ZW50c0NhY2hlID0ge307XG5cbi8vIE1hcHMgYSBmaWxlIHBhdGggdG8gYSBzb3VyY2UgbWFwIGZvciB0aGF0IGZpbGVcbnZhciBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuXG4vLyBSZWdleCBmb3IgZGV0ZWN0aW5nIHNvdXJjZSBtYXBzXG52YXIgcmVTb3VyY2VNYXAgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uW14sXStiYXNlNjQsLztcblxuLy8gUHJpb3JpdHkgbGlzdCBvZiByZXRyaWV2ZSBoYW5kbGVyc1xudmFyIHJldHJpZXZlRmlsZUhhbmRsZXJzID0gW107XG52YXIgcmV0cmlldmVNYXBIYW5kbGVycyA9IFtdO1xuXG5mdW5jdGlvbiBpc0luQnJvd3NlcigpIHtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcImJyb3dzZXJcIilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVudmlyb25tZW50ID09PSBcIm5vZGVcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiAoKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSAmJiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSAmJiAhKHdpbmRvdy5yZXF1aXJlICYmIHdpbmRvdy5tb2R1bGUgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiKSk7XG59XG5cbmZ1bmN0aW9uIGhhc0dsb2JhbFByb2Nlc3NFdmVudEVtaXR0ZXIoKSB7XG4gIHJldHVybiAoKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JykgJiYgKHByb2Nlc3MgIT09IG51bGwpICYmICh0eXBlb2YgcHJvY2Vzcy5vbiA9PT0gJ2Z1bmN0aW9uJykpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVyRXhlYyhsaXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSBsaXN0W2ldKGFyZyk7XG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG52YXIgcmV0cmlldmVGaWxlID0gaGFuZGxlckV4ZWMocmV0cmlldmVGaWxlSGFuZGxlcnMpO1xuXG5yZXRyaWV2ZUZpbGVIYW5kbGVycy5wdXNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgLy8gVHJpbSB0aGUgcGF0aCB0byBtYWtlIHN1cmUgdGhlcmUgaXMgbm8gZXh0cmEgd2hpdGVzcGFjZS5cbiAgcGF0aCA9IHBhdGgudHJpbSgpO1xuICBpZiAoL15maWxlOi8udGVzdChwYXRoKSkge1xuICAgIC8vIGV4aXN0c1N5bmMvcmVhZEZpbGVTeW5jIGNhbid0IGhhbmRsZSBmaWxlIHByb3RvY29sLCBidXQgb25jZSBzdHJpcHBlZCwgaXQgd29ya3NcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9maWxlOlxcL1xcL1xcLyhcXHc6KT8vLCBmdW5jdGlvbihwcm90b2NvbCwgZHJpdmUpIHtcbiAgICAgIHJldHVybiBkcml2ZSA/XG4gICAgICAgICcnIDogLy8gZmlsZTovLy9DOi9kaXIvZmlsZSAtPiBDOi9kaXIvZmlsZVxuICAgICAgICAnLyc7IC8vIGZpbGU6Ly8vcm9vdC1kaXIvZmlsZSAtPiAvcm9vdC1kaXIvZmlsZVxuICAgIH0pO1xuICB9XG4gIGlmIChwYXRoIGluIGZpbGVDb250ZW50c0NhY2hlKSB7XG4gICAgcmV0dXJuIGZpbGVDb250ZW50c0NhY2hlW3BhdGhdO1xuICB9XG5cbiAgdmFyIGNvbnRlbnRzID0gJyc7XG4gIHRyeSB7XG4gICAgaWYgKCFmcykge1xuICAgICAgLy8gVXNlIFNKQVggaWYgd2UgYXJlIGluIHRoZSBicm93c2VyXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgLyoqIGFzeW5jICovIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0ICYmIHhoci5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICBjb250ZW50cyA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHVzZSB0aGUgZmlsZXN5c3RlbVxuICAgICAgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMocGF0aCwgJ3V0ZjgnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgLyogaWdub3JlIGFueSBlcnJvcnMgKi9cbiAgfVxuXG4gIHJldHVybiBmaWxlQ29udGVudHNDYWNoZVtwYXRoXSA9IGNvbnRlbnRzO1xufSk7XG5cbi8vIFN1cHBvcnQgVVJMcyByZWxhdGl2ZSB0byBhIGRpcmVjdG9yeSwgYnV0IGJlIGNhcmVmdWwgYWJvdXQgYSBwcm90b2NvbCBwcmVmaXhcbi8vIGluIGNhc2Ugd2UgYXJlIGluIHRoZSBicm93c2VyIChpLmUuIGRpcmVjdG9yaWVzIG1heSBzdGFydCB3aXRoIFwiaHR0cDovL1wiIG9yIFwiZmlsZTovLy9cIilcbmZ1bmN0aW9uIHN1cHBvcnRSZWxhdGl2ZVVSTChmaWxlLCB1cmwpIHtcbiAgLy8gRm9yY2UgZmlsZSB0byBudWxsIG90aGVyd2lzZSBpdCB3aWxsIHJlbGF0aXZpemUgbG9jYXRpb25zIHRvIHRoZSBjdXJyZW50IGZpbGVcbiAgZmlsZSA9IG51bGxcblxuICBpZiAoIWZpbGUpIHJldHVybiB1cmw7XG4gIHZhciBkaXIgPSBwYXRoLmRpcm5hbWUoZmlsZSk7XG4gIHZhciBtYXRjaCA9IC9eXFx3KzpcXC9cXC9bXlxcL10qLy5leGVjKGRpcik7XG4gIHZhciBwcm90b2NvbCA9IG1hdGNoID8gbWF0Y2hbMF0gOiAnJztcbiAgdmFyIHN0YXJ0UGF0aCA9IGRpci5zbGljZShwcm90b2NvbC5sZW5ndGgpO1xuICBpZiAocHJvdG9jb2wgJiYgL15cXC9cXHdcXDovLnRlc3Qoc3RhcnRQYXRoKSkge1xuICAgIC8vIGhhbmRsZSBmaWxlOi8vL0M6LyBwYXRoc1xuICAgIHByb3RvY29sICs9ICcvJztcbiAgICByZXR1cm4gcHJvdG9jb2wgKyBwYXRoLnJlc29sdmUoZGlyLnNsaWNlKHByb3RvY29sLmxlbmd0aCksIHVybCkucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICB9XG4gIHJldHVybiBwcm90b2NvbCArIHBhdGgucmVzb2x2ZShkaXIuc2xpY2UocHJvdG9jb2wubGVuZ3RoKSwgdXJsKTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKSB7XG4gIHZhciBmaWxlRGF0YTtcblxuICBpZiAoaXNJbkJyb3dzZXIoKSkge1xuICAgICB0cnkge1xuICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICB4aHIub3BlbignR0VUJywgc291cmNlLCBmYWxzZSk7XG4gICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgZmlsZURhdGEgPSB4aHIucmVhZHlTdGF0ZSA9PT0gNCA/IHhoci5yZXNwb25zZVRleHQgOiBudWxsO1xuXG4gICAgICAgLy8gU3VwcG9ydCBwcm92aWRpbmcgYSBzb3VyY2VNYXBwaW5nVVJMIHZpYSB0aGUgU291cmNlTWFwIGhlYWRlclxuICAgICAgIHZhciBzb3VyY2VNYXBIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJTb3VyY2VNYXBcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiWC1Tb3VyY2VNYXBcIik7XG4gICAgICAgaWYgKHNvdXJjZU1hcEhlYWRlcikge1xuICAgICAgICAgcmV0dXJuIHNvdXJjZU1hcEhlYWRlcjtcbiAgICAgICB9XG4gICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgfVxuICB9XG5cbiAgLy8gR2V0IHRoZSBVUkwgb2YgdGhlIHNvdXJjZSBtYXBcbiAgZmlsZURhdGEgPSByZXRyaWV2ZUZpbGUoc291cmNlKTtcbiAgdmFyIHJlID0gLyg/OlxcL1xcL1tAI11bXFxzXSpzb3VyY2VNYXBwaW5nVVJMPShbXlxccydcIl0rKVtcXHNdKiQpfCg/OlxcL1xcKltAI11bXFxzXSpzb3VyY2VNYXBwaW5nVVJMPShbXlxccyonXCJdKylbXFxzXSooPzpcXCpcXC8pW1xcc10qJCkvbWc7XG4gIC8vIEtlZXAgZXhlY3V0aW5nIHRoZSBzZWFyY2ggdG8gZmluZCB0aGUgKmxhc3QqIHNvdXJjZU1hcHBpbmdVUkwgdG8gYXZvaWRcbiAgLy8gcGlja2luZyB1cCBzb3VyY2VNYXBwaW5nVVJMcyBmcm9tIGNvbW1lbnRzLCBzdHJpbmdzLCBldGMuXG4gIHZhciBsYXN0TWF0Y2gsIG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKGZpbGVEYXRhKSkgbGFzdE1hdGNoID0gbWF0Y2g7XG4gIGlmICghbGFzdE1hdGNoKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGxhc3RNYXRjaFsxXTtcbn07XG5cbi8vIENhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSByZXRyaWV2ZVNvdXJjZU1hcCBvcHRpb24gdG8gaW5zdGFsbC4gVGFrZXMgYVxuLy8gZ2VuZXJhdGVkIHNvdXJjZSBmaWxlbmFtZTsgcmV0dXJucyBhIHttYXAsIG9wdGlvbmFsIHVybH0gb2JqZWN0LCBvciBudWxsIGlmXG4vLyB0aGVyZSBpcyBubyBzb3VyY2UgbWFwLiAgVGhlIG1hcCBmaWVsZCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIHRoZSBwYXJzZWRcbi8vIEpTT04gb2JqZWN0IChpZSwgaXQgbXVzdCBiZSBhIHZhbGlkIGFyZ3VtZW50IHRvIHRoZSBTb3VyY2VNYXBDb25zdW1lclxuLy8gY29uc3RydWN0b3IpLlxudmFyIHJldHJpZXZlU291cmNlTWFwID0gaGFuZGxlckV4ZWMocmV0cmlldmVNYXBIYW5kbGVycyk7XG5yZXRyaWV2ZU1hcEhhbmRsZXJzLnB1c2goZnVuY3Rpb24oc291cmNlKSB7XG4gIHZhciBzb3VyY2VNYXBwaW5nVVJMID0gcmV0cmlldmVTb3VyY2VNYXBVUkwoc291cmNlKTtcbiAgaWYgKCFzb3VyY2VNYXBwaW5nVVJMKSByZXR1cm4gbnVsbDtcblxuICAvLyBSZWFkIHRoZSBjb250ZW50cyBvZiB0aGUgc291cmNlIG1hcFxuICB2YXIgc291cmNlTWFwRGF0YTtcbiAgaWYgKHJlU291cmNlTWFwLnRlc3Qoc291cmNlTWFwcGluZ1VSTCkpIHtcbiAgICAvLyBTdXBwb3J0IHNvdXJjZSBtYXAgVVJMIGFzIGEgZGF0YSB1cmxcbiAgICB2YXIgcmF3RGF0YSA9IHNvdXJjZU1hcHBpbmdVUkwuc2xpY2Uoc291cmNlTWFwcGluZ1VSTC5pbmRleE9mKCcsJykgKyAxKTtcbiAgICBzb3VyY2VNYXBEYXRhID0gYnVmZmVyRnJvbShyYXdEYXRhLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIHNvdXJjZU1hcHBpbmdVUkwgPSBzb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VwcG9ydCBzb3VyY2UgbWFwIFVSTHMgcmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBVUkxcbiAgICBzb3VyY2VNYXBwaW5nVVJMID0gc3VwcG9ydFJlbGF0aXZlVVJMKHNvdXJjZSwgc291cmNlTWFwcGluZ1VSTCk7XG4gICAgc291cmNlTWFwRGF0YSA9IHJldHJpZXZlRmlsZShzb3VyY2VNYXBwaW5nVVJMKTtcbiAgfVxuXG4gIGlmICghc291cmNlTWFwRGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHNvdXJjZU1hcHBpbmdVUkwsXG4gICAgbWFwOiBzb3VyY2VNYXBEYXRhXG4gIH07XG59KTtcblxuZnVuY3Rpb24gbWFwU291cmNlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV07XG4gIGlmICghc291cmNlTWFwKSB7XG4gICAgLy8gQ2FsbCB0aGUgKG92ZXJyaWRlYWJsZSkgcmV0cmlldmVTb3VyY2VNYXAgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzb3VyY2UgbWFwLlxuICAgIHZhciB1cmxBbmRNYXAgPSByZXRyaWV2ZVNvdXJjZU1hcChwb3NpdGlvbi5zb3VyY2UpO1xuICAgIGlmICh1cmxBbmRNYXApIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogdXJsQW5kTWFwLnVybCxcbiAgICAgICAgbWFwOiBuZXcgU291cmNlTWFwQ29uc3VtZXIodXJsQW5kTWFwLm1hcClcbiAgICAgIH07XG5cbiAgICAgIC8vIExvYWQgYWxsIHNvdXJjZXMgc3RvcmVkIGlubGluZSB3aXRoIHRoZSBzb3VyY2UgbWFwIGludG8gdGhlIGZpbGUgY2FjaGVcbiAgICAgIC8vIHRvIHByZXRlbmQgbGlrZSB0aGV5IGFyZSBhbHJlYWR5IGxvYWRlZC4gVGhleSBtYXkgbm90IGV4aXN0IG9uIGRpc2suXG4gICAgICBpZiAoc291cmNlTWFwLm1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICBzb3VyY2VNYXAubWFwLnNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihzb3VyY2UsIGkpIHtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSBzb3VyY2VNYXAubWFwLnNvdXJjZXNDb250ZW50W2ldO1xuICAgICAgICAgIGlmIChjb250ZW50cykge1xuICAgICAgICAgICAgdmFyIHVybCA9IHN1cHBvcnRSZWxhdGl2ZVVSTChzb3VyY2VNYXAudXJsLCBzb3VyY2UpO1xuICAgICAgICAgICAgZmlsZUNvbnRlbnRzQ2FjaGVbdXJsXSA9IGNvbnRlbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZU1hcCA9IHNvdXJjZU1hcENhY2hlW3Bvc2l0aW9uLnNvdXJjZV0gPSB7XG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgbWFwOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlc29sdmUgdGhlIHNvdXJjZSBVUkwgcmVsYXRpdmUgdG8gdGhlIFVSTCBvZiB0aGUgc291cmNlIG1hcFxuICBpZiAoc291cmNlTWFwICYmIHNvdXJjZU1hcC5tYXAgJiYgdHlwZW9mIHNvdXJjZU1hcC5tYXAub3JpZ2luYWxQb3NpdGlvbkZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBvcmlnaW5hbFBvc2l0aW9uID0gc291cmNlTWFwLm1hcC5vcmlnaW5hbFBvc2l0aW9uRm9yKHBvc2l0aW9uKTtcblxuICAgIC8vIE9ubHkgcmV0dXJuIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpZiBhIG1hdGNoaW5nIGxpbmUgd2FzIGZvdW5kLiBJZiBub1xuICAgIC8vIG1hdGNoaW5nIGxpbmUgaXMgZm91bmQgdGhlbiB3ZSByZXR1cm4gcG9zaXRpb24gaW5zdGVhZCwgd2hpY2ggd2lsbCBjYXVzZVxuICAgIC8vIHRoZSBzdGFjayB0cmFjZSB0byBwcmludCB0aGUgcGF0aCBhbmQgbGluZSBmb3IgdGhlIGNvbXBpbGVkIGZpbGUuIEl0IGlzXG4gICAgLy8gYmV0dGVyIHRvIGdpdmUgYSBwcmVjaXNlIGxvY2F0aW9uIGluIHRoZSBjb21waWxlZCBmaWxlIHRoYW4gYSB2YWd1ZVxuICAgIC8vIGxvY2F0aW9uIGluIHRoZSBvcmlnaW5hbCBmaWxlLlxuICAgIGlmIChvcmlnaW5hbFBvc2l0aW9uLnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgb3JpZ2luYWxQb3NpdGlvbi5zb3VyY2UgPSBzdXBwb3J0UmVsYXRpdmVVUkwoXG4gICAgICAgIHNvdXJjZU1hcC51cmwsIG9yaWdpbmFsUG9zaXRpb24uc291cmNlKTtcbiAgICAgIHJldHVybiBvcmlnaW5hbFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbjtcbn1cblxuLy8gUGFyc2VzIGNvZGUgZ2VuZXJhdGVkIGJ5IEZvcm1hdEV2YWxPcmlnaW4oKSwgYSBmdW5jdGlvbiBpbnNpZGUgVjg6XG4vLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL21lc3NhZ2VzLmpzXG5mdW5jdGlvbiBtYXBFdmFsT3JpZ2luKG9yaWdpbikge1xuICAvLyBNb3N0IGV2YWwoKSBjYWxscyBhcmUgaW4gdGhpcyBmb3JtYXRcbiAgdmFyIG1hdGNoID0gL15ldmFsIGZyb20gKFteKF0rKSBcXCgoLispOihcXGQrKTooXFxkKylcXCkkLy5leGVjKG9yaWdpbik7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IG1hcFNvdXJjZVBvc2l0aW9uKHtcbiAgICAgIHNvdXJjZTogbWF0Y2hbMl0sXG4gICAgICBsaW5lOiArbWF0Y2hbM10sXG4gICAgICBjb2x1bW46IG1hdGNoWzRdIC0gMVxuICAgIH0pO1xuICAgIHJldHVybiAnZXZhbCBmcm9tICcgKyBtYXRjaFsxXSArICcgKCcgKyBwb3NpdGlvbi5zb3VyY2UgKyAnOicgK1xuICAgICAgcG9zaXRpb24ubGluZSArICc6JyArIChwb3NpdGlvbi5jb2x1bW4gKyAxKSArICcpJztcbiAgfVxuXG4gIC8vIFBhcnNlIG5lc3RlZCBldmFsKCkgY2FsbHMgdXNpbmcgcmVjdXJzaW9uXG4gIG1hdGNoID0gL15ldmFsIGZyb20gKFteKF0rKSBcXCgoLispXFwpJC8uZXhlYyhvcmlnaW4pO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gJ2V2YWwgZnJvbSAnICsgbWF0Y2hbMV0gKyAnICgnICsgbWFwRXZhbE9yaWdpbihtYXRjaFsyXSkgKyAnKSc7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2Ugc3RpbGwgcmV0dXJuIHVzZWZ1bCBpbmZvcm1hdGlvbiBpZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZ1xuICByZXR1cm4gb3JpZ2luO1xufVxuXG4vLyBUaGlzIGlzIGNvcGllZCBhbG1vc3QgdmVyYmF0aW0gZnJvbSB0aGUgVjggc291cmNlIGNvZGUgYXRcbi8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3Avdjgvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvbWVzc2FnZXMuanMuIFRoZVxuLy8gaW1wbGVtZW50YXRpb24gb2Ygd3JhcENhbGxTaXRlKCkgdXNlZCB0byBqdXN0IGZvcndhcmQgdG8gdGhlIGFjdHVhbCBzb3VyY2Vcbi8vIGNvZGUgb2YgQ2FsbFNpdGUucHJvdG90eXBlLnRvU3RyaW5nIGJ1dCB1bmZvcnR1bmF0ZWx5IGEgbmV3IHJlbGVhc2Ugb2YgVjhcbi8vIGRpZCBzb21ldGhpbmcgdG8gdGhlIHByb3RvdHlwZSBjaGFpbiBhbmQgYnJva2UgdGhlIHNoaW0uIFRoZSBvbmx5IGZpeCBJXG4vLyBjb3VsZCBmaW5kIHdhcyBjb3B5L3Bhc3RlLlxuZnVuY3Rpb24gQ2FsbFNpdGVUb1N0cmluZygpIHtcbiAgdmFyIGZpbGVOYW1lO1xuICB2YXIgZmlsZUxvY2F0aW9uID0gXCJcIjtcbiAgaWYgKHRoaXMuaXNOYXRpdmUoKSkge1xuICAgIGZpbGVMb2NhdGlvbiA9IFwibmF0aXZlXCI7XG4gIH0gZWxzZSB7XG4gICAgZmlsZU5hbWUgPSB0aGlzLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICAgIGlmICghZmlsZU5hbWUgJiYgdGhpcy5pc0V2YWwoKSkge1xuICAgICAgZmlsZUxvY2F0aW9uID0gdGhpcy5nZXRFdmFsT3JpZ2luKCk7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCIsIFwiOyAgLy8gRXhwZWN0aW5nIHNvdXJjZSBwb3NpdGlvbiB0byBmb2xsb3cuXG4gICAgfVxuXG4gICAgaWYgKGZpbGVOYW1lKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gZmlsZU5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvdXJjZSBjb2RlIGRvZXMgbm90IG9yaWdpbmF0ZSBmcm9tIGEgZmlsZSBhbmQgaXMgbm90IG5hdGl2ZSwgYnV0IHdlXG4gICAgICAvLyBjYW4gc3RpbGwgZ2V0IHRoZSBzb3VyY2UgcG9zaXRpb24gaW5zaWRlIHRoZSBzb3VyY2Ugc3RyaW5nLCBlLmcuIGluXG4gICAgICAvLyBhbiBldmFsIHN0cmluZy5cbiAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjxhbm9ueW1vdXM+XCI7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVMb2NhdGlvbi5zdGFydHNXaXRoKFwiY29yZWxpYi9cIikpIHtcbiAgICAgIGZpbGVMb2NhdGlvbiA9IFwiPGludGVybmFsOlwiICsgZmlsZUxvY2F0aW9uICsgXCI+XCI7XG4gICAgfSBlbHNlIGlmIChmaWxlTG9jYXRpb24uZW5kc1dpdGgoXCIuanNcIikpIHtcbiAgICAgIGZpbGVMb2NhdGlvbiA9IFwiPGpzOlwiICsgZmlsZUxvY2F0aW9uICsgXCI+XCI7XG4gICAgfVxuXG4gICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKTtcbiAgICBpZiAobGluZU51bWJlciAhPSBudWxsKSB7XG4gICAgICBmaWxlTG9jYXRpb24gKz0gXCI6XCIgKyBsaW5lTnVtYmVyO1xuICAgICAgdmFyIGNvbHVtbk51bWJlciA9IHRoaXMuZ2V0Q29sdW1uTnVtYmVyKCk7XG4gICAgICBpZiAoY29sdW1uTnVtYmVyKSB7XG4gICAgICAgIGZpbGVMb2NhdGlvbiArPSBcIjpcIiArIGNvbHVtbk51bWJlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGluZSA9IFwiXCI7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSB0aGlzLmdldEZ1bmN0aW9uTmFtZSgpO1xuICB2YXIgYWRkU3VmZml4ID0gdHJ1ZTtcbiAgdmFyIGlzQ29uc3RydWN0b3IgPSB0aGlzLmlzQ29uc3RydWN0b3IoKTtcbiAgdmFyIGlzTWV0aG9kQ2FsbCA9ICEodGhpcy5pc1RvcGxldmVsKCkgfHwgaXNDb25zdHJ1Y3Rvcik7XG4gIGlmIChpc01ldGhvZENhbGwpIHtcbiAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLmdldFR5cGVOYW1lKCk7XG4gICAgLy8gRml4ZXMgc2hpbSB0byBiZSBiYWNrd2FyZCBjb21wYXRhYmxlIHdpdGggTm9kZSB2MCB0byB2NFxuICAgIGlmICh0eXBlTmFtZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgICAgdHlwZU5hbWUgPSBcIm51bGxcIjtcbiAgICB9XG4gICAgdmFyIG1ldGhvZE5hbWUgPSB0aGlzLmdldE1ldGhvZE5hbWUoKTtcbiAgICBpZiAoZnVuY3Rpb25OYW1lKSB7XG4gICAgICBpZiAoZnVuY3Rpb25OYW1lLnN0YXJ0c1dpdGgoXCIkJFwiKSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUuc2xpY2UoMik7XG4gICAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZS5zdGFydHNXaXRoKFwiJFwiKSkge1xuICAgICAgICBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbk5hbWUuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZU5hbWUgJiYgZnVuY3Rpb25OYW1lLmluZGV4T2YodHlwZU5hbWUpICE9IDApIHtcbiAgICAgICAgbGluZSArPSB0eXBlTmFtZSArIFwiLlwiO1xuICAgICAgfVxuICAgICAgbGluZSArPSBmdW5jdGlvbk5hbWU7XG4gICAgICBpZiAobWV0aG9kTmFtZSAmJiBmdW5jdGlvbk5hbWUuaW5kZXhPZihcIi5cIiArIG1ldGhvZE5hbWUpICE9IGZ1bmN0aW9uTmFtZS5sZW5ndGggLSBtZXRob2ROYW1lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgbGluZSArPSBcIiBbYXMgXCIgKyBtZXRob2ROYW1lICsgXCJdXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmUgKz0gdHlwZU5hbWUgKyBcIi5cIiArIChtZXRob2ROYW1lIHx8IFwiPGFub255bW91cz5cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQ29uc3RydWN0b3IpIHtcbiAgICBsaW5lICs9IFwibmV3IFwiICsgKGZ1bmN0aW9uTmFtZSB8fCBcIjxhbm9ueW1vdXM+XCIpO1xuICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSkge1xuICAgIGxpbmUgKz0gZnVuY3Rpb25OYW1lO1xuICB9IGVsc2Uge1xuICAgIGxpbmUgKz0gZmlsZUxvY2F0aW9uO1xuICAgIGFkZFN1ZmZpeCA9IGZhbHNlO1xuICB9XG4gIGlmIChhZGRTdWZmaXgpIHtcbiAgICBsaW5lICs9IFwiIChcIiArIGZpbGVMb2NhdGlvbiArIFwiKVwiO1xuICB9XG4gIGxpbmUgPSBmaWxlTG9jYXRpb24gKyBcIjppbiBgXCIgKyAoZnVuY3Rpb25OYW1lIHx8IG1ldGhvZE5hbWUpICsgXCInXCJcbiAgcmV0dXJuIGxpbmU7XG59XG5cbmZ1bmN0aW9uIGNsb25lQ2FsbFNpdGUoZnJhbWUpIHtcbiAgdmFyIG9iamVjdCA9IHt9O1xuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnJhbWUpKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBvYmplY3RbbmFtZV0gPSAvXig/OmlzfGdldCkvLnRlc3QobmFtZSkgPyBmdW5jdGlvbigpIHsgcmV0dXJuIGZyYW1lW25hbWVdLmNhbGwoZnJhbWUpOyB9IDogZnJhbWVbbmFtZV07XG4gIH0pO1xuICBvYmplY3QudG9TdHJpbmcgPSBDYWxsU2l0ZVRvU3RyaW5nO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiB3cmFwQ2FsbFNpdGUoZnJhbWUsIHN0YXRlKSB7XG4gIC8vIHByb3ZpZGVzIGludGVyZmFjZSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUgPSB7IG5leHRQb3NpdGlvbjogbnVsbCwgY3VyUG9zaXRpb246IG51bGwgfVxuICB9XG4gIGlmKGZyYW1lLmlzTmF0aXZlKCkpIHtcbiAgICBzdGF0ZS5jdXJQb3NpdGlvbiA9IG51bGw7XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gTW9zdCBjYWxsIHNpdGVzIHdpbGwgcmV0dXJuIHRoZSBzb3VyY2UgZmlsZSBmcm9tIGdldEZpbGVOYW1lKCksIGJ1dCBjb2RlXG4gIC8vIHBhc3NlZCB0byBldmFsKCkgZW5kaW5nIGluIFwiLy8jIHNvdXJjZVVSTD0uLi5cIiB3aWxsIHJldHVybiB0aGUgc291cmNlIGZpbGVcbiAgLy8gZnJvbSBnZXRTY3JpcHROYW1lT3JTb3VyY2VVUkwoKSBpbnN0ZWFkXG4gIHZhciBzb3VyY2UgPSBmcmFtZS5nZXRGaWxlTmFtZSgpIHx8IGZyYW1lLmdldFNjcmlwdE5hbWVPclNvdXJjZVVSTCgpO1xuICBpZiAoc291cmNlKSB7XG4gICAgdmFyIGxpbmUgPSBmcmFtZS5nZXRMaW5lTnVtYmVyKCk7XG4gICAgdmFyIGNvbHVtbiA9IGZyYW1lLmdldENvbHVtbk51bWJlcigpIC0gMTtcblxuICAgIC8vIEZpeCBwb3NpdGlvbiBpbiBOb2RlIHdoZXJlIHNvbWUgKGludGVybmFsKSBjb2RlIGlzIHByZXBlbmRlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L25vZGUtc291cmNlLW1hcC1zdXBwb3J0L2lzc3Vlcy8zNlxuICAgIC8vIEhlYWRlciByZW1vdmVkIGluIG5vZGUgYXQgXjEwLjE2IHx8ID49MTEuMTEuMFxuICAgIC8vIHYxMSBpcyBub3QgYW4gTFRTIGNhbmRpZGF0ZSwgd2UgY2FuIGp1c3QgdGVzdCB0aGUgb25lIHZlcnNpb24gd2l0aCBpdC5cbiAgICAvLyBUZXN0IG5vZGUgdmVyc2lvbnMgZm9yOiAxMC4xNi0xOSwgMTAuMjArLCAxMi0xOSwgMjAtOTksIDEwMCssIG9yIDExLjExXG4gICAgdmFyIG5vSGVhZGVyID0gL152KDEwXFwuMVs2LTldfDEwXFwuWzItOV1bMC05XXwxMFxcLlswLTldezMsfXwxWzItOV1cXGQqfFsyLTldXFxkfFxcZHszLH18MTFcXC4xMSkvO1xuICAgIHZhciBoZWFkZXJMZW5ndGggPSBub0hlYWRlci50ZXN0KHByb2Nlc3MudmVyc2lvbikgPyAwIDogNjI7XG4gICAgaWYgKGxpbmUgPT09IDEgJiYgY29sdW1uID4gaGVhZGVyTGVuZ3RoICYmICFpc0luQnJvd3NlcigpICYmICFmcmFtZS5pc0V2YWwoKSkge1xuICAgICAgY29sdW1uIC09IGhlYWRlckxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBtYXBTb3VyY2VQb3NpdGlvbih7XG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIGxpbmU6IGxpbmUsXG4gICAgICBjb2x1bW46IGNvbHVtblxuICAgIH0pO1xuICAgIHN0YXRlLmN1clBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgZnJhbWUgPSBjbG9uZUNhbGxTaXRlKGZyYW1lKTtcbiAgICB2YXIgb3JpZ2luYWxGdW5jdGlvbk5hbWUgPSBmcmFtZS5nZXRGdW5jdGlvbk5hbWU7XG4gICAgZnJhbWUuZ2V0RnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoc3RhdGUubmV4dFBvc2l0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25OYW1lKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RhdGUubmV4dFBvc2l0aW9uLm5hbWUgfHwgb3JpZ2luYWxGdW5jdGlvbk5hbWUoKTtcbiAgICB9O1xuICAgIGZyYW1lLmdldEZpbGVOYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgZnJhbWUuZ2V0TGluZU51bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcG9zaXRpb24ubGluZTsgfTtcbiAgICBmcmFtZS5nZXRDb2x1bW5OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHBvc2l0aW9uLmNvbHVtbiArIDE7IH07XG4gICAgZnJhbWUuZ2V0U2NyaXB0TmFtZU9yU291cmNlVVJMID0gZnVuY3Rpb24oKSB7IHJldHVybiBwb3NpdGlvbi5zb3VyY2U7IH07XG4gICAgcmV0dXJuIGZyYW1lO1xuICB9XG5cbiAgLy8gQ29kZSBjYWxsZWQgdXNpbmcgZXZhbCgpIG5lZWRzIHNwZWNpYWwgaGFuZGxpbmdcbiAgdmFyIG9yaWdpbiA9IGZyYW1lLmlzRXZhbCgpICYmIGZyYW1lLmdldEV2YWxPcmlnaW4oKTtcbiAgaWYgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IG1hcEV2YWxPcmlnaW4ob3JpZ2luKTtcbiAgICBmcmFtZSA9IGNsb25lQ2FsbFNpdGUoZnJhbWUpO1xuICAgIGZyYW1lLmdldEV2YWxPcmlnaW4gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9yaWdpbjsgfTtcbiAgICByZXR1cm4gZnJhbWU7XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHdlIHdlcmUgdW5hYmxlIHRvIGNoYW5nZSB0aGUgc291cmNlIHBvc2l0aW9uXG4gIHJldHVybiBmcmFtZTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXJ0IG9mIHRoZSBWOCBzdGFjayB0cmFjZSBBUEksIGZvciBtb3JlIGluZm8gc2VlOlxuLy8gaHR0cHM6Ly92OC5kZXYvZG9jcy9zdGFjay10cmFjZS1hcGlcbmZ1bmN0aW9uIHByZXBhcmVTdGFja1RyYWNlKGVycm9yLCBzdGFjaykge1xuICBpZiAoZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZmlsZUNvbnRlbnRzQ2FjaGUgPSB7fTtcbiAgICBzb3VyY2VNYXBDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIG5hbWUgPSBlcnJvci5uYW1lIHx8ICdFcnJvcic7XG4gIHZhciBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCAnJztcbiAgdmFyIGVycm9yU3RyaW5nID0gbmFtZSArIFwiOiBcIiArIG1lc3NhZ2U7XG5cbiAgdmFyIHN0YXRlID0geyBuZXh0UG9zaXRpb246IG51bGwsIGN1clBvc2l0aW9uOiBudWxsIH07XG4gIHZhciBwcm9jZXNzZWRTdGFjayA9IFtdO1xuICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwcm9jZXNzZWRTdGFjay5wdXNoKCdcXG4gIGZyb20gJyArIHdyYXBDYWxsU2l0ZShzdGFja1tpXSwgc3RhdGUpKTtcbiAgICBzdGF0ZS5uZXh0UG9zaXRpb24gPSBzdGF0ZS5jdXJQb3NpdGlvbjtcbiAgfVxuICBzdGF0ZS5jdXJQb3NpdGlvbiA9IHN0YXRlLm5leHRQb3NpdGlvbiA9IG51bGw7XG4gIHJldHVybiBlcnJvclN0cmluZyArIHByb2Nlc3NlZFN0YWNrLnJldmVyc2UoKS5qb2luKCcnKTtcbn1cblxuLy8gR2VuZXJhdGUgcG9zaXRpb24gYW5kIHNuaXBwZXQgb2Ygb3JpZ2luYWwgc291cmNlIHdpdGggcG9pbnRlclxuZnVuY3Rpb24gZ2V0RXJyb3JTb3VyY2UoZXJyb3IpIHtcbiAgdmFyIG1hdGNoID0gL1xcbiAgZnJvbSBbXihdKyBcXCgoLiopOihcXGQrKTooXFxkKylcXCkvLmV4ZWMoZXJyb3Iuc3RhY2spO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgc291cmNlID0gbWF0Y2hbMV07XG4gICAgdmFyIGxpbmUgPSArbWF0Y2hbMl07XG4gICAgdmFyIGNvbHVtbiA9ICttYXRjaFszXTtcblxuICAgIC8vIFN1cHBvcnQgdGhlIGlubGluZSBzb3VyY2VDb250ZW50cyBpbnNpZGUgdGhlIHNvdXJjZSBtYXBcbiAgICB2YXIgY29udGVudHMgPSBmaWxlQ29udGVudHNDYWNoZVtzb3VyY2VdO1xuXG4gICAgLy8gU3VwcG9ydCBmaWxlcyBvbiBkaXNrXG4gICAgaWYgKCFjb250ZW50cyAmJiBmcyAmJiBmcy5leGlzdHNTeW5jKHNvdXJjZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKHNvdXJjZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIGNvbnRlbnRzID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBsaW5lIGZyb20gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlIGxpa2Ugbm9kZSBkb2VzXG4gICAgaWYgKGNvbnRlbnRzKSB7XG4gICAgICB2YXIgY29kZSA9IGNvbnRlbnRzLnNwbGl0KC8oPzpcXHJcXG58XFxyfFxcbikvKVtsaW5lIC0gMV07XG4gICAgICBpZiAoY29kZSkge1xuICAgICAgICByZXR1cm4gc291cmNlICsgJzonICsgbGluZSArICdcXG4nICsgY29kZSArICdcXG4nICtcbiAgICAgICAgICBuZXcgQXJyYXkoY29sdW1uKS5qb2luKCcgJykgKyAnXic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmludEVycm9yQW5kRXhpdCAoZXJyb3IpIHtcbiAgdmFyIHNvdXJjZSA9IGdldEVycm9yU291cmNlKGVycm9yKTtcblxuICAvLyBFbnN1cmUgZXJyb3IgaXMgcHJpbnRlZCBzeW5jaHJvbm91c2x5IGFuZCBub3QgdHJ1bmNhdGVkXG4gIGlmIChwcm9jZXNzLnN0ZGVyci5faGFuZGxlICYmIHByb2Nlc3Muc3RkZXJyLl9oYW5kbGUuc2V0QmxvY2tpbmcpIHtcbiAgICBwcm9jZXNzLnN0ZGVyci5faGFuZGxlLnNldEJsb2NraW5nKHRydWUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlcnJvci4kZnVsbF9tZXNzYWdlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvci4kZnVsbF9tZXNzYWdlKCkuJGNob21wKCkpO1xuICB9XG4gIGVsc2Uge1xuICAgIGlmIChzb3VyY2UpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKTtcbiAgICAgIGNvbnNvbGUuZXJyb3Ioc291cmNlKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcbiAgfVxuICBwcm9jZXNzLmV4aXQoMSk7XG59XG5cbmZ1bmN0aW9uIHNoaW1FbWl0VW5jYXVnaHRFeGNlcHRpb24gKCkge1xuICB2YXIgb3JpZ0VtaXQgPSBwcm9jZXNzLmVtaXQ7XG5cbiAgcHJvY2Vzcy5lbWl0ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xuICAgICAgdmFyIGhhc1N0YWNrID0gKGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uc3RhY2spO1xuICAgICAgdmFyIGhhc0xpc3RlbmVycyA9ICh0aGlzLmxpc3RlbmVycyh0eXBlKS5sZW5ndGggPiAwKTtcblxuICAgICAgaWYgKGhhc1N0YWNrICYmICFoYXNMaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuIHByaW50RXJyb3JBbmRFeGl0KGFyZ3VtZW50c1sxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9yaWdFbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBvcmlnaW5hbFJldHJpZXZlRmlsZUhhbmRsZXJzID0gcmV0cmlldmVGaWxlSGFuZGxlcnMuc2xpY2UoMCk7XG52YXIgb3JpZ2luYWxSZXRyaWV2ZU1hcEhhbmRsZXJzID0gcmV0cmlldmVNYXBIYW5kbGVycy5zbGljZSgwKTtcblxuZXhwb3J0cy53cmFwQ2FsbFNpdGUgPSB3cmFwQ2FsbFNpdGU7XG5leHBvcnRzLmdldEVycm9yU291cmNlID0gZ2V0RXJyb3JTb3VyY2U7XG5leHBvcnRzLm1hcFNvdXJjZVBvc2l0aW9uID0gbWFwU291cmNlUG9zaXRpb247XG5leHBvcnRzLnJldHJpZXZlU291cmNlTWFwID0gcmV0cmlldmVTb3VyY2VNYXA7XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKG9wdGlvbnMuZW52aXJvbm1lbnQpIHtcbiAgICBlbnZpcm9ubWVudCA9IG9wdGlvbnMuZW52aXJvbm1lbnQ7XG4gICAgaWYgKFtcIm5vZGVcIiwgXCJicm93c2VyXCIsIFwiYXV0b1wiXS5pbmRleE9mKGVudmlyb25tZW50KSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVudmlyb25tZW50IFwiICsgZW52aXJvbm1lbnQgKyBcIiB3YXMgdW5rbm93bi4gQXZhaWxhYmxlIG9wdGlvbnMgYXJlIHthdXRvLCBicm93c2VyLCBub2RlfVwiKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFsbG93IHNvdXJjZXMgdG8gYmUgZm91bmQgYnkgbWV0aG9kcyBvdGhlciB0aGFuIHJlYWRpbmcgdGhlIGZpbGVzXG4gIC8vIGRpcmVjdGx5IGZyb20gZGlzay5cbiAgaWYgKG9wdGlvbnMucmV0cmlldmVGaWxlKSB7XG4gICAgaWYgKG9wdGlvbnMub3ZlcnJpZGVSZXRyaWV2ZUZpbGUpIHtcbiAgICAgIHJldHJpZXZlRmlsZUhhbmRsZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcmV0cmlldmVGaWxlSGFuZGxlcnMudW5zaGlmdChvcHRpb25zLnJldHJpZXZlRmlsZSk7XG4gIH1cblxuICAvLyBBbGxvdyBzb3VyY2UgbWFwcyB0byBiZSBmb3VuZCBieSBtZXRob2RzIG90aGVyIHRoYW4gcmVhZGluZyB0aGUgZmlsZXNcbiAgLy8gZGlyZWN0bHkgZnJvbSBkaXNrLlxuICBpZiAob3B0aW9ucy5yZXRyaWV2ZVNvdXJjZU1hcCkge1xuICAgIGlmIChvcHRpb25zLm92ZXJyaWRlUmV0cmlldmVTb3VyY2VNYXApIHtcbiAgICAgIHJldHJpZXZlTWFwSGFuZGxlcnMubGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICByZXRyaWV2ZU1hcEhhbmRsZXJzLnVuc2hpZnQob3B0aW9ucy5yZXRyaWV2ZVNvdXJjZU1hcCk7XG4gIH1cblxuICAvLyBTdXBwb3J0IHJ1bnRpbWUgdHJhbnNwaWxlcnMgdGhhdCBpbmNsdWRlIGlubGluZSBzb3VyY2UgbWFwc1xuICBpZiAob3B0aW9ucy5ob29rUmVxdWlyZSAmJiAhaXNJbkJyb3dzZXIoKSkge1xuICAgIC8vIFVzZSBkeW5hbWljUmVxdWlyZSB0byBhdm9pZCBpbmNsdWRpbmcgaW4gYnJvd3NlciBidW5kbGVzXG4gICAgdmFyIE1vZHVsZSA9IGR5bmFtaWNSZXF1aXJlKG1vZHVsZSwgJ21vZHVsZScpO1xuICAgIHZhciAkY29tcGlsZSA9IE1vZHVsZS5wcm90b3R5cGUuX2NvbXBpbGU7XG5cbiAgICBpZiAoISRjb21waWxlLl9fc291cmNlTWFwU3VwcG9ydCkge1xuICAgICAgTW9kdWxlLnByb3RvdHlwZS5fY29tcGlsZSA9IGZ1bmN0aW9uKGNvbnRlbnQsIGZpbGVuYW1lKSB7XG4gICAgICAgIGZpbGVDb250ZW50c0NhY2hlW2ZpbGVuYW1lXSA9IGNvbnRlbnQ7XG4gICAgICAgIHNvdXJjZU1hcENhY2hlW2ZpbGVuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuICRjb21waWxlLmNhbGwodGhpcywgY29udGVudCwgZmlsZW5hbWUpO1xuICAgICAgfTtcblxuICAgICAgTW9kdWxlLnByb3RvdHlwZS5fY29tcGlsZS5fX3NvdXJjZU1hcFN1cHBvcnQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbmZpZ3VyZSBvcHRpb25zXG4gIGlmICghZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zKSB7XG4gICAgZW1wdHlDYWNoZUJldHdlZW5PcGVyYXRpb25zID0gJ2VtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucycgaW4gb3B0aW9ucyA/XG4gICAgICBvcHRpb25zLmVtcHR5Q2FjaGVCZXR3ZWVuT3BlcmF0aW9ucyA6IGZhbHNlO1xuICB9XG5cbiAgLy8gSW5zdGFsbCB0aGUgZXJyb3IgcmVmb3JtYXR0ZXJcbiAgaWYgKCFlcnJvckZvcm1hdHRlckluc3RhbGxlZCkge1xuICAgIGVycm9yRm9ybWF0dGVySW5zdGFsbGVkID0gdHJ1ZTtcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXBhcmVTdGFja1RyYWNlO1xuICB9XG5cbiAgaWYgKCF1bmNhdWdodFNoaW1JbnN0YWxsZWQpIHtcbiAgICB2YXIgaW5zdGFsbEhhbmRsZXIgPSAnaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zJyBpbiBvcHRpb25zID9cbiAgICAgIG9wdGlvbnMuaGFuZGxlVW5jYXVnaHRFeGNlcHRpb25zIDogdHJ1ZTtcblxuICAgIC8vIERvIG5vdCBvdmVycmlkZSAndW5jYXVnaHRFeGNlcHRpb24nIHdpdGggb3VyIG93biBoYW5kbGVyIGluIE5vZGUuanNcbiAgICAvLyBXb3JrZXIgdGhyZWFkcy4gV29ya2VycyBwYXNzIHRoZSBlcnJvciB0byB0aGUgbWFpbiB0aHJlYWQgYXMgYW4gZXZlbnQsXG4gICAgLy8gcmF0aGVyIHRoYW4gcHJpbnRpbmcgc29tZXRoaW5nIHRvIHN0ZGVyciBhbmQgZXhpdGluZy5cbiAgICB0cnkge1xuICAgICAgLy8gV2UgbmVlZCB0byB1c2UgYGR5bmFtaWNSZXF1aXJlYCBiZWNhdXNlIGByZXF1aXJlYCBvbiBpdCdzIG93biB3aWxsIGJlIG9wdGltaXplZCBieSBXZWJQYWNrL0Jyb3dzZXJpZnkuXG4gICAgICB2YXIgd29ya2VyX3RocmVhZHMgPSBkeW5hbWljUmVxdWlyZShtb2R1bGUsICd3b3JrZXJfdGhyZWFkcycpO1xuICAgICAgaWYgKHdvcmtlcl90aHJlYWRzLmlzTWFpblRocmVhZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaW5zdGFsbEhhbmRsZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHt9ICAgICAgXG5cbiAgICAvLyBQcm92aWRlIHRoZSBvcHRpb24gdG8gbm90IGluc3RhbGwgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBoYW5kbGVyLiBUaGlzIGlzXG4gICAgLy8gdG8gc3VwcG9ydCBvdGhlciB1bmNhdWdodCBleGNlcHRpb24gaGFuZGxlcnMgKGluIHRlc3QgZnJhbWV3b3JrcywgZm9yXG4gICAgLy8gZXhhbXBsZSkuIElmIHRoaXMgaGFuZGxlciBpcyBub3QgaW5zdGFsbGVkIGFuZCB0aGVyZSBhcmUgbm8gb3RoZXIgdW5jYXVnaHRcbiAgICAvLyBleGNlcHRpb24gaGFuZGxlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgd2lsbCBiZSBjYXVnaHQgYnkgbm9kZSdzIGJ1aWx0LWluXG4gICAgLy8gZXhjZXB0aW9uIGhhbmRsZXIgYW5kIHRoZSBwcm9jZXNzIHdpbGwgc3RpbGwgYmUgdGVybWluYXRlZC4gSG93ZXZlciwgdGhlXG4gICAgLy8gZ2VuZXJhdGVkIEphdmFTY3JpcHQgY29kZSB3aWxsIGJlIHNob3duIGFib3ZlIHRoZSBzdGFjayB0cmFjZSBpbnN0ZWFkIG9mXG4gICAgLy8gdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICAgIGlmIChpbnN0YWxsSGFuZGxlciAmJiBoYXNHbG9iYWxQcm9jZXNzRXZlbnRFbWl0dGVyKCkpIHtcbiAgICAgIHVuY2F1Z2h0U2hpbUluc3RhbGxlZCA9IHRydWU7XG4gICAgICBzaGltRW1pdFVuY2F1Z2h0RXhjZXB0aW9uKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzLnJlc2V0UmV0cmlldmVIYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICByZXRyaWV2ZUZpbGVIYW5kbGVycy5sZW5ndGggPSAwO1xuICByZXRyaWV2ZU1hcEhhbmRsZXJzLmxlbmd0aCA9IDA7XG5cbiAgcmV0cmlldmVGaWxlSGFuZGxlcnMgPSBvcmlnaW5hbFJldHJpZXZlRmlsZUhhbmRsZXJzLnNsaWNlKDApO1xuICByZXRyaWV2ZU1hcEhhbmRsZXJzID0gb3JpZ2luYWxSZXRyaWV2ZU1hcEhhbmRsZXJzLnNsaWNlKDApO1xuXG4gIHJldHJpZXZlU291cmNlTWFwID0gaGFuZGxlckV4ZWMocmV0cmlldmVNYXBIYW5kbGVycyk7XG4gIHJldHJpZXZlRmlsZSA9IGhhbmRsZXJFeGVjKHJldHJpZXZlRmlsZUhhbmRsZXJzKTtcbn1cblxuLy8gQXV0b2luc3RhbGwuXG5leHBvcnRzLmluc3RhbGwoKTtcblxuLy8gUmVnZW5lcmF0ZSB0aGUgYnJvd3NlciB2ZXJzaW9uIHdpdGg6XG4vLyBicm93c2VyaWZ5IGxpYi9vcGFsL2NsaV9ydW5uZXJzL3NvdXJjZS1tYXAtc3VwcG9ydC5qcyAtcyBzb3VyY2VNYXBTdXBwb3J0IHwgdWdsaWZ5anMgLWMgPiBsaWIvb3BhbC9jbGlfcnVubmVycy9zb3VyY2UtbWFwLXN1cHBvcnQtYnJvd3Nlci5qc1xuXG4vLyA9IFN0YWNrdHJhY2UgRXhhbXBsZXM6XG4vL1xuLy8gPT0gVHJhZGl0aW9uYWwgUnVieSBzdGFja3RyYWNlOlxuLy9cbi8vIC9Vc2Vycy9lbGlhL0NvZGUvb3BhbC9saWIvb3BhbC9jbGlfcnVubmVycy9zeXN0ZW1fcnVubmVyLnJiOjQzOmluIGBjYWxsJzogdW5oYW5kbGVkIGV4Y2VwdGlvblxuLy8gICBmcm9tIC9Vc2Vycy9lbGlhL0NvZGUvb3BhbC9saWIvb3BhbC9jbGlfcnVubmVycy9ub2RlanMucmI6MTQ6aW4gYGNhbGwnXG4vLyAgIGZyb20gL1VzZXJzL2VsaWEvQ29kZS9vcGFsL2xpYi9vcGFsL2NsaV9ydW5uZXJzLnJiOjUwOmluIGBibG9jayBpbiByZWdpc3Rlcl9ydW5uZXInXG4vLyAgIGZyb20gL1VzZXJzL2VsaWEvQ29kZS9vcGFsL2xpYi9vcGFsL2NsaS5yYjo2MjppbiBgcnVuJ1xuLy8gICBmcm9tIC9Vc2Vycy9lbGlhL0NvZGUvb3BhbC9leGUvb3BhbDoyNDppbiBgPHRvcCAocmVxdWlyZWQpPidcbi8vICAgZnJvbSBiaW4vb3BhbDo0OmluIGBsb2FkJ1xuLy8gICBmcm9tIGJpbi9vcGFsOjQ6aW4gYDxtYWluPidcbi8vXG4vLyA9PSBUcmFjZWJhY2sgc3R5bGU6XG4vL1xuLy8gVHJhY2ViYWNrIChtb3N0IHJlY2VudCBjYWxsIGxhc3QpOlxuLy8gICA2OiBmcm9tIGJpbi9vcGFsOjQ6aW4gYDxtYWluPidcbi8vICAgNTogZnJvbSBiaW4vb3BhbDo0OmluIGBsb2FkJ1xuLy8gICA0OiBmcm9tIC9Vc2Vycy9lbGlhL0NvZGUvb3BhbC9leGUvb3BhbDoyNDppbiBgPHRvcCAocmVxdWlyZWQpPidcbi8vICAgMzogZnJvbSAvVXNlcnMvZWxpYS9Db2RlL29wYWwvbGliL29wYWwvY2xpLnJiOjYyOmluIGBydW4nXG4vLyAgIDI6IGZyb20gL1VzZXJzL2VsaWEvQ29kZS9vcGFsL2xpYi9vcGFsL2NsaV9ydW5uZXJzLnJiOjUwOmluIGBibG9jayBpbiByZWdpc3Rlcl9ydW5uZXInXG4vLyAgIDE6IGZyb20gL1VzZXJzL2VsaWEvQ29kZS9vcGFsL2xpYi9vcGFsL2NsaV9ydW5uZXJzL25vZGVqcy5yYjoxNDppbiBgY2FsbCdcbi8vIC9Vc2Vycy9lbGlhL0NvZGUvb3BhbC9saWIvb3BhbC9jbGlfcnVubmVycy9zeXN0ZW1fcnVubmVyLnJiOjQzOmluIGBjYWxsJzogdW5oYW5kbGVkIGV4Y2VwdGlvblxuXG59LHtcImJ1ZmZlci1mcm9tXCI6MSxcImZzXCI6dW5kZWZpbmVkLFwicGF0aFwiOnVuZGVmaW5lZCxcInNvdXJjZS1tYXBcIjoxMn1dfSx7fSxbXSkoXCIvbGliL29wYWwvY2xpX3J1bm5lcnMvc291cmNlLW1hcC1zdXBwb3J0LmpzXCIpXG59KTtcbk9wYWwubG9hZGVkKFtcIm9wYWwvY2xpX3J1bm5lcnMvc291cmNlLW1hcC1zdXBwb3J0LW5vZGUuanNcIl0pOyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFOztBQUVBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNKOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDSjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0E7QUFDSTtBQUNKO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0E7QUFDSjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDSjs7QUFFQTtBQUNDO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7O0FBRUE7QUFDQztBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDNEI7QUFDNUI7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBOztBQUVEOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNUOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0o7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFRjtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUM4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzlCO0FBQ0U7O0FBRUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNMO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDSjs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRjs7QUFFRjtBQUNDO0FBQ0E7QUFDRDs7QUFFQTtBQUNDO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRjs7QUFFRjtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDdUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNvQjtBQUN0QjtBQUNBO0FBQ0U7QUFDb0I7QUFDdEI7O0FBRUE7QUFDRjs7QUFFRjtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDSjs7QUFFRjtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0k7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNGO0FBQ0Y7O0FBRUE7QUFDSTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVGOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNEOztBQUVBO0FBQ0M7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNRO0FBQ1Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDQztBQUNBO0FBQ0g7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDRTs7QUFFQTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0M7QUFDQTtBQUNMO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFRjtBQUNDO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDNEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSjs7QUFFQTtBQUNJO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNTO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQzJCO0FBQzNCOztBQUVBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDMkI7QUFDM0I7O0FBRUE7QUFDMkI7QUFDM0I7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFRjtBQUNFO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNKO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNGOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFO0FBQ0k7QUFDTjtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEI7QUFDOUI7QUFDb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUN3QjtBQUNBO0FBQ0E7QUFDQTtBQUMxQjtBQUNGO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0U7QUFDYTtBQUNBO0FBQ0E7QUFDZjtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNGOztBQUVGO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGO0FBQ0Y7O0FBRUY7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNJO0FBQ0E7QUFDRjtBQUNHO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDQTtBQUNGO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNGO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGO0FBQ0E7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRjtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTs7QUFFRjtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0E7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNFO0FBQ0U7QUFDRjs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0Y7QUFDQTs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNGO0FBQ0U7QUFDRjtBQUNGOztBQUVBO0FBQ0U7QUFDRjs7QUFFQTtBQUNFO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0E7QUFDRjtBQUNGOztBQUVBOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNKO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0E7QUFDRjtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNGOztBQUVBO0FBQ0U7O0FBRUE7QUFDRztBQUNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDc0I7QUFDdEI7QUFDRTtBQUNGO0FBQ0Y7QUFDQTtBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRjtBQUNGOztBQUVBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjtBQUNBO0FBQ0U7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0U7QUFDQTtBQUNGO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0U7QUFDRjtBQUNBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDRTtBQUNFO0FBQ0o7QUFDRjtBQUNGO0FBQ0E7QUFDRjs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7QUFDRTtBQUNGOztBQUVBO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRTtBQUNBO0FBQ0Y7O0FBRUE7QUFDRjtBQUNBO0FBQ0Y7O0FBRUE7QUFDRTs7QUFFQTtBQUNFO0FBQ0U7QUFDQTs7QUFFQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0U7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDRTtBQUNFO0FBQ0Y7O0FBRUE7QUFDRjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRTtBQUNBO0FBQ0E7QUFDRjs7QUFFQTtBQUNGO0FBQ0Y7O0FBRUE7QUFDQTtBQUNFO0FBQ0U7QUFDSjs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNGOztBQUVBO0FBQ0U7QUFDRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNGO0FBQ0Y7QUFDRjs7QUFFQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTgwMSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vb3BhbC1wbGF0Zm9ybS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJgLyogZ2xvYmFsIEphdmEsIEdqc0ZpbGVJbXBvcnRlciAqL2BcblxuYnJvd3NlciAgICAgICAgID0gYHR5cGVvZihkb2N1bWVudCkgIT09IFwidW5kZWZpbmVkXCJgXG5ub2RlICAgICAgICAgICAgPSBgdHlwZW9mKHByb2Nlc3MpICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlYFxubmFzaG9ybiAgICAgICAgID0gYHR5cGVvZihKYXZhKSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBKYXZhLnR5cGVgXG5oZWFkbGVzc19jaHJvbWUgPSBgdHlwZW9mKG5hdmlnYXRvcikgIT09IFwidW5kZWZpbmVkXCIgJiYgL1xcYkhlYWRsZXNzQ2hyb21lXFwvLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpYFxuZ2pzICAgICAgICAgICAgID0gYHR5cGVvZih3aW5kb3cpICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZihHanNGaWxlSW1wb3J0ZXIpICE9PSAndW5kZWZpbmVkJ2Bcbm9wYWxtaW5pcmFjZXIgICA9IGB0eXBlb2Yob3BhbG1pbmlyYWNlcikgIT09ICd1bmRlZmluZWQnYFxuXG5PUEFMX1BMQVRGT1JNID0gaWYgbmFzaG9yblxuICAgICAgICAgICAgICAgICAgJ25hc2hvcm4nXG4gICAgICAgICAgICAgICAgZWxzaWYgbm9kZVxuICAgICAgICAgICAgICAgICAgJ25vZGVqcydcbiAgICAgICAgICAgICAgICBlbHNpZiBoZWFkbGVzc19jaHJvbWVcbiAgICAgICAgICAgICAgICAgICdoZWFkbGVzcy1jaHJvbWUnXG4gICAgICAgICAgICAgICAgZWxzaWYgZ2pzXG4gICAgICAgICAgICAgICAgICAnZ2pzJ1xuICAgICAgICAgICAgICAgIGVsc2lmIG9wYWxtaW5pcmFjZXJcbiAgICAgICAgICAgICAgICAgICdvcGFsLW1pbmlyYWNlcidcbiAgICAgICAgICAgICAgICBlbHNlICMgcG9zc2libHkgYnJvd3Nlciwgd2hpY2ggaXMgdGhlIHByaW1hcnkgdGFyZ2V0XG4gICAgICAgICAgICAgICAgZW5kXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsImJyb3dzZXIiLCJub2RlIiwibmFzaG9ybiIsImhlYWRsZXNzX2Nocm9tZSIsImdqcyIsIm9wYWxtaW5pcmFjZXIiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7O0VBQUNBO0VBRURDLFVBQW1CRDtFQUNuQkUsT0FBbUJGO0VBQ25CRyxVQUFtQkg7RUFDbkJJLGtCQUFtQko7RUFDbkJLLE1BQW1CTDtFQUNuQk0sZ0JBQW1CTjtFQUVuQkEsT0FBQSw2Q0FBZ0IsYUFBQSxJQUFBLFFBQUdHLE9BQUgsQ0FBQTtJQUNFSCxPQUFBQTtFQURGLE9BRUEsSUFBQSxRQUFNRSxJQUFOLENBQUE7SUFDRUYsT0FBQUE7RUFERixPQUVBLElBQUEsUUFBTUksZUFBTixDQUFBO0lBQ0VKLE9BQUFBO0VBREYsT0FFQSxJQUFBLFFBQU1LLEdBQU4sQ0FBQTtJQUNFTCxPQUFBQTtFQURGLE9BRUEsSUFBQSxRQUFNTSxhQUFOLENBQUE7SUFDRU4sT0FBQUE7RUFERjtJQWpCaEJBLE9BQUE7RUFpQmdCLENBUkEsa0JBQWhCO0FBVEFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTgyOCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5hc2hvcm4vaW8ucmIiXSwic291cmNlc0NvbnRlbnQiOlsiJHN0ZG91dC53cml0ZV9wcm9jID0gYGZ1bmN0aW9uKHMpe3ByaW50KHMpfWBcbiRzdGRlcnIud3JpdGVfcHJvYyA9IGBmdW5jdGlvbihzKXtwcmludChzKX1gXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIiR3cml0ZXIiLCJ3cml0ZV9wcm9jPSIsIiRzdGRvdXQiLCItIiwiMSIsIiRzdGRlcnIiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtFQUFBQTtBQUFBQTtBQUFBQTs7RUFBQUE7OztFQUFBQyxVQUFBLENBQXNCRCxxQkFBdEI7RUFBT0UsTUFBUEMsYUFBT0QsZUFBQUEsRUFBUCxVQUFBRCxPQUFBLENBQU9DO0VBQVBELE9BQUEsQ0FBQUcsVUFBQUgsT0FBQSxDQUFBRCxRQUFBLENBQUFJLEVBQUFDLENBQUFELENBQUE7O0VBQUFILFVBQUEsQ0FDc0JELHFCQUR0QjtFQUNPRSxNQUFQSSxhQUFPSixlQUFBQSxFQURQLFVBQUFELE9BQUEsQ0FDT0M7RUFEUEYsT0FBQUMsT0FBQSxDQUFBRyxVQUFBSCxPQUFBLENBQUFELFFBQUEsQ0FBQUksRUFBQUMsQ0FBQUQsQ0FBQTtBQUFBSjsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk4NDksImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJuYXNob3JuL2ZpbGUucmIiXSwic291cmNlc0NvbnRlbnQiOlsiYC8qIGdsb2JhbCBKYXZhICovYFxuXG5jbGFzcyBGaWxlXG4gIGRlZiBzZWxmLnJlYWQocGF0aClcbiAgICAleChcbiAgICAgICAgdmFyIFBhdGhzID0gSmF2YS50eXBlKCdqYXZhLm5pby5maWxlLlBhdGhzJyk7XG4gICAgICAgIHZhciBGaWxlcyA9IEphdmEudHlwZSgnamF2YS5uaW8uZmlsZS5GaWxlcycpO1xuICAgICAgICB2YXIgbGluZXMgPSBGaWxlcy5yZWFkQWxsTGluZXMoUGF0aHMuZ2V0KHBhdGgpLCBKYXZhLnR5cGUoJ2phdmEubmlvLmNoYXJzZXQuU3RhbmRhcmRDaGFyc2V0cycpLlVURl84KTtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lKSB7IGRhdGEucHVzaChsaW5lKTsgfSk7XG4gICAgICAgIHJldHVybiBkYXRhLmpvaW4oXCJcXG5cIik7XG4gICAgICApXG4gIGVuZFxuXG4gIGRlZiBzZWxmLmZpbGU/KHBhdGgpXG4gICAgJXh7XG4gICAgICB2YXIgRmlsZXMgPSBKYXZhLnR5cGUoJ2phdmEubmlvLmZpbGUuRmlsZXMnKTtcbiAgICAgIHJldHVybiBGaWxlcy5leGlzdHMocGF0aCkgJiYgRmlsZXMuaXNSZWd1bGFyRmlsZShwYXRoKTtcbiAgICB9XG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJlYWRhYmxlPyhwYXRoKVxuICAgICV4e1xuICAgICAgdmFyIEZpbGVzID0gSmF2YS50eXBlKCdqYXZhLm5pby5maWxlLkZpbGVzJyk7XG4gICAgICByZXR1cm4gRmlsZXMuZXhpc3RzKHBhdGgpICYmIEZpbGVzLmlzUmVhZGFibGUocGF0aCk7XG4gICAgfVxuICBlbmRcbmVuZFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8Y2xhc3M6RmlsZT4iLCJyZWFkIiwic2VsZiIsInBhdGgiLCJmaWxlPyIsInJlYWRhYmxlPyJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOzs7RUFBQ0E7RUFFREEsT0FBQUM7RUFBQUE7O0lBQUFBOzs7SUFDRUMsVUFBSUMsSUFBSkQsV0FBQUEsZUFBQUEsZ0JBQWNFLElBQWRGO0FBQUFBLE1BQUFBOzs7QUFFRkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7SUFSRUEsQ0FBQUEsMEJBQUFBO0lBV0FHLFVBQUlGLElBQUpFLFlBQUFBLG9CQUFBQSxTQUFlRCxJQUFmQztBQUFBQSxNQUFBQTs7O0FBRUZBO0FBQ0FBO0FBQ0FBO0lBSkVBLENBQUFBLCtCQUFBQTtJQU9BSixPQUFBSyxDQUFBQSxVQUFJSCxJQUFKRyxnQkFBQUEsd0JBQUFBLFNBQW1CRixJQUFuQkU7QUFBQUEsTUFBQUE7OztBQUVGQTtBQUNBQTtBQUNBQTtJQUpFQSxDQUFBQSxtQ0FBQUEsQ0FBQUE7RUFuQkZMLEdBQUFBLFdBQUFBLEVBQUFBLElBQUFBO0FBRkFEOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTg5MiwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4vbmFzaG9ybi5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUgTmFzaG9yblxuZW5kXG5cbnJlcXVpcmUgJ25hc2hvcm4vaW8nXG5yZXF1aXJlICduYXNob3JuL2ZpbGUnXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxtb2R1bGU6TmFzaG9ybj4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUM7RUFBQUE7O0lBQUFBOztJQUFBQSxPQUFBO0VBQUFBLEdBQUFBLFdBQUFBO0VBR0FDLElBQUFDLFNBQUFBLENBQVFILFlBQVJHO0VBQ0FILE9BQUFFLElBQUFDLFNBQUFBLENBQVFILGNBQVJHO0FBSkFIOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTkwOSwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImdqcy9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJgLyogZ2xvYmFsIGltcG9ydHMgKi9gXG5cbiMgQmFzaWMgdmVyc2lvbiwgYXBwZW5kcyBcXG46XG4jICRzdGRvdXQud3JpdGVfcHJvYyA9IGBmdW5jdGlvbihzKXtwcmludChzKX1gXG4jICRzdGRlcnIud3JpdGVfcHJvYyA9IGBmdW5jdGlvbihzKXtwcmludGVycihzKX1gXG5cbiMgQWR2YW5jZWQgdmVyc2lvbjpcbiV4e1xuICB2YXIgR0xpYiA9IGltcG9ydHMuZ2kuR0xpYjtcbiAgdmFyIEJ5dGVBcnJheSA9IGltcG9ydHMuYnl0ZUFycmF5O1xuXG4gIHZhciBzdGRpbiA9IEdMaWIuSU9DaGFubmVsLnVuaXhfbmV3KDApO1xuICB2YXIgc3Rkb3V0ID0gR0xpYi5JT0NoYW5uZWwudW5peF9uZXcoMSk7XG4gIHZhciBzdGRlcnIgPSBHTGliLklPQ2hhbm5lbC51bml4X25ldygyKTtcblxuICBPcGFsLmd2YXJzLnN0ZG91dC53cml0ZV9wcm9jID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBidWYgPSBCeXRlQXJyYXkuZnJvbVN0cmluZyhzKTtcbiAgICBzdGRvdXQud3JpdGVfY2hhcnMoYnVmLCBidWYubGVuZ3RoKTtcbiAgICBzdGRvdXQuZmx1c2goKTtcbiAgfVxuXG4gIE9wYWwuZ3ZhcnMuc3RkZXJyLndyaXRlX3Byb2MgPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGJ1ZiA9IEJ5dGVBcnJheS5mcm9tU3RyaW5nKHMpO1xuICAgIHN0ZGVyci53cml0ZV9jaGFycyhidWYsIGJ1Zi5sZW5ndGgpO1xuICAgIHN0ZGVyci5mbHVzaCgpO1xuICB9XG5cbiAgT3BhbC5ndmFycy5zdGRpbi5yZWFkX3Byb2MgPSBmdW5jdGlvbihfcykge1xuICAgIHZhciBvdXQgPSBzdGRpbi5yZWFkX2xpbmUoKTtcbiAgICBpZiAob3V0WzBdID09IEdMaWIuSU9TdGF0dXMuRU9GKSByZXR1cm4gbmlsO1xuICAgIHJldHVybiBvdXRbMV0udG9TdHJpbmcoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7O0VBQUNBOztBQVFEQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBL0JBQTsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk5NDMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnanMva2VybmVsLnJiIl0sInNvdXJjZXNDb250ZW50IjpbImAvKiBnbG9iYWwgQVJHViAqL2BcblxuQVJHViA9IGBBUkdWYFxuXG5gT3BhbC5leGl0ID0gaW1wb3J0cy5zeXN0ZW0uZXhpdGBcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Il0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7OztFQUFDQTtFQUVELG9DQUFRQSxJQUFSO0VBRUFBLE9BQUNBLCtCQUFEQTtBQUpBQTsifX0seyJvZmZzZXQiOnsibGluZSI6Mjk5NTMsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2dqcy5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdnanMvaW8nXG5yZXF1aXJlICdnanMva2VybmVsJ1xuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCJzZWxmIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOztFQUFBQTs7RUFBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsUUFBUkU7RUFDQUYsT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsWUFBUkU7QUFEQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjI5OTYzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibm9kZWpzL2tlcm5lbC5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJgT3BhbC5leGl0ID0gcHJvY2Vzcy5leGl0YFxuXG5tb2R1bGUgS2VybmVsXG4gIE5PREVfUkVRVUlSRSA9IGByZXF1aXJlYFxuXG4gICMgQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBgcmVxdWlyZSgnbW9kdWxlJylgIGluc3RlYWRcbiAgZGVmIG5vZGVfcmVxdWlyZShwYXRoKVxuICAgIHdhcm4gJ1tERVBSRUNBVElPTl0gbm9kZV9yZXF1aXJlIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYHJlcXVpcmUoXFwnbW9kdWxlXFwnKWAgaW5zdGVhZC4nXG4gICAgYCN7Tk9ERV9SRVFVSVJFfSgje3BhdGgudG9fc3RyfSlgXG4gIGVuZFxuZW5kXG5cbkFSR1YgPSBgcHJvY2Vzcy5hcmd2LnNsaWNlKDIpYFxuIl0sIm5hbWVzIjpbIjx0b3AgKHJlcXVpcmVkKT4iLCI8bW9kdWxlOktlcm5lbD4iLCJub2RlX3JlcXVpcmUiLCJwYXRoIiwic2VsZiIsIndhcm4iLCJOT0RFX1JFUVVJUkUiLCJ0b19zdHIiXSwibWFwcGluZ3MiOiJBQUFBQTtBQUFBQTtFQUFBQTs7RUFBQUE7O0VBQUNBO0VBRURDO0VBQUFBOztJQUFBQTs7O0lBQ0UsNENBQWdCQSxPQUFoQjtJQUdBQSxPQUFBQyxDQUFBQSxnQ0FBQUEseUJBQUFBLHdCQUFpQkMsSUFBakJEO0FBQUFBLE1BQUFBOzs7TUFDRUUsSUFBQUMsTUFBQUEsQ0FBS0gsbUZBQUxHO01BQ0FILE9BQUdJLDRCQUFhSixDQUFHQyxJQUFJSSxRQUFBQSxDQUFBQSxDQUFRTDtJQUZqQ0EsQ0FBQUEsb0NBQUFBLENBQUFBO0VBSkZELEdBQUFBLFdBQUFBO0VBVUFELE9BQUEsb0NBQVFBLHFCQUFSO0FBWkFBOyJ9fSx7Im9mZnNldCI6eyJsaW5lIjoyOTk4OCwiY29sdW1uIjowfSwibWFwIjp7InZlcnNpb24iOjMsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm5vZGVqcy9pby5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgZnVuY3Rpb24gZXhlY3V0ZUlPQWN0aW9uKGFjdGlvbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYWN0aW9uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSAnRUFDQ0VTJyB8fFxuICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFSVNESVInIHx8XG4gICAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VNRklMRScgfHxcbiAgICAgICAgICBlcnJvci5jb2RlID09PSAnRU5PRU5UJyB8fFxuICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFUEVSTScpIHtcbiAgICAgICAgdGhyb3cgT3BhbC5JT0Vycm9yLiRuZXcoZXJyb3IubWVzc2FnZSlcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufVxuXG5gdmFyIF9fZnNfXyA9IHJlcXVpcmUoJ2ZzJylgXG5cbmNsYXNzIElPXG4gIEBfX2ZzX18gPSBgX19mc19fYFxuXG4gIGF0dHJfcmVhZGVyIDpsaW5lbm9cblxuICBhbGlhcyBpbml0aWFsaXplX2JlZm9yZV9ub2RlX2lvIGluaXRpYWxpemVcblxuICBkZWYgaW5pdGlhbGl6ZShmZCwgZmxhZ3MgPSAncicpXG4gICAgQGxpbmVubyA9IDBcbiAgICBpbml0aWFsaXplX2JlZm9yZV9ub2RlX2lvKGZkLCBmbGFncylcbiAgZW5kXG5cbiAgZGVmIHNlbGYud3JpdGUocGF0aCwgZGF0YSlcbiAgICBGaWxlLndyaXRlKHBhdGgsIGRhdGEpXG4gIGVuZFxuXG4gIGRlZiBzZWxmLnJlYWQocGF0aClcbiAgICBGaWxlLnJlYWQocGF0aClcbiAgZW5kXG5cbiAgZGVmIHNlbGYuYmlucmVhZChwYXRoKVxuICAgIGByZXR1cm4gZXhlY3V0ZUlPQWN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIF9fZnNfXy5yZWFkRmlsZVN5bmMoI3twYXRofSkudG9TdHJpbmcoJ2JpbmFyeScpfSlgXG4gIGVuZFxuZW5kXG5cblNURE9VVC53cml0ZV9wcm9jID0gLT4oc3RyaW5nKSB7IGBwcm9jZXNzLnN0ZG91dC53cml0ZShzdHJpbmcpYCB9XG5TVERFUlIud3JpdGVfcHJvYyA9IC0+KHN0cmluZykgeyBgcHJvY2Vzcy5zdGRlcnIud3JpdGUoc3RyaW5nKWAgfVxuXG5TVERJTi5yZWFkX3Byb2MgPSAleHtmdW5jdGlvbihfY291bnQpIHtcbiAgLy8gSWdub3JlIGNvdW50LCByZXR1cm4gYXMgbXVjaCBhcyB3ZSBjYW4gZ2V0XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoNjU1MzYpO1xuICB2YXIgY291bnQgPSBfX2ZzX18ucmVhZFN5bmModGhpcy5mZCwgYnVmLCAwLCA2NTUzNiwgbnVsbCk7XG4gIGlmIChjb3VudCA9PSAwKSByZXR1cm4gbmlsO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgMCwgY291bnQpO1xufX1cblxuU1RESU4udHR5ID0gdHJ1ZVxuU1RET1VULnR0eSA9IHRydWVcblNUREVSUi50dHkgPSB0cnVlXG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiIsIjxjbGFzczpJTz4iLCJAX19mc19fIiwic2VsZiIsImF0dHJfcmVhZGVyIiwiaW5pdGlhbGl6ZSIsImZkIiwiZmxhZ3MiLCJAbGluZW5vIiwiMCIsImluaXRpYWxpemVfYmVmb3JlX25vZGVfaW8iLCJ3cml0ZSIsInBhdGgiLCJkYXRhIiwiRmlsZSIsInJlYWQiLCJiaW5yZWFkIiwiJHdyaXRlciIsImJsb2NrIGluIDx0b3AgKHJlcXVpcmVkKT4iLCJzdHJpbmciLCJibG9jayAoMiBsZXZlbHMpIGluIDx0b3AgKHJlcXVpcmVkKT4iLCJ3cml0ZV9wcm9jPSIsIlNURE9VVCIsIi0iLCIxIiwiU1RERVJSIiwicmVhZF9wcm9jPSIsIlNURElOIiwidHR5PSJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBO0VBQUFBO0VBQUFBO0VBQUFBOztFQUFBQTs7O0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztFQUdDQTtFQUVEQztFQUFBQTs7SUFBQUE7OztJQUNFQyxjQUFXRDtJQUVYRSxJQUFBQyxhQUFBQSxDQUFZLFFBQVpBO0lBRUEsYUFBTSwyQkFBTixFQUFnQyxZQUFoQzs7QUFFQUMsSUFBQUEsOEJBQUFBLG1CQUFBQSxzQkFBZUMsRUFBRCxFQUFLQyxLQUFuQkY7QUFBQUEsTUFBQUE7Ozs7TUFBbUI7TUFBQSxVQUFRQSxHQUFSO01BQUE7TUFDakJHLGNBQVVDO01BQ1ZKLE9BQUFGLElBQUFPLDJCQUFBQSxDQUEwQkosRUFBMUIsRUFBOEJDLEtBQTlCRztJQUZGTCxDQUFBQSwrQkFBQUE7SUFLQU0sVUFBSVIsSUFBSlEsWUFBQUEsY0FBQUEsaUJBQWVDLElBQUQsRUFBT0MsSUFBckJGO0FBQUFBLE1BQUFBOztNQUNFQSxPQUFBRyxvQkFBSUgsT0FBQUEsQ0FBT0MsSUFBWCxFQUFpQkMsSUFBYkY7SUFETkEsQ0FBQUEseUJBQUFBO0lBSUFJLFVBQUlaLElBQUpZLFdBQUFBLGFBQUFBLGdCQUFjSCxJQUFkRztBQUFBQSxNQUFBQTs7TUFDRUEsT0FBQUQsb0JBQUlDLE1BQUFBLENBQU1ILElBQU5HO0lBRE5BLENBQUFBLHdCQUFBQTtJQUlBZCxPQUFBZSxDQUFBQSxVQUFJYixJQUFKYSxjQUFBQSxnQkFBQUEsbUJBQWlCSixJQUFqQkk7QUFBQUEsTUFBQUE7O01BQ0dBLDZEQUErREosSUFBS0k7SUFEdkVBLENBQUFBLDJCQUFBQSxDQUFBQTtFQXBCRmYsR0FBQUEsV0FBQUEsRUFBQUEsSUFBQUE7O0VBbkJBZ0IsVUFBQSxDQTRDb0IsUUFBV0MsZ0JBQVJDLE1BQVFELEVBQUFFOzs7O0lBQVI7SUFBQTtJQUFBO0lBQVVBLE9BQUNBLDRCQUFEQSxFQUFGRixrQkFBQUEsaUJBQUFBLEtBQVgsQ0E1Q3BCO0VBNENNRyxNQUFOQyxzQkFBTUQsZUFBQUEsRUE1Q04sVUFBQUosT0FBQSxDQTRDTUk7RUE1Q05KLE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBakIsUUFBQSxDQUFBdUIsRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQU4sVUFBQSxDQTZDb0IsUUFBV0MsZ0JBQVJDLE1BQVFELEVBQUFFOzs7O0lBQVI7SUFBQTtJQUFBO0lBQVVBLE9BQUNBLDRCQUFEQSxFQUFGRixrQkFBQUEsaUJBQUFBLEtBQVgsQ0E3Q3BCO0VBNkNNRyxNQUFOSSxzQkFBTUosZUFBQUEsRUE3Q04sVUFBQUosT0FBQSxDQTZDTUk7RUE3Q05KLE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBakIsUUFBQSxDQUFBdUIsRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQU4sVUFBQSxDQStDcUJqQjtBQUNyQkE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUEsQ0FyREE7RUErQ0swQixNQUFMQyxxQkFBS0QsY0FBQUEsRUEvQ0wsVUFBQVQsT0FBQSxDQStDS1M7RUEvQ0xULE9BQUEsQ0FBQU0sVUFBQU4sT0FBQSxDQUFBakIsUUFBQSxDQUFBdUIsRUFBQUMsQ0FBQUQsQ0FBQTs7RUFBQU4sVUFBQSxDQXVEWSxJQXZEWjtFQXVES1csTUFBTEQscUJBQUtDLFFBQUFBLEVBdkRMLFVBQUFYLE9BQUEsQ0F1REtXO0VBdkRMWCxPQUFBLENBQUFNLFVBQUFOLE9BQUEsQ0FBQWpCLFFBQUEsQ0FBQXVCLEVBQUFDLENBQUFELENBQUE7O0VBQUFOLFVBQUEsQ0F3RGEsSUF4RGI7RUF3RE1XLE1BQU5OLHNCQUFNTSxRQUFBQSxFQXhETixVQUFBWCxPQUFBLENBd0RNVztFQXhETlgsT0FBQSxDQUFBTSxVQUFBTixPQUFBLENBQUFqQixRQUFBLENBQUF1QixFQUFBQyxDQUFBRCxDQUFBOztFQUFBTixVQUFBLENBeURhLElBekRiO0VBeURNVyxNQUFOSCxzQkFBTUcsUUFBQUEsRUF6RE4sVUFBQVgsT0FBQSxDQXlETVc7RUF6RE41QixPQUFBaUIsT0FBQSxDQUFBTSxVQUFBTixPQUFBLENBQUFqQixRQUFBLENBQUF1QixFQUFBQyxDQUFBRCxDQUFBO0FBQUF2QjsifX0seyJvZmZzZXQiOnsibGluZSI6MzAwOTcsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuL2hlYWRsZXNzX2Nocm9tZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIleHtcbiAgT3BhbC5leGl0ID0gZnVuY3Rpb24oY29kZSkge1xuICAgIC8vIFlvdSBjYW4ndCBleGl0IGZyb20gdGhlIGJyb3dzZXIuXG4gICAgLy8gVGhlIGZpcnN0IGNhbGwgdG8gT3BhbC5leGl0IHNob3VsZCBzYXZlIGFuIGV4aXQgY29kZS5cbiAgICAvLyBBbGwgbmV4dCBpbnZvY2F0aW9ucyBtdXN0IGJlIGlnbm9yZWQuXG5cbiAgICBpZiAodHlwZW9mKHdpbmRvdy5PUEFMX0VYSVRfQ09ERSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdpbmRvdy5PUEFMX0VYSVRfQ09ERSA9IGNvZGU7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiPHRvcCAocmVxdWlyZWQpPiJdLCJtYXBwaW5ncyI6IkFBQUFBO0FBQUFBO0VBQUFBOzs7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQVRBQTsifX0seyJvZmZzZXQiOnsibGluZSI6MzAxMTQsImNvbHVtbiI6MH0sIm1hcCI6eyJ2ZXJzaW9uIjozLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJvcGFsL21pbmlyYWNlci5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIENvbXBhdGliaWxpdHkgdXRpbGl0aWVzIGZvciB0aGUgQVBJIHdlIHByb3ZpZGUgaW5cbiMgbGliL29wYWwvY2xpX3J1bm5lcnMvbWluaV9yYWNlclxuXG5BUkdWID0gYG9wYWxtaW5pcmFjZXIuYXJndmBcblxuYE9wYWwuZXhpdCA9IG9wYWxtaW5pcmFjZXIuZXhpdGBcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Il0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7OztFQUdBLG9DQUFRQSxrQkFBUjtFQUVBQSxPQUFDQSw4QkFBREE7QUFMQUE7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwMTIzLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsib3BhbC9wbGF0Zm9ybS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlICdvcGFsLXBsYXRmb3JtJ1xuXG5jYXNlIE9QQUxfUExBVEZPUk1cbndoZW4gJ25hc2hvcm4nXG4gIHJlcXVpcmUgJ25hc2hvcm4nXG53aGVuICdnanMnXG4gIHJlcXVpcmUgJ2dqcydcbndoZW4gJ25vZGVqcydcbiAgcmVxdWlyZSAnbm9kZWpzL2tlcm5lbCdcbiAgcmVxdWlyZSAnbm9kZWpzL2lvJ1xud2hlbiAnaGVhZGxlc3MtY2hyb21lJ1xuICByZXF1aXJlICdoZWFkbGVzc19jaHJvbWUnXG53aGVuICdvcGFsLW1pbmlyYWNlcidcbiAgcmVxdWlyZSAnb3BhbC9taW5pcmFjZXInXG5lbmRcbiJdLCJuYW1lcyI6WyI8dG9wIChyZXF1aXJlZCk+Iiwic2VsZiIsInJlcXVpcmUiLCJPUEFMX1BMQVRGT1JNIiwiPT09Il0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUVBRixPQUFBLGFBQUEsUUFBS0csNkJBQUw7RUFDQSxJQUFLSCxTQUFMSSxRQUFBQSxDQUFBLEtBQUFBLENBQUEsR0FDRUosT0FBQUMsSUFBQUMsU0FBQUEsQ0FBUUYsU0FBUkUsQ0FERjtFQURBLEtBR0EsSUFBS0YsS0FBTEksUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLEdBQ0VKLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLEtBQVJFLENBREY7RUFIQSxLQUtBLElBQUtGLFFBQUxJLFFBQUFBLENBQUEsS0FBQUEsQ0FBQTtFQUNFSCxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTtFQUNBRixPQUFBQyxJQUFBQyxTQUFBQSxDQUFRRixXQUFSRSxFQUZGO0VBTEEsS0FRQSxJQUFLRixpQkFBTEksUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLEdBQ0VKLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGlCQUFSRSxDQURGO0VBUkEsS0FVQSxJQUFLRixnQkFBTEksUUFBQUEsQ0FBQSxLQUFBQSxDQUFBLEdBQ0VKLE9BQUFDLElBQUFDLFNBQUFBLENBQVFGLGdCQUFSRSxDQURGO0VBVkEsbUJBQUE7QUFGQUY7In19LHsib2Zmc2V0Ijp7ImxpbmUiOjMwMTQxLCJjb2x1bW4iOjB9LCJtYXAiOnsidmVyc2lvbiI6Mywic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiL2hvbWUvdXNlci9Db2RlL29wYWwvb3BhbC9saWIvb3BhbC9jbGlfcnVubmVycy9jaHJvbWVfY2RwX2ludGVyZmFjZS5yYiJdLCJzb3VyY2VzQ29udGVudCI6WyIjIFRoaXMgc2NyaXB0IEkgY29udmVydGVkIGludG8gT3BhbCwgc28gdGhhdCBJIGRvbid0IGhhdmUgdG8gd3JpdGVcbiMgYnVmZmVyIGhhbmRsaW5nIGFnYWluLiBXZSBoYXZlIGdldHMsIE5vZGUgaGFzIG5vdGhpbmcgY2xvc2UgdG8gaXQsXG4jIGV2ZW4gYXN5bmMuXG5cbnJlcXVpcmUgJ29wYWwvcGxhdGZvcm0nXG5cbiV4e1xudmFyIENEUCA9IHJlcXVpcmUoXCJjaHJvbWUtcmVtb3RlLWludGVyZmFjZVwiKTtcbnZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcblxudmFyIGRpciA9ICN7QVJHVlswXX1cblxudmFyIG9wdGlvbnMgPSB7XG4gIGhvc3Q6ICN7RU5WWydDSFJPTUVfSE9TVCddIHx8ICdsb2NhbGhvc3QnfSxcbiAgcG9ydDogI3tFTlZbJ0NIUk9NRV9QT1JUJ10gfHwgOTIyMn1cbn07XG5cbkNEUChvcHRpb25zLCBmdW5jdGlvbihjbGllbnQpIHtcbiAgdmFyIFBhZ2UgPSBjbGllbnQuUGFnZSxcbiAgICAgIFJ1bnRpbWUgPSBjbGllbnQuUnVudGltZSxcbiAgICAgIENvbnNvbGUgPSBjbGllbnQuQ29uc29sZTtcblxuICBQcm9taXNlLmFsbChbXG4gICAgQ29uc29sZS5lbmFibGUoKSxcbiAgICBQYWdlLmVuYWJsZSgpLFxuICAgIFJ1bnRpbWUuZW5hYmxlKCksXG4gIF0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgLy8gVGhpcyBob29rIGNhdGNoZXMgb25seSB0aGUgZmlyc3QgYXJndW1lbnQgb2YgYGNvbnNvbGUubG9nYFxuICAgIC8vIE1vcmUgYWR2YW5jZWQgdmVyc2lvbiBSdW50aW1lLmNvbnNvbGVBUElDYWxsZWQgcmV0dXJucyBhbGwgYXJndW1lbnRzXG4gICAgLy8gYnV0IGFsbCBvZiB0aGVtIGFyZSBub3QgZm9ybWF0dGVkLCBpLmUuIGJ5IGNhbGxpbmdcbiAgICAvLyAgIGNvbnNvbGUubG9nKCdzdHJpbmcnLCBbMSwgMiwgM10sIHthOiAnYid9KVxuICAgIC8vIGl0IHJldHVybnMgdGhlIGZvbGxvd2luZyBkYXRhIHRvIHRoZSBjYWxsYmFjazpcbiAgICAvLyAgIHtcbiAgICAvLyAgICAgXCJ0eXBlXCI6XCJsb2dcIixcbiAgICAvLyAgICAgXCJhcmdzXCI6W1xuICAgIC8vICAgICAgIHtcbiAgICAvLyAgICAgICAgIFwidHlwZVwiOlwic3RyaW5nXCIsXG4gICAgLy8gICAgICAgICBcInZhbHVlXCI6XCJzdHJpbmdcIlxuICAgIC8vICAgICAgIH0sXG4gICAgLy8gICAgICAge1xuICAgIC8vICAgICAgICAgXCJ0eXBlXCI6XCJvYmplY3RcIixcbiAgICAvLyAgICAgICAgIFwic3VidHlwZVwiOlwiYXJyYXlcIixcbiAgICAvLyAgICAgICAgIFwiY2xhc3NOYW1lXCI6XCJBcnJheVwiLFxuICAgIC8vICAgICAgICAgXCJkZXNjcmlwdGlvblwiOlwiQXJyYXkoMylcIixcbiAgICAvLyAgICAgICAgIFwib2JqZWN0SWRcIjpcIntcXFwiaW5qZWN0ZWRTY3JpcHRJZFxcXCI6MTEsXFxcImlkXFxcIjoxfVwiLFxuICAgIC8vICAgICAgICAgXCJwcmV2aWV3XCI6e1xuICAgIC8vICAgICAgICAgICBcInR5cGVcIjpcIm9iamVjdFwiLFxuICAgIC8vICAgICAgICAgICBcInN1YnR5cGVcIjpcImFycmF5XCIsXG4gICAgLy8gICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjpcIkFycmF5KDMpXCIsXG4gICAgLy8gICAgICAgICAgIFwib3ZlcmZsb3dcIjpmYWxzZSxcbiAgICAvLyAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6W1xuICAgIC8vICAgICAgICAgICAgIHtcIm5hbWVcIjpcIjBcIixcInR5cGVcIjpcIm51bWJlclwiLFwidmFsdWVcIjpcIjFcIn0sXG4gICAgLy8gICAgICAgICAgICAge1wibmFtZVwiOlwiMVwiLFwidHlwZVwiOlwibnVtYmVyXCIsXCJ2YWx1ZVwiOlwiMlwifSxcbiAgICAvLyAgICAgICAgICAgICB7XCJuYW1lXCI6XCIyXCIsXCJ0eXBlXCI6XCJudW1iZXJcIixcInZhbHVlXCI6XCIzXCJ9XG4gICAgLy8gICAgICAgICAgIF1cbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgICB9LFxuICAgIC8vICAgICAgIHtcbiAgICAvLyAgICAgICAgIFwidHlwZVwiOlwib2JqZWN0XCIsXG4gICAgLy8gICAgICAgICBcImNsYXNzTmFtZVwiOlwiT2JqZWN0XCIsXG4gICAgLy8gICAgICAgICBcImRlc2NyaXB0aW9uXCI6XCJPYmplY3RcIixcbiAgICAvLyAgICAgICAgIFwib2JqZWN0SWRcIjpcIntcXFwiaW5qZWN0ZWRTY3JpcHRJZFxcXCI6MTEsXFxcImlkXFxcIjoyfVwiLFxuICAgIC8vICAgICAgICAgXCJwcmV2aWV3XCI6e1xuICAgIC8vICAgICAgICAgICBcInR5cGVcIjpcIm9iamVjdFwiLFxuICAgIC8vICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6XCJPYmplY3RcIixcbiAgICAvLyAgICAgICAgICAgXCJvdmVyZmxvd1wiOmZhbHNlLFxuICAgIC8vICAgICAgICAgICBcInByb3BlcnRpZXNcIjpbXG4gICAgLy8gICAgICAgICAgICAge1wibmFtZVwiOlwiYVwiLFwidHlwZVwiOlwic3RyaW5nXCIsXCJ2YWx1ZVwiOlwiYlwifVxuICAgIC8vICAgICAgICAgICBdXG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICBdLFxuICAgIC8vICAgICAvLyAuLi5cbiAgICAvLyAgIH1cbiAgICAvLyBTdXBwb3J0aW5nIHRoaXMgZm9ybWF0IGZvciBjb21wbGV4IGRhdGEgc3RydWN0dXJlIGlzIGNoYWxsZW5naW5nLCBmZWVsIGZyZWUgdG8gY29udHJpYnV0ZSFcbiAgICAvL1xuICAgIENvbnNvbGUubWVzc2FnZUFkZGVkKGZ1bmN0aW9uKGNvbnNvbGVfbWVzc2FnZSkge1xuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29uc29sZV9tZXNzYWdlLm1lc3NhZ2UudGV4dCk7XG4gICAgfSk7XG5cbiAgICBSdW50aW1lLmV4Y2VwdGlvblRocm93bihmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gZXhjZXB0aW9uLmV4Y2VwdGlvbkRldGFpbHMuZXhjZXB0aW9uLnByZXZpZXcucHJvcGVydGllcyxcbiAgICAgICAgICBzdGFjaywgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcblxuICAgICAgICBpZiAocHJvcGVydHkubmFtZSA9PSBcInN0YWNrXCIpIHtcbiAgICAgICAgICBzdGFjayA9IHByb3BlcnR5LnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKHN0YWNrKTtcblxuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH0pO1xuXG4gICAgUGFnZS5qYXZhc2NyaXB0RGlhbG9nT3BlbmluZygoZGlhbG9nKSA9PiB7XG4gICAgICAje1xuICAgICAgICBpZiBgZGlhbG9nLnR5cGVgID09ICdwcm9tcHQnXG4gICAgICAgICAgbWVzc2FnZSA9IGdldHMmLmNob21wXG4gICAgICAgICAgaWYgbWVzc2FnZVxuICAgICAgICAgICAgYFBhZ2UuaGFuZGxlSmF2YVNjcmlwdERpYWxvZyh7YWNjZXB0OiB0cnVlLCBwcm9tcHRUZXh0OiAje21lc3NhZ2V9fSlgXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYFBhZ2UuaGFuZGxlSmF2YVNjcmlwdERpYWxvZyh7YWNjZXB0OiBmYWxzZX0pYFxuICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFBhZ2UubG9hZEV2ZW50RmlyZWQoKCkgPT4ge1xuICAgICAgUnVudGltZS5ldmFsdWF0ZSh7IGV4cHJlc3Npb246IFwid2luZG93Lk9QQUxfRVhJVF9DT0RFXCIgfSkudGhlbihmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgY2xpZW50LmNsb3NlKCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZihvdXRwdXQucmVzdWx0KSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvdXRwdXQucmVzdWx0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBwcm9jZXNzLmV4aXQob3V0cHV0LnJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgUGFnZS5uYXZpZ2F0ZSh7IHVybDogXCJmaWxlOi8vXCIrZGlyK1wiL2luZGV4Lmh0bWxcIiB9KVxuICB9KTtcbn0pO1xufVxuIl0sIm5hbWVzIjpbIjxtYWluPiIsInNlbGYiLCJyZXF1aXJlIiwiQVJHViIsIltdIiwiMCIsIiRyZXRfb3JfMSIsIkVOViIsIiRyZXRfb3JfMiIsIjkyMjIiLCI9PSIsIm1lc3NhZ2UiLCJnZXRzIl0sIm1hcHBpbmdzIjoiQUFBQUE7QUFBQUE7RUFBQUE7O0VBQUFBOztFQUlBQyxJQUFBQyxTQUFBQSxDQUFRRixlQUFSRTs7QUFHQUY7QUFDQUE7O0FBRUFBLFVBQVlHLG9CQUFJQyxPQUFBQSxDQUFDQyxDQUFERDs7QUFFaEJKO0FBQ0FBLFFBQVUsYUFBQSxJQUFBLFFBYlZNLENBQUFBLFlBYVVDLG1CQUFHSCxPQUFBQSxDQUFDSixhQUFESSxDQWJiRSxDQWFVLENBQUE7SUFiVk4sT0FBQTtFQWFVO0lBQXNCQSxPQUFBQTtFQUF0QixDQUFBLGtCQUFrQ0E7QUFDNUNBLFFBQVUsYUFBQSxJQUFBLFFBZFZRLENBQUFBLFlBY1VELG1CQUFHSCxPQUFBQSxDQUFDSixhQUFESSxDQWRiSSxDQWNVLENBQUE7SUFkVlIsT0FBQTtFQWNVO0lBQXNCQSxPQUFBUztFQUF0QixDQUFBO0FBQ1ZUOztBQUVBQTtBQUNBQTtBQUNBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUE7QUFDQUE7QUFDQUE7O0FBRUFBOztBQUVBQTtBQUNBQTs7QUFFQUE7QUFDQUEsTUFDUSxhQUFBLElBQUdBLENBQUNBLFdBQURBLENBQWNVLE9BQUFBLENBQUdWLFFBQUhVLENBQWpCOztJQUNFQyxVQUFVLENBQUEsS0FBQVYsSUFBQVcsTUFBQUEsQ0FBQUEsQ0FBQSxxQ0FBQSxNQUFBLEVBQUEsU0FBQSxFQUFBLEVBQUEsQ0FBQTtJQUNWLElBQUEsUUFBR0QsT0FBSCxDQUFBO01BQ0VYLE9BQUNBLHVEQUF5RFcsT0FBUVg7SUFEcEU7TUFHRUEsT0FBQ0EsNENBQURBO0lBSEY7RUFGRjtJQUFBQSxPQUFBO0VBQUEsQ0FBQTtBQVNSQTs7QUFFQUE7QUFDQUE7QUFDQUE7O0FBRUFBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBO0FBQ0FBOztBQUVBQTtBQUNBQTtBQUNBQTs7QUE1SEFBOyJ9fV19
